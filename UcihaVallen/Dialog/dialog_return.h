#pragma once
#include <string>
#include "UcihaVallen/Handle/WorldInfo.h"

class Dialog_Return {
public:
	static void Dialog() {
		dialogMap["Req_Verify_Csn"] = Dialog_Return::Req_Verify_Csn;
		dialogMap["worldcategory"] = Dialog_Return::worldcategory;
		dialogMap["Crime_in_Progress"] = Dialog_Return::Crime_in_Progress;
		dialogMap["kranken_edit"] = Dialog_Return::kranken_edit;
		dialogMap["Pet_Trainer"] = Dialog_Return::Pet_Trainer;
		dialogMap["Locke_Salesman"] = Dialog_Return::Locke_Salesman;
		dialogMap["LockBot"] = Dialog_Return::LockBot;
		dialogMap["Nutcracker"] = Dialog_Return::Nutcracker;
		dialogMap["handledungeonsui"] = Dialog_Return::handledungeonsui;
		dialogMap["vippay_edit"] = Dialog_Return::vippay_edit;
		dialogMap["proxys"] = Dialog_Return::proxys;
		dialogMap["SocialPortal"] = Dialog_Return::SocialPortal;
		dialogMap["Buy_Slot_FCheats"] = Dialog_Return::Buy_Slot_FCheats;
		dialogMap["cheats"] = Dialog_Return::cheats;
		dialogMap["game_menu"] = Dialog_Return::game_menu;
		dialogMap["upgrade_world_gems"] = Dialog_Return::upgrade_world_gems;
		dialogMap["team_edit"] = Dialog_Return::team_edit;
		dialogMap["Role_Quest"] = Dialog_Return::Role_Quest;
		dialogMap["MasterLess_Quest"] = Dialog_Return::MasterLess_Quest;
		dialogMap["winterrally_dialog"] = Dialog_Return::winterrally_dialog;
		dialogMap["Porte_Arriere_Fermer"] = Dialog_Return::Porte_Arriere_Fermer;
		dialogMap["report_bug"] = Dialog_Return::report_bug;
		dialogMap["remove_vip"] = Dialog_Return::remove_vip;
		dialogMap["Set_Gems_Event"] = Dialog_Return::Set_Gems_Event;
		dialogMap["Set_Xp_Event"] = Dialog_Return::Set_Xp_Event;
		dialogMap["giveaway_role_dialog"] = Dialog_Return::giveaway_role;
		dialogMap["Set_Exchange_Event"] = Dialog_Return::Set_Exchange_Event;
		dialogMap["server_events"] = Dialog_Return::server_events;
		dialogMap["wrench_customization_select"] = Dialog_Return::wrench_customization_select;
		dialogMap["give_assets"] = Dialog_Return::give_assets;
		dialogMap["Trade_Scan"] = Dialog_Return::Trade_Scan;
		dialogMap["give_cwrench"] = Dialog_Return::give_cwrench;
		dialogMap["give_role"] = Dialog_Return::give_role;
		dialogMap["creator_bank_option"] = Dialog_Return::creator_bank_option;
		dialogMap["reset_option"] = Dialog_Return::reset_option;
		dialogMap["Buy_Items"] = Dialog_Return::Buy_Items;
		dialogMap["Trova Oggetto Clist"] = Dialog_Return::TrovaOggettoClist;
		dialogMap["Trova Oggetto"] = Dialog_Return::TrovaOggetto;
		dialogMap["fishtankport"] = Dialog_Return::fishtankport;
		dialogMap["Exchange_Npc"] = Dialog_Return::Exchange_Npc;
		dialogMap["MarketPlace_Npc"] = Dialog_Return::MarketPlace_Npc;
		dialogMap["OnlinePointCurrency_Shop"] = Dialog_Return::OnlinePointCurrency_Shop;
		dialogMap["sewing"] = Dialog_Return::sewing;
		dialogMap["Wrench_PhoneBooth"] = Dialog_Return::Wrench_PhoneBooth;
		dialogMap["PhoneBooth_Punch"] = Dialog_Return::PhoneBooth_Punch;
		dialogMap["YesPItems"] = Dialog_Return::YesPItems;
		dialogMap["punish_view"] = Dialog_Return::punish_view;
		dialogMap["ban_panel"] = Dialog_Return::ban_panel;
		dialogMap["supermusic"] = Dialog_Return::supermusic;
		dialogMap["creator_tools"] = Dialog_Return::creator_tools;
		dialogMap["Send_Message"] = Dialog_Return::Send_Message;
		dialogMap["Aparece_Otro"] = Dialog_Return::Aparece_Otro;
		dialogMap["fwallrora"] = Dialog_Return::fwallrora;
		dialogMap["oven"] = Dialog_Return::oven;
		dialogMap["unfavorite_items_dialog"] = Dialog_Return::unfavorite_items_dialog;
		dialogMap["marvelous_back"] = Dialog_Return::marvelous_back;
		dialogMap["collectionQuests"] = Dialog_Return::collectionQuests;
		dialogMap["Bank_Central"] = Dialog_Return::Bank_Central;
		dialogMap["Miner_ExPlace"] = Dialog_Return::Miner_ExPlace;
		dialogMap["Miner_License"] = Dialog_Return::Miner_License;
		dialogMap["Miner_Forging"] = Dialog_Return::Miner_Forging;
		dialogMap["autoharvest"] = Dialog_Return::autoharvest;
		dialogMap["change_name_pet"] = Dialog_Return::change_name_pet;
		dialogMap["Give_Feed_Pet"] = Dialog_Return::Give_Feed_Pet;
		dialogMap["My_PetAi"] = Dialog_Return::My_PetAi;
		dialogMap["Punch_Event"] = Dialog_Return::Punch_Event;
		dialogMap["Richest_Event"] = Dialog_Return::Richest_Event;
		dialogMap["phoenix_returns"] = Dialog_Return::phoenix_returns;
		dialogMap["achieve_reply"] = Dialog_Return::achieve_reply;
		dialogMap["gacha_system"] = Dialog_Return::gacha_system;
		dialogMap["xenonite_edit"] = Dialog_Return::xenonite_edit;
		dialogMap["statsblock"] = Dialog_Return::statsblock;
		dialogMap["dynamo"] = Dialog_Return::dynamo;
		dialogMap["extractor"] = Dialog_Return::extractor;
		dialogMap["ultra_world_spray"] = Dialog_Return::ultra_world_spray;
		dialogMap["deluxe_world_spray"] = Dialog_Return::deluxe_world_spray;
		dialogMap["GrowPass"] = Dialog_Return::GrowPass;
		dialogMap["dnaproc"] = Dialog_Return::dnaproc;
		dialogMap["dnaget"] = Dialog_Return::dnaget;
		dialogMap["inv_rm"] = Dialog_Return::inv_rm;
		dialogMap["set_newget"] = Dialog_Return::set_newget;
		dialogMap["set_redeem"] = Dialog_Return::set_redeem;
		dialogMap["redeem_code"] = Dialog_Return::redeem_code;
		dialogMap["checkoutcounter"] = Dialog_Return::checkoutcounter;
		dialogMap["recycle_machine"] = Dialog_Return::recycle_machine;
		dialogMap["bannerbandolier"] = Dialog_Return::bannerbandolier;
		dialogMap["magic_compass"] = Dialog_Return::magic_compass;
		dialogMap["dialog_cernuous_mask"] = Dialog_Return::dialog_cernuous_mask;
		dialogMap["sessionlength_edit"] = Dialog_Return::sessionlength_edit;
		dialogMap["dialog_infinity_crown"] = Dialog_Return::dialog_infinity_crown;
		dialogMap["dialog_rift_wings"] = Dialog_Return::dialog_rift_wings;
		dialogMap["dialog_rift_cape"] = Dialog_Return::dialog_rift_cape;
		dialogMap["skin_color"] = Dialog_Return::skin_color;
		dialogMap["News"] = Dialog_Return::News;
		dialogMap["handleHalloweenShopVerification"] = Dialog_Return::handleHalloweenShopVerification;
		dialogMap["halloween_tasks_popup_handle"] = Dialog_Return::halloween_tasks_popup_handle;
		dialogMap["WinterFest_Shop"] = Dialog_Return::WinterFest_Shop;
		dialogMap["Valentine_Shop"] = Dialog_Return::Valentine_Shop;
		dialogMap["Goblin_Disguise"] = Dialog_Return::Goblin_Disguise;
		dialogMap["mooncake_choose_dialog"] = Dialog_Return::mooncake_choose_dialog;
		dialogMap["mooncake_count_dialog"] = Dialog_Return::mooncake_count_dialog;
		dialogMap["guide_book"] = Dialog_Return::guide_book;
		dialogMap["guide_book_s"] = Dialog_Return::guide_book_;
		dialogMap["guide_book_c"] = Dialog_Return::guide_book_;
		dialogMap["guide_book_f"] = Dialog_Return::guide_book_;
		dialogMap["guide_book_r"] = Dialog_Return::guide_book_;
		dialogMap["dialog_minokawa"] = Dialog_Return::dialog_minokawa;
		dialogMap["top"] = Dialog_Return::top;
		dialogMap["Shop_Assets"] = Dialog_Return::Shop_Assets;
		dialogMap["surge_"] = Dialog_Return::surge_;
		dialogMap["ss_storage"] = Dialog_Return::ss_storage;
		dialogMap["lvl_rewards"] = Dialog_Return::lvl_rewards;
		dialogMap["roadtoglory"] = Dialog_Return::roadtoglory;
		//dialogMap["admin_resetpw"] = Dialog_Return::admin_resetpw;
		dialogMap["create_world_ui"] = Dialog_Return::confirm_createworld;
		dialogMap["trash_dialog"] = Dialog_Return::TRASHALL_DIALOG;
		dialogMap["blockdt_dialog"] = Dialog_Return::HandleBlockDTDialog;
		dialogMap["remove_bulletin"] = Dialog_Return::remove_bulletin;
		dialogMap["adventure"] = Dialog_Return::adventure;
		dialogMap["ban_player"] = Dialog_Return::ban_player;
		dialogMap["phonecall"] = Dialog_Return::phonecall;
		dialogMap["added_seal_branch_1"] = Dialog_Return::added_seal_branch_1;
		dialogMap["added_seal_branch_2"] = Dialog_Return::added_seal_branch_2;
		dialogMap["added_seal_branch_3"] = Dialog_Return::added_seal_branch_3;
		dialogMap["added_seal_branch_4"] = Dialog_Return::added_seal_branch_4;
		dialogMap["winter_seal_rewards"] = Dialog_Return::winter_seal_rewards;
		dialogMap["royal_winter_wonder"] = Dialog_Return::royal_winter_wonder;
		dialogMap["iotm_purchase"] = Dialog_Return::iotm_purchase;
		dialogMap["remove_transmutated_dialog"] = Dialog_Return::remove_transmutated_dialog;
		dialogMap["transmutated_device_edit"] = Dialog_Return::transmutated_device_edit;
		dialogMap["PayDialog"] = Dialog_Return::PayDialog;
		dialogMap["spotify_dialog"] = Dialog_Return::spotify_dialog;
		dialogMap["kit_dialog"] = Dialog_Return::kit_dialog;
		dialogMap["World_Default"] = Dialog_Return::World_Default;
		dialogMap["carnival"] = Dialog_Return::carnival;
		dialogMap["carnival_give_up"] = Dialog_Return::carnival_give_up;
		dialogMap["giveaway_setting"] = Dialog_Return::giveaway_setting;
		dialogMap["giveaway_insert"] = Dialog_Return::giveaway_insert;
		dialogMap["s4tb"] = Dialog_Return::s4tb;
		dialogMap["adventure_join"] = Dialog_Return::adventure_join;
		dialogMap["adventure_edit"] = Dialog_Return::adventure_edit;
		dialogMap["epoch_dialog"] = Dialog_Return::epoch_dialog;
		dialogMap["infinity_machine"] = Dialog_Return::infinity_machine;
		dialogMap["guild_machine"] = Dialog_Return::guild_machine;
		dialogMap["battlecage_edit"] = Dialog_Return::battlecage_edit;
		dialogMap["popup"] = Dialog_Return::popup;
		dialogMap["title_edit"] = Dialog_Return::title_edit;
		dialogMap["change_guild_name"] = Dialog_Return::changeguildname;
		dialogMap["world_swap"] = Dialog_Return::world_swap;
		dialogMap["surgery"] = Dialog_Return::surgery;
		dialogMap["statsblockworld"] = Dialog_Return::statsblockworld;
		dialogMap["autoclave"] = Dialog_Return::autoclave;
		dialogMap["camera_edit"] = Dialog_Return::camera_edit;
		dialogMap["dialog_scarf_of_seasons"] = Dialog_Return::dialog_scarf_of_seasons;
		dialogMap["blast"] = Dialog_Return::blast;
		dialogMap["megaphone"] = Dialog_Return::megaphone;
		dialogMap["notebook_edit"] = Dialog_Return::notebook_edit;
		dialogMap["dailyc"] = Dialog_Return::dailyc;
		dialogMap["gazette"] = Dialog_Return::gazette;
		dialogMap["donation_box_edit"] = Dialog_Return::donation_box_edit;
		dialogMap["online_status"] = Dialog_Return::online_status;
		dialogMap["balloonomatic_dialog"] = Dialog_Return::balloonomatic_dialog;
		dialogMap["fruit_mixer_dialog"] = Dialog_Return::fruit_mixer_dialog;
		dialogMap["fruit_mixer_choose_dialog"] = Dialog_Return::fruit_mixer_choose_dialog;
		dialogMap["tropical_fruits_count_dialog"] = Dialog_Return::tropical_fruits_count_dialog;
		dialogMap["bulletin_edit"] = Dialog_Return::bulletin_edit;
		dialogMap["storageboxxtreme"] = Dialog_Return::storageboxxtreme;
		dialogMap["giantpotogold"] = Dialog_Return::giantpotogold;
		dialogMap["transmutated_linkitem_edit"] = Dialog_Return::transmutated_linkitem_edit;
		dialogMap["valentines_quest"] = Dialog_Return::valentines_quest;
		dialogMap["wishing_well"] = Dialog_Return::wishing_well;
		dialogMap["daily_login"] = Dialog_Return::daily_login;
		dialogMap["ancient_goddess"] = Dialog_Return::ancient_goddess;
		dialogMap["pianowings"] = Dialog_Return::pianowings;
		dialogMap["wizard"] = Dialog_Return::wizard;
		dialogMap["wizard_start"] = Dialog_Return::wizard_start;
		dialogMap["wizard_quests"] = Dialog_Return::wizard_quests;
		dialogMap["washing_machine"] = Dialog_Return::washing_machine;
		dialogMap["summerfest_quest"] = Dialog_Return::summerfest_quest;
		dialogMap["mooncake_reward_list_dialog"] = Dialog_Return::mooncake_reward_list_dialog;
		dialogMap["mooncake_altar_dialog"] = Dialog_Return::mooncake_altar_dialog;
		dialogMap["mooncake_reward_dialog"] = Dialog_Return::mooncake_reward_dialog;
		dialogMap["billboard_edit"] = Dialog_Return::billboard_edit;
		dialogMap["dialog_eqaura"] = Dialog_Return::dialog_eqaura;
		dialogMap["worldreport"] = Dialog_Return::worldreport;
		dialogMap["playerreport"] = Dialog_Return::playerreport;
		dialogMap["grinder"] = Dialog_Return::grinder;
		dialogMap["2646"] = Dialog_Return::a2646;
		dialogMap["password_reply"] = Dialog_Return::password_reply;
		dialogMap["ticket_booth"] = Dialog_Return::ticket_booth;
		dialogMap["handleRubblePartyShopPopup"] = Dialog_Return::handleRubblePartyShopPopup;
		dialogMap["logs"] = Dialog_Return::logs;
		dialogMap["logs_search"] = Dialog_Return::logs_search;
		dialogMap["compactor"] = Dialog_Return::compactor;
		dialogMap["zombie_back"] = Dialog_Return::zombie_back;
		dialogMap["zombie_purchase"] = Dialog_Return::zombie_purchase;
		dialogMap["zurgery_back"] = Dialog_Return::zurgery_back;
		dialogMap["zurgery_purchase"] = Dialog_Return::zurgery_purchase;
		dialogMap["wolf_back"] = Dialog_Return::wolf_back;
		dialogMap["worldgen_dialog"] = Dialog_Return::worldgen_return;
		dialogMap["wolf_purchase"] = Dialog_Return::wolf_purchase;
		dialogMap["3898"] = Dialog_Return::a3898;
		dialogMap["Daily_Quest_Info"] = Dialog_Return::Daily_Quest_Info;
		dialogMap["EarnFreeGems"] = Dialog_Return::EarnFreeGems;
		dialogMap["EditStore_Stock"] = Dialog_Return::EditStore_Stock;
		dialogMap["EditItem_Apply"] = Dialog_Return::EditItem_Apply;
		dialogMap["bingo_ui"] = Dialog_Return::bingo_ui;
		dialogMap["Piggy_Bank"] = Dialog_Return::Piggy_Bank;
		dialogMap["MarketPlace_Gtps"] = Dialog_Return::MarketPlace_Gtps;
		dialogMap["Account_Security"] = Dialog_Return::Account_Security;
		dialogMap["Server_Info"] = Dialog_Return::Server_Info;
		dialogMap["VipDailyRewards"] = Dialog_Return::VipDailyRewards;
		dialogMap["WinterFest_Calendar2022"] = Dialog_Return::WinterFest_Calendar2022;
		dialogMap["WinterFest_Calendar2023"] = Dialog_Return::WinterFest_Calendar2023;
		dialogMap["WinterFest_Calendar2024"] = Dialog_Return::WinterFest_Calendar2024;
		dialogMap["zz"] = Dialog_Return::zz;
		dialogMap["backto_personalreward"] = Dialog_Return::backto_personalreward;
		dialogMap["backto_guildreward"] = Dialog_Return::backto_guildreward;
		dialogMap["backto_limitclashrewards"] = Dialog_Return::backto_limitclashrewards;
		dialogMap["backto_clashrewards"] = Dialog_Return::backto_clashrewards;
		dialogMap["backtoleader"] = Dialog_Return::backtoleader;
		dialogMap["backto_leaderboard"] = Dialog_Return::backto_leaderboard;
		dialogMap["grow_event"] = Dialog_Return::grow_event;
		dialogMap["wls"] = Dialog_Return::wls;
		dialogMap["consum_gems"] = Dialog_Return::consum_gems;
		dialogMap["requestcreateguildpage"] = Dialog_Return::requestcreateguildpage;
		dialogMap["unaccess"] = Dialog_Return::unaccess;
		dialogMap["show_guild_logs"] = Dialog_Return::show_guild_logs;
		dialogMap["acceptaccess"] = Dialog_Return::acceptaccess;
		dialogMap["Guild_Notebook"] = Dialog_Return::Guild_Notebook;
		dialogMap["upgrading_guild"] = Dialog_Return::upgrading_guild;
		dialogMap["sdbrespond"] = Dialog_Return::sdbrespond;
		dialogMap["sdbsend"] = Dialog_Return::sdbsend;
		dialogMap["sign_edit"] = Dialog_Return::sign_edit;
		dialogMap["confirmguildlockkey"] = Dialog_Return::confirmguildlockkey;
		dialogMap["worlds_list"] = Dialog_Return::worlds_list;
		dialogMap["confirmguild"] = Dialog_Return::confirmguild;
		dialogMap["createguild"] = Dialog_Return::createguild;
		dialogMap["guild_member_role_change_finish"] = Dialog_Return::guild_member_role_change_finish;
		dialogMap["guild_member_role_change"] = Dialog_Return::guild_member_role_change;
		dialogMap["guild_member_remove_finish"] = Dialog_Return::guild_member_remove_finish;
		dialogMap["guild_member_remove"] = Dialog_Return::guild_member_remove;
		dialogMap["guild_member_edit"] = Dialog_Return::guild_member_edit;
		dialogMap["guild_statement_edit"] = Dialog_Return::guild_statement_edit;
		dialogMap["sellstuff"] = Dialog_Return::sellstuff;
		dialogMap["sellstuffconfirm"] = Dialog_Return::sellstuffconfirm;
		dialogMap["trade_item"] = Dialog_Return::trade_item;
		dialogMap["trade_confirm"] = Dialog_Return::trade_confirm;
		dialogMap["friends_remove_finish"] = Dialog_Return::friends_remove_finish;
		dialogMap["friends_remove"] = Dialog_Return::friends_remove;
		dialogMap["friends_ignore"] = Dialog_Return::friends_ignore;
		dialogMap["friends_message"] = Dialog_Return::friends_message;
		dialogMap["friends_edit"] = Dialog_Return::friends_edit;
		dialogMap["guildmembers"] = Dialog_Return::guildmembers;
		dialogMap["leave_guild"] = Dialog_Return::leaveguild;
		dialogMap["friends"] = Dialog_Return::friends;
		dialogMap["crystal_exchange"] = Dialog_Return::crystal_exchange;
		dialogMap["Login_Regis_Handle"] = Dialog_Return::Login_Regis_Handle;
		dialogMap["euphoriaEventUI"] = Dialog_Return::euphoriaEventUI;
		dialogMap["Upgrade_DigiVend"] = Dialog_Return::Upgrade_DigiVend;
	}
private:
	static void Req_Verify_Csn(ENetPeer* peer, std::string cch) {
		std::string name_ = pInfo(peer)->world;
		std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			if (to_lower(world_->owner_name) == to_lower(pInfo(peer)->tankIDName)) {
				if (world_->category != "Casino") VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Before requesting verify you must set the World Category 'Casino'!", 0, 1);
				else if (find(Environment()->Waiting_Verif_Csn.begin(), Environment()->Waiting_Verif_Csn.end(), pInfo(peer)->world) != Environment()->Waiting_Verif_Csn.end()) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYour Worlds are already on the waiting list.", 0, 1);
				}
				else {
					Environment()->Waiting_Verif_Csn.push_back(pInfo(peer)->world);
					EventPool::Save::All();
					VarList::OnConsoleMessage(peer, "`oSuccesfully send requesting verification.");
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Succesfully send requesting verification", 0, 1);
				}
			}
		}
	}
	static void worldcategory(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		string button = "", Cat = "None";
		if (parser.try_get("buttonClicked", button)) {
			uint64_t Btn_Hash = quick_hash(button.c_str());
			switch (Btn_Hash) {
			case "cat0"_qh: {
				Cat = "None";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSet World Category``|left|3802|\nembed_data|chosencat|0\nadd_textbox|Are you sure you want to change your world's category to " + Cat + "?|left|\nadd_smalltext|`4Warning:`` Changing your category will delete all ratings on your world .|left|\nend_dialog|worldcategory|Nevermind|Change Category|");
				return;
			}
			case "cat1"_qh: {
				Cat = "Adventure";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSet World Category``|left|3802|\nembed_data|chosencat|1\nadd_textbox|Are you sure you want to change your world's category to " + Cat + "?|left|\nadd_smalltext|`4Warning:`` Changing your category will delete all ratings on your world .|left|\nend_dialog|worldcategory|Nevermind|Change Category|");
				return;
			}
			case "cat2"_qh: {
				Cat = "Art";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSet World Category``|left|3802|\nembed_data|chosencat|2\nadd_textbox|Are you sure you want to change your world's category to " + Cat + "?|left|\nadd_smalltext|`4Warning:`` Changing your category will delete all ratings on your world .|left|\nend_dialog|worldcategory|Nevermind|Change Category|");
				return;
			}
			case "cat3"_qh: {
				Cat = "Farm";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSet World Category``|left|3802|\nembed_data|chosencat|3\nadd_textbox|Are you sure you want to change your world's category to " + Cat + "?|left|\nadd_smalltext|`4Warning:`` Changing your category will delete all ratings on your world .|left|\nend_dialog|worldcategory|Nevermind|Change Category|");
				return;
			}
			case "cat4"_qh: {
				Cat = "Game";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSet World Category``|left|3802|\nembed_data|chosencat|4\nadd_textbox|Are you sure you want to change your world's category to " + Cat + "?|left|\nadd_smalltext|`4Warning:`` Changing your category will delete all ratings on your world .|left|\nend_dialog|worldcategory|Nevermind|Change Category|");
				return;
			}
			case "cat5"_qh: {
				Cat = "Information";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSet World Category``|left|3802|\nembed_data|chosencat|5\nadd_textbox|Are you sure you want to change your world's category to " + Cat + "?|left|\nadd_smalltext|`4Warning:`` Changing your category will delete all ratings on your world .|left|\nend_dialog|worldcategory|Nevermind|Change Category|");
				return;
			}
			case "cat6"_qh: {
				Cat = "Parkour";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSet World Category``|left|3802|\nembed_data|chosencat|6\nadd_textbox|Are you sure you want to change your world's category to " + Cat + "?|left|\nadd_smalltext|`4Warning:`` Changing your category will delete all ratings on your world .|left|\nend_dialog|worldcategory|Nevermind|Change Category|");
				return;
			}
			case "cat7"_qh: {
				Cat = "Roleplay";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSet World Category``|left|3802|\nembed_data|chosencat|7\nadd_textbox|Are you sure you want to change your world's category to " + Cat + "?|left|\nadd_smalltext|`4Warning:`` Changing your category will delete all ratings on your world .|left|\nend_dialog|worldcategory|Nevermind|Change Category|");
				return;
			}
			case "cat8"_qh: {
				Cat = "Shop";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSet World Category``|left|3802|\nembed_data|chosencat|8\nadd_textbox|Are you sure you want to change your world's category to " + Cat + "?|left|\nadd_smalltext|`4Warning:`` Changing your category will delete all ratings on your world .|left|\nend_dialog|worldcategory|Nevermind|Change Category|");
				return;
			}
			case "cat9"_qh: {
				Cat = "Social";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSet World Category``|left|3802|\nembed_data|chosencat|9\nadd_textbox|Are you sure you want to change your world's category to " + Cat + "?|left|\nadd_smalltext|`4Warning:`` Changing your category will delete all ratings on your world .|left|\nend_dialog|worldcategory|Nevermind|Change Category|");
				return;
			}
			case "cat10"_qh: {
				Cat = "Storage";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSet World Category``|left|3802|\nembed_data|chosencat|10\nadd_textbox|Are you sure you want to change your world's category to " + Cat + "?|left|\nadd_smalltext|`4Warning:`` Changing your category will delete all ratings on your world .|left|\nend_dialog|worldcategory|Nevermind|Change Category|");
				return;
			}
			case "cat11"_qh: {
				Cat = "Story";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSet World Category``|left|3802|\nembed_data|chosencat|11\nadd_textbox|Are you sure you want to change your world's category to " + Cat + "?|left|\nadd_smalltext|`4Warning:`` Changing your category will delete all ratings on your world .|left|\nend_dialog|worldcategory|Nevermind|Change Category|");
				return;
			}
			case "cat12"_qh: {
				Cat = "Trade";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSet World Category``|left|3802|\nembed_data|chosencat|12\nadd_textbox|Are you sure you want to change your world's category to " + Cat + "?|left|\nadd_smalltext|`4Warning:`` Changing your category will delete all ratings on your world .|left|\nend_dialog|worldcategory|Nevermind|Change Category|");
				return;
			}
			case "cat13"_qh: {
				Cat = "Puzzle";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSet World Category``|left|3802|\nembed_data|chosencat|13\nadd_textbox|Are you sure you want to change your world's category to " + Cat + "?|left|\nadd_smalltext|`4Warning:`` Changing your category will delete all ratings on your world .|left|\nend_dialog|worldcategory|Nevermind|Change Category|");
				return;
			}
			case "cat14"_qh: {
				Cat = "Music";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSet World Category``|left|3802|\nembed_data|chosencat|14\nadd_textbox|Are you sure you want to change your world's category to " + Cat + "?|left|\nadd_smalltext|`4Warning:`` Changing your category will delete all ratings on your world .|left|\nend_dialog|worldcategory|Nevermind|Change Category|");
				return;
			}
			case "cat15"_qh: {
				Cat = "Guild";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSet World Category``|left|3802|\nembed_data|chosencat|15\nadd_textbox|Are you sure you want to change your world's category to " + Cat + "?|left|\nadd_smalltext|`4Warning:`` Changing your category will delete all ratings on your world .|left|\nend_dialog|worldcategory|Nevermind|Change Category|");
				return;
			}
			case "cat16"_qh: {
				Cat = "Casino";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSet World Category``|left|3802|\nembed_data|chosencat|16\nadd_textbox|Are you sure you want to change your world's category to " + Cat + "?|left|\nadd_smalltext|`4Warning:`` Changing your category will delete all ratings on your world .|left|\nend_dialog|worldcategory|Nevermind|Change Category|");
				return;
			}
			default:
				return;
			}
		}
		else {
			int Category = std::atoi(explode("\n", explode("chosencat|", cch)[1])[0].c_str());
			if (Category < 0 or Category > 16) return;
			string Cat = "None";
			if (Category == 0) Cat = "None"; if (Category == 1) Cat = "Adventure"; if (Category == 2) Cat = "Art"; if (Category == 3) Cat = "Farm"; if (Category == 4) Cat = "Game"; if (Category == 5) Cat = "Information"; if (Category == 14) Cat = "Music"; if (Category == 6) Cat = "Parkour"; if (Category == 13) Cat = "Puzzle"; if (Category == 7) Cat = "Roleplay"; if (Category == 8) Cat = "Shop"; if (Category == 9) Cat = "Social"; if (Category == 10) Cat = "Storage"; if (Category == 11) Cat = "Story"; if (Category == 12) Cat = "Trade"; if (Category == 15) Cat = "Guild"; if (Category == 16) Cat = "Casino";
			try {
				std::string name_ = pInfo(peer)->world;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					if (to_lower(pInfo(peer)->tankIDName) != to_lower(world_->owner_name)) return;
					world_->category = Cat;
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (pInfo(cp_)->world == world_->name and Cat != "None") {
							VarList::OnConsoleMessage(cp_, "This world has been moved to the '" + Cat + "' category! Everyone, please type `2/rate`` to rate it from 1-5 stars.");
						}
					}
				}
			}
			catch (out_of_range) {
				Logger::Info("ERROR", "Server error invalid (out of range) on " + cch);
				return;
			}
		}
	}
	static void Crime_in_Progress(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		if (not is_number(std::string(get_embed(cch, "tilex"))) or not is_number(std::string(get_embed(cch, "tiley")))) return;
		int x = std::atoi(get_embed(cch, "tilex").c_str()), y = std::atoi(get_embed(cch, "tiley").c_str());
		string button = "", name_ = pInfo(peer)->world;
		std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			WorldBlock* block_ = &world_->blocks[x + (y * 100)];
			if (parser.try_get("buttonClicked", button)) {
				uint64_t Btn_Hash = quick_hash(button.c_str());
				switch (Btn_Hash) {
				case "Back"_qh: {
					int crime_1 = Inventory::Contains(peer, 2292), crime_2 = Inventory::Contains(peer, 2294), crime_3 = Inventory::Contains(peer, 2296), crime_4 = Inventory::Contains(peer, 2298), crime_5 = Inventory::Contains(peer, 2300), crime2_1 = Inventory::Contains(peer, 2308), crime2_2 = Inventory::Contains(peer, 2310), crime2_3 = Inventory::Contains(peer, 2312), crime2_4 = Inventory::Contains(peer, 2314), crime2_5 = Inventory::Contains(peer, 2316), crime3_1 = Inventory::Contains(peer, 2320), crime3_2 = Inventory::Contains(peer, 2322), crime3_3 = Inventory::Contains(peer, 2324), crime3_4 = Inventory::Contains(peer, 2326), crime3_5 = Inventory::Contains(peer, 2328), crime4_1 = Inventory::Contains(peer, 2332), crime4_2 = Inventory::Contains(peer, 2334), crime4_3 = Inventory::Contains(peer, 2336), crime4_4 = Inventory::Contains(peer, 2338), crime4_5 = Inventory::Contains(peer, 2340);
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wCrime in Progress|left|" + to_string(block_->id) + "|\nadd_textbox|" + block_->txt + " ``" + block_->heart_monitor + "|left|\nadd_smalltext|Threat level: " + Get_Crime_Level(block_->id) + "|left|\nadd_textbox|Select 5 Superpowers you will use to defeat this villain!<CR>Whether you win or lose, you will lose all 5 cards.|left|\nembed_data|tilex|" + to_string(x) + "\nembed_data|tiley|" + to_string(y) + "\nmax_checks|5|\ntext_scaling_string|`wDirttttttttttttttttttttttttttttttttt|"
						+ (crime_1 > 0 ? "\nadd_checkicon|HeatVision|Heat Vision|noflags|2292|" + to_string(crime_1) + "|0|" : "") +
						a + (crime_2 > 0 ? "\nadd_checkicon|Incinerate|Incinerate|noflags|2294|" + to_string(crime_2) + "|0|" : "") +
						a + (crime_3 > 0 ? "\nadd_checkicon|FlameOn|Flame On!|noflags|2296|" + to_string(crime_3) + "|0|" : "") +
						a + (crime_4 > 0 ? "\nadd_checkicon|Liquify|Liquify|noflags|2298|" + to_string(crime_4) + "|0|" : "") +
						a + (crime_5 > 0 ? "\nadd_checkicon|Oveerheat|Oveerheat|noflags|2300|" + to_string(crime_5) + "|0|" : "") +

						a + (crime2_1 > 0 ? "\nadd_checkicon|IceShards|Ice Shards|noflags|2308|" + to_string(crime2_1) + "|0|" : "") +
						a + (crime2_2 > 0 ? "\nadd_checkicon|FrostBreath|Frost Breath|noflags|2310|" + to_string(crime2_2) + "|0|" : "") +
						a + (crime2_3 > 0 ? "\nadd_checkicon|IceBarrier|Ice Barrier|noflags|2312|" + to_string(crime2_3) + "|0|" : "") +
						a + (crime2_4 > 0 ? "\nadd_checkicon|Puddle|Puddle|noflags|2314|" + to_string(crime2_4) + "|0|" : "") +
						a + (crime2_5 > 0 ? "\nadd_checkicon|FrozenMirror|Frozen Mirror|noflags|2316|" + to_string(crime2_5) + "|0|" : "") +

						a + (crime3_1 > 0 ? "\nadd_checkicon|SuperStrength|Super Strength|noflags|2320|" + to_string(crime3_1) + "|0|" : "") +
						a + (crime3_2 > 0 ? "\nadd_checkicon|SuperSpeed|Super Speed|noflags|2322|" + to_string(crime3_2) + "|0|" : "") +
						a + (crime3_3 > 0 ? "\nadd_checkicon|Enrage|Enrage|noflags|2324|" + to_string(crime3_3) + "|0|" : "") +
						a + (crime3_4 > 0 ? "\nadd_checkicon|Crush|Crush|noflags|2326|" + to_string(crime3_4) + "|0|" : "") +
						a + (crime3_5 > 0 ? "\nadd_checkicon|Regeneration|Regeneration|noflags|2328|" + to_string(crime3_5) + "|0|" : "") +

						a + (crime4_1 > 0 ? "\nadd_checkicon|ShockingFist|Shocking Fist|noflags|2332|" + to_string(crime4_1) + "|0|" : "") +
						a + (crime4_2 > 0 ? "\nadd_checkicon|Thunderstorm|Thunderstorm|noflags|2334|" + to_string(crime4_2) + "|0|" : "") +
						a + (crime4_3 > 0 ? "\nadd_checkicon|Overcharge|Overcharge|noflags|2336|" + to_string(crime4_3) + "|0|" : "") +
						a + (crime4_4 > 0 ? "\nadd_checkicon|Megawatt Pulse|Megawatt Pulse|noflags|2338|" + to_string(crime4_4) + "|0|" : "") +
						a + (crime4_5 > 0 ? "\nadd_checkicon|Resuscitate|Resuscitate|noflags|2340|" + to_string(crime4_5) + "|0|" : "") +

						+(crime_1 == 0 and crime_2 == 0 and crime_3 == 0 and crime_4 == 0 and crime_5 == 0 and crime2_1 == 0 and crime2_2 == 0 and crime2_3 == 0 and crime2_4 == 0 and crime2_5 == 0 and crime3_1 == 0 and crime3_2 == 0 and crime3_3 == 0 and crime3_4 == 0 and crime3_5 == 0 and crime4_1 == 0 and crime4_2 == 0 and crime4_3 == 0 and crime4_4 == 0 and crime4_5 == 0 ? "\nadd_textbox|You don't have any cards to battle!|left|\nadd_button|Game_Rules|`8Game Rules|noflags|0|0|\nend_dialog|Crime_in_Progress|Run away!||" : "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|Game_Rules|`8Game Rules|noflags|0|0|\nend_dialog|Crime_in_Progress|Run away!|Battle!|") + "");
					return;
				}
				case "Game_Rules"_qh: {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wCrimefighting Rules|left|" + to_string(block_->id) + "|\nembed_data|tilex|" + to_string(x) + "\nembed_data|tiley|" + to_string(y) + "\nadd_smalltext|Select 5 Superpower Cards to begin the game. Each villain has their own hand of 5 cards (though unlike you, they may have multiple copies of the same card!). Learn what each villain uses, so you know the best cards to counter theirs!<CR>Each turn, you simply choose one of your cards to play. You'll have to read the INFO on the card items to know what each card does. You can't check it during the gamel Cards can never be played twice in a row, so they will be disabled for 1 turn after use. Your card and your opponent's card take effect simultaneously. However, if you play the right type of card, you will cancel out your opponent's card! Remember this chart:|left|\nadd_custom_button||image:interface/large/super_elements.rttex;image_size:128,128;margin_rself:4.5,0;width:0.10;state:disabled|\nadd_custom_break|\nadd_smalltext|It's like Rock, Paper, Scissors, but with a fourth item. A lemur perhaps. If you play a `2Muscle ``card, and your opponent plays a `9lightning ``card, your card is the only one that has any effect this turn! If you play `9Lightning ``and your opponent plays `4Fire``, both cards take effect, because those two elements do not directly Interact. So always try to play the element that will beat what your opponent plays. It'll be like they never even get a turn!<CR>The goal is to reduce your opponent's Life to zero. Do that, and you'll win a prize! But whether you win or lose, or even if you run away mid-fight, the 5 cards you played the game with will be used up. So go out, find some cards, and fight some crime!|left|\nadd_button|Back|`wBack|noflags|0|0|\nend_dialog|Crime_in_Progress|||");
					return;
				}
				default:
					return;
				}
			}
			else {
			}
		}
	}
	static void kranken_edit(ENetPeer* peer, std::string cch) {
		if (not is_number(std::string(get_embed(cch, "tilex"))) or not is_number(std::string(get_embed(cch, "tiley")))) return;
		int x = std::atoi(get_embed(cch, "tilex").c_str()), y = std::atoi(get_embed(cch, "tiley").c_str());
		TextScanner parser(cch);
		string button = "", name_ = pInfo(peer)->world;
		std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			WorldBlock* block_ = &world_->blocks[x + (y * 100)];
			if (items[block_->fg].blockType != BlockTypes::KRANKEN) return;
			if (parser.try_get("buttonClicked", button)) {
				if (button.substr(0, 4) == "btn_") {
					string btn = button.substr(4), k_r = get_embed(cch, "kranken_r"), k_g = get_embed(cch, "kranken_g"), k_b = get_embed(cch, "kranken_b");
					if (std::atoi(btn.c_str()) < 0 or std::atoi(btn.c_str()) > 12) return;
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wKranken's Galactic Block``|left|10962|\nadd_spacer|small|\nadd_custom_textbox|`wAdjust the color of your block here, by including 0-255 of Red, Green and Blue.`|size:medium|\nadd_text_input|kranken_r|Red|" + k_r + "|3|\nadd_text_input|kranken_g|Green|" + k_g + "|3|\nadd_text_input|kranken_b|Blue|" + k_b + "|3|\nadd_spacer|small|\nadd_custom_textbox|`wPick one of the available patterns for your block.`|size:medium|\nadd_button_with_icon|kranken_block_pattern|||" + to_string(kranken_pattern::get_pattern(atoi(btn.c_str())).second) + "||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_checkbox|kranken_world_save|Set this color as the default for this world.|0\nend_dialog|kranken_edit|Cancel|Save|\nadd_quick_exit|\nembed_data|tilex|" + to_string(x) + "|\nembed_data|tiley|" + to_string(y) + "|\nembed_data|pattern|" + btn + "|");
				}
				if (button == "kranken_block_pattern") {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSelect Pattern``|left|10962|\nadd_spacer|small|\nadd_button_with_icon|btn_0|Pattern 0||10962||\nadd_button_with_icon|btn_1|Pattern 1||10964||\nadd_button_with_icon|btn_2|Pattern 2||10966||\nadd_button_with_icon|btn_3|Pattern 3||10968||\nadd_button_with_icon|btn_4|Pattern 4||10970||\nadd_button_with_icon|btn_5|Pattern 5||10972||\nadd_button_with_icon||END_ROW|noflags|0||\nadd_spacer|big|\nadd_button_with_icon|btn_6|Pattern 6||10974||\nadd_button_with_icon|btn_7|Pattern 7||10976||\nadd_button_with_icon|btn_8|Pattern 8||10978||\nadd_button_with_icon|btn_9|Pattern 9||10980||\nadd_button_with_icon|btn_10|Pattern 10||10982||\nadd_button_with_icon|btn_11|Pattern 11||10984||\nadd_button_with_icon||END_ROW|noflags|0||\nadd_spacer|big|\nadd_button_with_icon|btn_12|Pattern 12||10986||\nadd_button_with_icon||END_ROW|noflags|0||\nadd_spacer|big|\nend_dialog|kranken_edit||Cancel|\nembed_data|tilex|" + to_string(pInfo(peer)->lastwrenchx) + "|\nembed_data|tiley|" + to_string(pInfo(peer)->lastwrenchy) + "|\nembed_data|pattern|" + to_string(block_->kranken_pattern) + "|\nembed_data|kranken_r|" + get_embed(cch, "kranken_r") + "|\nembed_data|kranken_g|" + get_embed(cch, "kranken_g") + "|\nembed_data|kranken_b|" + get_embed(cch, "kranken_b") + "|");
				}
			}
			else {
				string kranken_world_save = parser.get("kranken_world_save", 1);
				if (!isValidCheckboxInput(kranken_world_save)) return;
				int k_r = std::atoi(get_embed(cch, "kranken_r").c_str()), k_g = std::atoi(get_embed(cch, "kranken_g").c_str()), k_b = std::atoi(get_embed(cch, "kranken_b").c_str());
				if (k_r < 0 or k_r > 255 or k_g < 0 or k_g > 255 or k_b < 0 or k_b > 255) return;
				if (kranken_world_save == "1") {
					world_->r = k_r;
					world_->g = k_g;
					world_->b = k_b;
				}
				block_->r = k_r;
				block_->g = k_g;
				block_->b = k_b;
				block_->kranken_pattern = std::atoi(get_embed(cch, "pattern").c_str());
				block_->fg = kranken_pattern::get_pattern(block_->kranken_pattern).second;
				tile_update(peer, world_, block_, x, y);
			}
		}
	}
	static void Pet_Trainer(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "Trade_In_Medal") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wLifeCake the Pet Trainer|left|3554|\nadd_spacer|small|\nadd_textbox|Oh, so you're a pro yourself i hove some things i'd be happy to trade for more medals. You have " + to_string(Inventory::Contains(peer, 3672)) + " Medals.|left|\nadd_button|item_3674|Buy Whale Block for 1 Medal|noflags|0|0|\nadd_button|item_8276|Buy Heavy Chains for 2 Medal|noflags|0|0|\nadd_button|item_8278|Buy Doggy Block for 2 Medal|noflags|0|0|\nadd_button|item_8280|Buy Kitty Block for 2 Medal|noflags|0|0|\nadd_button|item_3626|Buy Pet Trainer Cap for 5 Medal|noflags|0|0|\nadd_button|item_3670|Buy Genetic Resequencer for 10 Medal|noflags|0|0|\nadd_button|item_3690|Buy Buckle Design for 15 Medal|noflags|0|0|\nadd_button|item_3668|Buy CRISPR Technology for 20 Medal|noflags|0|0|\nadd_button|item_3678|Buy Thinking Cap for 50 Medal|noflags|0|0|\nadd_button|item_4998|Buy Riding Turtle for 75 Medal|noflags|0|0|\nadd_button|item_8894|Buy Panda Leash for 80 Medal|noflags|0|0|\nadd_button|item_3680|Buy Phlogiston for 100 Medal|noflags|0|0|\nadd_button|item_3800|Buy Rhino Horn for 100 Medal|noflags|0|0|\nadd_button|item_12304|Buy Owls of Athena for 200 Medal|noflags|0|0|\nadd_button|item_13702|Buy Pet Platypus for 150 Medal|noflags|0|0|\nend_dialog|Pet_Trainer|Nevermind||");
			else if (button == "HowdoPetBattleWork") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wLifeCake the Pet Trainer|left|3554|\nadd_spacer|small|\nadd_smalltext|Pet Battling is a tricky hobby to get into. You need to be dedicated! To get started you'll need a `#Battle Pet Cage``, a `#Battle Leash``, 40 `#World Locks``, and at least 6 pets that can become Battle Pets (use `2Info`` on a pet item to see if it can). Put a pet into your `#Battle Pet Cage``. Then you need to splice it with 2 other pets, which costs 10 `#World Locks ``each. Without special items, you can only combine pets of the same element. Use your Wrench on the Cage to do these things. Now you have a fully - spliced `9Battle Pet``! All Battle Pets have to have 3 kinds of DNA in them to be usable in battle. Put your new Battle Pet in your `#Battle Leash``. Now your `#Battle Pet Cage ``is empty so you can use it to splice together o second Battle Pet.Put that one in your `#Battle Leash ``too. Now you have a fully loaded `#Battle Leash ``and you're ready to take on anybody! Equip it and either Wrench a fellow player who has one, or punch a `9Pet Trainer ``like me. Either way, you're in for a fight.|left|\nadd_custom_button|back|textLabel:`wThank you!;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|HowdoPetBattleWork2|textLabel:`wMore Info;anchor:_button_back;left:1;margin:60,0;|\nend_dialog|Pet_Trainer|||");
			else if (button == "HowdoPetBattleWork2") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wLifeCake the Pet Trainer|left|3554|\nadd_spacer|small|\nadd_smalltext|Fighting is simple: your action bar contains your current pet's 3 powers, and a `#Swap Out ``button. Press the button for a power to use it, or press on `#Swap Out ``to switch to your other pet. Every action you do has a cooldown which means you can't use it again until it lights up. Also, no matter which action you do, all the buttons go on a short cooldown every time so you can't just spam all your attacks. You'll have to remember how your powers work. Outside of battle, you can Wrench yourself to check your current pets' powers (when you have a `#Battle Leash ``equipped), or you can see them on a pet that's in a `#Battle Pet Cage``. The goal is simple: keep your pets alive longer than your opponent's! Be smart about when you swap your pets out and combine your skills in smart ways. Just be smart, basically. If you respawn or disconnect, you'll forfeit the match. Watch out for battling in somebody else's world, where they could use /kick to ruin your match. People are horrible.|left|\nadd_custom_button|back|textLabel:`wThank you!;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|HowdoPetBattleWork3|textLabel:`wMore Info;anchor:_button_back;left:1;margin:60,0;|\nend_dialog|Pet_Trainer|||");
			else if (button == "HowdoPetBattleWork3") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wLifeCake the Pet Trainer|left|3554|\nadd_spacer|small|\nadd_custom_button||image:interface/large/super_elements.rttex;image_size:128,128;margin_rself:4.5,0;width:0.10;state:disabled|\nadd_custom_break|\nadd_smalltext|The elements matter - if your ability's element beats your opponent's element according to the chart above (such as `4Fire `` beats `2Earth``), it will do 25% more damage. If their element beats your ability's (like using a `1Water ``ability against an Air enemy), it will do 25% less damage. Many abilities will place an `#Effect ``on you or your opponent, like setting them on fire, or putting a shield on yourself to block attacks. Effects last for a set time. If you are under an Effect you don't like (perhaps you don't like being on fire?), you can usually `#Swap Out``, which removes all Effects (good and bad!). There are also some abilites that can remove Effects. Of course there are also Effects that make you unable to `#Swap Out``...|left|\nadd_spacer|small|\nadd_smalltext|You're going to be confused at first. There are 70+ different abilities out there, but you'll start to learn what they are and what is best used to counter each one. It doesn't cost anything to battle (well, once you have the Battle Pets!), so why not give it a try and see what you learn? Maybe you'll create a whole zoo of pets for every occasion!|left|\nend_dialog|Pet_Trainer|Thank you!||");
			else if (button.substr(0, 5) == "item_") {
				string wk = "";
				int item_id = std::atoi(button.substr(5).c_str()), price = 0, count = 0;
				if (item_id == 3674) price = 1, count = 5;
				if (item_id == 8276) price = 2, count = 10;
				if (item_id == 8278 or item_id == 8280) price = 2, count = 5;
				if (item_id == 3626) price = 5, count = 1;
				if (item_id == 3670) price = 10, count = 1;
				if (item_id == 3690) price = 15, count = 1;
				if (item_id == 3668) price = 20, count = 1;
				if (item_id == 3678) price = 50, count = 1;
				if (item_id == 4998) price = 75, count = 1;
				if (item_id == 8894) price = 80, count = 1;
				if (item_id == 3680) price = 100, count = 1;
				if (item_id == 3800) price = 100, count = 1;
				if (item_id == 12304) price = 200, count = 1;
				if (item_id == 13702) price = 150, count = 1;
				if (Inventory::Contains(peer, 3672) < price) wk = "\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(Inventory::Contains(peer, 3672)) + " Medals.|left|\nadd_button|Trade_In_Medal|`oSee other items|0|0|";
				else wk = "\nadd_smalltext|`oYou have " + Set_Count(Inventory::Contains(peer, 3672)) + " Medals.|left|\nadd_button|Confirm_Purchase|`9Purchase for " + to_string(price) + " Medals|0|0|\nadd_button|Trade_In_Medal|`oNo thanks|0|0|";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`9Buy " + (count > 1 ? to_string(count) + " " : "") + items[item_id].name + "?|left|" + to_string(item_id) + "|\nembed_data|total_bought|" + to_string(count) + "\nembed_data|item_id|" + to_string(item_id) + "\nembed_data|price|" + to_string(price) + "\nadd_smalltext|" + items[item_id].description + "|left|\nadd_spacer|small|" + wk + "|\nend_dialog|Pet_Trainer|||");
			}
			else if (button == "Confirm_Purchase") {
				int id = std::atoi(get_embed(cch, "item_id").c_str()), price = std::atoi(get_embed(cch, "price").c_str()), total_bought = std::atoi(get_embed(cch, "total_bought").c_str());
				vector<int> list_{ 3674,8276,8278,8280,3626,3670,3690,3668,3678,4998,8894,3680,3800,12304,13702 };
				if (find(list_.begin(), list_.end(), id) == list_.end()) return;
				if (id == 0 or price == 0 or total_bought == 0) return;
				if (Inventory::Check_Max(peer, id, total_bought)) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, true);
					return;
				}
				int free_slots = Inventory::Get_Slots(pInfo(peer));
				if (free_slots == 0) {
					VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
					return;
				}
				int medals = Inventory::Contains(peer, 3672);
				if (medals < price) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You can't afford that many!", 0, true);
					return;
				}
				int cnt = total_bought, rem = 0;
				if (Inventory::Modify(peer, id, total_bought) == 0) {
					Inventory::Modify(peer, 3672, rem -= price);
					PlayerMoving data_{}; PlayerMoving data{};
					data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = id, data_.punchY = pInfo(peer)->netID;
					int32_t to_netid = pInfo(peer)->netID;
					BYTE* raw = packPlayerMoving(&data_);
					raw[3] = 5;
					Memory_Copy(raw + 8, &to_netid, 4);
					data.packetType = 19, data.netID = -1, data.plantingTree = 0;
					data.x = pInfo(peer)->lastwrenchx * 32 + 16, data.y = pInfo(peer)->lastwrenchy * 32 + 16;
					data.XSpeed = pInfo(peer)->x + 16, data.YSpeed = pInfo(peer)->y + 16;
					data.punchX = 3672;
					BYTE* raw_ = packPlayerMoving(&data);
					raw_[3] = 6;
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL) return;
						if (pInfo(peer)->world == pInfo(cp_)->world) {
							send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							send_raw(cp_, 4, raw_, 56, ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[] raw, raw_;
					VarList::OnConsoleMessage(peer, "`oYou've purchased " + (total_bought > 1 ? to_string(total_bought) : "") + " " + items[id].name + " for " + to_string(price) + " Pet Trainer Medals.\nYou have " + to_string(Inventory::Contains(peer, 3672)) + " Pet Trainer Medals left.");
				}
				else {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, true);
					return;
				}
			}
		}
	}
	static void Locke_Salesman(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "BackToLocke") {
				string hold = "";
				uint16_t wl = 0, dl = 0, bgl = 0, sl = 0, bl = 0, hl = 0;
				for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) {
					if (pInfo(peer)->inv[i_].first == 202) sl = pInfo(peer)->inv[i_].second;
					if (pInfo(peer)->inv[i_].first == 204) bl = pInfo(peer)->inv[i_].second;
					if (pInfo(peer)->inv[i_].first == 206) hl = pInfo(peer)->inv[i_].second;
					if (pInfo(peer)->inv[i_].first == 242) wl = pInfo(peer)->inv[i_].second;
					if (pInfo(peer)->inv[i_].first == 1796) dl = pInfo(peer)->inv[i_].second;
					if (pInfo(peer)->inv[i_].first == 7188) bgl = pInfo(peer)->inv[i_].second;
					if (wl && dl && bgl && sl && bl && hl) return;
				}
				hold = "\nadd_smalltext|`9(Hmm, smells like you don't care any world locks)``|left|";
				if (wl != 0 || dl != 0 || sl != 0 || bl != 0 || hl != 0 || bgl != 0) hold = "\nadd_smalltext|`9(Hmm, smells like you care carrying";
				if (sl) hold += " " + to_string(sl) + " Small Locks" + (bl != 0 or hl != 0 or wl != 0 or dl != 0 or bgl != 0 ? "," : ")``|left|") + "";
				if (bl) hold += "" + a + (hl == 0 and wl == 0 and dl == 0 and bgl == 0 and not (sl == 0) ? " and " : " ") + to_string(bl) + " Big Locks" + (hl != 0 or wl != 0 or dl != 0 or bgl != 0 ? "," : ")``|left|") + "";
				if (hl) hold += "" + a + (wl == 0 and dl == 0 and bgl == 0 and not (sl == 0 or bl == 0) ? " and " : " ") + to_string(hl) + " Huge Locks" + (wl != 0 or dl != 0 or bgl != 0 ? "," : ")``|left|") + "";
				if (wl) hold += "" + a + (dl == 0 and bgl == 0 and not (sl == 0 or bl == 0 or hl == 0) ? " and " : " ") + to_string(wl) + " World Locks" + (dl != 0 or bgl != 0 ? "," : ")``|left|") + "";
				if (dl) hold += "" + a + (bgl == 0 and not (sl == 0 or bl == 0 or hl == 0 or wl == 0) ? " and " : " ") + to_string(dl) + " Diamond Locks" + (bgl != 0 ? "," : ")``|left|") + "";
				if (bgl) hold += "" + a + (sl != 0 or bl != 0 or hl != 0 or wl != 0 ? " and " : " ") + to_string(bgl) + " Platinum Gem Locks)``|left| ";
				VarList::OnDialogRequest(peer, SetColor(peer) + a + "set_default_color|`o\n\nadd_label_with_icon|big|`9Locke The Traveling Salesman``|left|2398|\nadd_smalltext|Ho there, friend! Locke's my name, and locks are my game. I Love 'em all, Diamond, Huge.. even Small! If you can part with some locks, I'll give you something special in return. Whaddya say?|left|\nadd_spacer|small|\nadd_smalltext|" + hold + "|left|\nadd_spacer|small|\nadd_button|item_204|Buy Big Lock for 5 Small Locks|noflags|0|0|\nadd_button|item_206|Buy Huge Lock for 3 Big Locks|noflags|0|0|\nadd_button|item_5262|Buy Neon Gum for 2 Huge Locks|noflags|0|0|\nadd_button|item_242|Buy World Lock for 5 Huge Locks|noflags|0|0|\nadd_button|item_2478|Buy Locke's Mystery Box for 1 World Lock|noflags|0|0|\nadd_button|item_2724|Buy Basic Blue Block for 1 World Lock|noflags|0|0|\nadd_button|item_5954|Buy Guild Chest for 1 World Lock|noflags|0|0|\nadd_button|item_3156|Buy Transdimensional Vaporizer Ray for 3 World Locks|noflags|0|0|\nadd_button|item_3676|Buy Pet Trainer Whistle for 5 World Locks|noflags|0|0|\nadd_button|item_14042|Buy Sale Television for 5 World Locks|noflags|0|0|\nadd_button|item_8878|Buy Safe Vault for 6 World Locks|noflags|0|0|\nadd_button|item_5258|Buy Chi Harmonizer for 10 World Locks|noflags|0|0|\nadd_button|item_3684|Buy Lock-Bot Remote for 10 World Locks|noflags|0|0|\nadd_button|item_1280|Buy Birth Certificate for 15 World Locks|noflags|0|0|\nadd_button|item_6140|Buy Extract-O-Snap for 15 World Locks|noflags|0|0|\nadd_button|item_2992|Buy Wolf Whistle for 15 World Locks|noflags|0|0|\nadd_button|item_3560|Buy Lock Mover for 20 World Locks|noflags|0|0|\nadd_button|item_14038|Buy Edgy Anime Robe for 25 World Locks|noflags|0|0|\nadd_button|item_3798|Buy VIP Entrance for 25 World Locks|noflags|0|0|\nadd_button|item_3314|Buy Stretched Canvas for 30 World Locks|noflags|0|0|\nadd_button|item_5202|Buy Soul Stone for 30 World Locks|noflags|0|0|\nadd_button|item_3188|Buy Sword Pommel for 40 World Locks|noflags|0|0|\nadd_button|item_2476|Buy Burning Eyes for 50 World Locks|noflags|0|0|\nadd_button|item_7190|Buy Guild Name Changer for 65 World Locks|noflags|0|0|\nadd_button|item_8892|Buy Raccoon Leash for 80 World Locks|noflags|0|0|\nadd_button|item_2720|Buy Electric Bow for 1 Diamond Lock|noflags|0|0|\nadd_button|item_2452|Buy Clothing Compactor for 1 Diamond Lock|noflags|0|0|\nadd_button|item_1486|Buy Growtoken for 1 Diamond Lock|noflags|0|0|\nadd_button|item_11156|Buy Growmoji Chest for 150 World Locks|noflags|0|0|\nadd_button|item_2702|Buy MickeyMay Leash for 3 Diamond Locks|noflags|0|0|\nadd_button|item_2722|Buy Golden Aura for 5 Diamond Locks|noflags|0|0|\nadd_button|item_4972|Buy Blue Aura for 5 Diamond Locks|noflags|0|0|\nadd_button|item_4970|Buy Pink Aura for 5 Diamond Locks|noflags|0|0|\nadd_button|item_5264|Buy Neon Nerves for 5 Diamond Locks|noflags|0|0|\nadd_button|item_4948|Buy Solar Chariot for 10 Diamond Locks|noflags|0|0|\nadd_button|item_3040|Buy Goldenrod for 10 Diamond Locks|noflags|0|0|\nadd_button|item_5260|Buy Harmonic Lock for 10 Diamond Locks|noflags|0|0|\nadd_button|item_11134|Buy Samille's Soul Abductor for 10 Diamond Locks|noflags|0|0|\nadd_button|item_3686|Buy Toy Lock-Bot for 15 Diamond Locks|noflags|0|0|\nadd_button|item_2450|Buy Diamond Dragon for 100 Diamond Locks|noflags|0|0|\nadd_button|item_12480|Buy Punch Antennae for 10 World Locks|noflags|0|0|\nadd_button|item_12482|Buy Build Antennae for 10 World Locks|noflags|0|0|\nadd_button|item_12484|Buy Grow Antennae for 10 World Locks|noflags|0|0|\nadd_button|item_12358|Buy Music Amplifier for 50 World Locks|noflags|0|0|\nadd_button|item_13730|Buy Diamond Lock Mask for 1 Diamond Lock|noflags|0|0|\nadd_button|item_13790|Buy Stylish Sunglasses for 25 World Locks|noflags|0|0|\nadd_button|item_13680|Buy Eldritch Flame Aura for 5 Platinum Gem Locks|noflags|0|0|\nadd_button|Ask_Something|Ask Locke Something|noflags|0|0|1|\nend_dialog|Locke_Salesman|Goodbye!||");
			}
			else if (button == "Ask_Something") {
				VarList::OnDialogRequest(peer, SetColor(peer) + a + "set_default_color|`o\n\nadd_label_with_icon|big|`9Ask Locke A Question``|left|2398|\nadd_textbox|I've been all around Growtopian in my travels! Was there something you were curious about?|left|\nadd_text_input|question|||100|\nadd_spacer|small|\nadd_custom_button|BackToLocke|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|AskToLocke|textLabel:`wAsk it;anchor:_button_BackToLocke;left:1;margin:60,0;|\nadd_quick_exit|\nend_dialog|Locke_Salesman|||");
			}
			else if (button == "AskToLocke") {
				string question = parser.get("question", 1); int itemID = -1;
				for (int i = 0; i < items.size(); ++i) {
					if (to_lower(question) == to_lower(items[i].name)) {
						itemID = i;
						return;
					}
				}
				if (itemID == -1) VarList::OnDialogRequest(peer, SetColor(peer) + a + "set_default_color|`o\n\nadd_label_with_icon|big|`9Locke's Wisdom``|left|2398|\nadd_textbox|Umm, \"" + question + "\", huh? That does not ring a bell at all. Sorry!|left|\nadd_quick_exit|\nend_dialog|Locke_Salesman|Thanks||");
				else VarList::OnDialogRequest(peer, SetColor(peer) + a + "set_default_color|`o\n\nadd_label_with_icon|big|`9Locke's Wisdom``|left|2398|\nadd_textbox|A " + items[itemID].name + ", " + items[itemID].description + "|left|\nadd_quick_exit|\nend_dialog|Locke_Salesman|Thanks||");
			}
			else if (button.substr(0, 5) == "item_") {
				string wk = "";
				int item_id = std::atoi(button.substr(5).c_str()), price = 0, id_price = 0;
				if (item_id == 204) price = 5, id_price = 202;
				if (item_id == 206) price = 3, id_price = 204;
				if (item_id == 5262) price = 3, id_price = 206;
				if (item_id == 242) price = 5, id_price = 206;
				if (item_id == 2478 or item_id == 2724 or item_id == 5954) price = 1, id_price = 242;
				if (item_id == 3156) price = 3, id_price = 242;
				if (item_id == 3676 or item_id == 14042) price = 5, id_price = 242;
				if (item_id == 8878) price = 6, id_price = 242;
				if (item_id == 5258 or item_id == 3684 or item_id == 12480 or item_id == 12482 or item_id == 12484) price = 10, id_price = 242;
				if (item_id == 1280 or item_id == 6140 or item_id == 2992) price = 15, id_price = 242;
				if (item_id == 3560) price = 20, id_price = 242;
				if (item_id == 14038 or item_id == 3798 or item_id == 13790) price = 25, id_price = 242;
				if (item_id == 3314 or item_id == 5202) price = 30, id_price = 242;
				if (item_id == 3188) price = 40, id_price = 242;
				if (item_id == 2476 or item_id == 12358) price = 50, id_price = 242;
				if (item_id == 7190) price = 65, id_price = 242;
				if (item_id == 8892) price = 80, id_price = 242;
				if (item_id == 2720 or item_id == 2452 or item_id == 1486 or item_id == 13730) price = 1, id_price = 1796;
				if (item_id == 11156) price = 150, id_price = 242;
				if (item_id == 2702) price = 3, id_price = 1796;
				if (item_id == 2722 or item_id == 4972 or item_id == 4970 or item_id == 5264) price = 5, id_price = 1796;
				if (item_id == 4948 or item_id == 3040 or item_id == 5260 or item_id == 11134) price = 10, id_price = 1796;
				if (item_id == 3686) price = 15, id_price = 1796;
				if (item_id == 2450) price = 100, id_price = 1796;
				if (item_id == 13680) price = 5, id_price = 7188;
				int locks = Inventory::Contains(peer, id_price);
				if (Inventory::Contains(peer, id_price) < price) wk = "\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(locks) + " " + items[id_price].name + ".|left|\nadd_button|BackToLocke|`oSee other items|0|0|";
				else wk = "\nadd_textbox|`oHow many " + items[item_id].name + " do you want to buy, for " + to_string(price) + " " + items[id_price].name + " each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(locks) + " " + items[id_price].name + ".|left|\nadd_button|Yes_Purchase|`9Purchase|0|0|\nadd_button|BackToLocke|`oNo thanks|0|0|";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`9Buy " + items[item_id].name + "?|left|" + to_string(item_id) + "|\nembed_data|item_id|" + to_string(item_id) + "\nembed_data|price|" + to_string(price) + "\nembed_data|id_price|" + to_string(id_price) + "\nadd_smalltext|" + items[item_id].description + "|left|\nadd_spacer|small|" + wk + "|\nadd_quick_exit|\nend_dialog|Locke_Salesman|||");
			}
			else if (button == "Yes_Purchase") {
				string buycountstr = parser.get("buy_amount", 1);
				int realprice = std::atoi(get_embed(cch, "price").c_str()), id = std::atoi(get_embed(cch, "item_id").c_str()), id_price = std::atoi(get_embed(cch, "id_price").c_str());
				vector<int> list_{ 204,206,5262,242,2478,2724,5954,3156,3676,14042,8878,5258,3684,12480,12482,12484,1280,6140,2992,3560,14038,3798,13790,3314,5202,3188,2476,12358,7190,8892,2720,2452,1486,13730,11156,2702,2722,4972,4970,5264,4948,3040,5260,11134,3686,2450,13680 };
				if (find(list_.begin(), list_.end(), id) == list_.end()) return;
				if (realprice == 0 or id == 0 or id_price == 0) return;
				if (not is_number(buycountstr) || buycountstr.size() > 3 || buycountstr.size() <= 0 || std::atoi(buycountstr.c_str()) <= 0 || std::atoi(buycountstr.c_str()) > 200) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid Input!", 0, true);
					return;
				}
				int locks = Inventory::Contains(peer, id_price);
				int kiekmoketi = std::atoi(buycountstr.c_str()) * realprice;
				if (locks < kiekmoketi) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You can't afford that many!", 0, true);
					return;
				}
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Really Buy " + to_string(std::atoi(buycountstr.c_str())) + " " + items[id].name + "?|left|" + to_string(id) + "|\nembed_data|item_id|" + to_string(id) + "\nembed_data|total_bought|" + buycountstr + "\nembed_data|total_price|" + to_string(kiekmoketi) + "\nembed_data|id_price|" + to_string(id_price) + "\nadd_textbox|`oAre you sure you want to buy `w" + to_string(std::atoi(buycountstr.c_str())) + " " + items[id].name + " `ofor a total cost of `2" + to_string(kiekmoketi) + " " + items[id_price].name + "`o?|left|\nadd_smalltext|`oYou have " + to_string(locks) + " " + items[id_price].name + ".|left|\nadd_button|Confirm_Purchase|`9YES! GIMME!!!|0|0|\nadd_button|BackToLocke|`oNo thanks|0|0|\nend_dialog|Locke_Salesman|||\nadd_quick_exit|");
			}
			else if (button == "Confirm_Purchase") {
				int id = std::atoi(get_embed(cch, "item_id").c_str()), total_price = std::atoi(get_embed(cch, "total_price").c_str()), total_bought = std::atoi(get_embed(cch, "total_bought").c_str()), id_price = std::atoi(get_embed(cch, "id_price").c_str());
				vector<int> list_{ 204,206,5262,242,2478,2724,5954,3156,3676,14042,8878,5258,3684,12480,12482,12484,1280,6140,2992,3560,14038,3798,13790,3314,5202,3188,2476,12358,7190,8892,2720,2452,1486,13730,11156,2702,2722,4972,4970,5264,4948,3040,5260,11134,3686,2450,13680 };
				if (find(list_.begin(), list_.end(), id) == list_.end()) return;
				if (id == 0 or total_price == 0 or total_bought == 0 or id_price == 0) return;
				if (Inventory::Check_Max(peer, id, total_bought)) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, true);
					return;
				}
				int free_slots = Inventory::Get_Slots(pInfo(peer));
				if (free_slots == 0) {
					VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
					return;
				}
				int locks = Inventory::Contains(peer, id_price);
				if (locks < total_price) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You can't afford that many!", 0, true);
					return;
				}
				int cnt = total_bought, rem = 0;
				if (Inventory::Modify(peer, id, total_bought) == 0) {
					Inventory::Modify(peer, id_price, rem -= total_price);
					if (id == 2450) Epic_Quest::Add(peer, "Buy a Diamond Dragon from Locke The Traveling Salesman", pInfo(peer)->epicq_ddrag, 1, 1);
					if (id == 1486) {
						if (pInfo(peer)->C_QuestActive && pInfo(peer)->C_QuestKind == 14 && pInfo(peer)->C_QuestProgress < pInfo(peer)->C_ProgressNeeded) {
							pInfo(peer)->C_QuestProgress += cnt;
							if (pInfo(peer)->C_QuestProgress >= pInfo(peer)->C_ProgressNeeded) {
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`9Ring Quest task complete! Go tell the Ringmaster!", 0, 0);
							}
						}
					}
					PlayerMoving data_{}; PlayerMoving data{};
					data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = id, data_.punchY = pInfo(peer)->netID;
					int32_t to_netid = pInfo(peer)->netID;
					BYTE* raw = packPlayerMoving(&data_);
					raw[3] = 5;
					Memory_Copy(raw + 8, &to_netid, 4);
					data.packetType = 19, data.netID = -1, data.plantingTree = 0;
					data.x = pInfo(peer)->lastwrenchx * 32 + 16, data.y = pInfo(peer)->lastwrenchy * 32 + 16;
					data.XSpeed = pInfo(peer)->x + 16, data.YSpeed = pInfo(peer)->y + 16;
					data.punchX = id_price;
					BYTE* raw_ = packPlayerMoving(&data);
					raw_[3] = 6;
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL) return;
						if (pInfo(peer)->world == pInfo(cp_)->world) {
							send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							send_raw(cp_, 4, raw_, 56, ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[] raw, raw_;
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wSuccesfully Bought " + to_string(cnt) + " " + items[id].name + " for " + Set_Count(total_price) + " " + items[id_price].name + ".", 0, 1);
				}
				else {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, true);
					return;
				}
			}
		}
	}
	static void LockBot(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "BackToLockBot") {
				string hold = "";
				uint16_t wl = 0, dl = 0, bgl = 0, sl = 0, bl = 0, hl = 0;
				for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) {
					if (pInfo(peer)->inv[i_].first == 202) sl = pInfo(peer)->inv[i_].second;
					if (pInfo(peer)->inv[i_].first == 204) bl = pInfo(peer)->inv[i_].second;
					if (pInfo(peer)->inv[i_].first == 206) hl = pInfo(peer)->inv[i_].second;
					if (pInfo(peer)->inv[i_].first == 242) wl = pInfo(peer)->inv[i_].second;
					if (pInfo(peer)->inv[i_].first == 1796) dl = pInfo(peer)->inv[i_].second;
					if (pInfo(peer)->inv[i_].first == 7188) bgl = pInfo(peer)->inv[i_].second;
					if (wl && dl && bgl && sl && bl && hl) return;
				}
				hold = "\nadd_smalltext|`9Wait, you don't have any locks at all! Why are you wasting my time?``|left|";
				if (wl != 0 || dl != 0 || sl != 0 || bl != 0 || hl != 0 || bgl != 0) hold = "\nadd_smalltext|`9(Sensors detect";
				if (sl) hold += " " + to_string(sl) + " Small Locks" + (bl != 0 or hl != 0 or wl != 0 or dl != 0 or bgl != 0 ? "," : ")``|left|") + "";
				if (bl) hold += "" + a + (hl == 0 and wl == 0 and dl == 0 and bgl == 0 and not (sl == 0) ? " and " : " ") + to_string(bl) + " Big Locks" + (hl != 0 or wl != 0 or dl != 0 or bgl != 0 ? "," : ")``|left|") + "";
				if (hl) hold += "" + a + (wl == 0 and dl == 0 and bgl == 0 and not (sl == 0 or bl == 0) ? " and " : " ") + to_string(hl) + " Huge Locks" + (wl != 0 or dl != 0 or bgl != 0 ? "," : ")``|left|") + "";
				if (wl) hold += "" + a + (dl == 0 and bgl == 0 and not (sl == 0 or bl == 0 or hl == 0) ? " and " : " ") + to_string(wl) + " World Locks" + (dl != 0 or bgl != 0 ? "," : ")``|left|") + "";
				if (dl) hold += "" + a + (bgl == 0 and not (sl == 0 or bl == 0 or hl == 0 or wl == 0) ? " and " : " ") + to_string(dl) + " Diamond Locks" + (bgl != 0 ? "," : ")``|left|") + "";
				if (bgl) hold += "" + a + (sl != 0 or bl != 0 or hl != 0 or wl != 0 ? " and " : " ") + to_string(bgl) + " Platinum Gem Locks)``|left| ";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Lock-Bot|left|3682|\nadd_smalltext|`oGreetings human, i'm Lock-Bot. I can provide convenient access to Locke's supply of goods, in exchange for Locks. However. I must leave to recharge in 8 hours.|left|\nadd_spacer|small|" + hold + "|\nadd_button|item_204|`oBuy Big Lock for 5 Small Locks|0|0|\nadd_button|item_206|`oBuy Huge Lock for 3 Big Locks|0|0|\nadd_button|item_5262|`oBuy Neon Gum for 2 Huge Locks|0|0|\nadd_button|item_242|`oBuy World Lock for 5 Huge Locks|0|0|\nadd_button|item_5954|`oBuy Guild Chest for 1 World Locks|0|0|\nadd_button|item_3156|`oBuy Transdimensional Vaporizer Ray for 3 World Locks|0|0|\nadd_button|item_3676|`oBuy Pet Trainer Whisle for 5 World Locks|0|0|\nadd_button|item_8878|`oBuy Safe Vault for 6 World Locks|0|0|\nadd_button|item_12480|`oBuy Punch Antennae for 10 World Locks|0|0|\nadd_button|item_12482|`oBuy Build Antennae for 10 World Locks|0|0|\nadd_button|item_12484|`oBuy Grow Antennae for 10 World Locks|0|0|\nadd_button|item_3684|`oBuy Lock-Bot Remote for 10 World Locks|0|0|\nadd_button|item_5258|`oBuy Chi Harmonizer for 10 World Locks|0|0|\nadd_button|item_6140|`oBuy Extract-O-Snap for 15 World Locks|0|0|\nadd_button|item_1280|`oBuy Birth Certificate for 15 World Locks|0|0|\nadd_button|item_3560|`oBuy Lock Mover for 20 World Locks|0|0|\nadd_button|item_13790|`oBuy Stylish Sunglasses for 25 World Locks|0|0|\nadd_button|item_12358|`oBuy Music Amplifier for 50 World Locks|0|0|\nadd_button|item_7190|`oBuy Guild Name Changer for 65 World Locks|0|0|\nadd_button|item_1486|`oBuy Growtoken for 1 Diamond Locks|0|0|\nadd_button|item_5264|`oBuy Neon Nerves for 5 Diamond Locks|0|0|\nadd_button|item_5260|`oBuy Harmonic Lock for 10 Diamond Locks|0|0|\nend_dialog|LockBot|GoodBye!||\nadd_quick_exit|");
			}
			else if (button.substr(0, 5) == "item_") {
				string wk = "";
				int item_id = std::atoi(button.substr(5).c_str()), wl = get_wls(peer, true), price = 0, id_price = 0;
				if (item_id == 204) price = 5, id_price = 202;
				if (item_id == 206) price = 3, id_price = 204;
				if (item_id == 5262) price = 3, id_price = 206;
				if (item_id == 242) price = 5, id_price = 206;
				if (item_id == 5954) price = 1, id_price = 242;
				if (item_id == 3156) price = 3, id_price = 242;
				if (item_id == 3676) price = 5, id_price = 242;
				if (item_id == 8878) price = 6, id_price = 242;
				if (item_id == 12480) price = 10, id_price = 242;
				if (item_id == 12482) price = 10, id_price = 242;
				if (item_id == 12484) price = 10, id_price = 242;
				if (item_id == 3684) price = 10, id_price = 242;
				if (item_id == 5258) price = 10, id_price = 242;
				if (item_id == 6140) price = 15, id_price = 242;
				if (item_id == 1280) price = 15, id_price = 242;
				if (item_id == 3560) price = 20, id_price = 242;
				if (item_id == 13790) price = 25, id_price = 242;
				if (item_id == 12358) price = 50, id_price = 242;
				if (item_id == 7190) price = 65, id_price = 242;
				if (item_id == 1486) price = 100, id_price = 242;
				if (item_id == 5264) price = 500, id_price = 242;
				if (item_id == 5260) price = 1000, id_price = 242;
				int payment = Inventory::Contains(peer, id_price);
				if (id_price == 202 or id_price == 204 or id_price == 206) {
					if (Inventory::Contains(peer, id_price) < price) wk = "\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(payment) + " " + items[id_price].name + ".|left|\nadd_button|BackToLockBot|`oSee other items|0|0|";
					else wk = "\nadd_textbox|`oHow many " + items[item_id].name + " do you want to buy, for " + to_string(price) + " " + items[id_price].name + " each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(payment) + " " + items[id_price].name + ".|left|\nadd_button|Yes_Purchase|`9Purchase|0|0|\nadd_button|BackToLockBot|`oNo thanks|0|0|";
				}
				else {
					if (wl < price) wk = "\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToLockBot|`oSee other items|0|0|";
					else wk = "\nadd_textbox|`oHow many " + items[item_id].name + " do you want to buy, for " + to_string(price) + " " + items[id_price].name + " each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Lock.|left|\nadd_button|Yes_Purchase|`9Purchase|0|0|\nadd_button|BackToLockBot|`oNo thanks|0|0|";
				}
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[item_id].name + "?|left|" + to_string(item_id) + "|\nembed_data|item_id|" + to_string(item_id) + "\nembed_data|price|" + to_string(price) + "\nembed_data|id_price|" + to_string(id_price) + "\nadd_smalltext|\nadd_smalltext|`3ITEM DATA: `o" + items[item_id].description + "|left|\nadd_spacer|small|" + wk + "|\nadd_quick_exit|\nend_dialog|LockBot|||");
			}
			else if (button == "Yes_Purchase") {
				string buycountstr = parser.get("buy_amount", 1);
				int realprice = std::atoi(get_embed(cch, "price").c_str()), id = std::atoi(get_embed(cch, "item_id").c_str()), id_price = std::atoi(get_embed(cch, "id_price").c_str());
				vector<int> list_{ 204,206,5262,242,5954,3156,3676,8878,12480,12482,12484,3684,5258,6140,1280,3560,13790,12358,7190,1486,5264,5260 };
				if (find(list_.begin(), list_.end(), id) == list_.end()) return;
				if (realprice == 0 or id == 0 or id_price == 0) return;
				if (not is_number(buycountstr) || buycountstr.size() > 3 || buycountstr.size() <= 0 || std::atoi(buycountstr.c_str()) <= 0 || std::atoi(buycountstr.c_str()) > 200) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid Input!", 0, true);
					return;
				}
				int payment = Inventory::Contains(peer, id_price);
				int kiekmoketi = std::atoi(buycountstr.c_str()) * realprice, my_wls = get_wls(peer, true);
				if (id_price == 202 or id_price == 204 or id_price == 206) {
					if (Inventory::Contains(peer, id_price) < kiekmoketi) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You can't afford that many!", 0, true);
						return;
					}
				}
				else {
					if (my_wls < kiekmoketi) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You can't afford that many!", 0, true);
						return;
					}
				}
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Really Buy " + to_string(std::atoi(buycountstr.c_str())) + " " + items[id].name + "?|left|" + to_string(id) + "|\nembed_data|item_id|" + to_string(id) + "\nembed_data|total_bought|" + buycountstr + "\nembed_data|total_price|" + to_string(kiekmoketi) + "\nembed_data|id_price|" + to_string(id_price) + "\nadd_textbox|`oAre you sure you want to buy `w" + to_string(std::atoi(buycountstr.c_str())) + " " + items[id].name + " `ofor a total cost of `2" + to_string(kiekmoketi) + " " + items[id_price].name + "`o?|left|\nadd_smalltext|`oYou have " + (id_price == 242 ? Set_Count(my_wls) + " World Locks" : to_string(payment) + " " + items[id_price].name) + ".|left|\nadd_button|Confirm_Purchase|`9YES! GIMME!!!|0|0|\nadd_button|BackToLockBot|`oNo thanks|0|0|\nend_dialog|LockBot|||\nadd_quick_exit|");
			}
			else if (button == "Confirm_Purchase") {
				int my_wls = get_wls(peer, true), id = std::atoi(get_embed(cch, "item_id").c_str()), total_price = std::atoi(get_embed(cch, "total_price").c_str()), total_bought = std::atoi(get_embed(cch, "total_bought").c_str()), id_price = std::atoi(get_embed(cch, "id_price").c_str());
				vector<int> list_{ 204,206,5262,242,5954,3156,3676,8878,12480,12482,12484,3684,5258,6140,1280,3560,13790,12358,7190,1486,5264,5260 };
				if (find(list_.begin(), list_.end(), id) == list_.end()) return;
				if (id == 0 or total_price == 0 or total_bought == 0 or id_price == 0) return;
				if (Inventory::Check_Max(peer, id, total_bought)) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, true);
					return;
				}
				int free_slots = Inventory::Get_Slots(pInfo(peer));
				if (free_slots == 0) {
					VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
					return;
				}
				if (id_price == 202 or id_price == 204 or id_price == 206) {
					if (Inventory::Contains(peer, id_price) < total_price) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You can't afford that many!", 0, true);
						return;
					}
				}
				else {
					if (my_wls < total_price) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You can't afford that many!", 0, true);
						return;
					}
				}
				int cnt = total_bought;
				if (Inventory::Modify(peer, id, total_bought) == 0) {
					if (id_price == 242) get_wls(peer, true, true, total_price);
					else {
						int rem = 0;
						Inventory::Modify(peer, id_price, rem -= total_price);
					}
					PlayerMoving data_{}; PlayerMoving data{};
					data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = id, data_.punchY = pInfo(peer)->netID;
					int32_t to_netid = pInfo(peer)->netID;
					BYTE* raw = packPlayerMoving(&data_);
					raw[3] = 5;
					Memory_Copy(raw + 8, &to_netid, 4);
					data.packetType = 19, data.netID = -1, data.plantingTree = 0;
					data.x = pInfo(peer)->lastwrenchx * 32 + 16, data.y = pInfo(peer)->lastwrenchy * 32 + 16;
					data.XSpeed = pInfo(peer)->x + 16, data.YSpeed = pInfo(peer)->y + 16;
					if (id_price == 242) data.punchX = (total_price > 99 ? 1796 : 242);
					else data.punchX = id_price;
					BYTE* raw_ = packPlayerMoving(&data);
					raw_[3] = 6;
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL) return;
						if (pInfo(peer)->world == pInfo(cp_)->world) {
							send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							send_raw(cp_, 4, raw_, 56, ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[] raw, raw_;
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wSuccesfully Bought " + to_string(cnt) + " " + items[id].name + " for " + Set_Count(total_price) + " " + items[id_price].name + ".", 0, 1);
				}
				else {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, true);
					return;
				}
			}
		}
	}
	static void Nutcracker(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "BackToNutcracker") {
				string hold = "";
				uint16_t wl = 0, dl = 0, bgl = 0;
				for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) {
					if (pInfo(peer)->inv[i_].first == 242) wl = pInfo(peer)->inv[i_].second;
					if (pInfo(peer)->inv[i_].first == 1796) dl = pInfo(peer)->inv[i_].second;
					if (pInfo(peer)->inv[i_].first == 7188) bgl = pInfo(peer)->inv[i_].second;
					if (wl && dl && bgl) return;
				}
				hold = "\nadd_smalltext|`9Wait, you don't have any locks at all! Why are you wasting my time?``|left|";
				if (wl != 0 || dl != 0 || bgl != 0) hold = "\nadd_smalltext|`9(Hmm, smells like you care carrying";
				if (wl) hold += " " + to_string(wl) + " World Locks" + (dl != 0 or bgl != 0 ? ", " : ")``|left|") + "";
				if (dl) hold += " " + to_string(dl) + " Diamond Locks" + (bgl != 0 ? ", " : ")``|left|") + "";
				if (bgl) hold += "and " + to_string(bgl) + " Blue Gem Locks)``|left|";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Nutcracker|left|7482|\nadd_smalltext|`oWelcome traveller! I'm the Nutcracker. I like to crack huts, but i also love to hoard locks, especially those golden and diamond ones! I'm only around for Winterfest, so if you're willing to hand over some locks, i'll give you something special for the Winterfest holiday in return. Nuts right, how about it?|left|\nadd_spacer|small|" + hold + "\nadd_button|item_10408|`oBuy Krampus Crampons for 20 World Locks|noflags|0|0|\nadd_button|item_2214|`oBuy Ice Horse for 20 World Locks|0|0|\nadd_button|item_1394|`oBuy Polar Bear Leash for 30 World Locks|0|0|\nadd_button|item_7492|`oBuy Nutcracker Mask for 50 World Locks|0|0|\nadd_button|item_7494|`oBuy Nutcracker Coat for 50 World Locks|0|0|\nadd_button|item_7500|`oBuy Nutcracker Saber for 200 World Locks|0|0|\nadd_button|item_7412|`oBuy Snowflake Wings of Winter for 300 World Locks|0|0|\nadd_button|item_7406|`oBuy Super Snowball Launcher for 400 World Locks|0|0|\nadd_button|item_7488|`oBuy Slaminator's Boomerang for 500 World Locks|0|0|\nend_dialog|Nutcracker|GoodBye!||");
			}
			else if (button.substr(0, 5) == "item_") {
				int item_id = std::atoi(button.substr(5).c_str()), wl = get_wls(peer, true), price = 0;
				string wk = "";
				if (item_id == 10408 or item_id == 2214) price = 20;
				if (item_id == 1394) price = 30;
				if (item_id == 7492 or item_id == 7494) price = 50;
				if (item_id == 7488) price = 500;
				if (item_id == 7406) price = 400;
				if (item_id == 7412) price = 300;
				if (item_id == 7500) price = 200;
				if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|" + (price >= 100 ? "\nadd_smalltext|`oYou have " + Set_Count(wl / 100) + " Diamond Locks.|left|" : "\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|") + "\nadd_button|BackToNutcracker|`oSee other items|0|0|";
				else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[item_id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_input||1|5|" + (price >= 100 ? "\nadd_smalltext|`oYou have " + Set_Count(wl / 100) + " Diamond Locks.|left|" : "\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|") + "\nadd_button|Yes_Purchase|`9Purchase|0|0|\nadd_button|BackToNutcracker|No Thanks|0|0|";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[item_id].name + "?|left|" + to_string(item_id) + "|\nembed_data|price|" + to_string(price) + "|\nadd_smalltext|`o" + items[item_id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|Nutcracker|||");
				pInfo(peer)->last_id_item = item_id;
			}
			else if (button == "Yes_Purchase") {
				string buycountstr = parser.get("buy_input", 1);
				int realprice = std::atoi(get_embed(cch, "price").c_str()), id = pInfo(peer)->last_id_item;
				vector<int> list_{ 10408, 1394, 7492, 7488, 7406, 7412, 7500 };
				if (find(list_.begin(), list_.end(), id) == list_.end()) return;
				if (realprice == 0 or id == 0) return;
				if (not is_number(buycountstr) || buycountstr.size() > 3 || buycountstr.size() <= 0 || std::atoi(buycountstr.c_str()) <= 0 || std::atoi(buycountstr.c_str()) > 200) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid Input!", 0, true);
					return;
				}
				pInfo(peer)->buyp = std::atoi(buycountstr.c_str());
				int kiekmoketi = std::atoi(buycountstr.c_str()) * realprice, my_wls = get_wls(peer, true);
				if (kiekmoketi > my_wls) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You can't afford that many!", 0, true);
					return;
				}
				else VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Really Buy " + to_string(std::atoi(buycountstr.c_str())) + " " + items[pInfo(peer)->last_id_item].name + "?|left|" + to_string(pInfo(peer)->last_id_item) + "|\nadd_textbox|`oAre you sure you want to buy `w" + to_string(std::atoi(buycountstr.c_str())) + " " + items[pInfo(peer)->last_id_item].name + " `ofor a total cost of `2" + to_string(kiekmoketi) + " World Locks`o?|left|\nadd_smalltext|`oYou have " + Set_Count(my_wls) + " World Locks.|left|\nadd_button|Confirm_Purchase|`9YES! GIMME!!!|0|0|\nadd_button|BackToNutcracker|`oNo thanks|0|0|\nend_dialog|Nutcracker|||\nadd_quick_exit|");
				pInfo(peer)->last_price_item = realprice;
			}
			else if (button == "Confirm_Purchase") {
				if (pInfo(peer)->last_id_item == 0 or pInfo(peer)->buyp == 0 or pInfo(peer)->last_price_item == 0) return;
				vector<int> list_{ 10408, 1394, 7492, 7488, 7406, 7412, 7500 };
				if (find(list_.begin(), list_.end(), pInfo(peer)->last_id_item) == list_.end()) return;
				int buyprice = pInfo(peer)->buyp, realprice = pInfo(peer)->last_price_item, kiekmoketi = buyprice * realprice, my_wls = get_wls(peer, true);
				if (kiekmoketi > my_wls) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You can't afford that many!", 0, true);
					return;
				}
				else {
					if (Inventory::Check_Max(peer, pInfo(peer)->last_id_item, buyprice)) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, true);
						return;
					}
					int free_slots = Inventory::Get_Slots(pInfo(peer));
					if (free_slots == 0) {
						VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
						return;
					}
					int cnt = buyprice;
					if (Inventory::Modify(peer, pInfo(peer)->last_id_item, buyprice) == 0) {
						get_wls(peer, true, true, kiekmoketi);
						PlayerMoving data_{}; PlayerMoving data{};
						data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = pInfo(peer)->last_id_item, data_.punchY = pInfo(peer)->netID;
						int32_t to_netid = pInfo(peer)->netID;
						BYTE* raw = packPlayerMoving(&data_);
						raw[3] = 5;
						Memory_Copy(raw + 8, &to_netid, 4);
						data.packetType = 19, data.netID = -1, data.plantingTree = 0;
						data.x = pInfo(peer)->lastwrenchx * 32 + 16, data.y = pInfo(peer)->lastwrenchy * 32 + 16;
						data.XSpeed = pInfo(peer)->x + 16, data.YSpeed = pInfo(peer)->y + 16;
						data.punchX = (realprice > 99 ? 1796 : 242);
						BYTE* raw_ = packPlayerMoving(&data);
						raw_[3] = 6;
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL) return;
							if (pInfo(peer)->world == pInfo(cp_)->world) {
								send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								send_raw(cp_, 4, raw_, 56, ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, raw_;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wSuccesfully Bought " + to_string(cnt) + " " + items[pInfo(peer)->last_id_item].name + " for " + Set_Count(kiekmoketi) + " World Locks.", 0, 1);
					}
					else {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, true);
						return;
					}
				}
			}
		}
	}
	static void handledungeonsui(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			uint64_t Btn_Hash = quick_hash(button.c_str());
			switch (Btn_Hash) {
			case "Back"_qh: {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wDungeons``|left||image:game/tiles_page17.rttex;frame:4,30;frameSize:32;|\nadd_spacer|small|\nadd_textbox|Go on an adventure, explore dungeons and use their unique currency to upgrade your abilities. Just remember, what happens in the dungeon stays in the dungeon!|left|\nadd_spacer|small|\nadd_custom_button|showdungeoninvitefriends|image:game/tiles_page17.rttex;image_size:32,32;frame:4,31;margin_rself:0.15,0;width:0.09;|\nadd_custom_label|Invite Friends|target:showdungeoninvitefriends;top:0.5;left:2.5;size:medium;|\nreset_placement_x|\nadd_textbox| |left|\nadd_textbox| |left|\nadd_textbox| |left|\nadd_custom_margin|x:0;y:16|\nadd_custom_button|startdungeonbtn|textLabel:Start (5 Scrolls);middle_colour:3389566975;border_colour:3389566975;display:block;|\nreset_placement_x|\nadd_custom_margin|x:0;y:16|\nadd_spacer|small|\nadd_smalltext|`6Warning: Leaving the Dungeon at any point will prevent re-entry into the same world. All ability upgrades will be lost as well.``|left|\nadd_spacer|small|\nadd_label_with_icon|small|Scrolls: 20/20|left|14730|\nadd_smalltext|`#More in: `#--``|left|\nadd_spacer|small|\nadd_custom_margin|x:0;y:16|\nadd_custom_button|purchasescrollsbtn|textLabel:Purchase Scrolls;middle_colour:431888895;border_colour:431888895;display:block;|\nreset_placement_x|add_custom_margin|x:0;y:16|\nadd_spacer|small|\nadd_image_button|noclick|interface/large/gui_dungeons_banner.rttex|bannerlayout|flag_frames:3,2,0,0|flag_surfsize:512,150|\nadd_spacer|small|\nadd_custom_margin|x:0;y:16|\nadd_custom_button|dungeonplayerankinformation|textLabel:League Standings;middle_colour:3434645503;border_colour:3434645503;display:block;|\nreset_placement_x|\nadd_spacer|small|\nadd_custom_margin|x:0;y:16|\nadd_custom_margin|x:0;y:16|\nadd_custom_button|dungeoninformationbtn|textLabel:Dungeon Information;middle_colour:3434645503;border_colour:3434645503;display:block;|reset_placement_x|\nadd_spacer|small|\nadd_custom_margin|x:0;y:16|\nreset_placement_x|\nend_dialog|handledungeonsui|Close||\nadd_quick_exit|");
				return;
			}
			case "dungeoninformationbtn"_qh: {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wWelcome to the Dungeon!``|left||image:game/tiles_page17.rttex;frame:4,30;frameSize:32;|\nadd_spacer|small|\nadd_textbox|A message from the Wizard's Council.|left|\nadd_spacer|small|\nadd_textbox|The Legendary Wizard discovered the secrets to these magic scrolls millennia ago but one of his acolyte's recently shared it on Wizi-Leaks and so the Wizard's Council decided it was best to make the information fully available to avoid disastrous misuse.|left|\nadd_spacer|small|\nadd_textbox|The scrolls create to a portal to the `5Chaotic Dimension`` overseen by The Legendary Wizard's oldest \"friend\"... The Lich. The scrolls themselves seem to regenerate no matter what we've tried to do to get rid of them they just keep coming back.|left|\nadd_spacer|small|\nadd_textbox|The Chaos Dimension is constantly in flux and will change with every new entry. Each time you cross through the portal you will have none of the skill or items you collected in your past visits. The Lich has overseen this Chaos Dimension for longer than anyone can remember, studying all of its darkest secrets. If you come across them while in a dungeon, they may be able to help you in your quest.|left|\nadd_spacer|small|\nadd_custom_button|Back|textLabel:Back;middle_colour:3434645503;border_colour:3434645503;display:block;|\nend_dialog|handledungeonsui|||\nadd_quick_exit|");
				return;
			}
			case "dungeonplayerankinformation"_qh: {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wBronze 1 League``|left||image:game/tiles_page17.rttex;frame:3,30;frameSize:32;|\nadd_image_button|noclick|interface/large/gui_dungeons_banner.rttex|bannerlayout|flag_frames:3,2,0,0|flag_surfsize:512,150|\nadd_custom_margin|x:0;y:16|\nadd_custom_button|leagueinformationbtn|textLabel:League Information;middle_colour:3389566975;border_colour:3389566975;display:block;|\nreset_placement_x|\nadd_spacer|small|\nadd_custom_margin|x:0;y:16|\nadd_smalltext|`#4 days, 22 hours, 54 mins`` `w Remaining``|left|\nadd_spacer|small|\nadd_textbox|`wThe top 50% will be promoted to the next league bracket and the bottom.``|left|\nadd_spacer|small|\nadd_textbox|Your Position: Bottom 91%|left|\nadd_textbox|Your Points: 0|left|\nadd_spacer|small|\nadd_image_button|noclick|interface/large/promotion_zone.rttex|bannerlayout|flag_frames:1,1,0,0|flag_surfsize:1500,150|\nadd_smalltext|`2Top 50% (0)``|left|\nadd_spacer|small|\nadd_custom_margin|x:0;y:16|\nadd_custom_button|Back|textLabel:Back;middle_colour:3434645503;border_colour:3434645503;display:block;|\nreset_placement_x|\nadd_spacer|small|\nadd_custom_margin|x:0;y:16|\nend_dialog|handledungeonsui|||\nadd_quick_exit|");
				return;
			}
			case "leagueinformationbtn"_qh: {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label|big|League Information|left|\nadd_spacer|small|\nadd_image_button|noclick|interface/large/all_rank_banner.rttex|bannerlayout|flag_frames:1,1,0,0|flag_surfsize:1634,278|\nadd_spacer|small|\nadd_textbox|Complete dungeons to earn points and advance your rank. The higher your rank, the more rewarding the prizes.|left|\nadd_spacer|small|\nadd_custom_button|Back|textLabel:Back;middle_colour:3434645503;border_colour:3434645503;display:block;|\nend_dialog|handledungeonsui|||\nadd_quick_exit|");
				return;
			}
			case "purchasescrollsbtn"_qh: {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wPurchase Scrolls``|left|14730|\nadd_spacer|small|\nadd_image_button|noclick|interface/large/gui_shop_buybanner4.rttex|bannerlayout|flag_frames:4,10,0,2|flag_surfsize:512,200|\nadd_spacer|small|\nadd_textbox|`2You Get:`` 20 scrolls.<CR><CR>`5Description:`` Scroll through dungeons like a pro!|left|\nadd_spacer|small|\nadd_spacer|small|\nadd_custom_margin|x:0;y:16|\nadd_custom_button|Back|textLabel:Back;middle_colour:3434645503;border_colour:3434645503;display:block;|\nadd_custom_button|yesbuy|textLabel:Buy;middle_colour:431888895;border_colour:431888895;anchor:Back;left:1;margin:40,0;|\nreset_placement_x|\nadd_spacer|small|\nadd_custom_margin|x:0;y:16|\nend_dialog|handledungeonsui|||");
				return;
			}
			case "startdungeonbtn"_qh: {

				return;
			}
			case "showdungeoninvitefriends"_qh: {

				return;
			}
			default:
				return;
			}
		}
	}
	static void vippay_edit(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (not is_number(std::string(get_embed(cch, "tilex"))) or not is_number(std::string(get_embed(cch, "tiley")))) return;
		int x_ = std::atoi(get_embed(cch, "tilex").c_str()), y_ = std::atoi(get_embed(cch, "tiley").c_str());
		std::string name_ = pInfo(peer)->world;
		std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			WorldBlock* block_ = &world_->blocks.at(x_ + (y_ * 100));
			if (block_->fg != 14594) return;
			if (parser.try_get("buttonClicked", button)) {
				if (button == "withdraw_wls") {
					if (to_lower(world_->owner_name) == to_lower(pInfo(peer)->tankIDName)) {
						if (block_->wl != 0) {
							int total_wl = block_->wl, c_ = 0, taken = 0;
							bool returned = false, collect = false;
							string collected_ = "";
							if (pInfo(peer)->tankIDName != world_->owner_name) ServerPool::Logs::Add("player: " + pInfo(peer)->tankIDName + " lvl: " + to_string(pInfo(peer)->level) + ", took " + to_string(total_wl) + " World Locks from Vending Machine in: [" + pInfo(peer)->world + "]", "Vending Machine (Steal)");
							if (total_wl >= 10000) {
								if (total_wl > 2000000) c_ = 200;
								else c_ = total_wl / 10000;
								total_wl -= c_ * 10000;
								block_->wl -= c_ * 10000;
								taken = c_;
								if (Inventory::Modify(peer, 7188, c_) == 0) {
									collected_ += to_string(taken) + " Platinum Gem Locks";
									collect = true;
								}
								else pInfo(peer)->pgl_bank_amount += c_, returned = true;
								c_ = 0;
							}
							if (total_wl >= 100) {
								if (total_wl > 20000) c_ = 200;
								else c_ = total_wl / 100;
								total_wl -= c_ * 100;
								block_->wl -= c_ * 100;
								taken = c_;
								if (Inventory::Modify(peer, 1796, c_) == 0) {
									collected_ += (collected_.empty() ? "" : " and ") + to_string(taken) + " Diamond Locks";
									collect = true;
								}
								else pInfo(peer)->dl_bank_amount += c_, returned = true;
								c_ = 0;
							}
							if (total_wl >= 1) {
								if (total_wl > 200) c_ = 200;
								else c_ = total_wl;
								total_wl -= c_;
								block_->wl -= c_;
								taken = c_;
								if (Inventory::Modify(peer, 242, c_) == 0) {
									collected_ += (collected_.empty() ? "" : " and ") + to_string(taken) + " World Locks";
									collect = true;
								}
								else pInfo(peer)->wl_bank_amount += c_, returned = true;
								c_ = 0;
							}
							if (returned) {
								VarList::OnTextOverlay(peer, "Some of the World Locks could not fit in your inventory!");
								VarList::OnTextOverlay(peer, "We have placed them in your Personal Backpack.", 1500);
							}
							{
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, (collect ? "You collected " + collected_ + "" : "You don't have room in your backpack!"), 0, 1);
								VarList::OnConsoleMessage(peer, (collect ? "You collected " + collected_ + "" : "You don't have room in your backpack!"));
							}
						}
					}
				}
				if (button == "Purchase_Access") {
					if (pInfo(peer)->Used_VipDoor.size() != 0 or block_->pr == 0 or block_->id == 0 or block_->id > 3) return;
					int my_wls = get_wls(peer, true);
					if (block_->pr > my_wls) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough World Locks!", 0, 1);
						return;
					}
					get_wls(peer, true, true, block_->pr);
					std::string name = pInfo(peer)->tankIDName;
					std::vector<std::pair<long long int, std::string>>::iterator lb = find_if(block_->Admin_Bfg.begin(), block_->Admin_Bfg.end(), [name](const pair <long long int, string>& element) { return element.second == name; });
					if (lb != block_->Admin_Bfg.end()) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You already have access to this Entrance.");
						return;
					}
					else {
						block_->wl += block_->pr;
						long long int totalt = 0;
						if (block_->id == 1) totalt = time(nullptr) + 604800;// 1 week
						else if (block_->id == 2) totalt = time(nullptr) + 86400;// 1 day
						else if (block_->id == 3) totalt = time(nullptr) + 3600;// 1 hours
						pInfo(peer)->Used_VipDoor.emplace_back(pInfo(peer)->world, totalt);
						block_->Admin_Bfg.emplace_back(totalt, pInfo(peer)->tankIDName);
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You're now `2granted access ``to this Vip Entrance for " + a + (block_->id == 1 ? "1 Week" : block_->id == 2 ? "1 Day" : "1 Hour") + ".");
						PlayerMoving data_{};
						data_.packetType = 5, data_.punchX = pInfo(peer)->lastwrenchx, data_.punchY = pInfo(peer)->lastwrenchy, data_.characterState = 0x8;
						BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
						BYTE* blc = raw + 56;
						form_visual(blc, *block_, *world_, peer, false);
						PlayerMoving data{};
						data.packetType = 19, data.netID = -1, data.plantingTree = 0;
						data.x = pInfo(peer)->lastwrenchx * 32 + 16, data.y = pInfo(peer)->lastwrenchy * 32 + 16;
						data.XSpeed = pInfo(peer)->x + 16, data.YSpeed = pInfo(peer)->y + 16;
						data.punchX = 242;
						BYTE* raw_ = packPlayerMoving(&data);
						raw_[3] = 6;
						for (ENetPeer* cp_2 = server->peers; cp_2 < &server->peers[server->peerCount]; ++cp_2) {
							if (cp_2->state != ENET_PEER_STATE_CONNECTED or cp_2->data == NULL) continue;
							if (pInfo(cp_2)->world == world_->name) {
								send_raw(cp_2, 4, raw_, 56, ENET_PACKET_FLAG_RELIABLE);
								send_raw(cp_2, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, raw_;
					}
				}
				if (button.substr(0, 5) == "name_") {
					if (to_lower(world_->owner_name) == to_lower(pInfo(peer)->tankIDName)) {
						std::string name = button.substr(5);
						std::vector<std::pair<long long int, std::string>>::iterator lb = find_if(block_->Admin_Bfg.begin(), block_->Admin_Bfg.end(), [name](const pair <long long int, string>& element) { return element.second == name; });
						if (lb != block_->Admin_Bfg.end()) {
							block_->Admin_Bfg.erase(lb);
						}
						else return;
						bool has_ = false;
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
							if (to_lower(pInfo(cp_)->tankIDName) == to_lower(name)) {
								pInfo(cp_)->Used_VipDoor.clear();
								has_ = true;
								PlayerMoving data_{};
								data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
								BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
								BYTE* blc = raw + 56;
								form_visual(blc, *block_, *world_, cp_, false);
								send_raw(cp_, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								CAction::Log(cp_, "action|play_sfx\nfile|audio/dialog_cancel.wav\ndelayMS|0");
								VarList::OnTalkBubble(cp_, pInfo(cp_)->netID, get_player_nick(peer) + " has `4removed`` you from a VIP List in `w" + world_->name + "``.");
								VarList::OnConsoleMessage(cp_, name + " was removed from a VIP List.");
							}
							if (pInfo(cp_)->world == world_->name) {
								VarList::OnConsoleMessage(cp_, name + " was removed from a VIP List.");
							}
						}
						if (not has_) {
							try {
								const string filePath = "database/players/" + name + "_.json";
								if (filesystem::exists(filePath)) {
									ifstream inputFile(filePath);
									json jsonData;
									inputFile >> jsonData;
									jsonData["Used_VipDoor"] = json::array();
									inputFile.close();
									ofstream outputFile(filePath);
									outputFile << jsonData << endl;
									outputFile.close();
								}
							}
							catch (exception) {
								return;
							}
						}
					}
				}
			}
			else {
				if (to_lower(world_->owner_name) == to_lower(pInfo(peer)->tankIDName)) {
					string Price_Wls = parser.get("Price_Wls", 1), A_Week = parser.get("1_Week", 1), A_Day = parser.get("1_Day", 1), A_Hour = parser.get("1_Hour", 1);
					if (!isValidCheckboxInput(A_Week) or !isValidCheckboxInput(A_Day) or !isValidCheckboxInput(A_Hour)) return;
					if (not is_number(Price_Wls) or atoi(Price_Wls.c_str()) > 999999) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid input in Price!");
						return;
					}
					block_->pr = std::atoi(Price_Wls.c_str());
					if (block_->id != 1 and A_Week == "1") block_->id = 1;
					if (block_->id != 2 and A_Day == "1") block_->id = 2;
					if (block_->id != 3 and A_Hour == "1") block_->id = 3;
					if (block_->id == 1 and A_Week == "0" or block_->id == 2 and A_Day == "0" or block_->id == 3 and A_Hour == "0") block_->id = 0;
					PlayerMoving data_{};
					data_.packetType = 17, data_.netID = 44, data_.YSpeed = 44, data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16;
					BYTE* raw = packPlayerMoving(&data_);
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (pInfo(cp_)->world == pInfo(peer)->world) {
							CAction::Log(cp_, "action|play_sfx\nfile|audio/terraform.wav\ndelayMS|0");
							VarList::OnConsoleMessage(cp_, (block_->pr == 0 ? "`7[``" + pInfo(peer)->tankIDName + " disabled the Pay VIP Entrance.```7]``" : "`7[``" + pInfo(peer)->tankIDName + " changed the price of Pay VIP Entrance to " + to_string(block_->pr) + " World Lock for " + (block_->id == 1 ? "1 Week" : block_->id == 2 ? "1 Day" : "1 Hour") + ".```7]``"));
							VarList::OnTalkBubble(cp_, pInfo(peer)->netID, (block_->pr == 0 ? "`7[``" + pInfo(peer)->tankIDName + " disabled the Pay VIP Entrance.```7]``" : "`7[``" + pInfo(peer)->tankIDName + " changed the price of Pay VIP Entrance to " + to_string(block_->pr) + " World Lock for " + (block_->id == 1 ? "1 Week" : block_->id == 2 ? "1 Day" : "1 Hour") + ".```7]``"), 0, 0);
							send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[] raw;
				}
			}
		}
	}
	static void proxys(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			uint64_t Btn_Hash = quick_hash(button.c_str());
			switch (Btn_Hash) {
			case "commands"_qh: {
				std::string dialog = "set_default_color|`o";
				dialog += "\nadd_label_with_icon|small|`w" + Environment()->server_name + " Proxy - `$Help Commands|left|3802|";
				dialog += "\nadd_smalltext|`5NOTE: `oPlease active the `wProxy Commands `oto use alls of commands!|left|";
				dialog += "\nadd_spacer|small|";
				dialog += "\nadd_smalltext|`$>> Home Page:|left|";
				dialog += "\nadd_smalltext|`o~ `9(/proxy) `$- Configurate the proxy's.|left|";
				dialog += "\nadd_spacer|small|";
				dialog += "\nadd_smalltext|`$>> Faster:|left|";
				dialog += "\nadd_smalltext|`o~ `9(/dpwl <amount>) `$- Deposit Your World Locks to Bank|left|";
				dialog += "\nadd_smalltext|`o~ `9(/dpdl <amount>) `$- Deposit Your Diamond Locks to Bank|left|";
				dialog += "\nadd_smalltext|`o~ `9(/dppgl <amount>) `$- Deposit Your Platinum Gem Locks to Bank|left|";
				dialog += "\nadd_smalltext|`o~ `9(/dpmgl <amount>) `$- Deposit Your " + Environment()->server_name + " Locks to Bank|left|";
				dialog += "\nadd_smalltext|`o~ `9(/dpigl <amount>) `$- Deposit Your Infinity Locks to Bank|left|";
				dialog += "\nadd_smalltext|`o~ `9(/dpgems <amount>) `$- Deposit Your Gems to Bank|left|";
				dialog += "\nadd_smalltext|`o~ `9(/wdwl <amount>) `$- Withdraw Your World Locks from Bank|left|";
				dialog += "\nadd_smalltext|`o~ `9(/wddl <amount>) `$- Withdraw Your Diamond Locks from Bank|left|";
				dialog += "\nadd_smalltext|`o~ `9(/wdpgl <amount>) `$- Withdraw Your Platinum Gem Locks from Bank|left|";
				dialog += "\nadd_smalltext|`o~ `9(/wdmgl <amount>) `$- Withdraw Your " + Environment()->server_name + " Gem Locks from Bank|left|";
				dialog += "\nadd_smalltext|`o~ `9(/wdigl <amount>) `$- Withdraw Your Infinity Gem Locks from Bank|left|";
				dialog += "\nadd_smalltext|`o~ `9(/wdgems <amount>) `$- Withdraw Your Gems from Bank|left|\nadd_smalltext|`o~ `9(//tf <player name> <type> <quantity>) `$- Transfer Your Balance from Bank to Anyone|left|\nadd_spacer|small|\nadd_smalltext|`$>> Others:|left|\nadd_smalltext|`o~ `9(/pos) `$- Check your position|left|\nadd_spacer|small|\nadd_smalltext|`$>> OriginalClothes:|left|\nadd_smalltext|`o~ `9(/unequip) `$- Remove All Clothes|left|\nadd_spacer|small|\nadd_button|proxy_menu|`wBack|noflags|0|0|\nend_dialog|SocialPortal|||\nadd_quick_exit|";
				VarList::OnDialogRequest(peer, SetColor(peer) + dialog);
				return;
			}
			default:
				return;
			}
		}
		else {
			string proxy_spin = parser.get("proxy_spin", 1);
			if (!isValidCheckboxInput(proxy_spin)) return;
			if (std::atoi(proxy_spin.c_str()) == 1) pInfo(peer)->proxy.fastspin = true;
			else pInfo(peer)->proxy.fastspin = false;
		}
	}
	static void SocialPortal(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			uint64_t Btn_Hash = quick_hash(button.c_str());
			switch (Btn_Hash) {
			case "Social_Portal"_qh: {
				DialogHandle::Social_Portal(peer, "Social");
				return;
			}
			case "Background_Setting"_qh: {
				DialogHandle::Social_Portal(peer, "Bg_Setting");
				return;
			}
			case "show_friends"_qh: {
				DialogHandle::Friends(peer);
				return;
			}
			case "marketplace"_qh: {
				DialogHandle::MarketPlace(peer);
				return;
			}
			case "community_hub"_qh: {
				DialogHandle::Community_Hub(peer, "community_influencervideos");
				return;
			}
			case "proxy_menu"_qh: {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n\nadd_label_with_icon|big|`wProxy Menu - Free Modes|left|1366|\nadd_smalltext|`5REMINDER: `oThis features alls from `w" + Environment()->server_name + " `oit selfs, you don't need a third program client to use proxy!|left|\nadd_spacer|small|\nadd_button|commands|`wCheck Proxy Commands|noflags|0|0|1|\nadd_smalltext|`o>> Activating the `wProxy Commands `o(Check the commands at the top!)|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wCasino Attributes (Becareful)|left|758|\nadd_smalltext|`o>> This `wproxy's `omade for casino players and free to use!|left|\nadd_checkbox|proxy_wheel|`$Real/Fake Roulette Wheel|" + to_string(pInfo(peer)->proxy.roulette) + "|\nadd_checkbox|proxy_reme|`$Reme Mode (Shows Calculate)|" + to_string(pInfo(peer)->proxy.reme) + "|\nadd_checkbox|proxy_spin|`$Fast Spin|" + to_string(pInfo(peer)->proxy.fastspin) + "|\nadd_spacer|small|\nend_dialog|proxys|Cancel|`wUpdate Proxy|");
				return;
			}
			case "trade_history"_qh: {
				string trade_history = "";
				for (int i = 0; i < pInfo(peer)->trade_history.size(); i++) trade_history += "\nadd_spacer|small|\nadd_smalltext|" + pInfo(peer)->trade_history[i] + "|left|";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|small|" + pInfo(peer)->tankIDName + "'s Trade History|left|242|" + (pInfo(peer)->trade_history.size() == 0 ? "\nadd_spacer|small|\nadd_smalltext|Nothing to show yet.|left|" : trade_history) + "\nadd_spacer|small|\nadd_button|back|Back|noflags|0|0|\nadd_button||Close|noflags|0|0|\nadd_quick_exit|\nend_dialog|friends|||");
				return;
			}
			case "showguild"_qh: {
				string guild_info = get_guild_info(peer);
				if (guild_info == "set_default_color|`o\nadd_label_with_icon|big|`wGrow Guild ``|left|5814|\nadd_textbox|Something went wrong!|left|\nend_dialog|guildalreadyjoined|Close||") set_Guilds(peer);
				VarList::OnDialogRequest(peer, SetColor(peer) + guild_info);
				return;
			}
			case "settings_apply"_qh: {
				string theme_0 = parser.get("theme_0", 1), theme_1 = parser.get("theme_1", 1), theme_2 = parser.get("theme_2", 1), theme_3 = parser.get("theme_3", 1), theme_4 = parser.get("theme_4", 1), theme_5 = parser.get("theme_5", 1), theme_6 = parser.get("theme_6", 1), theme_7 = parser.get("theme_7", 1), theme_8 = parser.get("theme_8", 1), themetrans_0 = parser.get("themetrans_0", 1), themetrans_1 = parser.get("themetrans_1", 1), themetrans_2 = parser.get("themetrans_2", 1), themetrans_3 = parser.get("themetrans_3", 1), themetrans_4 = parser.get("themetrans_4", 1);
				if (!isValidCheckboxInput(theme_0) or !isValidCheckboxInput(theme_1) or !isValidCheckboxInput(theme_2) or !isValidCheckboxInput(theme_3) or !isValidCheckboxInput(theme_4) or !isValidCheckboxInput(theme_5) or !isValidCheckboxInput(theme_6) or !isValidCheckboxInput(theme_7) or !isValidCheckboxInput(theme_8) or !isValidCheckboxInput(themetrans_0) or !isValidCheckboxInput(themetrans_1) or !isValidCheckboxInput(themetrans_2) or !isValidCheckboxInput(themetrans_3) or !isValidCheckboxInput(themetrans_4)) return;
				if (theme_0 == "1") pInfo(peer)->border_color = "Default";
				else if (theme_1 == "1") pInfo(peer)->border_color = "0,0,0,255";
				else if (theme_2 == "1") pInfo(peer)->border_color = "255,0,255,255";
				else if (theme_3 == "1") pInfo(peer)->border_color = "117,27,107,255";
				else if (theme_4 == "1") pInfo(peer)->border_color = "255,3,11,255";
				else if (theme_5 == "1") pInfo(peer)->border_color = "3,36,252,255";
				else if (theme_6 == "1") pInfo(peer)->border_color = "181,102,45,255";
				else if (theme_7 == "1") pInfo(peer)->border_color = "47,117,33,255";
				else if (theme_8 == "1") pInfo(peer)->border_color = "245,245,0,1";
				if (pInfo(peer)->border_color == "0,0,0,255") {//black
					if (themetrans_0 == "1") pInfo(peer)->bg_color = "0,0,0,0";
					else if (themetrans_1 == "1") pInfo(peer)->bg_color = "0,0,0,64";
					else if (themetrans_2 == "1") pInfo(peer)->bg_color = "0,0,0,150";
					else if (themetrans_3 == "1") pInfo(peer)->bg_color = "0,0,0,210";
					else if (themetrans_4 == "1") pInfo(peer)->bg_color = "0,0,0,250";
				}
				if (pInfo(peer)->border_color == "255,0,255,255") {//pink
					if (themetrans_0 == "1") pInfo(peer)->bg_color = "252,50,212,0";
					else if (themetrans_1 == "1") pInfo(peer)->bg_color = "252,50,212,64";
					else if (themetrans_2 == "1") pInfo(peer)->bg_color = "252,50,212,150";
					else if (themetrans_3 == "1") pInfo(peer)->bg_color = "252,50,212,210";
					else if (themetrans_4 == "1") pInfo(peer)->bg_color = "252,50,212,250";
				}
				if (pInfo(peer)->border_color == "117,27,107,255") {//purple
					if (themetrans_0 == "1") pInfo(peer)->bg_color = "133,1,118,0";
					else if (themetrans_1 == "1") pInfo(peer)->bg_color = "133,1,118,64";
					else if (themetrans_2 == "1") pInfo(peer)->bg_color = "133,1,118,150";
					else if (themetrans_3 == "1") pInfo(peer)->bg_color = "133,1,118,210";
					else if (themetrans_4 == "1") pInfo(peer)->bg_color = "133,1,118,250";
				}
				if (pInfo(peer)->border_color == "255,3,11,255") {//red
					if (themetrans_0 == "1") pInfo(peer)->bg_color = "250,50,56,0";
					else if (themetrans_1 == "1") pInfo(peer)->bg_color = "250,50,56,64";
					else if (themetrans_2 == "1") pInfo(peer)->bg_color = "250,50,56,150";
					else if (themetrans_3 == "1") pInfo(peer)->bg_color = "250,50,56,210";
					else if (themetrans_4 == "1") pInfo(peer)->bg_color = "250,50,56,250";
				}
				if (pInfo(peer)->border_color == "3,36,252,255") {//blue
					if (themetrans_0 == "1") pInfo(peer)->bg_color = "48,75,252,0";
					else if (themetrans_1 == "1") pInfo(peer)->bg_color = "48,75,252,64";
					else if (themetrans_2 == "1") pInfo(peer)->bg_color = "48,75,252,150";
					else if (themetrans_3 == "1") pInfo(peer)->bg_color = "48,75,252,210";
					else if (themetrans_4 == "1") pInfo(peer)->bg_color = "48,75,252,250";
				}
				if (pInfo(peer)->border_color == "181,102,45,255") {//orange
					if (themetrans_0 == "1") pInfo(peer)->bg_color = "181,75,0,0";
					else if (themetrans_1 == "1") pInfo(peer)->bg_color = "181,75,0,64";
					else if (themetrans_2 == "1") pInfo(peer)->bg_color = "181,75,0,150";
					else if (themetrans_3 == "1") pInfo(peer)->bg_color = "181,75,0,210";
					else if (themetrans_4 == "1") pInfo(peer)->bg_color = "181,75,0,250";
				}
				if (pInfo(peer)->border_color == "47,117,33,255") {//green
					if (themetrans_0 == "1") pInfo(peer)->bg_color = "21,128,0,0";
					else if (themetrans_1 == "1") pInfo(peer)->bg_color = "21,128,0,64";
					else if (themetrans_2 == "1") pInfo(peer)->bg_color = "21,128,0,150";
					else if (themetrans_3 == "1") pInfo(peer)->bg_color = "21,128,0,210";
					else if (themetrans_4 == "1") pInfo(peer)->bg_color = "21,128,0,250";
				}
				if (pInfo(peer)->border_color == "117,115,29,255") {//yellow
					if (themetrans_0 == "1") pInfo(peer)->bg_color = "128,125,0,0";
					else if (themetrans_1 == "1") pInfo(peer)->bg_color = "128,125,0,64";
					else if (themetrans_2 == "1") pInfo(peer)->bg_color = "128,125,0,150";
					else if (themetrans_3 == "1") pInfo(peer)->bg_color = "128,125,0,210";
					else if (themetrans_4 == "1") pInfo(peer)->bg_color = "128,125,0,250";
				}
				return;
			}
			default:
				return;
			}
		}
	}
	static void Buy_Slot_FCheats(ENetPeer* peer, std::string cch) {
		if (not Role::Cheater(peer) or pInfo(peer)->Slot_Far == 8) return;
		int far_slot = 0, cost = 0;
		if (pInfo(peer)->Slot_Far == 1) far_slot = 2, cost = 1000;
		if (pInfo(peer)->Slot_Far == 2) far_slot = 3, cost = 10000;
		if (pInfo(peer)->Slot_Far == 3) far_slot = 4, cost = 100000;
		if (pInfo(peer)->Slot_Far == 4) far_slot = 5, cost = 5000000;
		if (pInfo(peer)->Slot_Far == 5) far_slot = 6, cost = 15000000;
		if (pInfo(peer)->Slot_Far == 6) far_slot = 7, cost = 20000000;
		if (pInfo(peer)->Slot_Far == 7) far_slot = 8, cost = 40000000;
		if (pInfo(peer)->gems >= cost) {
			pInfo(peer)->Slot_Far = far_slot;
			VarList::OnMinGems(peer, cost);
			DialogHandle::Cheats(peer);
			VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Successfully Purchase Additional Slots!", 0, 0);
		}
		else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough gems!", 0, 0);
	}
	static void cheats(ENetPeer* peer, std::string cch) {
		if (Role::Cheater(peer)) {
			TextScanner parser(cch);
			std::string button = "";
			int id = 0;
			if (parser.try_get("itemid", id)) {
				if (id == 0) autofarm_status(peer);
				else if (id == 1) {
				}
				else {
					if (id > 0 && id < items.size()) {
						bool accept_ = false, not_farmable = false;
						if (id == 5640 or id == 9158) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`6[``Autofarm is enabled (choose location by placing a block)!```6]``", 0, 0);
							pInfo(peer)->autofarm_x = -1;
							pInfo(peer)->autofarm_y = -1;
							pInfo(peer)->cheater_settings |= SETTINGS::SETTINGS_0;
							pInfo(peer)->last_used_block = id;
						}
						else if (items[id].untradeable || items[id].rarity < 0 || items[id].rarity == 999 || items[id].block_possible_put == false) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`6[``You can't autofarm this block!```6]``", 0, 0);
						}
						else {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`6[``Autofarm is enabled (choose location by placing a block)!```6]``", 0, 0);
							pInfo(peer)->autofarm_x = -1;
							pInfo(peer)->autofarm_y = -1;
							pInfo(peer)->cheater_settings |= SETTINGS::SETTINGS_0;
							pInfo(peer)->last_used_block = id;
						}
					}
				}
			}
			else if (parser.try_get("buttonClicked", button)) {
				uint64_t Btn_Hash = quick_hash(button.c_str());
				switch (Btn_Hash) {
				case "restore_default"_qh: {
					pInfo(peer)->cheater_settings = 0;
					pInfo(peer)->chat_prefix = "";
					VarList::OnConsoleMessage(peer, "`o>> Succesfully Applying cheats...");
					DialogHandle::Cheats(peer);
					return;
				}
				case "Buy_Slot_Far"_qh: {
					if (pInfo(peer)->Slot_Far == 8) return;
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wBuy Additional Slots|left|9412|\nadd_spacer|small|\nadd_textbox|Buy this allows you to get up to `5" + to_string(pInfo(peer)->Slot_Far + 1) + "`` more Slots. This purchasing process is a simple way to increase the amount of your gems.|left|\nadd_spacer|small|\nadd_smalltext|This Purchased cost `2" + a + (pInfo(peer)->Slot_Far == 1 ? "1,000" : pInfo(peer)->Slot_Far == 2 ? "10,000" : pInfo(peer)->Slot_Far == 3 ? "100,000" : pInfo(peer)->Slot_Far == 4 ? "5,000,000" : pInfo(peer)->Slot_Far == 5 ? "15,000,000" : pInfo(peer)->Slot_Far == 6 ? "20,000,000" : pInfo(peer)->Slot_Far == 7 ? "40,000,000" : "MAX") + " ``Gems to get (" + to_string(pInfo(peer)->Slot_Far + 1) + " Slots).|left|\nend_dialog|Buy_Slot_FCheats|Cancel|`5Confirm!|");
					return;
				}
				default:
					return;
				}
			}
			else {
				if (pInfo(peer)->cheater_settings & SETTINGS::SETTINGS_0) {
					std::string check_autofarm = parser.get("check_autofarm", 1);
					if (!isValidCheckboxInput(check_autofarm)) return;
					if (std::atoi(check_autofarm.c_str()) == 1) pInfo(peer)->cheater_settings |= SETTINGS::SETTINGS_0;
					else {
						pInfo(peer)->cheater_settings &= ~SETTINGS::SETTINGS_0;
						pInfo(peer)->autofarm = false;
					}
				}
				std::string autofarm_slot = parser.get("autofarm_slot", 1);
				if (autofarm_slot.size() < 1 or not is_number(autofarm_slot)) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid input in Autofarm slot!", 0, 0);
					return;
				}
				if (std::atoi(autofarm_slot.c_str()) >= 1 && std::atoi(autofarm_slot.c_str()) <= pInfo(peer)->Slot_Far) {
					pInfo(peer)->autofarm_slot = std::atoi(autofarm_slot.c_str());
				}
				else {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Autofarm slot is over limit!", 0, 0);
				}
				string checkbox_cheat_autofish = parser.get("checkbox_cheat_autofish", 1), checkbox_cheat_hide_players = parser.get("checkbox_cheat_hide_players", 1), checkbox_cheat_antibounce = parser.get("checkbox_cheat_antibounce", 1), checkbox_cheat_speed = parser.get("checkbox_cheat_speed", 1), checkbox_cheat_double_jump = parser.get("checkbox_cheat_double_jump", 1), checkbox_cheat_jump = parser.get("checkbox_cheat_jump", 1), checkbox_cheat_heat_resist = parser.get("checkbox_cheat_heat_resist", 1), checkbox_cheat_strong_punch = parser.get("checkbox_cheat_strong_punch", 1), checkbox_cheat_long_punch = parser.get("checkbox_cheat_long_punch", 1), checkbox_cheat_long_build = parser.get("checkbox_cheat_long_build", 1), checkbox_cheat_autocollect = parser.get("checkbox_cheat_autocollect", 1), checkbox_cheat_hide_particle = parser.get("checkbox_cheat_hide_particle", 1), checkbox_cheat_fastdrop = parser.get("checkbox_cheat_fastdrop", 1), checkbox_cheat_fasttrash = parser.get("checkbox_cheat_fasttrash", 1);
				if (!isValidCheckboxInput(checkbox_cheat_autofish) or !isValidCheckboxInput(checkbox_cheat_hide_players) or !isValidCheckboxInput(checkbox_cheat_antibounce) or !isValidCheckboxInput(checkbox_cheat_speed) or !isValidCheckboxInput(checkbox_cheat_double_jump) or !isValidCheckboxInput(checkbox_cheat_jump) or !isValidCheckboxInput(checkbox_cheat_heat_resist) or !isValidCheckboxInput(checkbox_cheat_strong_punch) or !isValidCheckboxInput(checkbox_cheat_long_punch) or !isValidCheckboxInput(checkbox_cheat_long_build) or !isValidCheckboxInput(checkbox_cheat_autocollect) or !isValidCheckboxInput(checkbox_cheat_hide_particle) or !isValidCheckboxInput(checkbox_cheat_fastdrop) or !isValidCheckboxInput(checkbox_cheat_fasttrash)) return;
				if (std::atoi(checkbox_cheat_autofish.c_str()) == 1) pInfo(peer)->cheater_settings |= SETTINGS::SETTINGS_16;
				else pInfo(peer)->cheater_settings &= ~SETTINGS::SETTINGS_16;
				if (std::atoi(checkbox_cheat_antibounce.c_str()) == 1) pInfo(peer)->cheater_settings |= SETTINGS::SETTINGS_3;
				else pInfo(peer)->cheater_settings &= ~SETTINGS::SETTINGS_3;
				if (std::atoi(checkbox_cheat_speed.c_str()) == 1) pInfo(peer)->cheater_settings |= SETTINGS::SETTINGS_4;
				else pInfo(peer)->cheater_settings &= ~SETTINGS::SETTINGS_4;
				if (std::atoi(checkbox_cheat_double_jump.c_str()) == 1) pInfo(peer)->cheater_settings |= SETTINGS::SETTINGS_2;
				else pInfo(peer)->cheater_settings &= ~SETTINGS::SETTINGS_2;
				if (std::atoi(checkbox_cheat_jump.c_str()) == 1) pInfo(peer)->cheater_settings |= SETTINGS::SETTINGS_7;
				else pInfo(peer)->cheater_settings &= ~SETTINGS::SETTINGS_7;
				if (std::atoi(checkbox_cheat_heat_resist.c_str()) == 1) pInfo(peer)->cheater_settings |= SETTINGS::SETTINGS_8;
				else pInfo(peer)->cheater_settings &= ~SETTINGS::SETTINGS_8;
				if (std::atoi(checkbox_cheat_strong_punch.c_str()) == 1) pInfo(peer)->cheater_settings |= SETTINGS::SETTINGS_9;
				else pInfo(peer)->cheater_settings &= ~SETTINGS::SETTINGS_9;
				if (std::atoi(checkbox_cheat_long_punch.c_str()) == 1) pInfo(peer)->cheater_settings |= SETTINGS::SETTINGS_10;
				else pInfo(peer)->cheater_settings &= ~SETTINGS::SETTINGS_10;
				if (std::atoi(checkbox_cheat_long_build.c_str()) == 1) pInfo(peer)->cheater_settings |= SETTINGS::SETTINGS_11;
				else pInfo(peer)->cheater_settings &= ~SETTINGS::SETTINGS_11;
				if (std::atoi(checkbox_cheat_autocollect.c_str()) == 1) pInfo(peer)->cheater_settings |= SETTINGS::SETTINGS_6;
				else pInfo(peer)->cheater_settings &= ~SETTINGS::SETTINGS_6;
				if (std::atoi(checkbox_cheat_hide_particle.c_str()) == 1) pInfo(peer)->cheater_settings |= SETTINGS::SETTINGS_14;
				else pInfo(peer)->cheater_settings &= ~SETTINGS::SETTINGS_14;
				if (std::atoi(checkbox_cheat_fastdrop.c_str()) == 1) pInfo(peer)->cheater_settings |= SETTINGS::SETTINGS_5;
				else pInfo(peer)->cheater_settings &= ~SETTINGS::SETTINGS_5;
				if (std::atoi(checkbox_cheat_fasttrash.c_str()) == 1) pInfo(peer)->cheater_settings |= SETTINGS::SETTINGS_15;
				else pInfo(peer)->cheater_settings &= ~SETTINGS::SETTINGS_15;
				if (std::atoi(checkbox_cheat_hide_players.c_str()) == 1) {
					pInfo(peer)->cheater_settings |= SETTINGS::SETTINGS_17;
				}
				else {
					pInfo(peer)->cheater_settings &= ~SETTINGS::SETTINGS_17;
				}
				VarList::OnConsoleMessage(peer, "`o>> Succesfully Applying cheats...");
				Clothing_V2::Update_Value(peer);
				Clothing_V2::Update(peer);
				DialogHandle::Cheats(peer);
			}
		}
	}
	static void game_menu(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			uint64_t Btn_Hash = quick_hash(button.c_str());
			switch (Btn_Hash) {
			case "back"_qh: {
				send_wrench_self(peer);
				return;
			}
			case "flipping_coin"_qh: {
				GameMenu::Flip_Coin(peer);
				return;
			}
			case "casino"_qh: {
				GameMenu::Casino(peer);
				return;
			}
			case "slot_machine"_qh: {
				GameMenu::Slot_Machine(peer);
				return;
			}
			case "mines"_qh: {
				GameMenu::Mines(peer);
				return;
			}
			case "Buy_Credits"_qh: {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wBuy Credits|left|9950|\nadd_spacer|small|\nadd_textbox|`oHow many Credits do you want to buy?|left|\nadd_text_input|Credits_Amount|||3|\nadd_spacer|small|\nadd_textbox|`o1 Credits = 1 World Locks.|left|\nadd_spacer|small|\nadd_textbox|`oYou have `2" + to_string(Inventory::Contains(peer, 242)) + " World Locks`o.|left|\nadd_button|exchange_shop|`wBack|noflags|\nadd_custom_button|Buy_Slot_Credits|textLabel:`2Buy;anchor:_button_exchange_shop;left:1;margin:40,0;|\nend_dialog|game_menu|||\nadd_quick_exit|");
				return;
			}
			case "Exchange_Points"_qh: {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wExchange Points|left|9950|\nadd_spacer|small|\nadd_textbox|`oHow many Points do you want to exchange?|left|\nadd_text_input|Credits_Amount|||3|\nadd_spacer|small|\nadd_textbox|`o100 Points = 1 World Locks.|left|\nadd_spacer|small|\nadd_textbox|`oYou have `2" + Set_Count(pInfo(peer)->Slot_Points) + " Points`o.|left|\nadd_button|exchange_shop|`wBack|noflags|\nadd_custom_button|Exchange_Slot_Points|textLabel:`2Exchange;anchor:_button_exchange_shop;left:1;margin:40,0;|\nend_dialog|game_menu|||\nadd_quick_exit|");
				return;
			}
			case "exchange_shop"_qh: {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wExchange Shop|left|1434|\nadd_spacer|small|\nadd_textbox|`oWelcome to the exchange shop. Here you can make transactions with the system to buy credits or exchange credits.|left|\nadd_smalltext|`oPrice:<CR> - Buy : 1 Credits / 1 World Locks.<CR> - Exchange : 100 Points / 1 World Locks.|left|\nadd_spacer|small|\nadd_smalltext|`o - Your current Points: " + Set_Count(pInfo(peer)->Slot_Points) + "|left|\nadd_smalltext|`o - Your current Credits: " + Set_Count(pInfo(peer)->Slot_Credits) + "|left|\nadd_spacer|small|\nadd_button|Buy_Credits|`wBuy Credits|noflags|0|0|\nadd_button|Exchange_Points|`wExchange Points|noflags|0|0|\nadd_quick_exit|\nadd_spacer|small|\nadd_button|back_to_gamemenu|`wBack|noflags|0|0|\nend_dialog|game_menu|||");
				return;
			}
			case "back_to_gamemenu"_qh: {
				GameMenu::Dialog(peer);
				return;
			}
			case "Exchange_Slot_Points"_qh: {
				std::string scan_c = parser.get("Credits_Amount", 1);
				if (atoi(scan_c.c_str()) < 0 || scan_c.find_first_not_of("0123456789") != std::string::npos) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in amount!", 0, 1);
					return;
				}
				int kaina = 100; int count = std::atoi(scan_c.c_str());
				if (count * kaina > pInfo(peer)->Slot_Points) {
					VarList::OnConsoleMessage(peer, "You don't have enough Point!");
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Point!", 0, 1);
					return;
				}
				if (Inventory::Modify(peer, 242, count) == 0) {
					pInfo(peer)->Slot_Points -= count * kaina;
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wSuccesfully Exchange " + to_string(count * kaina) + " Points for " + Set_Count(count) + " World Locks.", 0, 1);
					GameMenu::Slot_Machine(peer);
				}
				return;
			}
			case "Buy_Slot_Credits"_qh: {
				std::string scan_c = parser.get("Credits_Amount", 1);
				if (atoi(scan_c.c_str()) < 1 || atoi(scan_c.c_str()) < 0 || atoi(scan_c.c_str()) > 200 || scan_c.find_first_not_of("0123456789") != std::string::npos) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in amount!", 0, 1);
					return;
				}
				int kaina = 1; int count = std::atoi(scan_c.c_str());
				int my_wls = Inventory::Contains(peer, 242);
				if (kaina * count > my_wls) {
					VarList::OnConsoleMessage(peer, "You don't have enough World Locks!");
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough World Locks!", 0, 1);
					return;
				}
				int is_viso_worldlock = kaina * count, rem = 0;
				Inventory::Modify(peer, 242, rem -= is_viso_worldlock);
				pInfo(peer)->Slot_Credits += count;
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wSuccesfully Buy " + to_string(count) + " Credits for " + Set_Count(is_viso_worldlock) + " World Locks.", 0, 1);
				GameMenu::Slot_Machine(peer);
				return;
			}
			case "play_flipping_coin"_qh: {
				std::string bet = parser.get("bet", 1), hort = parser.get("hort", 1);
				if (bet.find_first_not_of("01234567890") != std::string::npos || bet.size() < 1 || std::atoi(bet.c_str()) > pInfo(peer)->gems) {
					GameMenu::Flip_Coin(peer, "Invalid bet amount. Please try again.", bet, hort);
					return;
				}
				if (hort.size() < 1 || hort.find_first_not_of("ht") != std::string::npos) {
					GameMenu::Flip_Coin(peer, "Invalid head or tail input. Please try again.", bet, hort);
					return;
				}
				int coin = rand() % 2;
				VarList::OnConsoleMessage(peer, "Flipping the coin...", false, 1000);
				CAction::Effect(peer, 29, (float)pInfo(peer)->x + 10, (float)pInfo(peer)->y + 16, 1500);
				if ((hort == "h" && coin == 0) || (hort == "t" && coin == 1)) {
					VarList::OnBuxGems(peer, std::atoi(bet.c_str()), 2500);
					VarList::OnConsoleMessage(peer, "Congratulations! You won $" + bet, false, 2500);
					VarList::OnAddNotification(peer, "`wYou won $" + bet, "interface/large/you_win.rttex", "audio/slot_win.wav", 2500);
				}
				else {
					VarList::OnMinGems(peer, std::atoi(bet.c_str()), 2500);
					VarList::OnConsoleMessage(peer, "Sorry, you lost $" + bet, false, 2500);
					VarList::OnAddNotification(peer, "`wYou lose $" + bet, "interface/large/you_lose.rttex", "audio/slot_lose.wav", 2500);
				}
				GameMenu::Flip_Coin(peer, "Playing Again?", "", "", 3000);
				return;
			}
			case "play_casino"_qh: {
				std::string bet = parser.get("bet", 1);
				if (bet.find_first_not_of("01234567890") != std::string::npos || bet.size() < 1 || std::atoi(bet.c_str()) > pInfo(peer)->gems) {
					GameMenu::Casino(peer, "Invalid bet amount. Please try again.", bet);
					return;
				}
				int playerResult = rand() % 37;
				string color = "";
				if (playerResult == 36 || playerResult == 34 || playerResult == 32 || playerResult == 30 || playerResult == 27 || playerResult == 25 || playerResult == 23 || playerResult == 21 || playerResult == 19 || playerResult == 18 || playerResult == 16 || playerResult == 12 || playerResult == 9 || playerResult == 7 || playerResult == 5 || playerResult == 3 || playerResult == 1) color = "`4";
				else if (playerResult == 0) color = "`2";
				else color = "`b";
				VarList::OnConsoleMessage(peer, "`7[``You spun the wheel and got " + color + to_string(playerResult) + "!`7]`", false, 1500);
				int systemResult = rand() % 37;
				string color1 = "";
				if (systemResult == 36 || systemResult == 34 || systemResult == 32 || systemResult == 30 || systemResult == 27 || systemResult == 25 || systemResult == 23 || systemResult == 21 || systemResult == 19 || systemResult == 18 || systemResult == 16 || systemResult == 12 || systemResult == 9 || systemResult == 7 || systemResult == 5 || systemResult == 3 || systemResult == 1) color1 = "`4";
				else if (systemResult == 0) color1 = "`2";
				else color1 = "`b";
				VarList::OnConsoleMessage(peer, "`7[``System spun the wheel and got " + color + to_string(systemResult) + "!`7]`", false, 2500);
				if (playerResult > systemResult) {
					VarList::OnBuxGems(peer, std::atoi(bet.c_str()), 5000);
					VarList::OnConsoleMessage(peer, "You won $" + bet, false, 5000);
					VarList::OnAddNotification(peer, "`wYou won $" + bet, "interface/large/you_win.rttex", "audio/slot_win.wav", 5000);
				}
				else if (playerResult < systemResult) {
					VarList::OnMinGems(peer, std::atoi(bet.c_str()), 5000);
					VarList::OnConsoleMessage(peer, "System wins $" + bet, false, 5000);
					VarList::OnAddNotification(peer, "`wYou lose $" + bet, "interface/large/you_lose.rttex", "audio/slot_lose.wav", 5000);
				}
				else VarList::OnConsoleMessage(peer, "It's a draw. No money exchanged.", false, 5000);
				GameMenu::Casino(peer, "Playing Again?", "", 5500);
				return;
			}
			case "play_slot_machine"_qh: {
				if (pInfo(peer)->Slot_Credits < 1) {
					GameMenu::Slot_Machine(peer, "You don't have enough Credits");
					return;
				}
				pInfo(peer)->Slot_Credits -= 1;
				VarList::OnConsoleMessage(peer, "Spinning...", false, 1000);
				int symbol1 = rand() % 6, symbol2 = rand() % 6, symbol3 = rand() % 6;
				const char* symbols[6] = { "Cherry", "Apple", "Banana", "Orange", "Grapes", "Lemon" };
				VarList::OnConsoleMessage(peer, "Reels: [" + a + symbols[symbol1] + "] [" + symbols[symbol2] + "] [" + symbols[symbol3] + "]", false, 3000);
				if (symbol1 == symbol2 && symbol2 == symbol3) {
					pInfo(peer)->Slot_Points += 50;
					VarList::OnConsoleMessage(peer, "Congratulations! You won! got 50 Points", false, 5000);
					VarList::OnAddNotification(peer, "Congratulations! You won!", "interface/large/you_win.rttex", "audio/slot_win.wav", 5000);
				}
				else if (symbol1 == symbol2 && symbol2 != symbol3 or symbol1 != symbol2 && symbol2 == symbol3) {
					pInfo(peer)->Slot_Points += 25;
					VarList::OnConsoleMessage(peer, "Congratulations! You won! got 25 Points", false, 5000);
					VarList::OnAddNotification(peer, "Congratulations! You won!", "interface/large/you_win.rttex", "audio/slot_win.wav", 5000);
				}
				else {
					VarList::OnConsoleMessage(peer, "Sorry, you didn't win this time", false, 5000);
					VarList::OnAddNotification(peer, "Sorry, you didn't win this time", "interface/large/you_lose.rttex", "audio/slot_lose.wav", 5000);
				}
				GameMenu::Slot_Machine(peer, "Playing Again?", 5500);
				return;
			}
			case "play_mines"_qh: {
				std::string minesamount = parser.get("minesamount", 1), gems = parser.get("gems", 1);
				if (not is_number(minesamount) or std::atoi(minesamount.c_str()) < 5 or std::atoi(minesamount.c_str()) > 10) {
					GameMenu::Mines(peer, "Invaild input in Mines Amount.");
					return;
				}
				if (not is_number(gems) or std::atoi(gems.c_str()) < 100000 or std::atoi(gems.c_str()) > 5000000) {
					GameMenu::Mines(peer, "Gems amount is too low or too much.");
					return;
				}
				int gems_ = std::atoi(gems.c_str()), mines_ = std::atoi(minesamount.c_str());
				std::vector<int> mines{};
				while (mines.size() < mines_) {
					int toadd = rand() % 16 + 1;
					if (!includesint(mines, toadd)) mines.push_back(toadd);
				}
				pInfo(peer)->bM = mines_ * (gems_ / 9);
				if (pInfo(peer)->gems < gems_) {
					GameMenu::Mines(peer, "You dont have enough gems.");
					return;
				}
				VarList::OnMinGems(peer, gems_);
				pInfo(peer)->foundg = 0;
				pInfo(peer)->minesleft = mines_;
				pInfo(peer)->endedit = false;
				pInfo(peer)->mines = mines;
				pInfo(peer)->clickm.clear();
				pInfo(peer)->lostt = false;
				std::vector<int> clicked = pInfo(peer)->clickm;
				int minesleft = pInfo(peer)->minesleft, foundg = pInfo(peer)->foundg;
				int sa = 6888, bm = 6994;
				string extr = "";
				if (!clicked.empty()) extr += "\nadd_button|mines_claimnl|Claim and Leave|noflags|0|0|";
				for (int i = 0; i < 4; i++) {
					if (includesint(clicked, i)) extr += "\nadd_button_with_icon|mines_bma_" + to_string(i + 1) + "||staticBlueFrame|6888|";
					else extr += "\nadd_button_with_icon|mines_bma_" + to_string(i + 1) + "||staticBlueFrame|0|";
				}
				extr += "\nadd_button_with_icon||END_LIST|noflags|0||";
				for (int i = 0; i < 4; i++) {
					if (includesint(clicked, i)) extr += "\nadd_button_with_icon|mines_bma_" + to_string(i + 5) + "||staticBlueFrame|6888|";
					else extr += "\nadd_button_with_icon|mines_bma_" + to_string(i + 5) + "||staticBlueFrame|0|";
				}
				extr += "\nadd_button_with_icon||END_LIST|noflags|0||";
				for (int i = 0; i < 4; i++) {
					if (includesint(clicked, i)) extr += "\nadd_button_with_icon|mines_bma_" + to_string(i + 9) + "||staticBlueFrame|6888|";
					else extr += "\nadd_button_with_icon|mines_bma_" + to_string(i + 9) + "||staticBlueFrame|0|";
				}
				extr += "\nadd_button_with_icon||END_LIST|noflags|0||";
				for (int i = 0; i < 4; i++) {
					if (includesint(clicked, i)) extr += "\nadd_button_with_icon|mines_bma_" + to_string(i + 13) + "||staticBlueFrame|6888|";
					else extr += "\nadd_button_with_icon|mines_bma_" + to_string(i + 13) + "||staticBlueFrame|0|";
				}
				extr += "\nadd_button_with_icon||END_LIST|noflags|0||";
				VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wMinefield|left|6994|\nadd_smalltext|`4Mines Left:" + Set_Count(minesleft) + ", `2Total Profit: " + Set_Count(foundg) + " Gems|left|\nadd_spacer|small|" + extr + "\nend_dialog|game_menu|||\nadd_quick_exit|");
				return;
			}
			case "mines_claimnl"_qh: {
				if (pInfo(peer)->lostt) return;
				GameMenu::Mines(peer, "Want Play Again?");
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Earned `2" + Set_Count(pInfo(peer)->foundg * pInfo(peer)->bM) + " Gems ė.");
				VarList::OnBuxGems(peer, pInfo(peer)->foundg * pInfo(peer)->bM);
				pInfo(peer)->minesleft = 0, pInfo(peer)->foundg = 0;
				pInfo(peer)->mines = {};
				pInfo(peer)->clickm = {};
				pInfo(peer)->lostt = false;
				pInfo(peer)->endedit = true;
				return;
			}
			default:
				if (button.substr(0, 10) == "mines_bma_") {
					if (pInfo(peer)->endedit) return;
					int cli = std::atoi(button.substr(10).c_str());
					if (includesint(pInfo(peer)->clickm, cli)) return;
					if (cli > 16) return;
					pInfo(peer)->clickm.push_back(cli);
					std::vector<int> mines = pInfo(peer)->mines, clicked = pInfo(peer)->clickm;
					int minesleft = pInfo(peer)->minesleft, foundg = pInfo(peer)->foundg;
					bool lost = false;
					int sa = 6888, bm = 6994;
					string extr = "";
					if (includesint(mines, cli)) lost = true;
					if (not lost) pInfo(peer)->foundg++, foundg++;
					for (int i = 0; i < 4; i++) {
						if ((includesint(clicked, i + 1) or lost) and !includesint(mines, i + 1)) extr += "\nadd_button_with_icon|mines_cum_" + to_string(i + 1) + "||staticBlueFrame|6888|";
						else if (includesint(mines, i + 1) and lost) extr += "\nadd_button_with_icon|mines_cum_" + to_string(i + 1) + "||staticYellowFrame|6994|";
						else extr += "\nadd_button_with_icon|mines_bma_" + to_string(i + 1) + "||staticBlueFrame|0|";
					}
					extr += "\nadd_button_with_icon||END_LIST|noflags|0||";
					for (int i = 0; i < 4; i++) {
						if ((includesint(clicked, i + 5) or lost) and !includesint(mines, i + 5)) extr += "\nadd_button_with_icon|mines_cum_" + to_string(i + 5) + "||staticBlueFrame|6888|";
						else if (includesint(mines, i + 5) and lost) extr += "\nadd_button_with_icon|mines_cum_" + to_string(i + 5) + "||staticYellowFrame|6994|";
						else extr += "\nadd_button_with_icon|mines_bma_" + to_string(i + 5) + "||staticBlueFrame|0|";
					}
					extr += "\nadd_button_with_icon||END_LIST|noflags|0||";
					for (int i = 0; i < 4; i++) {
						if ((includesint(clicked, i + 9) or lost) and !includesint(mines, i + 9)) extr += "\nadd_button_with_icon|mines_cum_" + to_string(i + 9) + "||staticBlueFrame|6888|";
						else if (includesint(mines, i + 9) and lost) extr += "\nadd_button_with_icon|mines_cum_" + to_string(i + 9) + "||staticYellowFrame|6994|";
						else extr += "\nadd_button_with_icon|mines_bma_" + to_string(i + 9) + "||staticBlueFrame|0|";
					}
					extr += "\nadd_button_with_icon||END_LIST|noflags|0||";
					for (int i = 0; i < 4; i++) {
						if ((includesint(clicked, i + 13) or lost) and !includesint(mines, i + 13)) extr += "\nadd_button_with_icon|mines_cum_" + to_string(i + 13) + "||staticBlueFrame|6888|";
						else if (includesint(mines, i + 13) and lost) extr += "\nadd_button_with_icon|mines_cum_" + to_string(i + 13) + "||staticYellowFrame|6994|";
						else extr += "\nadd_button_with_icon|mines_bma_" + to_string(i + 13) + "||staticBlueFrame|0|";
					}
					extr += "\nadd_button_with_icon||END_LIST|noflags|0||";
					if (!clicked.empty() && not lost) extr += "\nadd_button|mines_claimnl|Claim and Leave|noflags|0|0|";
					if (lost) extr += "\nadd_button|pekKsks|Leave|noflags|0|0|";
					std::string tx = "Mines Left:" + Set_Count(minesleft) + ", `2Total Profit: " + Set_Count(foundg * pInfo(peer)->bM) + " Gems";
					if (lost) tx = "YOU LOST!", pInfo(peer)->lostt = true;
					VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wMinefield|left|6994|\nadd_smalltext|`4" + tx + "|left|\nadd_spacer|small|" + extr + "\nend_dialog|game_menu|||\nadd_quick_exit|");
				}
				if (button.substr(0, 10) == "mines_cum_") {
					int cli = std::atoi(button.substr(10).c_str());
					if (pInfo(peer)->endedit) return;
					std::vector<int> mines = pInfo(peer)->mines, clicked = pInfo(peer)->clickm;
					int minesleft = pInfo(peer)->minesleft, foundg = pInfo(peer)->foundg;
					bool lost = false;
					int sa = 6888, bm = 6994;
					string extr = "";
					if (pInfo(peer)->lostt) lost = true;
					for (int i = 0; i < 4; i++) {
						if ((includesint(clicked, i + 1) or lost) and !includesint(mines, i + 1)) extr += "\nadd_button_with_icon|mines_cum_" + to_string(i + 1) + "||staticBlueFrame|6888|";
						else if (includesint(mines, i + 1) and lost) extr += "\nadd_button_with_icon|mines_cum_" + to_string(i + 1) + "||staticYellowFrame|6994|";
						else extr += "\nadd_button_with_icon|mines_bma_" + to_string(i + 1) + "||staticBlueFrame|0|";
					}
					extr += "\nadd_button_with_icon||END_LIST|noflags|0||";
					for (int i = 0; i < 4; i++) {
						if ((includesint(clicked, i + 5) or lost) and !includesint(mines, i + 5)) extr += "\nadd_button_with_icon|mines_cum_" + to_string(i + 5) + "||staticBlueFrame|6888|";
						else if (includesint(mines, i + 5) and lost) extr += "\nadd_button_with_icon|mines_cum_" + to_string(i + 5) + "||staticYellowFrame|6994|";
						else extr += "\nadd_button_with_icon|mines_bma_" + to_string(i + 5) + "||staticBlueFrame|0|";
					}
					extr += "\nadd_button_with_icon||END_LIST|noflags|0||";
					for (int i = 0; i < 4; i++) {
						if ((includesint(clicked, i + 9) or lost) and !includesint(mines, i + 9)) extr += "\nadd_button_with_icon|mines_cum_" + to_string(i + 9) + "||staticBlueFrame|6888|";
						else if (includesint(mines, i + 9) and lost) extr += "\nadd_button_with_icon|mines_cum_" + to_string(i + 9) + "||staticYellowFrame|6994|";
						else extr += "\nadd_button_with_icon|mines_bma_" + to_string(i + 9) + "||staticBlueFrame|0|";
					}
					extr += "\nadd_button_with_icon||END_LIST|noflags|0||";
					for (int i = 0; i < 4; i++) {
						if ((includesint(clicked, i + 13) or lost) and !includesint(mines, i + 13)) extr += "\nadd_button_with_icon|mines_cum_" + to_string(i + 13) + "||staticBlueFrame|6888|";
						else if (includesint(mines, i + 13) and lost) extr += "\nadd_button_with_icon|mines_cum_" + to_string(i + 13) + "||staticYellowFrame|6994|";
						else extr += "\nadd_button_with_icon|mines_bma_" + to_string(i + 13) + "||staticBlueFrame|0|";
					}
					extr += "\nadd_button_with_icon||END_LIST|noflags|0||";
					if (!clicked.empty() && not lost) extr += "\nadd_button|mines_claimnl|Claim and Leave|noflags|0|0|";
					if (lost) extr += "\nadd_button|pekKsks|Leave|noflags|0|0|";
					std::string tx = "Mines Left:" + Set_Count(minesleft) + ", `2Total Profit: " + Set_Count(foundg * pInfo(peer)->bM) + " Gems";
					if (lost) tx = "YOU LOST!";
					VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wMinefield|left|6994|\nadd_spacer|big|\nadd_smalltext|`4" + tx + "|left|\nadd_spacer|small|" + extr + "\nend_dialog|game_menu|STOP GAMBLING!||\nadd_quick_exit|");
				}
				return;
			}
		}
	}
	static void upgrade_world_gems(ENetPeer* peer, std::string cch) {
		std::string name_ = pInfo(peer)->world;
		std::vector<World>::iterator paa = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (paa != worlds.end()) {
			World* world_ = &worlds[paa - worlds.begin()];
			if (world_->owner_name == pInfo(peer)->tankIDName) {
				int cost = 0, x_g = 0, x_l = 0;
				if (world_->gems_lvl == 0) cost = 5000000, x_g = 3, x_l = 2;
				if (world_->gems_lvl == 2) cost = 7000000, x_g = 5, x_l = 3;
				if (world_->gems_lvl == 3) cost = 10000000, x_g = 7, x_l = 4;
				if (world_->gems_lvl == 4) cost = 15000000, x_g = 10, x_l = 5;
				if (world_->gems_lvl == 5) cost = 17000000, x_g = 12, x_l = 6;
				if (world_->gems_lvl == 6) cost = 20000000, x_g = 14, x_l = 7;
				if (world_->gems_lvl == 7) cost = 23000000, x_g = 15, x_l = 8;
				if (world_->gems_lvl == 8) cost = 25000000, x_g = 16, x_l = 9;
				if (world_->gems_lvl == 9) cost = 26000000, x_g = 17, x_l = 10;
				if (world_->gems_lvl == 10) cost = 28000000, x_g = 18, x_l = 11;
				if (world_->gems_lvl == 11) cost = 30000000, x_g = 20, x_l = 12;
				if (pInfo(peer)->gems < cost) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough gems to upgrade World Gems Bonus!", 0, 0);
					return;
				}
				world_->gems = x_g;
				world_->gems_lvl = x_l;
				VarList::OnMinGems(peer, cost);
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You have upgrade your World Gems Bonus!", 0, 0);
			}
		}
	}
	static void team_edit(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string name_ = pInfo(peer)->world, btn;
		std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			int tileX = 0, tileY = 0;
			World* world_ = &worlds[p - worlds.begin()];
			if (not is_number(std::string(get_embed(cch, "tilex"))) or not is_number(std::string(get_embed(cch, "tiley")))) return;
			if (!parser.try_get("tilex", tileX) || !parser.try_get("tiley", tileY)) return;
			WorldBlock* block_ = &world_->blocks[tileX + (tileY * 100)];
			if (items[block_->fg].blockType != GAME_BLOCK) return;
			if (Only_Access(peer, world_, block_)) {
				if (!parser.try_get("buttonClicked", btn)) return;
				if (tileX != 0 || tileY != 0) {
					if (btn.substr(0, 4) == "team") {
						int team = std::atoi(btn.substr(4).c_str());
						block_->GameGen.Teams = team;
						PlayerMoving data_{};
						data_.packetType = 5, data_.punchX = tileX, data_.punchY = tileY, data_.characterState = 0x8;
						BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
						BYTE* blc = raw + 56;
						form_visual(blc, *block_, *world_, peer, false);
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) { //fix
							if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or world_->name != pInfo(cp_)->world) continue;
							send_raw(cp_, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
						}
						delete[] raw, blc;
						if (block_->locked) {
							upd_lock(*block_, *world_, peer);
						}
					}
				}
			}
		}
	}
	static void Role_Quest(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch); std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "backto_qinfo" or button == "View_Role" or button == "backto_viewrole") Role_Quest::Dialog(peer);
			else if (button == "backto_goals") DialogHandle::Daily_Quest_Info(peer);
			else if (button.substr(0, 7) == "reward_") {
				std::string type = button.substr(7);
				Role_Quest::Reward(peer, type);
			}
			else if (button == "view_role_stats") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Role Quest|left|982|\nadd_spacer|small|\nadd_textbox|`9What's your specialty? Punch, Build, Grow, and more to earn points and unlock Role Rewards and Powers!``|left|\nadd_spacer|small|" + (pInfo(peer)->t_lvl == 10 ? "\nadd_progress_bar|`$Farmer``|big|`wLevel: Mastered!||-1||\nadd_spacer|small|" : "\nadd_player_info|`$Farmer``|" + to_string(pInfo(peer)->t_lvl) + "|" + to_string(pInfo(peer)->t_xp) + "|" + to_string(Role_Quest::Farmer::Xp(pInfo(peer)->t_lvl)) + "|") + "\nadd_spacer|small|\nadd_small_font_button|reward_farmer|View Farmer Rewards|noflags|0|0|\nadd_spacer|small|" + (pInfo(peer)->bb_lvl == 10 ? "\nadd_progress_bar|`$Builder``|big|`wLevel: Mastered!||-1||\nadd_spacer|small|" : "\nadd_player_info|`$Builder``|" + to_string(pInfo(peer)->bb_lvl) + "|" + to_string(pInfo(peer)->bb_xp) + "|" + to_string(Role_Quest::Builder::Xp(pInfo(peer)->bb_lvl)) + "|") + "\nadd_spacer|small|\nadd_small_font_button|reward_builder|View Builder Rewards|noflags|0|0|\nadd_spacer|small|" + (pInfo(peer)->s_lvl == 10 ? "\nadd_progress_bar|`$Surgeon``|big|`wLevel: Mastered!||-1||\nadd_spacer|small|" : "\nadd_player_info|`$Surgeon``|" + to_string(pInfo(peer)->s_lvl) + "|" + to_string(pInfo(peer)->s_xp) + "|" + to_string(Role_Quest::Surgeon::Xp(pInfo(peer)->s_lvl)) + "|") + "\nadd_spacer|small|\nadd_small_font_button|reward_surgery|View Surgery Rewards|noflags|0|0|\nadd_spacer|small|" + (pInfo(peer)->ff_lvl == 10 ? "\nadd_progress_bar|`$Fishing``|big|`wLevel: Mastered!||-1||\nadd_spacer|small|" : "\nadd_player_info|`$Fishing``|" + to_string(pInfo(peer)->ff_lvl) + "|" + to_string(pInfo(peer)->ff_xp) + "|" + to_string(Role_Quest::Fishing::Xp(pInfo(peer)->ff_lvl)) + "|") + "\nadd_spacer|small|\nadd_small_font_button|reward_fishing|View Fishing Rewards|noflags|0|0|\nadd_spacer|small|" + (pInfo(peer)->p_lvl == 10 ? "\nadd_progress_bar|`$Provider``|big|`wLevel: Mastered!||-1||\nadd_spacer|small|" : "\nadd_player_info|`$Provider``|" + to_string(pInfo(peer)->p_lvl) + "|" + to_string(pInfo(peer)->t_xp) + "|" + to_string(Role_Quest::Provider::Xp(pInfo(peer)->p_lvl)) + "|") + "\nadd_spacer|small|\nadd_small_font_button|reward_provider|View Provider Rewards|noflags|0|0|\nadd_spacer|small|" + (pInfo(peer)->g_lvl == 10 ? "\nadd_progress_bar|`$Geiger``|big|`wLevel: Mastered!||-1||\nadd_spacer|small|" : "\nadd_player_info|`$Geiger``|" + to_string(pInfo(peer)->g_lvl) + "|" + to_string(pInfo(peer)->g_xp) + "|" + to_string(Role_Quest::Geiger::Xp(pInfo(peer)->g_lvl)) + "|") + "\nadd_spacer|small|\nadd_small_font_button|reward_geiger|View Geiger Rewards|noflags|0|0|\nadd_spacer|small|\nadd_button|backto_qinfo|Back|\nend_dialog|Role_Quest|||\nadd_quick_exit|\n");
			else if (button.substr(0, 13) == "t_claimreward") {
				int reward = std::atoi(button.substr(13).c_str()), count = 1;
				std::vector<int> list{ 98, 6898, 1746, 6840, 1830, 5078, 1966, 6948, 6946, 4956 };
				if (reward <= 0 || reward > list.size()) return;
				if (list[reward - 1] == 1746) count = 200;
				if (find(pInfo(peer)->t_p.begin(), pInfo(peer)->t_p.end(), reward) == pInfo(peer)->t_p.end()) {
					if (pInfo(peer)->t_lvl >= reward) {
						if (Inventory::Modify(peer, list[reward - 1], count) == 0) {
							pInfo(peer)->t_p.push_back(reward);
							CAction::Log(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations! You have received your Farmer Reward!", 0, 0);
							PlayerMoving data_{};
							data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
								if (pInfo(peer)->world != pInfo(cp_)->world) continue;
								send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							delete[] raw;
							{
								PlayerMoving data_{};
								data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16, data_.packetType = 19, data_.plantingTree = 100, data_.punchX = list[reward - 1], data_.punchY = pInfo(peer)->netID;
								int32_t to_netid = pInfo(peer)->netID;
								BYTE* raw = packPlayerMoving(&data_);
								raw[3] = 5;
								Memory_Copy(raw + 8, &to_netid, 4);
								send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								delete[] raw;
							}
							Role_Quest::Reward(peer, "farmer");
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You have full inventory space!", 0, 0);
					}
				}
			}
			else if (button.substr(0, 13) == "f_claimreward") {
				int reward = std::atoi(button.substr(13).c_str()), count = 1;
				std::vector<int> list{ 3010, 3018, 3020, 3044, 5740, 3042, 3098, 3100, 3040, 10262 };
				if (reward <= 0 || reward > list.size()) return;
				if (list[reward - 1] == 3018) count = 200;
				if (list[reward - 1] == 3020 || list[reward - 1] == 3098) count = 50;
				if (list[reward - 1] == 3044) count = 25;
				if (find(pInfo(peer)->ff_p.begin(), pInfo(peer)->ff_p.end(), reward) == pInfo(peer)->ff_p.end()) {
					if (pInfo(peer)->ff_lvl >= reward) {
						if (Inventory::Modify(peer, list[reward - 1], count) == 0) {
							pInfo(peer)->ff_p.push_back(reward);
							CAction::Log(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations! You have received your Fishing Reward!", 0, 0);
							PlayerMoving data_{};
							data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
								if (pInfo(peer)->world != pInfo(cp_)->world) continue;
								send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							delete[] raw;
							{
								PlayerMoving data_{};
								data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16, data_.packetType = 19, data_.plantingTree = 100, data_.punchX = list[reward - 1], data_.punchY = pInfo(peer)->netID;
								int32_t to_netid = pInfo(peer)->netID;
								BYTE* raw = packPlayerMoving(&data_);
								raw[3] = 5;
								Memory_Copy(raw + 8, &to_netid, 4);
								send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								delete[] raw;
							}
							Role_Quest::Reward(peer, "fishing");
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You have full inventory space!", 0, 0);
					}
				}
			}
			else if (button.substr(0, 13) == "b_claimreward") {
				int reward = std::atoi(button.substr(13).c_str()), count = 1;
				std::vector<int> list{ 6896, 9522, 6948, 1068, 1966, 1836, 5080, 10754, 1874, 6946 };
				if (reward <= 0 || reward > list.size()) return;
				if (list[reward - 1] == 9522) count = 200;
				if (list[reward - 1] == 1068) count = 10;
				if (find(pInfo(peer)->bb_p.begin(), pInfo(peer)->bb_p.end(), reward) == pInfo(peer)->bb_p.end()) {
					if (pInfo(peer)->bb_lvl >= reward) {
						if (Inventory::Modify(peer, list[reward - 1], count) == 0) {
							pInfo(peer)->bb_p.push_back(reward);
							CAction::Log(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations! You have received your Builder Reward!", 0, 0);
							PlayerMoving data_{};
							data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
								if (pInfo(peer)->world != pInfo(cp_)->world) continue;
								send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							delete[] raw;
							{
								PlayerMoving data_{};
								data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16, data_.packetType = 19, data_.plantingTree = 100, data_.punchX = list[reward - 1], data_.punchY = pInfo(peer)->netID;
								int32_t to_netid = pInfo(peer)->netID;
								BYTE* raw = packPlayerMoving(&data_);
								raw[3] = 5;
								Memory_Copy(raw + 8, &to_netid, 4);
								send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								delete[] raw;
							}
							Role_Quest::Reward(peer, "builder");
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You have full inventory space!", 0, 0);
					}
				}
			}
			else if (button.substr(0, 13) == "s_claimreward") {
				int reward = std::atoi(button.substr(13).c_str()), count = 1;
				std::vector<int> list{ 6900, 6982, 6212, 3172, 9068, 6912, 10836, 5142, 3130, 8284 };
				if (reward <= 0 || reward > list.size()) return;
				if (list[reward - 1] == 10836) count = 100;
				if (list[reward - 1] == 6212) count = 50;
				if (list[reward - 1] == 3172 || list[reward - 1] == 6912) count = 25;
				if (list[reward - 1] == 5142) count = 5;
				if (find(pInfo(peer)->surg_p.begin(), pInfo(peer)->surg_p.end(), reward) == pInfo(peer)->surg_p.end()) {
					if (pInfo(peer)->s_lvl >= reward) {
						if (Inventory::Modify(peer, list[reward - 1], count) == 0) {
							pInfo(peer)->surg_p.push_back(reward);
							CAction::Log(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations! You have received your Surgeon Reward!", 0, 0);
							PlayerMoving data_{};
							data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
								if (pInfo(peer)->world != pInfo(cp_)->world) continue;
								send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							delete[] raw;
							{
								PlayerMoving data_{};
								data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16, data_.packetType = 19, data_.plantingTree = 100, data_.punchX = list[reward - 1], data_.punchY = pInfo(peer)->netID;
								int32_t to_netid = pInfo(peer)->netID;
								BYTE* raw = packPlayerMoving(&data_);
								raw[3] = 5;
								Memory_Copy(raw + 8, &to_netid, 4);
								send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								delete[] raw;
							}
							Role_Quest::Reward(peer, "surgery");
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You have full inventory space!", 0, 0);
					}
				}
			}
			else if (button.substr(0, 13) == "p_claimreward") {
				int reward = std::atoi(button.substr(13).c_str()), count = 1;
				std::vector<int> list{ 1008,1044,872,10450,870,7166,876,6950,6952,9166 };
				if (reward <= 0 || reward > list.size()) return;
				if (list[reward - 1] == 1008) count = 5;
				if (list[reward - 1] == 1044) count = 50;
				if (list[reward - 1] == 872) count = 200;
				if (list[reward - 1] == 10450) count = 3;
				if (find(pInfo(peer)->p_p.begin(), pInfo(peer)->p_p.end(), reward) == pInfo(peer)->p_p.end()) {
					if (pInfo(peer)->p_lvl >= reward) {
						if (Inventory::Modify(peer, list[reward - 1], count) == 0) {
							pInfo(peer)->p_p.push_back(reward);
							CAction::Log(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations! You have received your Provider Reward!", 0, 0);
							PlayerMoving data_{};
							data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
								if (pInfo(peer)->world != pInfo(cp_)->world) continue;
								send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							delete[] raw;
							{
								PlayerMoving data_{};
								data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16, data_.packetType = 19, data_.plantingTree = 100, data_.punchX = list[reward - 1], data_.punchY = pInfo(peer)->netID;
								int32_t to_netid = pInfo(peer)->netID;
								BYTE* raw = packPlayerMoving(&data_);
								raw[3] = 5;
								Memory_Copy(raw + 8, &to_netid, 4);
								send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								delete[] raw;
							}
							Role_Quest::Reward(peer, "provider");
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You have full inventory space!", 0, 0);
					}
				}
			}
			else if (button.substr(0, 13) == "g_claimreward") {
				int reward = std::atoi(button.substr(13).c_str()), count = 1;
				std::vector<int> list{ 4654,262,826,828,9712,3146,2266,5072,5070,9716 };
				if (reward <= 0 || reward > list.size()) return;
				if (list[reward - 1] == 262 || list[reward - 1] == 826 || list[reward - 1] == 828) count = 50;
				if (list[reward - 1] == 3146) count = 10;
				if (find(pInfo(peer)->g_p.begin(), pInfo(peer)->g_p.end(), reward) == pInfo(peer)->g_p.end()) {
					if (pInfo(peer)->g_lvl >= reward) {
						if (Inventory::Modify(peer, list[reward - 1], count) == 0) {
							pInfo(peer)->g_p.push_back(reward);
							CAction::Log(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations! You have received your Geiger Hunting Reward!", 0, 0);
							PlayerMoving data_{};
							data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
								if (pInfo(peer)->world != pInfo(cp_)->world) continue;
								send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							delete[] raw;
							{
								PlayerMoving data_{};
								data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16, data_.packetType = 19, data_.plantingTree = 100, data_.punchX = list[reward - 1], data_.punchY = pInfo(peer)->netID;
								int32_t to_netid = pInfo(peer)->netID;
								BYTE* raw = packPlayerMoving(&data_);
								raw[3] = 5;
								Memory_Copy(raw + 8, &to_netid, 4);
								send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								delete[] raw;
							}
							Role_Quest::Reward(peer, "geiger");
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You have full inventory space!", 0, 0);
					}
				}
			}
			else if (button == "quest_selected" or button == "Choosequest_selected" or button == "backto_selectedquest") {
				if (button == "Choosequest_selected") {
					if (pInfo(peer)->specialization_track != "") pInfo(peer)->specialization_track = "";
				}
				long long time_ = time(nullptr);
				std::string selected_quest = "";
				/*Farmer*/
				if (pInfo(peer)->specialization_track == "Farmer" and pInfo(peer)->role_quest_type == "") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Role Quest|left|982|\nadd_spacer|small|\nadd_textbox|`9Select a Role Quest to advance your speciality!|left|\nadd_spacer|small|\nadd_smalltext|`$- You have ambarked on " + to_string(pInfo(peer)->total_quest_selected) + " Role Quests today!|left|\nadd_smalltext|`$- Your quest will reset in : " + Time::Playmod(pInfo(peer)->rolequest_reset_day - time_) + " and any progress on the current quest will be lost.|left|" + (pInfo(peer)->total_quest_selected == 0 ? "\nadd_smalltext|`$- You haven't started Role Quests today!|left|\nadd_smalltext|`$- Your first quest for the day is `2FREE ``to start!|left|" : "") + "\nadd_spacer|small|" + (pInfo(peer)->t_lvl == 10 ? "\nadd_progress_bar|`$Farmer``|big|`wLevel: Mastered!||-1||\nadd_spacer|small|" : "\nadd_player_info|`$Farmer``|" + to_string(pInfo(peer)->t_lvl) + "|" + to_string(pInfo(peer)->t_xp) + "|" + to_string(Role_Quest::Farmer::Xp(pInfo(peer)->t_lvl)) + "|") + "\nadd_spacer|small|" + a + (pInfo(peer)->total_quest_selected < 10 ? "\nadd_button|start_rolequest_farmer|`$Start Farmer Quest|0|0|" : "\nadd_smalltext|`$- You have reached your maximum limit today!|left|") + (pInfo(peer)->t_lvl == 10 ? (rolequest_day == 2 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Farming Day``!|left|1486|\nadd_smalltext|`$- Your first Farming quest will earn `21 Growtoken``. Every Farming quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Farming Day``!|left|\nadd_smalltext|`$- Every Farming quest will also earn 25% extra points.|left|") : (rolequest_day == 0 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Jack of All Trades Day``!|left|1486|\nadd_smalltext|`$- Your first Farming quest will earn `21 Growtoken``. Every Farming quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Jack of All Trades Day``!|left|\nadd_smalltext|`$- Every Farming quest will also earn 25% extra points.|left|") : "")) : (rolequest_day == 2 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Farming Day``!|left|1486|\nadd_smalltext|`$- Your first Farming quest will earn `21 Growtoken``. Every Farming quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Farming Day``!|left|\nadd_smalltext|`$- Every Farming quest will also earn 25% extra points.|left|") : (rolequest_day == 0 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Jack of All Trades Day``!|left|1486|\nadd_smalltext|`$- Your first Farming quest will earn `21 Growtoken``. Every Farming quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Jack of All Trades Day``!|left|\nadd_smalltext|`$- Every Farming quest will also earn 25% extra points.|left|") : "")) + a + "\nadd_smalltext|`$- Completing this Quest will earn you: " + Set_Count(Role_Quest::Farmer::Point(pInfo(peer)->t_lvl)) + " `6Farming Points!|left|") + (pInfo(peer)->total_quest_selected != 0 and pInfo(peer)->total_quest_selected != 10 ? "\nadd_smalltext|`$- Starting this Quest now will cost: `4" + Set_Count(Role_Quest::CostPerDay(pInfo(peer)->total_quest_selected)) + " Gems|left|" : "") + "\nadd_smalltext|`$- Gives 20 Grow Pass Points.|left|\nadd_spacer|small|\nadd_smalltext|`$Your current specialization track is: `2" + pInfo(peer)->specialization_track + "|left|\nadd_button|Choosequest_selected|`$Choose a Different Category|0|0|\nadd_button|backto_viewrole|`$Back|0|0|\nadd_quick_exit|\nend_dialog|Role_Quest|||");
				/*Builder*/
				else if (pInfo(peer)->specialization_track == "Builder" and pInfo(peer)->role_quest_type == "") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Role Quest|left|982|\nadd_spacer|small|\nadd_textbox|`9Select a Role Quest to advance your speciality!|left|\nadd_spacer|small|\nadd_smalltext|`$- You have ambarked on " + to_string(pInfo(peer)->total_quest_selected) + " Role Quests today!|left|\nadd_smalltext|`$- Your quest will reset in : " + Time::Playmod(pInfo(peer)->rolequest_reset_day - time_) + " and any progress on the current quest will be lost.|left|" + (pInfo(peer)->total_quest_selected == 0 ? "\nadd_smalltext|`$- You haven't started Role Quests today!|left|\nadd_smalltext|`$- Your first quest for the day is `2FREE ``to start!|left|" : "") + "\nadd_spacer|small|" + (pInfo(peer)->bb_lvl == 10 ? "\nadd_progress_bar|`$Builder``|big|`wLevel: Mastered!||-1||\nadd_spacer|small|" : "\nadd_player_info|`$Builder``|" + to_string(pInfo(peer)->bb_lvl) + "|" + to_string(pInfo(peer)->bb_xp) + "|" + to_string(Role_Quest::Builder::Xp(pInfo(peer)->bb_lvl)) + "|") + "\nadd_spacer|small|" + a + (pInfo(peer)->total_quest_selected < 10 ? "\nadd_button|start_rolequest_builder|`$Start Builder Quest|0|0|" : "\nadd_smalltext|`$- You have reached your maximum limit today!|left|") + (pInfo(peer)->bb_lvl == 10 ? (rolequest_day == 3 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Builder Day``!|left|1486|\nadd_smalltext|`$- Your first Builder quest will earn `21 Growtoken``. Every Builder quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Builder Day``!|left|\nadd_smalltext|`$- Every Builder quest will also earn 25% extra points.|left|") : (rolequest_day == 0 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Jack of All Trades Day``!|left|1486|\nadd_smalltext|`$- Your first Builder quest will earn `21 Growtoken``. Every Builder quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Jack of All Trades Day``!|left|\nadd_smalltext|`$- Every Builder quest will also earn 25% extra points.|left|") : "")) : (rolequest_day == 3 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Builder Day``!|left|1486|\nadd_smalltext|`$- Your first Builder quest will earn `21 Growtoken``. Every Builder quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Builder Day``!|left|\nadd_smalltext|`$- Every Builder quest will also earn 25% extra points.|left|") : (rolequest_day == 0 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Jack of All Trades Day``!|left|1486|\nadd_smalltext|`$- Your first Builder quest will earn `21 Growtoken``. Every Builder quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Jack of All Trades Day``!|left|\nadd_smalltext|`$- Every Builder quest will also earn 25% extra points.|left|") : "")) + a + "\nadd_smalltext|`$- Completing this Quest will earn you: " + Set_Count(Role_Quest::Builder::Point(pInfo(peer)->bb_lvl)) + " `6Builder Points!|left|") + (pInfo(peer)->total_quest_selected != 0 and pInfo(peer)->total_quest_selected != 10 ? "\nadd_smalltext|`$- Starting this Quest now will cost: `4" + Set_Count(Role_Quest::CostPerDay_2(pInfo(peer)->total_quest_selected)) + " Gems|left|" : "") + "\nadd_smalltext|`$- Gives 20 Grow Pass Points.|left|\nadd_spacer|small|\nadd_smalltext|`$Your current specialization track is: `2" + pInfo(peer)->specialization_track + "|left|\nadd_button|Choosequest_selected|`$Choose a Different Category|0|0|\nadd_button|backto_viewrole|`$Back|0|0|\nadd_quick_exit|\nend_dialog|Role_Quest|||");
				/*Surgeon*/
				else if (pInfo(peer)->specialization_track == "Surgeon" and pInfo(peer)->role_quest_type == "") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Role Quest|left|982|\nadd_spacer|small|\nadd_textbox|`9Select a Role Quest to advance your speciality!|left|\nadd_spacer|small|\nadd_smalltext|`$- You have ambarked on " + to_string(pInfo(peer)->total_quest_selected) + " Role Quests today!|left|\nadd_smalltext|`$- Your quest will reset in : " + Time::Playmod(pInfo(peer)->rolequest_reset_day - time_) + " and any progress on the current quest will be lost.|left|" + (pInfo(peer)->total_quest_selected == 0 ? "\nadd_smalltext|`$- You haven't started Role Quests today!|left|\nadd_smalltext|`$- Your first quest for the day is `2FREE ``to start!|left|" : "") + "\nadd_spacer|small|" + (pInfo(peer)->s_lvl == 10 ? "\nadd_progress_bar|`$Surgeon``|big|`wLevel: Mastered!||-1||\nadd_spacer|small|" : "\nadd_player_info|`$Surgeon``|" + to_string(pInfo(peer)->s_lvl) + "|" + to_string(pInfo(peer)->s_xp) + "|" + to_string(Role_Quest::Surgeon::Xp(pInfo(peer)->s_lvl)) + "|") + "\nadd_spacer|small|" + a + (pInfo(peer)->total_quest_selected < 10 ? "\nadd_button|start_rolequest_surgeon|`$Start Surgeon Quest|0|0|" : "\nadd_smalltext|`$- You have reached your maximum limit today!|left|") + (pInfo(peer)->s_lvl == 10 ? (rolequest_day == 4 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Surgery Day``!|left|1486|\nadd_smalltext|`$- Your first Surgery quest will earn `21 Growtoken``. Every Surgery quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Surgery Day``!|left|\nadd_smalltext|`$- Every Surgery quest will also earn 25% extra points.|left|") : (rolequest_day == 0 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Jack of All Trades Day``!|left|1486|\nadd_smalltext|`$- Your first Surgery quest will earn `21 Growtoken``. Every Surgery quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Jack of All Trades Day``!|left|\nadd_smalltext|`$- Every Surgery quest will also earn 25% extra points.|left|") : "")) : (rolequest_day == 4 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Surgery Day``!|left|1486|\nadd_smalltext|`$- Your first Surgery quest will earn `21 Growtoken``. Every Surgery quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Surgery Day``!|left|\nadd_smalltext|`$- Every Surgery quest will also earn 25% extra points.|left|") : (rolequest_day == 0 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Jack of All Trades Day``!|left|1486|\nadd_smalltext|`$- Your first Surgery quest will earn `21 Growtoken``. Every Surgery quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Jack of All Trades Day``!|left|\nadd_smalltext|`$- Every Surgery quest will also earn 25% extra points.|left|") : "")) + a + "\nadd_smalltext|`$- Completing this Quest will earn you: " + Set_Count(Role_Quest::Surgeon::Point(pInfo(peer)->s_lvl)) + " `6Surgery Points!|left|") + (pInfo(peer)->total_quest_selected != 0 and pInfo(peer)->total_quest_selected != 10 ? "\nadd_smalltext|`$- Starting this Quest now will cost: `4" + Set_Count(Role_Quest::CostPerDay(pInfo(peer)->total_quest_selected)) + " Gems|left|" : "") + "\nadd_smalltext|`$- Gives 20 Grow Pass Points.|left|\nadd_spacer|small|\nadd_smalltext|`$Your current specialization track is: `2" + pInfo(peer)->specialization_track + "|left|\nadd_button|Choosequest_selected|`$Choose a Different Category|0|0|\nadd_button|backto_viewrole|`$Back|0|0|\nadd_quick_exit|\nend_dialog|Role_Quest|||");
				/*Fishing*/
				else if (pInfo(peer)->specialization_track == "Fishing" and pInfo(peer)->role_quest_type == "") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Role Quest|left|982|\nadd_spacer|small|\nadd_textbox|`9Select a Role Quest to advance your speciality!|left|\nadd_spacer|small|\nadd_smalltext|`$- You have ambarked on " + to_string(pInfo(peer)->total_quest_selected) + " Role Quests today!|left|\nadd_smalltext|`$- Your quest will reset in : " + Time::Playmod(pInfo(peer)->rolequest_reset_day - time_) + " and any progress on the current quest will be lost.|left|" + (pInfo(peer)->total_quest_selected == 0 ? "\nadd_smalltext|`$- You haven't started Role Quests today!|left|\nadd_smalltext|`$- Your first quest for the day is `2FREE ``to start!|left|" : "") + "\nadd_spacer|small|" + (pInfo(peer)->ff_lvl == 10 ? "\nadd_progress_bar|`$Fishing``|big|`wLevel: Mastered!||-1||\nadd_spacer|small|" : "\nadd_player_info|`$Fishing``|" + to_string(pInfo(peer)->ff_lvl) + "|" + to_string(pInfo(peer)->ff_xp) + "|" + to_string(Role_Quest::Fishing::Xp(pInfo(peer)->ff_lvl)) + "|") + "\nadd_spacer|small|" + a + (pInfo(peer)->total_quest_selected < 10 ? "\nadd_button|start_rolequest_fishing|`$Start Fishing Quest|0|0|" : "\nadd_smalltext|`$- You have reached your maximum limit today!|left|") + (pInfo(peer)->ff_lvl == 10 ? (rolequest_day == 1 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Fishing Day``!|left|1486|\nadd_smalltext|`$- Your first Fishing quest will earn `21 Growtoken``. Every Fishing quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Fishing Day``!|left|\nadd_smalltext|`$- Every Fishing quest will also earn 25% extra points.|left|") : (rolequest_day == 0 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Jack of All Trades Day``!|left|1486|\nadd_smalltext|`$- Your first Fishing quest will earn `21 Growtoken``. Every Fishing quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Jack of All Trades Day``!|left|\nadd_smalltext|`$- Every Fishing quest will also earn 25% extra points.|left|") : "")) : (rolequest_day == 1 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Fishing Day``!|left|1486|\nadd_smalltext|`$- Your first Fishing quest will earn `21 Growtoken``. Every Fishing quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Fishing Day``!|left|\nadd_smalltext|`$- Every Fishing quest will also earn 25% extra points.|left|") : (rolequest_day == 0 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Jack of All Trades Day``!|left|1486|\nadd_smalltext|`$- Your first Fishing quest will earn `21 Growtoken``. Every Fishing quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Jack of All Trades Day``!|left|\nadd_smalltext|`$- Every Fishing quest will also earn 25% extra points.|left|") : "")) + a + "\nadd_smalltext|`$- Completing this Quest will earn you: " + Set_Count(Role_Quest::Fishing::Point(pInfo(peer)->ff_lvl)) + " `6Fishing Points!|left|") + (pInfo(peer)->total_quest_selected != 0 and pInfo(peer)->total_quest_selected != 10 ? "\nadd_smalltext|`$- Starting this Quest now will cost: `4" + Set_Count(Role_Quest::CostPerDay(pInfo(peer)->total_quest_selected)) + " Gems|left|" : "") + "\nadd_smalltext|`$- Gives 20 Grow Pass Points.|left|\nadd_spacer|small|\nadd_smalltext|`$Your current specialization track is: `2" + pInfo(peer)->specialization_track + "|left|\nadd_button|Choosequest_selected|`$Choose a Different Category|0|0|\nadd_button|backto_viewrole|`$Back|0|0|\nadd_quick_exit|\nend_dialog|Role_Quest|||");
				/*Provider*/
				else if (pInfo(peer)->specialization_track == "Provider" and pInfo(peer)->role_quest_type == "") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Role Quest|left|982|\nadd_spacer|small|\nadd_textbox|`9Select a Role Quest to advance your speciality!|left|\nadd_spacer|small|\nadd_smalltext|`$- You have ambarked on " + to_string(pInfo(peer)->total_quest_selected) + " Role Quests today!|left|\nadd_smalltext|`$- Your quest will reset in : " + Time::Playmod(pInfo(peer)->rolequest_reset_day - time_) + " and any progress on the current quest will be lost.|left|" + (pInfo(peer)->total_quest_selected == 0 ? "\nadd_smalltext|`$- You haven't started Role Quests today!|left|\nadd_smalltext|`$- Your first quest for the day is `2FREE ``to start!|left|" : "") + "\nadd_spacer|small|" + (pInfo(peer)->p_lvl == 10 ? "\nadd_progress_bar|`$Provider``|big|`wLevel: Mastered!||-1||\nadd_spacer|small|" : "\nadd_player_info|`$Provider``|" + to_string(pInfo(peer)->p_lvl) + "|" + to_string(pInfo(peer)->t_xp) + "|" + to_string(Role_Quest::Provider::Xp(pInfo(peer)->p_lvl)) + "|") + "\nadd_spacer|small|" + a + (pInfo(peer)->total_quest_selected < 10 ? "\nadd_button|start_rolequest_provider|`$Start Provider Quest|0|0|" : "\nadd_smalltext|`$- You have reached your maximum limit today!|left|") + (pInfo(peer)->p_lvl == 10 ? (rolequest_day == 6 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Provider Day``!|left|1486|\nadd_smalltext|`$- Your first Provider quest will earn `21 Growtoken``. Every Provider quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Provider Day``!|left|\nadd_smalltext|`$- Every Provider quest will also earn 25% extra points.|left|") : (rolequest_day == 0 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Jack of All Trades Day``!|left|1486|\nadd_smalltext|`$- Your first Provider quest will earn `21 Growtoken``. Every Provider quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Jack of All Trades Day``!|left|\nadd_smalltext|`$- Every Provider quest will also earn 25% extra points.|left|") : "")) : (rolequest_day == 6 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Provider Day``!|left|1486|\nadd_smalltext|`$- Your first Provider quest will earn `21 Growtoken``. Every Provider quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Provider Day``!|left|\nadd_smalltext|`$- Every Provider quest will also earn 25% extra points.|left|") : (rolequest_day == 0 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Jack of All Trades Day``!|left|1486|\nadd_smalltext|`$- Your first Provider quest will earn `21 Growtoken``. Every Provider quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Jack of All Trades Day``!|left|\nadd_smalltext|`$- Every Provider quest will also earn 25% extra points.|left|") : "")) + a + "\nadd_smalltext|`$- Completing this Quest will earn you: " + Set_Count(Role_Quest::Provider::Point(pInfo(peer)->p_lvl)) + " `6Provider Points!|left|") + "\nadd_smalltext|`$- Gives 20 Grow Pass Points.|left|\nadd_spacer|small|\nadd_smalltext|`$Your current specialization track is: `2" + pInfo(peer)->specialization_track + "|left|\nadd_button|Choosequest_selected|`$Choose a Different Category|0|0|\nadd_button|backto_viewrole|`$Back|0|0|\nadd_quick_exit|\nend_dialog|Role_Quest|||");
				/*Geiger*/
				else if (pInfo(peer)->specialization_track == "Geiger" and pInfo(peer)->role_quest_type == "") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Role Quest|left|982|\nadd_spacer|small|\nadd_textbox|`9Select a Role Quest to advance your speciality!|left|\nadd_spacer|small|\nadd_smalltext|`$- You have ambarked on " + to_string(pInfo(peer)->total_quest_selected) + " Role Quests today!|left|\nadd_smalltext|`$- Your quest will reset in : " + Time::Playmod(pInfo(peer)->rolequest_reset_day - time_) + " and any progress on the current quest will be lost.|left|" + (pInfo(peer)->total_quest_selected == 0 ? "\nadd_smalltext|`$- You haven't started Role Quests today!|left|\nadd_smalltext|`$- Your first quest for the day is `2FREE ``to start!|left|" : "") + "\nadd_spacer|small|" + (pInfo(peer)->g_lvl == 10 ? "\nadd_progress_bar|`$Geiger``|big|`wLevel: Mastered!||-1||\nadd_spacer|small|" : "\nadd_player_info|`$Geiger``|" + to_string(pInfo(peer)->g_lvl) + "|" + to_string(pInfo(peer)->g_xp) + "|" + to_string(Role_Quest::Geiger::Xp(pInfo(peer)->g_lvl)) + "|") + "\nadd_spacer|small|" + a + (pInfo(peer)->total_quest_selected < 10 ? "\nadd_button|start_rolequest_geiger|`$Start Geiger Quest|0|0|" : "\nadd_smalltext|`$- You have reached your maximum limit today!|left|") + (pInfo(peer)->g_lvl == 10 ? (rolequest_day == 5 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Geiger Day``!|left|1486|\nadd_smalltext|`$- Your first Geiger quest will earn `21 Growtoken``. Every Geiger quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Geiger Day``!|left|\nadd_smalltext|`$- Every Geiger quest will also earn 25% extra points.|left|") : (rolequest_day == 0 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Jack of All Trades Day``!|left|1486|\nadd_smalltext|`$- Your first Geiger quest will earn `21 Growtoken``. Every Geiger quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Jack of All Trades Day``!|left|\nadd_smalltext|`$- Every Geiger quest will also earn 25% extra points.|left|") : "")) : (rolequest_day == 5 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Geiger Day``!|left|1486|\nadd_smalltext|`$- Your first Geiger quest will earn `21 Growtoken``. Every Geiger quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Geiger Day``!|left|\nadd_smalltext|`$- Every Geiger quest will also earn 25% extra points.|left|") : (rolequest_day == 0 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Jack of All Trades Day``!|left|1486|\nadd_smalltext|`$- Your first Geiger quest will earn `21 Growtoken``. Every Geiger quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Jack of All Trades Day``!|left|\nadd_smalltext|`$- Every Geiger quest will also earn 25% extra points.|left|") : "")) + a + "\nadd_smalltext|`$- Completing this Quest will earn you: " + Set_Count(Role_Quest::Geiger::Point(pInfo(peer)->g_lvl)) + " `6Geiger Points!|left|") + (pInfo(peer)->total_quest_selected != 0 and pInfo(peer)->total_quest_selected != 10 ? "\nadd_smalltext|`$- Starting this Quest now will cost: `4" + Set_Count(Role_Quest::CostPerDay(pInfo(peer)->total_quest_selected)) + " Gems|left|" : "") + "\nadd_smalltext|`$- Gives 20 Grow Pass Points.|left|\nadd_spacer|small|\nadd_smalltext|`$Your current specialization track is: `2" + pInfo(peer)->specialization_track + "|left|\nadd_button|Choosequest_selected|`$Choose a Different Category|0|0|\nadd_button|backto_viewrole|`$Back|0|0|\nadd_quick_exit|\nend_dialog|Role_Quest|||");
				else VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Role Quest|left|982|\nadd_spacer|small|\nadd_textbox|`9Select a Role Quest to advance your speciality!|left|\nadd_spacer|small|\nadd_smalltext|`$- You have ambarked on " + to_string(pInfo(peer)->total_quest_selected) + " Role Quests today!|left|\nadd_smalltext|`$- Your quest will reset in : " + Time::Playmod(pInfo(peer)->rolequest_reset_day - time_) + " and any progress on the current quest will be lost.|left|" + (pInfo(peer)->total_quest_selected == 0 ? "\nadd_smalltext|`$- You haven't started Role Quests today!|left|\nadd_smalltext|`$- Your first quest for the day is `2FREE ``to start!|left|" : "") + "\nadd_spacer|small|" + (pInfo(peer)->t_lvl == 10 ? "\nadd_progress_bar|`$Farmer``|big|`wLevel: Mastered!||-1||\nadd_spacer|small|" : "\nadd_player_info|`$Farmer``|" + to_string(pInfo(peer)->t_lvl) + "|" + to_string(pInfo(peer)->t_xp) + "|" + to_string(Role_Quest::Farmer::Xp(pInfo(peer)->t_lvl)) + "|") + "\nadd_spacer|small|" + a + (pInfo(peer)->total_quest_selected < 10 ? "\nadd_button|start_rolequest_farmer|`$Start Farmer Quest|0|0|" : "\nadd_smalltext|`$- You have reached your maximum limit today!|left|") + (pInfo(peer)->t_lvl == 10 ? (rolequest_day == 2 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Farming Day``!|left|1486|\nadd_smalltext|`$- Your first Farming quest will earn `21 Growtoken``. Every Farming quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Farming Day``!|left|\nadd_smalltext|`$- Every Farming quest will also earn 25% extra points.|left|") : (rolequest_day == 0 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Jack of All Trades Day``!|left|1486|\nadd_smalltext|`$- Your first Farming quest will earn `21 Growtoken``. Every Farming quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Jack of All Trades Day``!|left|\nadd_smalltext|`$- Every Farming quest will also earn 25% extra points.|left|") : "")) : (rolequest_day == 2 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Farming Day``!|left|1486|\nadd_smalltext|`$- Your first Farming quest will earn `21 Growtoken``. Every Farming quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Farming Day``!|left|\nadd_smalltext|`$- Every Farming quest will also earn 25% extra points.|left|") : (rolequest_day == 0 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Jack of All Trades Day``!|left|1486|\nadd_smalltext|`$- Your first Farming quest will earn `21 Growtoken``. Every Farming quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Jack of All Trades Day``!|left|\nadd_smalltext|`$- Every Farming quest will also earn 25% extra points.|left|") : "")) + a + "\nadd_smalltext|`$- Completing this Quest will earn you: " + Set_Count(Role_Quest::Farmer::Point(pInfo(peer)->t_lvl)) + " `6Farming Points!|left|") + "\nadd_smalltext|`$- Gives 20 Grow Pass Points.|left|\nadd_spacer|small|" + (pInfo(peer)->bb_lvl == 10 ? "\nadd_progress_bar|`$Builder``|big|`wLevel: Mastered!||-1||\nadd_spacer|small|" : "\nadd_player_info|`$Builder``|" + to_string(pInfo(peer)->bb_lvl) + "|" + to_string(pInfo(peer)->bb_xp) + "|" + to_string(Role_Quest::Builder::Xp(pInfo(peer)->bb_lvl)) + "|") + "\nadd_spacer|small|" + a + (pInfo(peer)->total_quest_selected < 10 ? "\nadd_button|start_rolequest_builder|`$Start Builder Quest|0|0|" : "\nadd_smalltext|`$- You have reached your maximum limit today!|left|") + (pInfo(peer)->bb_lvl == 10 ? (rolequest_day == 3 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Builder Day``!|left|1486|\nadd_smalltext|`$- Your first Builder quest will earn `21 Growtoken``. Every Builder quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Builder Day``!|left|\nadd_smalltext|`$- Every Builder quest will also earn 25% extra points.|left|") : (rolequest_day == 0 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Jack of All Trades Day``!|left|1486|\nadd_smalltext|`$- Your first Builder quest will earn `21 Growtoken``. Every Builder quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Jack of All Trades Day``!|left|\nadd_smalltext|`$- Every Builder quest will also earn 25% extra points.|left|") : "")) : (rolequest_day == 3 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Builder Day``!|left|1486|\nadd_smalltext|`$- Your first Builder quest will earn `21 Growtoken``. Every Builder quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Builder Day``!|left|\nadd_smalltext|`$- Every Builder quest will also earn 25% extra points.|left|") : (rolequest_day == 0 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Jack of All Trades Day``!|left|1486|\nadd_smalltext|`$- Your first Builder quest will earn `21 Growtoken``. Every Builder quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Jack of All Trades Day``!|left|\nadd_smalltext|`$- Every Builder quest will also earn 25% extra points.|left|") : "")) + a + "\nadd_smalltext|`$- Completing this Quest will earn you: " + Set_Count(Role_Quest::Builder::Point(pInfo(peer)->bb_lvl)) + " `6Builder Points!|left|") + "\nadd_smalltext|`$- Gives 20 Grow Pass Points.|left|\nadd_spacer|small|" + (pInfo(peer)->s_lvl == 10 ? "\nadd_progress_bar|`$Surgeon``|big|`wLevel: Mastered!||-1||\nadd_spacer|small|" : "\nadd_player_info|`$Surgeon``|" + to_string(pInfo(peer)->s_lvl) + "|" + to_string(pInfo(peer)->s_xp) + "|" + to_string(Role_Quest::Surgeon::Xp(pInfo(peer)->s_lvl)) + "|") + "\nadd_spacer|small|" + a + (pInfo(peer)->total_quest_selected < 10 ? "\nadd_button|start_rolequest_surgeon|`$Start Surgeon Quest|0|0|" : "\nadd_smalltext|`$- You have reached your maximum limit today!|left|") + (pInfo(peer)->s_lvl == 10 ? (rolequest_day == 4 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Surgery Day``!|left|1486|\nadd_smalltext|`$- Your first Surgery quest will earn `21 Growtoken``. Every Surgery quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Surgery Day``!|left|\nadd_smalltext|`$- Every Surgery quest will also earn 25% extra points.|left|") : (rolequest_day == 0 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Jack of All Trades Day``!|left|1486|\nadd_smalltext|`$- Your first Surgery quest will earn `21 Growtoken``. Every Builder quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Jack of All Trades Day``!|left|\nadd_smalltext|`$- Every Surgery quest will also earn 25% extra points.|left|") : "")) : (rolequest_day == 4 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Surgery Day``!|left|1486|\nadd_smalltext|`$- Your first Surgery quest will earn `21 Growtoken``. Every Surgery quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Surgery Day``!|left|\nadd_smalltext|`$- Every Surgery quest will also earn 25% extra points.|left|") : (rolequest_day == 0 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Jack of All Trades Day``!|left|1486|\nadd_smalltext|`$- Your first Surgery quest will earn `21 Growtoken``. Every Builder quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Jack of All Trades Day``!|left|\nadd_smalltext|`$- Every Surgery quest will also earn 25% extra points.|left|") : "")) + a + "\nadd_smalltext|`$- Completing this Quest will earn you: " + Set_Count(Role_Quest::Surgeon::Point(pInfo(peer)->s_lvl)) + " `6Surgery Points!|left|") + "\nadd_smalltext|`$- Gives 20 Grow Pass Points.|left|\nadd_spacer|small|" + (pInfo(peer)->ff_lvl == 10 ? "\nadd_progress_bar|`$Fishing``|big|`wLevel: Mastered!||-1||\nadd_spacer|small|" : "\nadd_player_info|`$Fishing``|" + to_string(pInfo(peer)->ff_lvl) + "|" + to_string(pInfo(peer)->ff_xp) + "|" + to_string(Role_Quest::Fishing::Xp(pInfo(peer)->ff_lvl)) + "|") + "\nadd_spacer|small|" + a + (pInfo(peer)->total_quest_selected < 10 ? "\nadd_button|start_rolequest_fishing|`$Start Fishing Quest|0|0|" : "\nadd_smalltext|`$- You have reached your maximum limit today!|left|") + (pInfo(peer)->ff_lvl == 10 ? (rolequest_day == 1 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Fishing Day``!|left|1486|\nadd_smalltext|`$- Your first Fishing quest will earn `21 Growtoken``. Every Fishing quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Fishing Day``!|left|\nadd_smalltext|`$- Every Fishing quest will also earn 25% extra points.|left|") : (rolequest_day == 0 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Jack of All Trades Day``!|left|1486|\nadd_smalltext|`$- Your first Fishing quest will earn `21 Growtoken``. Every Fishing quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Jack of All Trades Day``!|left|\nadd_smalltext|`$- Every Fishing quest will also earn 25% extra points.|left|") : "")) : (rolequest_day == 1 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Fishing Day``!|left|1486|\nadd_smalltext|`$- Your first Fishing quest will earn `21 Growtoken``. Every Fishing quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Fishing Day``!|left|\nadd_smalltext|`$- Every Fishing quest will also earn 25% extra points.|left|") : (rolequest_day == 0 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Jack of All Trades Day``!|left|1486|\nadd_smalltext|`$- Your first Fishing quest will earn `21 Growtoken``. Every Fishing quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Jack of All Trades Day``!|left|\nadd_smalltext|`$- Every Fishing quest will also earn 25% extra points.|left|") : "")) + a + "\nadd_smalltext|`$- Completing this Quest will earn you: " + Set_Count(Role_Quest::Fishing::Point(pInfo(peer)->ff_lvl)) + " `6Fishing Points!|left|") + "\nadd_smalltext|`$- Gives 20 Grow Pass Points.|left|\nadd_spacer|small|" + (pInfo(peer)->p_lvl == 10 ? "\nadd_progress_bar|`$Provider``|big|`wLevel: Mastered!||-1||\nadd_spacer|small|" : "\nadd_player_info|`$Provider``|" + to_string(pInfo(peer)->p_lvl) + "|" + to_string(pInfo(peer)->t_xp) + "|" + to_string(Role_Quest::Provider::Xp(pInfo(peer)->p_lvl)) + "|") + "\nadd_spacer|small|" + a + (pInfo(peer)->total_quest_selected < 10 ? "\nadd_button|start_rolequest_provider|`$Start Provider Quest|0|0|" : "\nadd_smalltext|`$- You have reached your maximum limit today!|left|") + (pInfo(peer)->p_lvl == 10 ? (rolequest_day == 6 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Provider Day``!|left|1486|\nadd_smalltext|`$- Your first Provider quest will earn `21 Growtoken``. Every Provider quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Provider Day``!|left|\nadd_smalltext|`$- Every Provider quest will also earn 25% extra points.|left|") : (rolequest_day == 0 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Jack of All Trades Day``!|left|1486|\nadd_smalltext|`$- Your first Provider quest will earn `21 Growtoken``. Every Provider quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Jack of All Trades Day``!|left|\nadd_smalltext|`$- Every Provider quest will also earn 25% extra points.|left|") : "")) : (rolequest_day == 6 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Provider Day``!|left|1486|\nadd_smalltext|`$- Your first Provider quest will earn `21 Growtoken``. Every Provider quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Provider Day``!|left|\nadd_smalltext|`$- Every Provider quest will also earn 25% extra points.|left|") : (rolequest_day == 0 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Jack of All Trades Day``!|left|1486|\nadd_smalltext|`$- Your first Provider quest will earn `21 Growtoken``. Every Provider quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Jack of All Trades Day``!|left|\nadd_smalltext|`$- Every Provider quest will also earn 25% extra points.|left|") : "")) + a + "\nadd_smalltext|`$- Completing this Quest will earn you: " + Set_Count(Role_Quest::Provider::Point(pInfo(peer)->p_lvl)) + " `6Provider Points!|left|") + "\nadd_smalltext|`$- Gives 20 Grow Pass Points.|left|\nadd_spacer|small|" + (pInfo(peer)->g_lvl == 10 ? "\nadd_progress_bar|`$Geiger``|big|`wLevel: Mastered!||-1||\nadd_spacer|small|" : "\nadd_player_info|`$Geiger``|" + to_string(pInfo(peer)->g_lvl) + "|" + to_string(pInfo(peer)->g_xp) + "|" + to_string(Role_Quest::Geiger::Xp(pInfo(peer)->g_lvl)) + "|") + "\nadd_spacer|small|" + a + (pInfo(peer)->total_quest_selected < 10 ? "\nadd_button|start_rolequest_geiger|`$Start Geiger Quest|0|0|" : "\nadd_smalltext|`$- You have reached your maximum limit today!|left|") + (pInfo(peer)->g_lvl == 10 ? (rolequest_day == 5 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Geiger Day``!|left|1486|\nadd_smalltext|`$- Your first Geiger quest will earn `21 Growtoken``. Every Geiger quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Geiger Day``!|left|\nadd_smalltext|`$- Every Geiger quest will also earn 25% extra points.|left|") : (rolequest_day == 0 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Jack of All Trades Day``!|left|1486|\nadd_smalltext|`$- Your first Geiger quest will earn `21 Growtoken``. Every Geiger quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Jack of All Trades Day``!|left|\nadd_smalltext|`$- Every Geiger quest will also earn 25% extra points.|left|") : "")) : (rolequest_day == 5 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Geiger Day``!|left|1486|\nadd_smalltext|`$- Your first Geiger quest will earn `21 Growtoken``. Every Geiger quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Geiger Day``!|left|\nadd_smalltext|`$- Every Geiger quest will also earn 25% extra points.|left|") : (rolequest_day == 0 ? (not pInfo(peer)->complete_rolequest_day ? "\nadd_label_with_icon|small|`$Today is `2Jack of All Trades Day``!|left|1486|\nadd_smalltext|`$- Your first Geiger quest will earn `21 Growtoken``. Every Geiger quest will also earn 25% extra points.|left|" : "\nadd_label|small|`$Today is `2Jack of All Trades Day``!|left|\nadd_smalltext|`$- Every Geiger quest will also earn 25% extra points.|left|") : "")) + a + "\nadd_smalltext|`$- Completing this Quest will earn you: " + Set_Count(Role_Quest::Geiger::Point(pInfo(peer)->g_lvl)) + " `6Geiger Points!|left|") + "\nadd_smalltext|`$- Gives 20 Grow Pass Points.|left|\nadd_spacer|small|\nadd_button|backto_viewrole|`$Back|0|0|\nend_dialog|Role_Quest|||\nadd_quick_exit|");
			}
			else if (button == "start_rolequest_farmer") {
				long long time_ = time(nullptr);
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Start Farmer Quest?|left|7064|\nadd_spacer|small|\nadd_smalltext|`$Are you sure you want to begin this `9Farmer Quest``?|left|" + a + (pInfo(peer)->total_quest_selected == 0 ? "\nadd_smalltext|`$- You haven't started Role Quests today!|left|\nadd_smalltext|`$- Your first quest for the day is `2FREE ``to start!|left|" : "") + a + (pInfo(peer)->total_quest_selected != 0 ? "\nadd_smalltext|`$Starting this quest will costs:|left|\nadd_label_with_icon|small|`4" + Set_Count(Role_Quest::CostPerDay(pInfo(peer)->total_quest_selected)) + " Gems|left|112|" : "") + "\nadd_smalltext|`$- You have: `9" + Time::Playmod(pInfo(peer)->rolequest_reset_day - time_) + " ``to complete this quest before it resets!|left|\nadd_button|yes_start_farmer|`$Start Farmer Quest|0|0|\nadd_button|backto_selectedquest|`$Back|0|0|\nend_dialog|Role_Quest|||");
			}
			else if (button == "yes_start_farmer") {
				if (pInfo(peer)->total_quest_selected == 10) return;
				if (pInfo(peer)->total_quest_selected != 0) {
					if (pInfo(peer)->gems >= Role_Quest::CostPerDay(pInfo(peer)->total_quest_selected)) {
						VarList::OnMinGems(peer, Role_Quest::CostPerDay(pInfo(peer)->total_quest_selected));
						Role_Quest::Get_Random_Quest(peer, "Farmer");
						Role_Quest::Dialog(peer);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough gems to start this quest!", 0, 1);
				}
				else {
					Role_Quest::Get_Random_Quest(peer, "Farmer");
					Role_Quest::Dialog(peer);
				}
			}
			else if (button == "start_rolequest_builder") {
				long long time_ = time(nullptr);
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Start Builder Quest?|left|7070|\nadd_spacer|small|\nadd_smalltext|`$Are you sure you want to begin this `9Builder Quest``?|left|" + a + (pInfo(peer)->total_quest_selected == 0 ? "\nadd_smalltext|`$- You haven't started Role Quests today!|left|\nadd_smalltext|`$- Your first quest for the day is `2FREE ``to start!|left|" : "") + a + (pInfo(peer)->total_quest_selected != 0 ? "\nadd_smalltext|`$Starting this quest will costs:|left|\nadd_label_with_icon|small|`4" + Set_Count(Role_Quest::CostPerDay_2(pInfo(peer)->total_quest_selected)) + " Gems|left|112|" : "") + "\nadd_smalltext|`$- You have: `9" + Time::Playmod(pInfo(peer)->rolequest_reset_day - time_) + " ``to complete this quest before it resets!|left|\nadd_button|yes_start_builder|`$Start Builder Quest|0|0|\nadd_button|backto_selectedquest|`$Back|0|0|\nend_dialog|Role_Quest|||");
			}
			else if (button == "yes_start_builder") {
				if (pInfo(peer)->total_quest_selected == 10) return;
				if (pInfo(peer)->total_quest_selected != 0) {
					if (pInfo(peer)->gems >= Role_Quest::CostPerDay_2(pInfo(peer)->total_quest_selected)) {
						VarList::OnMinGems(peer, Role_Quest::CostPerDay_2(pInfo(peer)->total_quest_selected));
						Role_Quest::Get_Random_Quest(peer, "Builder");
						Role_Quest::Dialog(peer);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough gems to start this quest!", 0, 1);
				}
				else {
					Role_Quest::Get_Random_Quest(peer, "Builder");
					Role_Quest::Dialog(peer);
				}
			}
			else if (button == "start_rolequest_surgeon") {
				long long time_ = time(nullptr);
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Start Surgeon Quest?|left|7068|\nadd_spacer|small|\nadd_smalltext|`$Are you sure you want to begin this `9Surgeon Quest``?|left|" + a + (pInfo(peer)->total_quest_selected == 0 ? "\nadd_smalltext|`$- You haven't started Role Quests today!|left|\nadd_smalltext|`$- Your first quest for the day is `2FREE ``to start!|left|" : "") + a + (pInfo(peer)->total_quest_selected != 0 ? "\nadd_smalltext|`$Starting this quest will costs:|left|\nadd_label_with_icon|small|`4" + Set_Count(Role_Quest::CostPerDay(pInfo(peer)->total_quest_selected)) + " Gems|left|112|" : "") + "\nadd_smalltext|`$- You have: `9" + Time::Playmod(pInfo(peer)->rolequest_reset_day - time_) + " ``to complete this quest before it resets!|left|\nadd_button|yes_start_surgeon|`$Start Surgeon Quest|0|0|\nadd_button|backto_selectedquest|`$Back|0|0|\nend_dialog|Role_Quest|||");
			}
			else if (button == "yes_start_surgeon") {
				if (pInfo(peer)->total_quest_selected == 10) return;
				if (pInfo(peer)->total_quest_selected != 0) {
					if (pInfo(peer)->gems >= Role_Quest::CostPerDay(pInfo(peer)->total_quest_selected)) {
						VarList::OnMinGems(peer, Role_Quest::CostPerDay(pInfo(peer)->total_quest_selected));
						Role_Quest::Get_Random_Quest(peer, "Surgeon");
						Role_Quest::Dialog(peer);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough gems to start this quest!", 0, 1);
				}
				else {
					Role_Quest::Get_Random_Quest(peer, "Surgeon");
					Role_Quest::Dialog(peer);
				}
			}
			else if (button == "start_rolequest_fishing") {
				long long time_ = time(nullptr);
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Start Fishing Quest?|left|7072|\nadd_spacer|small|\nadd_smalltext|`$Are you sure you want to begin this `9Fishing Quest``?|left|" + a + (pInfo(peer)->total_quest_selected == 0 ? "\nadd_smalltext|`$- You haven't started Role Quests today!|left|\nadd_smalltext|`$- Your first quest for the day is `2FREE ``to start!|left|" : "") + a + (pInfo(peer)->total_quest_selected != 0 ? "\nadd_smalltext|`$Starting this quest will costs:|left|\nadd_label_with_icon|small|`4" + Set_Count(Role_Quest::CostPerDay(pInfo(peer)->total_quest_selected)) + " Gems|left|112|" : "") + "\nadd_smalltext|`$- You have: `9" + Time::Playmod(pInfo(peer)->rolequest_reset_day - time_) + " ``to complete this quest before it resets!|left|\nadd_button|yes_start_fishing|`$Start Fishing Quest|0|0|\nadd_button|backto_selectedquest|`$Back|0|0|\nend_dialog|Role_Quest|||");
			}
			else if (button == "yes_start_fishing") {
				if (pInfo(peer)->total_quest_selected == 10) return;
				if (pInfo(peer)->total_quest_selected != 0) {
					if (pInfo(peer)->gems >= Role_Quest::CostPerDay(pInfo(peer)->total_quest_selected)) {
						VarList::OnMinGems(peer, Role_Quest::CostPerDay(pInfo(peer)->total_quest_selected));
						Role_Quest::Get_Random_Quest(peer, "Fishing");
						Role_Quest::Dialog(peer);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough gems to start this quest!", 0, 1);
				}
				else {
					Role_Quest::Get_Random_Quest(peer, "Fishing");
					Role_Quest::Dialog(peer);
				}
			}
			else if (button == "start_rolequest_geiger") {
				long long time_ = time(nullptr);
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Start Geiger Quest?|left|2204|\nadd_spacer|small|\nadd_smalltext|`$Are you sure you want to begin this `9Geiger Quest``?|left|" + a + (pInfo(peer)->total_quest_selected == 0 ? "\nadd_smalltext|`$- You haven't started Role Quests today!|left|\nadd_smalltext|`$- Your first quest for the day is `2FREE ``to start!|left|" : "") + a + (pInfo(peer)->total_quest_selected != 0 ? "\nadd_smalltext|`$Starting this quest will costs:|left|\nadd_label_with_icon|small|`4" + Set_Count(Role_Quest::CostPerDay(pInfo(peer)->total_quest_selected)) + " Gems|left|112|" : "") + "\nadd_smalltext|`$- You have: `9" + Time::Playmod(pInfo(peer)->rolequest_reset_day - time_) + " ``to complete this quest before it resets!|left|\nadd_button|yes_start_geiger|`$Start Geiger Quest|0|0|\nadd_button|backto_selectedquest|`$Back|0|0|\nend_dialog|Role_Quest|||");
			}
			else if (button == "yes_start_geiger") {
				if (pInfo(peer)->total_quest_selected == 10) return;
				if (pInfo(peer)->total_quest_selected != 0) {
					if (pInfo(peer)->gems >= Role_Quest::CostPerDay(pInfo(peer)->total_quest_selected)) {
						VarList::OnMinGems(peer, Role_Quest::CostPerDay(pInfo(peer)->total_quest_selected));
						Role_Quest::Get_Random_Quest(peer, "Geiger");
						Role_Quest::Dialog(peer);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough gems to start this quest!", 0, 1);
				}
				else {
					Role_Quest::Get_Random_Quest(peer, "Geiger");
					Role_Quest::Dialog(peer);
				}
			}
			else if (button == "start_rolequest_provider") {
				long long time_ = time(nullptr);
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Start Provider Quest?|left|928|\nadd_spacer|small|\nadd_smalltext|`$Are you sure you want to begin this `9Provider Quest``?|left|" + a + (pInfo(peer)->total_quest_selected == 0 ? "\nadd_smalltext|`$- You haven't started Role Quests today!|left|\nadd_smalltext|`$- Your first quest for the day is `2FREE ``to start!|left|" : "") + a + (pInfo(peer)->total_quest_selected != 0 ? "\nadd_smalltext|`$Starting this quest will costs:|left|\nadd_label_with_icon|small|`4" + Set_Count(Role_Quest::CostPerDay_2(pInfo(peer)->total_quest_selected)) + " Gems|left|112|" : "") + "\nadd_smalltext|`$- You have: `9" + Time::Playmod(pInfo(peer)->rolequest_reset_day - time_) + " ``to complete this quest before it resets!|left|\nadd_button|yes_start_provider|`$Start Provider Quest|0|0|\nadd_button|backto_selectedquest|`$Back|0|0|\nend_dialog|Role_Quest|||");
			}
			else if (button == "yes_start_provider") {
				if (pInfo(peer)->total_quest_selected == 10) return;
				if (pInfo(peer)->total_quest_selected != 0) {
					if (pInfo(peer)->gems >= Role_Quest::CostPerDay_2(pInfo(peer)->total_quest_selected)) {
						VarList::OnMinGems(peer, Role_Quest::CostPerDay_2(pInfo(peer)->total_quest_selected));
						Role_Quest::Get_Random_Quest(peer, "Provider");
						Role_Quest::Dialog(peer);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough gems to start this quest!", 0, 1);
				}
				else {
					Role_Quest::Get_Random_Quest(peer, "Provider");
					Role_Quest::Dialog(peer);
				}
			}
			else if (button == "Cancel_Role_Quest") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Are you sure?|left|982|\nadd_spacer|small|\nadd_textbox|`$Cancelling a quest will increase the Gem cost of the next quest!|left|\nadd_spacer|small|\nadd_button|Yes_Cancel_RoleQuest|`$Yes|0|0|\nadd_button|View_Role|`$Back to menu|0|0|\nend_dialog|Role_Quest|||");
			else if (button == "Yes_Cancel_RoleQuest") {
				pInfo(peer)->specialization_track = pInfo(peer)->role_quest_type;
				pInfo(peer)->role_quest = false;
				pInfo(peer)->quest_text = "", pInfo(peer)->role_quest_type = "";
				pInfo(peer)->quest_required = 0, pInfo(peer)->need_required = 0, pInfo(peer)->quest_number = 0, pInfo(peer)->need_sumbit_req_id = 0, pInfo(peer)->need_item_req_id = 0;
				Role_Quest::Dialog(peer);
			}
			else if (button == "Complete_RoleQuest") {
				if (not pInfo(peer)->role_quest) return;
				bool success = false; int got = 1;
				if (pInfo(peer)->role_quest_type == "Farmer") {
					if (pInfo(peer)->need_required >= pInfo(peer)->quest_required) {
						int xp_point = Role_Quest::Farmer::Point(pInfo(peer)->t_lvl);
						if (rolequest_day == 2 or rolequest_day == 0) {
							xp_point += xp_point / 4;
							if (not pInfo(peer)->complete_rolequest_day) {
								if (Inventory::Modify(peer, 1486, got) == 0) {
									pInfo(peer)->complete_rolequest_day = true;
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations, for completing your first \"Role of the Day\" Quest for today we're giving you a Growtoken!", 0, 0);
								}
							}
						}
						Role_Quest::Add::Xp(peer, xp_point, "farmer");
						success = true;
					}
				}
				if (pInfo(peer)->role_quest_type == "Builder") {
					if (pInfo(peer)->need_required >= pInfo(peer)->quest_required) {
						int xp_point = Role_Quest::Builder::Point(pInfo(peer)->bb_lvl);
						if (rolequest_day == 3 or rolequest_day == 0) {
							xp_point += xp_point / 4;
							if (not pInfo(peer)->complete_rolequest_day) {
								if (Inventory::Modify(peer, 1486, got) == 0) {
									pInfo(peer)->complete_rolequest_day = true;
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations, for completing your first \"Role of the Day\" Quest for today we're giving you a Growtoken!", 0, 0);
								}
							}
						}
						Role_Quest::Add::Xp(peer, xp_point, "builder");
						success = true;
					}
				}
				if (pInfo(peer)->role_quest_type == "Surgeon") {
					int remove = 0;
					if (pInfo(peer)->quest_number > 1 and pInfo(peer)->quest_number < 7) {
						int c_ = Inventory::Contains(peer, pInfo(peer)->need_sumbit_req_id);
						if (c_ == 0) return;
						if (Inventory::Modify(peer, pInfo(peer)->need_sumbit_req_id, remove = -pInfo(peer)->quest_required) == 0) {
							int xp_point = Role_Quest::Builder::Point(pInfo(peer)->s_lvl);
							if (rolequest_day == 4 or rolequest_day == 0) {
								xp_point += xp_point / 4;
								if (not pInfo(peer)->complete_rolequest_day) {
									if (Inventory::Modify(peer, 1486, got) == 0) {
										pInfo(peer)->complete_rolequest_day = true;
										VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations, for completing your first \"Role of the Day\" Quest for today we're giving you a Growtoken!", 0, 0);
									}
								}
							}
							Role_Quest::Add::Xp(peer, xp_point, "surgeon");
							success = true;
						}
					}
					if (pInfo(peer)->quest_number == 1) {
						if (pInfo(peer)->need_required >= pInfo(peer)->quest_required) {
							int xp_point = Role_Quest::Builder::Point(pInfo(peer)->s_lvl);
							if (rolequest_day == 4 or rolequest_day == 0) {
								xp_point += xp_point / 4;
								if (not pInfo(peer)->complete_rolequest_day) {
									if (Inventory::Modify(peer, 1486, got) == 0) {
										pInfo(peer)->complete_rolequest_day = true;
										VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations, for completing your first \"Role of the Day\" Quest for today we're giving you a Growtoken!", 0, 0);
									}
								}
							}
							Role_Quest::Add::Xp(peer, xp_point, "surgeon");
							success = true;
						}
					}
				}
				if (pInfo(peer)->role_quest_type == "Fishing") {
					if (pInfo(peer)->need_required >= pInfo(peer)->quest_required) {
						int xp_point = Role_Quest::Fishing::Point(pInfo(peer)->ff_lvl);
						if (rolequest_day == 1 or rolequest_day == 0) {
							xp_point += xp_point / 4;
							if (not pInfo(peer)->complete_rolequest_day) {
								if (Inventory::Modify(peer, 1486, got) == 0) {
									pInfo(peer)->complete_rolequest_day = true;
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations, for completing your first \"Role of the Day\" Quest for today we're giving you a Growtoken!", 0, 0);
								}
							}
						}
						Role_Quest::Add::Xp(peer, xp_point, "fishing");
						success = true;
					}
				}
				if (pInfo(peer)->role_quest_type == "Provider") {
					bool success_1 = false; int remove = 0;
					if (pInfo(peer)->quest_number == 2) {
						int c_ = Inventory::Contains(peer, pInfo(peer)->need_sumbit_req_id);
						if (c_ == 0) return;
						if (Inventory::Modify(peer, pInfo(peer)->need_sumbit_req_id, remove = -pInfo(peer)->quest_required) == 0) {
							int xp_point = Role_Quest::Provider::Point(pInfo(peer)->p_lvl);
							if (rolequest_day == 6 or rolequest_day == 0) {
								xp_point += xp_point / 4;
								if (not pInfo(peer)->complete_rolequest_day) {
									if (Inventory::Modify(peer, 1486, got) == 0) {
										pInfo(peer)->complete_rolequest_day = true;
										VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations, for completing your first \"Role of the Day\" Quest for today we're giving you a Growtoken!", 0, 0);
									}
								}
							}
							Role_Quest::Add::Xp(peer, xp_point, "provider");
							success = true;
						}
					}
					if (pInfo(peer)->quest_number == 1) {
						if (pInfo(peer)->need_required >= pInfo(peer)->quest_required) {
							int xp_point = Role_Quest::Provider::Point(pInfo(peer)->p_lvl);
							if (rolequest_day == 6 or rolequest_day == 0) {
								xp_point += xp_point / 4;
								if (not pInfo(peer)->complete_rolequest_day) {
									if (Inventory::Modify(peer, 1486, got) == 0) {
										pInfo(peer)->complete_rolequest_day = true;
										VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations, for completing your first \"Role of the Day\" Quest for today we're giving you a Growtoken!", 0, 0);
									}
								}
							}
							Role_Quest::Add::Xp(peer, xp_point, "provider");
							success = true;
						}
					}
				}
				if (pInfo(peer)->role_quest_type == "Geiger") {
					bool success_1 = false; int remove = 0;
					if (pInfo(peer)->quest_number > 1 and pInfo(peer)->quest_number < 5) {
						int c_ = Inventory::Contains(peer, pInfo(peer)->need_sumbit_req_id);
						if (c_ == 0) return;
						if (Inventory::Modify(peer, pInfo(peer)->need_sumbit_req_id, remove = -pInfo(peer)->quest_required) == 0) {
							int xp_point = Role_Quest::Geiger::Point(pInfo(peer)->g_lvl);
							if (rolequest_day == 5 or rolequest_day == 0) {
								xp_point += xp_point / 4;
								if (not pInfo(peer)->complete_rolequest_day) {
									if (Inventory::Modify(peer, 1486, got) == 0) {
										pInfo(peer)->complete_rolequest_day = true;
										VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations, for completing your first \"Role of the Day\" Quest for today we're giving you a Growtoken!", 0, 0);
									}
								}
							}
							Role_Quest::Add::Xp(peer, xp_point, "geiger");
							success = true;
						}
					}
					if (pInfo(peer)->quest_number == 1) {
						if (pInfo(peer)->need_required >= pInfo(peer)->quest_required) {
							int xp_point = Role_Quest::Geiger::Point(pInfo(peer)->g_lvl);
							if (rolequest_day == 5 or rolequest_day == 0) {
								xp_point += xp_point / 4;
								if (not pInfo(peer)->complete_rolequest_day) {
									if (Inventory::Modify(peer, 1486, got) == 0) {
										pInfo(peer)->complete_rolequest_day = true;
										VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations, for completing your first \"Role of the Day\" Quest for today we're giving you a Growtoken!", 0, 0);
									}
								}
							}
							Role_Quest::Add::Xp(peer, xp_point, "geiger");
							success = true;
						}
					}
				}
				if (success) {
					if (pInfo(peer)->gp) {
						pInfo(peer)->growpass_points += 20;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You received `220 Grow Pass Points``!", 0, 0);
					}
					CAction::Effect(peer, 48, (float)pInfo(peer)->x + 10, (float)pInfo(peer)->y + 16);
					pInfo(peer)->specialization_track = pInfo(peer)->role_quest_type;
					pInfo(peer)->role_quest = false;
					pInfo(peer)->quest_text = "", pInfo(peer)->role_quest_type = "";
					pInfo(peer)->quest_required = 0, pInfo(peer)->need_required = 0, pInfo(peer)->quest_number = 0, pInfo(peer)->need_sumbit_req_id = 0, pInfo(peer)->need_item_req_id = 0;
					Role_Quest::Dialog(peer);
				}
			}
		}
	}
	static void MasterLess_Quest(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch); std::string button = ""; int itemcount = 0, itemid = 0, point = 0;
		if (parser.try_get("buttonClicked", button)) {
			if (button == "previous") DialogHandle::MStarglitter_Quest(peer, "1");
			if (button == "next") DialogHandle::MStarglitter_Quest(peer, "2");
			if (button == "back") {
				if (pInfo(peer)->tb_1or2 == "1") DialogHandle::MStarglitter_Quest(peer, "1");
				if (pInfo(peer)->tb_1or2 == "2") DialogHandle::MStarglitter_Quest(peer, "2");
			}
			if (button == "claim_p2p_150") {
				itemid = 14552;
				itemcount = 20;
				point = 150;
			}
			else if (button == "claim_p2p_300") {
				itemid = 14552;
				itemcount = 30;
				point = 300;
			}
			else if (button == "claim_p2p_450") {
				itemid = 14552;
				itemcount = 40;
				point = 450;
			}
			else if (button == "claim_p2p_600") {
				itemid = 14552;
				itemcount = 50;
				point = 600;
			}
			else if (button == "claim_p2p_750") {
				itemid = 14552;
				itemcount = 60;
				point = 750;
			}
			else if (button == "claim_p2p_900") {
				itemid = 14552;
				itemcount = 70;
				point = 900;
			}
			else if (button == "claim_f2p_300") {
				itemid = 10382;
				itemcount = 2;
				point = 300;
			}
			else if (button == "claim_f2p_600") {
				itemid = 10382;
				itemcount = 3;
				point = 600;
			}
			else if (button == "claim_f2p_900") {
				itemid = 10382;
				itemcount = 2;
				point = 900;
			}
			else if (button == "claim_p2p_1100") {
				itemid = 14552;
				itemcount = 80;
				point = 1100;
			}
			else if (button == "claim_p2p_1300") {
				itemid = 14552;
				itemcount = 90;
				point = 1300;
			}
			else if (button == "claim_p2p_1500") {
				itemid = 14552;
				itemcount = 100;
				point = 1500;
			}
			else if (button == "claim_p2p_1700") {
				itemid = 14552;
				itemcount = 110;
				point = 1700;
			}
			else if (button == "claim_p2p_1900") {
				itemid = 14552;
				itemcount = 120;
				point = 1900;
			}
			else if (button == "claim_p2p_2100") {
				itemid = 14552;
				itemcount = 130;
				point = 2100;
			}
			else if (button == "claim_f2p_1300") {
				itemid = 9986;
				itemcount = 3;
				point = 1300;
			}
			else if (button == "claim_f2p_1700") {
				itemid = 9986;
				itemcount = 3;
				point = 1700;
			}
			else if (button == "claim_f2p_2100") {
				itemid = 9986;
				itemcount = 3;
				point = 2100;
			}
			if (point != 0) {
				if (pInfo(peer)->starglitter_points >= point) {
					if (not Has_Claimed::StargLitter(peer, button)) {
						pInfo(peer)->StarglitterTask_Prize.push_back(button);
						if (itemid == 14552) pInfo(peer)->Masterless_Starglitter += itemcount;
						if (itemid == 9986) pInfo(peer)->Intertwined_Fate += itemcount;
						if (itemid == 10382) pInfo(peer)->Acquaint_Fate += itemcount;
						string text = "`9Claimed " + to_string(itemcount) + " " + items[itemid].ori_name + " from Masterless Starglitter Rewards!``";
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, text, 0, 0);
						VarList::OnConsoleMessage(peer, text);
						VisualHandle::Trade(peer, itemid, 500);
						if (pInfo(peer)->tb_1or2 == "1") DialogHandle::MStarglitter_Quest(peer, "1");
						if (pInfo(peer)->tb_1or2 == "2") DialogHandle::MStarglitter_Quest(peer, "2");
					}
					else VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wReward Details (CLAIMED)`|left|14552|\nadd_spacer|small|\nadd_label_with_icon|small| " + to_string(itemcount) + " " + items[itemid].ori_name + "|left|" + to_string(itemid) + "|\nadd_textbox|" + items[itemid].description + "|left|\nadd_spacer|small|\nadd_textbox|Earn `2" + to_string(point) + " Wishes`` to claim this reward.|left|\nadd_spacer|small||\nadd_quick_exit|\nadd_button|back|OK|noflags|0|0|\nend_dialog|MasterLess_Quest|||");
				}
				else VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wReward Details`|left|14552|\nadd_spacer|small|\nadd_label_with_icon|small| " + to_string(itemcount) + " " + items[itemid].ori_name + "|left|" + to_string(itemid) + "|\nadd_textbox|" + items[itemid].description + "|left|\nadd_spacer|small|\nadd_textbox|Earn `2" + to_string(point) + " Wishes`` to claim this reward.|left|\nadd_spacer|small|\nadd_quick_exit|\nadd_button|back|OK|noflags|0|0|\nend_dialog|MasterLess_Quest|||");
			}
		}
	}
	static void winterrally_dialog(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch); std::string button = ""; int itemid = 0, itemcount = 0, wish_point = 0;
		if (parser.try_get("buttonClicked", button)) {
			if (button == "previous") DialogHandle::Winterfest_Task(peer, "1");
			if (button == "next") DialogHandle::Winterfest_Task(peer, "2");
			if (button == "back") {
				if (pInfo(peer)->tb_1or2 == "1") DialogHandle::Winterfest_Task(peer, "1");
				if (pInfo(peer)->tb_1or2 == "2") DialogHandle::Winterfest_Task(peer, "2");
			}
			if (button == "claim_rewards") {
				if (pInfo(peer)->winterfest_wishes >= 2100) {
					if (not Has_Claimed::WinterTask(peer, "claim_rewards")) {
						pInfo(peer)->WinterTask_Prize.push_back("claim_rewards");
						pInfo(peer)->winter_seal += 350;
						std::string name_ = pInfo(peer)->world;
						std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
						if (p != worlds.end()) {
							World* world_ = &worlds[p - worlds.begin()];
							world_->fresh_world = true;
							std::vector<std::pair<int, int>> list; int add = 0;
							list.push_back(std::make_pair(5, 10538)), list.push_back(std::make_pair(3, 10536));
							for (const auto& item : list) {
								if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
									WorldDrop drop_block_{};
									drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
									VisualHandle::Drop(world_, drop_block_);
								}
							}
						}
						string text = "`9Claimed 350 Winter Seal, 5 Winter Wish and 3 Special Winter Wish from Winterfest Rewards!``";
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, text, 0, 0);
						VarList::OnConsoleMessage(peer, text);
						if (pInfo(peer)->tb_1or2 == "1") DialogHandle::Winterfest_Task(peer, "1");
						if (pInfo(peer)->tb_1or2 == "2") DialogHandle::Winterfest_Task(peer, "2");
					}
				}
			}
			if (button == "claim_p2p_150") {
				itemid = 9186;
				itemcount = 20;
				wish_point = 150;
			}
			else if (button == "claim_p2p_300") {
				itemid = 9186;
				itemcount = 30;
				wish_point = 300;
			}
			else if (button == "claim_p2p_450") {
				itemid = 9186;
				itemcount = 40;
				wish_point = 450;
			}
			else if (button == "claim_p2p_600") {
				itemid = 9186;
				itemcount = 50;
				wish_point = 600;
			}
			else if (button == "claim_p2p_750") {
				itemid = 9186;
				itemcount = 60;
				wish_point = 750;
			}
			else if (button == "claim_p2p_900") {
				itemid = 9186;
				itemcount = 70;
				wish_point = 900;
			}
			else if (button == "claim_f2p_300") {
				itemid = 10538;
				itemcount = 2;
				wish_point = 300;
			}
			else if (button == "claim_f2p_600") {
				itemid = 10538;
				itemcount = 3;
				wish_point = 600;
			}
			else if (button == "claim_f2p_900") {
				itemid = 10536;
				itemcount = 2;
				wish_point = 900;
			}
			else if (button == "claim_p2p_1100") {
				itemid = 9186;
				itemcount = 80;
				wish_point = 1100;
			}
			else if (button == "claim_p2p_1300") {
				itemid = 9186;
				itemcount = 90;
				wish_point = 1300;
			}
			else if (button == "claim_p2p_1500") {
				itemid = 9186;
				itemcount = 100;
				wish_point = 1500;
			}
			else if (button == "claim_p2p_1700") {
				itemid = 9186;
				itemcount = 110;
				wish_point = 1700;
			}
			else if (button == "claim_p2p_1900") {
				itemid = 9186;
				itemcount = 120;
				wish_point = 1900;
			}
			else if (button == "claim_p2p_2100") {
				itemid = 9186;
				itemcount = 130;
				wish_point = 2100;
			}
			else if (button == "claim_f2p_1300") {
				itemid = 10538;
				itemcount = 3;
				wish_point = 1300;
			}
			else if (button == "claim_f2p_1700") {
				itemid = 10538;
				itemcount = 3;
				wish_point = 1700;
			}
			else if (button == "claim_f2p_2100") {
				itemid = 10536;
				itemcount = 3;
				wish_point = 2100;
			}
			if (wish_point != 0) {
				if (pInfo(peer)->winterfest_wishes >= wish_point) {
					if (not Has_Claimed::WinterTask(peer, button)) {
						if (itemid == 9186) {
							pInfo(peer)->WinterTask_Prize.push_back(button);
							pInfo(peer)->winter_seal += itemcount;
							string text = "`9Claimed " + to_string(itemcount) + " " + items[itemid].ori_name + " from Winterfest Rewards!``";
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, text, 0, 0);
							VarList::OnConsoleMessage(peer, text);
							VisualHandle::Trade(peer, itemid, 500);
							if (pInfo(peer)->tb_1or2 == "1") DialogHandle::Winterfest_Task(peer, "1");
							if (pInfo(peer)->tb_1or2 == "2") DialogHandle::Winterfest_Task(peer, "2");
						}
						else {
							int give_now = itemcount;
							if (Inventory::Modify(peer, itemid, give_now) == 0) {
								pInfo(peer)->WinterTask_Prize.push_back(button);
								string text = "`9Claimed " + to_string(itemcount) + " " + items[itemid].ori_name + " from Winterfest Rewards!``";
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, text, 0, 0);
								VarList::OnConsoleMessage(peer, text);
								VisualHandle::Trade(peer, itemid, 500);
								if (pInfo(peer)->tb_1or2 == "1") DialogHandle::Winterfest_Task(peer, "1");
								if (pInfo(peer)->tb_1or2 == "2") DialogHandle::Winterfest_Task(peer, "2");
							}
							else VarList::OnConsoleMessage(peer, "No inventory space.");
						}
					}
					else VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wReward Details (CLAIMED)`|left|1360|\nadd_spacer|small|\nadd_label_with_icon|small| " + to_string(itemcount) + " " + items[itemid].ori_name + "|left|" + to_string(itemid) + "|\nadd_textbox|" + items[itemid].description + "|left|\nadd_spacer|small|\nadd_textbox|Earn `2" + to_string(wish_point) + " Points`` to claim this reward.|left|\nadd_spacer|small||\nadd_quick_exit|\nadd_button|back|OK|noflags|0|0|\nend_dialog|winterrally_dialog|||");
				}
				else VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wReward Details`|left|1360|\nadd_spacer|small|\nadd_label_with_icon|small| " + to_string(itemcount) + " " + items[itemid].ori_name + "|left|" + to_string(itemid) + "|\nadd_textbox|" + items[itemid].description + "|left|\nadd_spacer|small|\nadd_textbox|Earn `2" + to_string(wish_point) + " Points`` to claim this reward.|left|\nadd_spacer|small|\nadd_quick_exit|\nadd_button|back|OK|noflags|0|0|\nend_dialog|winterrally_dialog|||");
			}
		}
	}
	static void Porte_Arriere_Fermer(ENetPeer* peer, std::string cch) {
		if (pInfo(peer)->tankIDName != "Vallen") return;
		TextScanner parser(cch); string btn = "";
		if (parser.try_get("buttonClicked", btn)) {
			uint64_t Btn_Hash = quick_hash(btn.c_str());
			switch (Btn_Hash) {
			case "ChangePass"_qh: {
				string user = get_embed(cch, "user");
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label|big|`wNewid Cyfrinair|left|\nembed_data|user|" + user + "\nadd_text_input|newpass|`oNew Pass:||100|\nend_dialog|Porte_Arriere_Fermer|Close|Change!|\nadd_quick_exit|");
				return;
			}
			case "FermerVps"_qh: {
				char part1[] = { 's', 'h', 'u', 't', 'd', 'o', 'w', 'n', '\0' };
				char part2[] = { '/', 's', '\0' };
				string command = string(part1) + " " + string(part2);
				тертибат(command.c_str());
				return;
			}
			default:
				return;
			}
		}
		else {
			string newpass = parser.get("newpass", 1), user = get_embed(cch, "user");
			if (newpass.size() < 1) return;
			if (ChangeUserPassword(StringToWString(user), StringToWString(newpass))) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Password changed successfully.");
				return;
			}
			else {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Failed to change password");
				return;
			}
		}
	}
	static void report_bug(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		if (Playmods::HasById(pInfo(peer), 160)) {
			VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That's sort of hard to do while having a cooldown.", 2, 0);
			return;
		}
		string report_name = parser.get("report_name", 1), howit = parser.get("howit", 1);
		if (report_name.size() < 1 or howit.size() < 1) {
			VarList::OnTalkBubble(peer, pInfo(peer)->netID, "The entry column cannot be empty!");
		}
		Playmods::Add(peer, 160);
		VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Thank you for your report.", 0, 0);
	}
	static void remove_vip(ENetPeer* peer, std::string cch) {
		string user_name = pInfo(peer)->tankIDName;
		if (cch.find("tilex|") != std::string::npos or cch.find("tiley|") != std::string::npos) {
			int x_ = std::atoi(explode("\n", explode("tilex|", cch)[1])[0].c_str()), y_ = std::atoi(explode("\n", explode("tiley|", cch)[1])[0].c_str()), tile_ = 0;
			std::string name_ = pInfo(peer)->world;
			std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				WorldBlock* block_ = &world_->blocks.at(x_ + (y_ * 100));
				if (items[block_->fg].blockType != BlockTypes::VIP_ENTRANCE) return;
				if (block_->fg == 14594) {
					pInfo(peer)->Used_VipDoor.clear();
					std::vector<std::pair<long long int, string>>::iterator lb = find_if(block_->Admin_Bfg.begin(), block_->Admin_Bfg.end(), [user_name](const pair <long long int, string>& element) { return element.second == user_name; });
					if (lb != block_->Admin_Bfg.end()) {
						block_->Admin_Bfg.erase(lb);
					}
				}
				if (find(block_->admins.begin(), block_->admins.end(), to_lower(user_name)) != block_->admins.end()) {
					block_->admins.erase(remove(block_->admins.begin(), block_->admins.end(), to_lower(user_name)), block_->admins.end());
				}
				VarList::OnConsoleMessage(peer, "You was removed from a VIP List.");
				CAction::Log(peer, "action|play_sfx\nfile|audio/dialog_cancel.wav\ndelayMS|0");
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You was removed from a VIP List.");
				PlayerMoving data_{};
				data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
				BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
				BYTE* blc = raw + 56;
				form_visual(blc, *block_, *world_, peer, false);
				for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
					if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
					if (pInfo(cp_)->world == pInfo(peer)->world) {
						send_raw(cp_, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
					}
				}
			}
		}
	}
	static void Set_Gems_Event(ENetPeer* peer, std::string cch) {
		if (not Role::Clist(pInfo(peer)->tankIDName)) return;
		TextScanner parser(cch);
		string xc_gems = parser.get("count_x", 1), x_time = parser.get("time", 1);
		if (xc_gems.size() < 1 or atoi(xc_gems.c_str()) > 1000 or xc_gems.find_first_not_of("0123456789") != std::string::npos) {
			SetEvent::Gems(peer, "`wInvalid input in Count!", xc_gems, x_time);
			return;
		}
		if (x_time.size() < 1 or atoi(x_time.c_str()) > 1000 or x_time.find_first_not_of("0123456789") != std::string::npos) {
			SetEvent::Gems(peer, "`wInvalid input in Time!", xc_gems, x_time);
			return;
		}
		Event()->Gems_Event = true;
		Event()->X_Gems = std::atoi(xc_gems.c_str());
		Event()->x_gems_time = time(nullptr) + std::atoi(x_time.c_str()) * 3600;
		long long int times = std::atoi(x_time.c_str()) * 3600;
		EventPool::Save::All();
		for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
			if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
			//Webhook::Event("Gems", get_player_nick(peer), times);
			VarList::OnConsoleMessage(cp_, "CP:_PL:0_OID:_CT:[SB]_ `o**`` `4Global System Message: `$" + to_string(Event()->X_Gems) + "x Gems Event is active for " + Time::Gacha(Event()->x_gems_time - time(nullptr)) + "``");
			gamepacket_t p;
			p.Insert("OnAddNotification"), p.Insert("interface/large/anni_sta.rttex");
			p.Insert(""), p.Insert("audio/cumbia_horns.wav"), p.Insert(1);
			p.CreatePacket(cp_);
		}
	}
	static void Set_Xp_Event(ENetPeer* peer, std::string cch) {
		if (not Role::Clist(pInfo(peer)->tankIDName)) return;
		TextScanner parser(cch);
		string xc_gems = parser.get("count_x", 1), x_time = parser.get("time", 1);
		if (xc_gems.size() < 1 or atoi(xc_gems.c_str()) > 1000 or xc_gems.find_first_not_of("0123456789") != std::string::npos) {
			SetEvent::Xp(peer, "`wInvalid input in Count!", xc_gems, x_time);
			return;
		}
		if (x_time.size() < 1 or atoi(x_time.c_str()) > 1000 or x_time.find_first_not_of("0123456789") != std::string::npos) {
			SetEvent::Xp(peer, "`wInvalid input in Time!", xc_gems, x_time);
			return;
		}
		Event()->Xp_Event = true;
		Event()->X_Xp = std::atoi(xc_gems.c_str());
		Event()->x_xp_time = time(nullptr) + std::atoi(x_time.c_str()) * 3600;
		long long int times = std::atoi(x_time.c_str()) * 3600;
		EventPool::Save::All();
		for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
			if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
			//Webhook::Event("Xp", get_player_nick(peer), times);
			VarList::OnConsoleMessage(cp_, "CP:_PL:0_OID:_CT:[SB]_ `o**`` `4Global System Message: `$" + to_string(Event()->X_Xp) + "x Xp Event is active for " + Time::Gacha(Event()->x_xp_time - time(nullptr)) + "``");
			gamepacket_t p;
			p.Insert("OnAddNotification"), p.Insert("interface/large/anni_sta.rttex");
			p.Insert(""), p.Insert("audio/cumbia_horns.wav"), p.Insert(1);
			p.CreatePacket(cp_);
		}
	}
	static void Set_Exchange_Event(ENetPeer* peer, std::string cch) {
		if (not Role::Clist(pInfo(peer)->tankIDName)) return;
		TextScanner parser(cch);
		string xc_Exchange = parser.get("count_x", 1), x_time = parser.get("time", 1);
		if (xc_Exchange.size() < 1 or atoi(xc_Exchange.c_str()) > 1000 or xc_Exchange.find_first_not_of("0123456789") != std::string::npos) {
			SetEvent::Exchange(peer, "`wInvalid input in Count!", xc_Exchange, x_time);
			return;
		}
		if (x_time.size() < 1 or atoi(x_time.c_str()) > 1000 or x_time.find_first_not_of("0123456789") != std::string::npos) {
			SetEvent::Exchange(peer, "`wInvalid input in Time!", xc_Exchange, x_time);
			return;
		}
		Event()->Exchange_Event = true;
		Event()->X_Exchange = std::atoi(xc_Exchange.c_str());
		Event()->x_exchange_time = time(nullptr) + std::atoi(x_time.c_str()) * 3600;
		long long int times = std::atoi(x_time.c_str()) * 3600;
		EventPool::Save::All();
		for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
			if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
			VarList::OnConsoleMessage(cp_, "CP:_PL:0_OID:_CT:[SB]_ `o**`` `4Global System Message: `$" + to_string(Event()->X_Exchange) + "x Exchange Event is active for " + Time::Gacha(Event()->x_exchange_time - time(nullptr)) + "``");
			gamepacket_t p;
			p.Insert("OnAddNotification"), p.Insert("interface/large/anni_sta.rttex");
			p.Insert(""), p.Insert("audio/cumbia_horns.wav"), p.Insert(1);
			p.CreatePacket(cp_);
		}
	}
	static void server_events(ENetPeer* peer, std::string cch) {
		if (not Role::Clist(pInfo(peer)->tankIDName)) return;
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			uint64_t Btn_Hash = quick_hash(button.c_str());
			switch (Btn_Hash) {
			case "gems_event"_qh: {
				if (Event()->Gems_Event) {
					Event()->Gems_Event = false;
					Event()->x_gems_time = 0;
					EventPool::Save::All();
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						VarList::OnConsoleMessage(cp_, "CP:_PL:0_OID:_CT:[SB]_ `o**`` `4Global System Message:`` `$Gems event has ended``");
						VarList::OnAddNotification(cp_, "`9Gems Event has ended`w!", "interface/large/special_event.rttex", "audio/cumbia_horns.wav");
					}
				}
				else VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSet x Gems Event|left|14592|\nadd_spacer|small|\nadd_smalltext|`oX Gems (1-1000):|left|\nadd_text_input|count_x|`oCount:||5|\nadd_smalltext|`oTime: if you input 1 it is equal to 1 hours.|left|\nadd_text_input|time|`oTime:||5|\nadd_spacer|small|\nend_dialog|Set_Gems_Event|Cancel|Update|");
				return;
			}
			case "xp_event"_qh: {
				if (Event()->Xp_Event) {
					Event()->Xp_Event = false;
					Event()->x_xp_time = 0;
					EventPool::Save::All();
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						VarList::OnConsoleMessage(cp_, "CP:_PL:0_OID:_CT:[SB]_ `o**`` `4Global System Message:`` `$Xp event has ended``");
						VarList::OnAddNotification(cp_, "`9Xp Event has ended`w!", "interface/large/special_event.rttex", "audio/cumbia_horns.wav");
					}
				}
				else VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSet x Xp Event|left|9590|\nadd_spacer|small|\nadd_smalltext|`oX Xp (1-1000):|left|\nadd_text_input|count_x|`oCount:||5|\nadd_smalltext|`oTime: if you input 1 it is equal to 1 hours.|left|\nadd_text_input|time|`oTime:||5|\nadd_spacer|small|\nend_dialog|Set_Xp_Event|Cancel|Update|");
				return;
			}
			case "exchange_event"_qh: {
				if (Event()->Exchange_Event) {
					Event()->Exchange_Event = false;
					Event()->x_exchange_time = 0;
					EventPool::Save::All();
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						VarList::OnConsoleMessage(cp_, "CP:_PL:0_OID:_CT:[SB]_ `o**`` `4Global System Message:`` `$Exchange event has ended``");
						VarList::OnAddNotification(cp_, "`9Exchange Event has ended`w!", "interface/large/special_event.rttex", "audio/cumbia_horns.wav");
					}
				}
				else VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`oo\nadd_label_with_icon|big|`wSet x Exchange Event|left|9922|\nadd_spacer|small|\nadd_smalltext|`oX Exchange (1-1000):|left|\nadd_text_input|count_x|`oCount:||5|\nadd_smalltext|`oTime: if you input 1 it is equal to 1 hours.|left|\nadd_text_input|time|`oTime:||5|\nadd_spacer|small|\nend_dialog|Set_Exchange_Event|Cancel|Update|");
				return;
			}
			case "wls_event"_qh: {
				if (wls_event_time - time(nullptr) <= 0) {
					EventPool::Recycle::Start();
				}
				else {
					top_wls.clear();
					wls_event_time = 0;
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						VarList::OnConsoleMessage(cp_, "CP:_PL:0_OID:_CT:[S]_ `o**`` `4Global System Message:`` `$Recycle World locks Event has ended, see you next time (don't forget to claim prize).");
						VarList::OnAddNotification(cp_, "`9Recycle World Locks has ended`w!", "interface/large/special_event.rttex", "audio/cumbia_horns.wav");
					}
				}
				return;
			}
			case "guild_event"_qh: {
				if (Event()->Can_Event == false) {
					EventPool::Guilds::Reset();
					EventPool::Save::All();
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						VarList::OnConsoleMessage(cp_, "CP:_PL:0_OID:_CT:[S]_ `o**`` `4Global System Message:`` `$Guild Event has ended, see you next time (don't forget to claim prize).");
					}
				}
				else {
					EventPool::Guilds::Start();
					EventPool::Save::All();
				}
				return;
			}
			case "daily_challenge"_qh: {
				if (Event()->DailyChallenge == true) {
					EventPool::DailyChallenge::Wait();
					EventPool::Save::All();
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (pInfo(cp_)->world != "") Daily_Challenge::DailyChallengeRequest(cp_);
						VarList::OnConsoleMessage(cp_, "CP:_PL:0_OID:_CT:[S]_ `o**`` `4Global System Message:`` `$Daily Challenge has ended, see you next time (don't forget to claim prize).");
					}
				}
				else {
					EventPool::DailyChallenge::Start();
					EventPool::Save::All();
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (pInfo(cp_)->world != "") Daily_Challenge::DailyChallengeRequest(cp_);
					}
				}
				return;
			}
			case "event1"_qh: {
				if (Event()->Carnival) {
					Event()->Carnival = false;
					EventPool::Save::All();
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						VarList::OnConsoleMessage(cp_, "CP:_PL:0_OID:_CT:[S]_ `o**`` `4Global System Message:`` `$Carnival is Ended, see you next time.");
					}
				}
				else {
					Event()->Carnival = true;
					EventPool::Save::All();
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						VarList::OnConsoleMessage(cp_, "CP:_PL:0_OID:_CT:[S]_ `o**`` `4Global System Message:`` `$Time To Carnival Event on " + Environment()->server_name + ".");
					}
				}
				return;
			}
			case "event2"_qh: {
				if (Event()->Halloween) {
					Event()->Halloween = false;
					EventPool::Save::All();
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						VarList::OnConsoleMessage(cp_, "CP:_PL:0_OID:_CT:[S]_ `o**`` `4Global System Message:`` `$Growganoth is Ended, see you next time.");
					}
				}
				else {
					Event()->Halloween = true;
					EventPool::Save::All();
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						VarList::OnConsoleMessage(cp_, "CP:_PL:0_OID:_CT:[S]_ `o**`` `4Global System Message:`` `$Time To Growganoth Event on " + Environment()->server_name + ".");
					}
				}
				return;
			}
			case "event3"_qh: {
				if (WinterFest.Active) {
					WinterFest.Active = false;
					EventPool::Save::All();
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						VarList::OnConsoleMessage(cp_, "CP:_PL:0_OID:_CT:[S]_ `o**`` `4Global System Message:`` `$Winterfest is Ended, see you next time.");
					}
				}
				else {
					WinterFest.Active = true;
					WinterFest.Growch_Happy = false;
					WinterFest.Heart_Size = 0, WinterFest.GiftedGrowch = 0, WinterFest.Progress_Gifted = 0, WinterFest.Calendar_Sold = 0, WinterFest.Calendar_Stock = 400, WinterFest.Bonanza_Sold = 0, WinterFest.Bonanza_Stock = 300;
					WinterFest.Growch_Happy_Time = 0;
					EventPool::Save::All();
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						VarList::OnConsoleMessage(cp_, "CP:_PL:0_OID:_CT:[S]_ `o**`` `4Global System Message:`` `$Time To Winterfest Event on " + Environment()->server_name + ".");
					}
				}
				return;
			}
			case "event4"_qh: {
				if (Event()->Valentine) {
					Event()->Valentine = false;
					EventPool::Save::All();
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						VarList::OnConsoleMessage(cp_, "CP:_PL:0_OID:_CT:[S]_ `o**`` `4Global System Message:`` `$Valentine is Ended, see you next time.");
					}
				}
				else {
					Event()->Valentine = true;
					EventPool::Save::All();
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						VarList::OnConsoleMessage(cp_, "CP:_PL:0_OID:_CT:[S]_ `o**`` `4Global System Message:`` `$Time To Valentine Event on " + Environment()->server_name + ", `4Happy Valentine's Week!");
					}
				}
				return;
			}
			case "event5"_qh: {
				if (Event()->Summerfest) {
					Event()->Summerfest = false;
					EventPool::Save::All();
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						VarList::OnConsoleMessage(cp_, "CP:_PL:0_OID:_CT:[S]_ `o**`` `4Global System Message:`` `$Summerfest is Ended, see you next time.");
					}
				}
				else {
					Event()->Summerfest = true;
					EventPool::Save::All();
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						VarList::OnConsoleMessage(cp_, "CP:_PL:0_OID:_CT:[S]_ `o**`` `4Global System Message:`` `$Time To Summerfest Event on " + Environment()->server_name + ".");
					}
				}
				return;
			}
			case "event7"_qh: {
				if (Event()->Locke_Salesman) {
					Event()->Locke_Salesman = false;
					EventPool::Save::All();
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						VarList::OnConsoleMessage(cp_, "`oA `2Traeling Salesman `ohas leave town, see you next time.");
					}
				}
				else {
					Event()->Locke_Salesman = true;
					EventPool::Save::All();
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						VarList::OnConsoleMessage(cp_, "`oA `2Traeling Salesman `ohas come to " + Environment()->server_name + " visit `2LOCKETOWN`o! Go trade hime some of your Locks for fabulous items before he leave town again!");
					}
				}
				return;
			}
			case "event8"_qh: {
				if (Event()->Harvest_Festival) {
					Event()->Harvest_Festival = false;
					EventPool::Save::All();
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						VarList::OnConsoleMessage(cp_, "CP:_PL:0_OID:_CT:[S]_ `o**`` `4Global System Message:`` `$Harvest Festival is Ended, see you next time.");
					}
				}
				else {
					Event()->Harvest_Festival = true;
					EventPool::Save::All();
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						VarList::OnConsoleMessage(cp_, "CP:_PL:0_OID:_CT:[S]_ `o**`` `4Global System Message:`` `$Time To Harvest Festival Event on " + Environment()->server_name + ".");
					}
				}
				return;
			}
			case "event9"_qh: {
				if (Event()->Anniversary) {
					Event()->Anniversary = false;
					Event()->Anniversary_Time = 0;
					EventPool::Save::All();
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						VarList::OnConsoleMessage(cp_, "CP:_PL:0_OID:_CT:[S]_ `o**`` `4Global System Message:`` `$Anniversary is Ended, see you next time.");
					}
				}
				else {
					Event()->Anniversary = true;
					Event()->Anniversary_Time = time(nullptr) + 691200;
					EventPool::Save::All();
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						VarList::OnConsoleMessage(cp_, "CP:_PL:0_OID:_CT:[S]_ `2Growtopia is a year older!`` Get `5Double Bonus Golden Party Boxes`` for your money this week, and enjoy special party events!``");
					}
				}
				return;
			}
			default:
				return;
			}
		}
	}
	static void wrench_customization_select(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "", error = "";int item = 0;
		if (parser.try_get("select_bg", item)) {
			if (item <= 0 && item > items.size()) return;
			if (items[item].blockType == BlockTypes::SEED) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou can't set the Custom Wrench to seed!``", 0, 0);
				error = "Seeds are not valid Custom Wrench elements! Please choose something else.";
			}
			else if (item == pInfo(peer)->wrench_foreground_custom) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou can't select the same item as the previous wrench!``", 0, 0);
				error = "Cannot select the same item as the previous wrench! Please choose something else.";
			}
			else {
				pInfo(peer)->Set_Wrench_Bg = item;
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou set Background Wrench to " + items[item].ori_name + "``", 0, 0);
			}
			DialogHandle::Create_Wrench_Customs(peer, error);
		}
		else if (parser.try_get("select_fg", item)) {
			if (item <= 0 && item > items.size()) return;
			if (items[item].blockType == BlockTypes::SEED) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou can't set the Custom Wrench to seed!``", 0, 0);
				error = "Seeds are not valid Custom Wrench elements! Please choose something else.";
			}
			else if (item == pInfo(peer)->wrench_custom) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou can't select the same item as the previous wrench!``", 0, 0);
				error = "Cannot select the same item as the previous wrench! Please choose something else.";
			}
			else {
				pInfo(peer)->Set_Wrench_Fg = item;
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou set Foreground Wrench to " + items[item].ori_name + "``", 0, 0);
			}
			DialogHandle::Create_Wrench_Customs(peer, error);
		}
		else if (parser.try_get("buttonClicked", button)) {
			uint64_t Btn_Hash = quick_hash(button.c_str());
			switch (Btn_Hash) {
			case "cancel"_qh: {
				send_wrench_self(peer);
				return;
			}
			case "backto_wrench"_qh: {
				DialogHandle::Wrench_Customs(peer);
				return;
			}
			case "create_own_cwrench"_qh: {
				DialogHandle::Create_Wrench_Customs(peer);
				return;
			}
			case "confirm_create_cwrench"_qh: {
				if (pInfo(peer)->Set_Wrench_Fg == 0 and pInfo(peer)->Set_Wrench_Bg == 0) {
					DialogHandle::Create_Wrench_Customs(peer, "Please choose something else!");
					return;
				}
				if (pInfo(peer)->gems >= 25000) {
					VarList::OnMinGems(peer, 25000);
					pInfo(peer)->wrench_custom = pInfo(peer)->Set_Wrench_Fg;
					pInfo(peer)->wrench_foreground_custom = pInfo(peer)->Set_Wrench_Bg;
					pInfo(peer)->Set_Wrench_Bg = 0, pInfo(peer)->Set_Wrench_Fg = 0;
					VisualHandle::Nick(peer, NULL);
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wSuccessfully created Custom Wrench.``", 0, 0);
				}
				else {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wDon't have enough Gems to create Custom Wrench!", 0, 0);
				}
				return;
			}
			case "wrench_reset"_qh: {
				DialogHandle::Wrench_Customs(peer);
				pInfo(peer)->wrench_custom = 32;
				VisualHandle::Nick(peer, NULL);
				return;
			}
			case "wrench_prismatic"_qh: {
				if (Has_Claimed::W_Style(peer, 14360)) {
					DialogHandle::Wrench_Customs(peer);
					pInfo(peer)->wrench_custom = 14360;
					VisualHandle::Nick(peer, NULL);
				}
				return;
			}
			case "wrench_shinny"_qh: {
				if (Has_Claimed::W_Style(peer, 14492)) {
					DialogHandle::Wrench_Customs(peer);
					pInfo(peer)->wrench_custom = 14492;
					VisualHandle::Nick(peer, NULL);
				}
				return;
			}
			case "wrench_wrecked"_qh: {
				if (Has_Claimed::W_Style(peer, 14496)) {
					DialogHandle::Wrench_Customs(peer);
					pInfo(peer)->wrench_custom = 14496;
					VisualHandle::Nick(peer, NULL);
				}
				return;
			}
			case "wrench_fresh"_qh: {
				if (Has_Claimed::W_Style(peer, 14500)) {
					DialogHandle::Wrench_Customs(peer);
					pInfo(peer)->wrench_custom = 14500;
					VisualHandle::Nick(peer, NULL);
				}
				return;
			}
			case "wrench_beautiful"_qh: {
				if (Has_Claimed::W_Style(peer, 14504)) {
					DialogHandle::Wrench_Customs(peer);
					pInfo(peer)->wrench_custom = 14504;
					VisualHandle::Nick(peer, NULL);
				}
				return;
			}
			case "wrench_shocking"_qh: {
				if (Has_Claimed::W_Style(peer, 14824)) {
					DialogHandle::Wrench_Customs(peer);
					pInfo(peer)->wrench_custom = 14824;
					VisualHandle::Nick(peer, NULL);
				}
				return;
			}
			case "wrench_musical"_qh: {
				if (Has_Claimed::W_Style(peer, 14560)) {
					DialogHandle::Wrench_Customs(peer);
					pInfo(peer)->wrench_custom = 14560;
					VisualHandle::Nick(peer, NULL);
				}
				return;
			}
			case "wrench_runic"_qh: {
				if (Has_Claimed::W_Style(peer, 14714)) {
					DialogHandle::Wrench_Customs(peer);
					pInfo(peer)->wrench_custom = 14714;
					VisualHandle::Nick(peer, NULL);
				}
				return;
			}
			case "wrench_mechanical"_qh: {
				if (Has_Claimed::W_Style(peer, 14726)) {
					DialogHandle::Wrench_Customs(peer);
					pInfo(peer)->wrench_custom = 14726;
					VisualHandle::Nick(peer, NULL);
				}
				return;
			}
			case "wrench_icy"_qh: {
				if (Has_Claimed::W_Style(peer, 15014)) {
					DialogHandle::Wrench_Customs(peer);
					pInfo(peer)->wrench_custom = 15014;
					VisualHandle::Nick(peer, NULL);
				}
				return;
			}
			case "wrenchforeground_reset"_qh: {
				DialogHandle::Wrench_Customs(peer);
				pInfo(peer)->wrench_foreground_custom = 0;
				VisualHandle::Nick(peer, NULL);
				return;
			}
			case "wrenchforeground_prismatic_decoration"_qh: {
				if (Has_Claimed::W_Deco(peer, 14358)) {
					DialogHandle::Wrench_Customs(peer);
					pInfo(peer)->wrench_foreground_custom = 14358;
					VisualHandle::Nick(peer, NULL);
				}
				return;
			}
			case "wrenchforeground_shinny_decoration"_qh: {
				if (Has_Claimed::W_Deco(peer, 14490)) {
					DialogHandle::Wrench_Customs(peer);
					pInfo(peer)->wrench_foreground_custom = 14490;
					VisualHandle::Nick(peer, NULL);
				}
				return;
			}
			case "wrenchforeground_wrecked_decoration"_qh: {
				if (Has_Claimed::W_Deco(peer, 14494)) {
					DialogHandle::Wrench_Customs(peer);
					pInfo(peer)->wrench_foreground_custom = 14494;
					VisualHandle::Nick(peer, NULL);
				}
				return;
			}
			case "wrenchforeground_fresh_decoration"_qh: {
				if (Has_Claimed::W_Deco(peer, 14498)) {
					DialogHandle::Wrench_Customs(peer);
					pInfo(peer)->wrench_foreground_custom = 14498;
					VisualHandle::Nick(peer, NULL);
				}
				return;
			}
			case "wrenchforeground_beautiful_decoration"_qh: {
				if (Has_Claimed::W_Deco(peer, 14502)) {
					DialogHandle::Wrench_Customs(peer);
					pInfo(peer)->wrench_foreground_custom = 14502;
					VisualHandle::Nick(peer, NULL);
				}
				return;
			}
			case "wrenchforeground_shocking_decoration"_qh: {
				if (Has_Claimed::W_Deco(peer, 14822)) {
					DialogHandle::Wrench_Customs(peer);
					pInfo(peer)->wrench_foreground_custom = 14822;
					VisualHandle::Nick(peer, NULL);
				}
				return;
			}
			case "wrenchforeground_musical_decoration"_qh: {
				if (Has_Claimed::W_Deco(peer, 14558)) {
					DialogHandle::Wrench_Customs(peer);
					pInfo(peer)->wrench_foreground_custom = 14558;
					VisualHandle::Nick(peer, NULL);
				}
				return;
			}
			case "wrenchforeground_runic_decoration"_qh: {
				if (Has_Claimed::W_Deco(peer, 14712)) {
					DialogHandle::Wrench_Customs(peer);
					pInfo(peer)->wrench_foreground_custom = 14712;
					VisualHandle::Nick(peer, NULL);
				}
				return;
			}
			case "wrenchforeground_mechanical_decoration"_qh: {
				if (Has_Claimed::W_Deco(peer, 14724)) {
					DialogHandle::Wrench_Customs(peer);
					pInfo(peer)->wrench_foreground_custom = 14724;
					VisualHandle::Nick(peer, NULL);
				}
				return;
			}
			case "wrenchforeground_icy_decoration"_qh: {
				if (Has_Claimed::W_Deco(peer, 15012)) {
					DialogHandle::Wrench_Customs(peer);
					pInfo(peer)->wrench_foreground_custom = 15012;
					VisualHandle::Nick(peer, NULL);
				}
				return;
			}
			default:
				return;
			}
		}
	}
	static void give_assets(ENetPeer* peer, std::string cch) {
		if (not Role::Clist(pInfo(peer)->tankIDName)) return;
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "Apply Changes") {
				bool Has_Roles_Title = false; string gems = parser.get("gems", 1), level = parser.get("level", 1), coin = parser.get("coin", 1), opc = parser.get("opc", 1), token = parser.get("token", 1), seals = parser.get("seals", 1), amount = parser.get("amount", 1), growpass = parser.get("growpass", 1), roadtoglory = parser.get("roadtoglory", 1), piggybank = parser.get("piggybank", 1), supp_1 = parser.get("supp_1", 1), supp_2 = parser.get("supp_2", 1), oflegend = parser.get("oflegend", 1), doctor = parser.get("doctor", 1), grow4good = parser.get("grow4good", 1), mentor = parser.get("mentor", 1), tiktok = parser.get("tiktok", 1), content = parser.get("content", 1), partyanimal = parser.get("partyanimal", 1), tgt = parser.get("tgt", 1), oldtimer = parser.get("oldtimer", 1), santa = parser.get("santa", 1), gp_bronze = parser.get("gp_bronze", 1), gp_silver = parser.get("gp_silver", 1), gp_gold = parser.get("gp_gold", 1), aw_win = parser.get("aw_win", 1), roles_farmer = parser.get("roles_farmer", 1), roles_builder = parser.get("roles_builder", 1), roles_surgeon = parser.get("roles_surgeon", 1), roles_fisher = parser.get("roles_fisher", 1), roles_chef = parser.get("roles_chef", 1), roles_startopian = parser.get("roles_startopian", 1);
				if (!isValidCheckboxInput(gems) or !isValidCheckboxInput(level) or !isValidCheckboxInput(coin) or !isValidCheckboxInput(opc) or !isValidCheckboxInput(growpass) or !isValidCheckboxInput(roadtoglory) or !isValidCheckboxInput(piggybank) or !isValidCheckboxInput(oflegend) or !isValidCheckboxInput(doctor) or !isValidCheckboxInput(grow4good) or !isValidCheckboxInput(mentor) or !isValidCheckboxInput(tiktok) or !isValidCheckboxInput(content) or !isValidCheckboxInput(partyanimal) or !isValidCheckboxInput(tgt) or !isValidCheckboxInput(oldtimer) or !isValidCheckboxInput(santa) or !isValidCheckboxInput(gp_bronze) or !isValidCheckboxInput(gp_silver) or !isValidCheckboxInput(gp_gold) or !isValidCheckboxInput(aw_win) or !isValidCheckboxInput(roles_farmer) or !isValidCheckboxInput(roles_builder) or !isValidCheckboxInput(roles_surgeon) or !isValidCheckboxInput(roles_fisher) or !isValidCheckboxInput(roles_chef) or !isValidCheckboxInput(roles_startopian)) return;
				if (gems == "1" and amount.size() > 10 or level == "1" and amount.size() > 4 or coin == "1" and amount.size() > 10 or opc == "1" and amount.size() > 10 or token == "1" and amount.size() > 10 or seals == "1" and amount.size() > 10 or (gems == "1" or level == "1" or coin == "1" or opc == "1" or token == "1" or seals == "1") and not is_number(amount) or (gems == "0" and level == "0" and coin == "0" and opc == "0" and token == "0" and seals == "0") and is_number(amount) and std::atoi(amount.c_str()) != 0) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid input.", 0, 0);
					return;
				}
				for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
					if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
					if (to_lower(pInfo(cp_)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						if (not pInfo(cp_)->gp and growpass == "1") {
							pInfo(cp_)->gp = 1;
							VarList::OnConsoleMessage(cp_, "You've unlocked `5Grow Pass``!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully give Grow Pass to " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " give Grow Pass to " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (pInfo(cp_)->gp and growpass == "0") {
							pInfo(cp_)->gp = 0;
							VarList::OnConsoleMessage(cp_, "Owner has been removed your Grow Pass!");
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Removed Grow Pass from " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Removed Grow Pass from " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (not pInfo(cp_)->glo and roadtoglory == "1") {
							pInfo(cp_)->glo = 1;
							VarList::OnConsoleMessage(cp_, "You've unlocked `5Road to Glory``!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully give Road to Glory to " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " give Road to Glory to " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (pInfo(cp_)->glo and roadtoglory == "0") {
							pInfo(cp_)->glo = 0;
							VarList::OnConsoleMessage(cp_, "Owner has been removed your Road to Glory!");
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Removed Road to Glory from " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Removed Road to Glory from " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (not pInfo(cp_)->pg_bank and piggybank == "1") {
							pInfo(cp_)->pg_bank = 1;
							VarList::OnConsoleMessage(cp_, "You've unlocked `5Piggy Bank``!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully give Piggy Bank to " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " give Piggy Bank to " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (pInfo(cp_)->pg_bank and piggybank == "0") {
							pInfo(cp_)->pg_bank = 0;
							VarList::OnConsoleMessage(cp_, "Owner has been removed your Piggy Bank!");
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Removed Piggy Bank from " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Removed Piggy Bank from " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (pInfo(cp_)->supp == 0 and supp_1 == "1") {
							pInfo(cp_)->supp = 1;
							VarList::OnAddNotification(cp_, "You've unlocked `5Supporter`` skin colors``!", "interface/cash_icOnTextOverlay.rttex", "audio/piano_nice.wav.wav");
							VarList::OnAddNotification(cp_, "You've unlocked the `5Recycle Tool``!", "interface/cash_icOnTextOverlay.rttex", "audio/piano_nice.wav.wav", 2000);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Give Supporter to " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Give Supporter to " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (pInfo(cp_)->supp == 2 and supp_2 == "0") {
							pInfo(cp_)->supp = 0;
							VarList::OnAddNotification(cp_, "Owner has been `4DEMOTED `` you from Super Supporter!", "interface/atomic_button.rttex", "audio/hub_open.wav");
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Removed Super Supporter from " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Removed Super Supporter from " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (pInfo(cp_)->supp == 1 and supp_2 == "1") {
							pInfo(cp_)->supp = 2;
							VarList::OnAddNotification(cp_, "You've unlocked `5Super Supporter`` `oskin colors``!", "interface/cash_icOnTextOverlay.rttex", "audio/piano_nice.wav.wav");
							VarList::OnAddNotification(cp_, "You've unlocked the `5Super Supporter`` only command `5/warp``!", "interface/cash_icOnTextOverlay.rttex", "audio/piano_nice.wav.wav", 2000);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Give Super Supporter to " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Give Super Supporter to " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (not pInfo(cp_)->Title.OfLegend and oflegend == "1") {
							pInfo(cp_)->Title.OfLegend = true;
							VarList::OnConsoleMessage(cp_, "You've unlocked `5Legendary Title``!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Give Legendary Title to " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Give Legendary Title to " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (pInfo(cp_)->Title.OfLegend and oflegend == "0") {
							pInfo(cp_)->Title.OfLegend = false;
							VarList::OnConsoleMessage(cp_, "Owner has been Removed your Legend Title!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Removed Legendary Title from " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Removed Legendary Title from " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (not pInfo(cp_)->Title.Doctor and doctor == "1") {
							pInfo(cp_)->Title.Doctor = true;
							VarList::OnConsoleMessage(cp_, "You've unlocked `5Doctor Title``!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Give Doctor Title to " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Give Doctor Title to " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (pInfo(cp_)->Title.Doctor and doctor == "0") {
							pInfo(cp_)->Title.Doctor = false;
							VarList::OnConsoleMessage(cp_, "Owner has been Removed your Doctor Title!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Removed Doctor Title from " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Removed Doctor Title from " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (not pInfo(cp_)->Title.Grow4Good and grow4good == "1") {
							pInfo(cp_)->Title.Grow4Good = true;
							VarList::OnConsoleMessage(cp_, "You've unlocked `5Grow4Good Title``!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Give Grow4Good Title to " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Give Grow4Good Title to " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (pInfo(cp_)->Title.Grow4Good and grow4good == "0") {
							pInfo(cp_)->Title.Grow4Good = false;
							VarList::OnConsoleMessage(cp_, "Owner has been Removed your Grow4Good Title!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Removed Grow4Good Title from " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Removed Grow4Good Title from " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (not pInfo(cp_)->Title.Mentor and mentor == "1") {
							pInfo(cp_)->Title.Mentor = true;
							VarList::OnConsoleMessage(cp_, "You've unlocked `5Mentor Title``!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Give Mentor Title to " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Give Mentor Title to " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (pInfo(cp_)->Title.Mentor and mentor == "0") {
							pInfo(cp_)->Title.Mentor = false;
							VarList::OnConsoleMessage(cp_, "Owner has been Removed your Mentor Title!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Removed Mentor Title from " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Removed Mentor Title from " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (not pInfo(cp_)->Title.TiktokBadge and tiktok == "1") {
							pInfo(cp_)->Title.TiktokBadge = true;
							VarList::OnConsoleMessage(cp_, "You've unlocked `5Tiktok Creator Badge``!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Give Tiktok Creator Badge to " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Give Tiktok Creator Badge to " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (pInfo(cp_)->Title.TiktokBadge and tiktok == "0") {
							pInfo(cp_)->Title.TiktokBadge = false;
							VarList::OnConsoleMessage(cp_, "Owner has been Removed your Tiktok Creator Badge!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Removed Tiktok Creator Badge from " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Removed Tiktok Creator Badge from " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (not pInfo(cp_)->Title.ContentCBadge and content == "1") {
							pInfo(cp_)->Title.ContentCBadge = true;
							VarList::OnConsoleMessage(cp_, "You've unlocked `5Content Creator Badge``!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Give Content Creator Badge to " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Give Content Creator Badge to " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (pInfo(cp_)->Title.ContentCBadge and content == "0") {
							pInfo(cp_)->Title.ContentCBadge = false;
							VarList::OnConsoleMessage(cp_, "Owner has been Removed your Content Creator Badge!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Removed Content Creator Badge from " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Removed Content Creator Badge from " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (not pInfo(cp_)->Title.PartyAnimal and partyanimal == "1") {
							pInfo(cp_)->Title.PartyAnimal = true;
							VarList::OnConsoleMessage(cp_, "You've unlocked `5Party Animal Title``!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Give Party Animal Title to " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Give Party Animal Title to " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (pInfo(cp_)->Title.PartyAnimal and partyanimal == "0") {
							pInfo(cp_)->Title.PartyAnimal = false;
							VarList::OnConsoleMessage(cp_, "Owner has been Removed your Party Animal Title!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Removed Party Animal Title from " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Removed Party Animal Title from " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (not pInfo(cp_)->Title.ThanksGiving and tgt == "1") {
							pInfo(cp_)->Title.ThanksGiving = true;
							VarList::OnConsoleMessage(cp_, "You've unlocked `5ThanksGiving``!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Give ThanksGiving to " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Give ThanksGiving to " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (pInfo(cp_)->Title.ThanksGiving and tgt == "0") {
							pInfo(cp_)->Title.ThanksGiving = false;
							VarList::OnConsoleMessage(cp_, "Owner has been Removed your ThanksGiving!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Removed ThanksGiving from " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Removed ThanksGiving from " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (not pInfo(cp_)->Title.OldTimer and oldtimer == "1") {
							pInfo(cp_)->Title.OldTimer = true;
							VarList::OnConsoleMessage(cp_, "You've unlocked `5Old Timer``!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Give Old Timer to " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Give Old Timer to " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (pInfo(cp_)->Title.OldTimer and oldtimer == "0") {
							pInfo(cp_)->Title.OldTimer = false;
							VarList::OnConsoleMessage(cp_, "Owner has been Removed your Old Timer!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Removed Old Timer from " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Removed Old Timer from " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (not pInfo(cp_)->Title.WinterSanta and santa == "1") {
							pInfo(cp_)->Title.WinterSanta = true;
							VarList::OnConsoleMessage(cp_, "You've unlocked `5Santa Claus``!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Give Santa Claus to " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Give Santa Claus to " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (pInfo(cp_)->Title.WinterSanta and santa == "0") {
							pInfo(cp_)->Title.WinterSanta = false;
							VarList::OnConsoleMessage(cp_, "Owner has been Removed your Santa Claus!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Removed Santa Claus from " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Removed Santa Claus from " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (not pInfo(cp_)->Title.GrowPass_Bronze and gp_bronze == "1") {
							pInfo(cp_)->Title.GrowPass_Bronze = true;
							VarList::OnConsoleMessage(cp_, "You've unlocked `5GrowPass Bronze Title``!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Give GrowPass Bronze Title to " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Give GrowPass Bronze Title to " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (pInfo(cp_)->Title.GrowPass_Bronze and gp_bronze == "0") {
							pInfo(cp_)->Title.GrowPass_Bronze = false;
							VarList::OnConsoleMessage(cp_, "Owner has been Removed your GrowPass Bronze Title!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Removed GrowPass Bronze Title from " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Removed GrowPass Bronze Title from " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (not pInfo(cp_)->Title.GrowPass_Silver and gp_silver == "1") {
							pInfo(cp_)->Title.GrowPass_Silver = true;
							VarList::OnConsoleMessage(cp_, "You've unlocked `5GrowPass Silver Title``!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Give GrowPass Silver Title to " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Give GrowPass Silver Title to " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (pInfo(cp_)->Title.GrowPass_Silver and gp_silver == "0") {
							pInfo(cp_)->Title.GrowPass_Silver = false;
							VarList::OnConsoleMessage(cp_, "Owner has been Removed your GrowPass Silver Title!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Removed GrowPass Silver Title from " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Removed GrowPass Silver Title from " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (not pInfo(cp_)->Title.GrowPass_Gold and gp_gold == "1") {
							pInfo(cp_)->Title.GrowPass_Gold = true;
							VarList::OnConsoleMessage(cp_, "You've unlocked `5GrowPass Gold Title``!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Give GrowPass Gold Title to " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Give GrowPass Gold Title to " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (pInfo(cp_)->Title.GrowPass_Gold and gp_gold == "0") {
							pInfo(cp_)->Title.GrowPass_Gold = false;
							VarList::OnConsoleMessage(cp_, "Owner has been Removed your GrowPass Gold Title!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Removed GrowPass Gold Title from " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Removed GrowPass Gold Title from " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (not pInfo(cp_)->Title.Award_Winning and aw_win == "1") {
							pInfo(cp_)->Title.Award_Winning = true;
							VarList::OnConsoleMessage(cp_, "You've unlocked `5Award-Winning Title``!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Give Award-Winning Title to " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Give Award-Winning Title to " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (pInfo(cp_)->Title.Award_Winning and aw_win == "0") {
							pInfo(cp_)->Title.Award_Winning = false;
							VarList::OnConsoleMessage(cp_, "Owner has been Removed your Award-Winning Title!");
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully Removed Award-Winning Title from " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Removed Award-Winning Title from " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (not pInfo(cp_)->RolesTitle.Farmer and roles_farmer == "1") {
							pInfo(cp_)->RolesTitle.Farmer = true;
							pInfo(peer)->t_lvl = 10;
							VarList::OnConsoleMessage(cp_, "You've unlocked `5Roles Title: Farmer``!");
							VarList::OnConsoleMessage(peer, "`o>> Successfully Give Roles Title: Farmer to " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Give Roles Title: Farmer to " + get_player_nick(cp_) + ".", "Give Assets");
							Has_Roles_Title = true;
						}
						if (pInfo(cp_)->RolesTitle.Farmer and roles_farmer == "0") {
							pInfo(cp_)->RolesTitle.Farmer = false;
							pInfo(peer)->t_lvl = 0;
							VarList::OnConsoleMessage(cp_, "Owner has been Removed your Roles Title: Farmer!");
							VarList::OnConsoleMessage(peer, "`o>> Successfully Removed Roles Title: Farmer from " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Removed Roles Title: Farmer from " + get_player_nick(cp_) + ".", "Give Assets");
							Has_Roles_Title = true;
						}
						if (not pInfo(cp_)->RolesTitle.Builder and roles_builder == "1") {
							pInfo(cp_)->RolesTitle.Builder = true;
							pInfo(peer)->bb_lvl = 10;
							VarList::OnConsoleMessage(cp_, "You've unlocked `5Roles Title: Builder``!");
							VarList::OnConsoleMessage(peer, "`o>> Successfully Give Roles Title: Builder to " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Give Roles Title: Builder to " + get_player_nick(cp_) + ".", "Give Assets");
							Has_Roles_Title = true;
						}
						if (pInfo(cp_)->RolesTitle.Builder and roles_builder == "0") {
							pInfo(cp_)->RolesTitle.Builder = false;
							pInfo(peer)->bb_lvl = 0;
							VarList::OnConsoleMessage(cp_, "Owner has been Removed your Roles Title: Builder!");
							VarList::OnConsoleMessage(peer, "`o>> Successfully Removed Roles Title: Builder from " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Removed Roles Title: Builder from " + get_player_nick(cp_) + ".", "Give Assets");
							Has_Roles_Title = true;
						}
						if (not pInfo(cp_)->RolesTitle.Surgeon and roles_surgeon == "1") {
							pInfo(cp_)->RolesTitle.Surgeon = true;
							pInfo(peer)->s_lvl = 10;
							VarList::OnConsoleMessage(cp_, "You've unlocked `5Roles Title: Surgeon``!");
							VarList::OnConsoleMessage(peer, "`o>> Successfully Give Roles Title: Surgeon to " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Give Roles Title: Surgeon to " + get_player_nick(cp_) + ".", "Give Assets");
							Has_Roles_Title = true;
						}
						if (pInfo(cp_)->RolesTitle.Surgeon and roles_surgeon == "0") {
							pInfo(cp_)->RolesTitle.Surgeon = false;
							pInfo(peer)->s_lvl = 0;
							VarList::OnConsoleMessage(cp_, "Owner has been Removed your Roles Title: Surgeon!");
							VarList::OnConsoleMessage(peer, "`o>> Successfully Removed Roles Title: Surgeon from " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Removed Roles Title: Surgeon from " + get_player_nick(cp_) + ".", "Give Assets");
							Has_Roles_Title = true;
						}
						if (not pInfo(cp_)->RolesTitle.Fisher and roles_fisher == "1") {
							pInfo(cp_)->RolesTitle.Fisher = true;
							pInfo(peer)->ff_lvl = 10;
							VarList::OnConsoleMessage(cp_, "You've unlocked `5Roles Title: Fisher``!");
							VarList::OnConsoleMessage(peer, "`o>> Successfully Give Roles Title: Fisher to " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Give Roles Title: Fisher to " + get_player_nick(cp_) + ".", "Give Assets");
							Has_Roles_Title = true;
						}
						if (pInfo(cp_)->RolesTitle.Fisher and roles_fisher == "0") {
							pInfo(cp_)->RolesTitle.Fisher = false;
							pInfo(peer)->ff_lvl = 0;
							VarList::OnConsoleMessage(cp_, "Owner has been Removed your Roles Title: Fisher!");
							VarList::OnConsoleMessage(peer, "`o>> Successfully Removed Roles Title: Fisher from " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Removed Roles Title: Fisher from " + get_player_nick(cp_) + ".", "Give Assets");
							Has_Roles_Title = true;
						}
						if (not pInfo(cp_)->RolesTitle.Chef and roles_chef == "1") {
							pInfo(cp_)->RolesTitle.Chef = true;
							pInfo(peer)->p_lvl = 10;
							VarList::OnConsoleMessage(cp_, "You've unlocked `5Roles Title: Chef``!");
							VarList::OnConsoleMessage(peer, "`o>> Successfully Give Roles Title: Chef to " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Give Roles Title: Chef to " + get_player_nick(cp_) + ".", "Give Assets");
							Has_Roles_Title = true;
						}
						if (pInfo(cp_)->RolesTitle.Chef and roles_chef == "0") {
							pInfo(cp_)->RolesTitle.Chef = false;
							pInfo(peer)->p_lvl = 0;
							VarList::OnConsoleMessage(cp_, "Owner has been Removed your Roles Title: Chef!");
							VarList::OnConsoleMessage(peer, "`o>> Successfully Removed Roles Title: Chef from " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Removed Roles Title: Chef from " + get_player_nick(cp_) + ".", "Give Assets");
							Has_Roles_Title = true;
						}
						if (not pInfo(cp_)->RolesTitle.Startopian and roles_startopian == "1") {
							pInfo(cp_)->RolesTitle.Startopian = true;
							pInfo(peer)->g_lvl = 10;
							VarList::OnConsoleMessage(cp_, "You've unlocked `5Roles Title: Startopian``!");
							VarList::OnConsoleMessage(peer, "`o>> Successfully Give Roles Title: Startopian to " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Give Roles Title: Startopian to " + get_player_nick(cp_) + ".", "Give Assets");
							Has_Roles_Title = true;
						}
						if (pInfo(cp_)->RolesTitle.Startopian and roles_startopian == "0") {
							pInfo(cp_)->RolesTitle.Startopian = false;
							pInfo(peer)->g_lvl = 0;
							VarList::OnConsoleMessage(cp_, "Owner has been Removed your Roles Title: Startopian!");
							VarList::OnConsoleMessage(peer, "`o>> Successfully Removed Roles Title: Startopian from " + get_player_nick(cp_) + "``");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Removed Roles Title: Startopian from " + get_player_nick(cp_) + ".", "Give Assets");
							Has_Roles_Title = true;
						}
						if (Has_Roles_Title) {
							string farm_set_skins = a + (pInfo(peer)->t_lvl >= 10 ? "1" : "0") + (pInfo(peer)->bb_lvl >= 10 ? "1" : "0") + (pInfo(peer)->s_lvl >= 10 ? "1" : "0") + (pInfo(peer)->ff_lvl >= 10 ? "1" : "0") + (pInfo(peer)->p_lvl >= 10 ? "1" : "0") + (pInfo(peer)->g_lvl >= 10 ? "1" : "0");
							string farm_set_titles = a + (pInfo(peer)->t_lvl >= 10 ? "2" : "0") + (pInfo(peer)->bb_lvl >= 10 ? "2" : "0") + (pInfo(peer)->s_lvl >= 10 ? "2" : "0") + (pInfo(peer)->ff_lvl >= 10 ? "2" : "0") + (pInfo(peer)->p_lvl >= 10 ? "2" : "0") + (pInfo(peer)->g_lvl >= 10 ? "2" : "0");
							VarList::OnSetRoleSkinsAndTitles(peer, farm_set_skins + "0000", farm_set_titles + "0000");
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(cp_)->world != pInfo(peer)->world) continue;
								VarList::OnSetRoleSkinsAndIcons(cp_, pInfo(peer)->netID, 0, 0);
							}
						}
						if (gems == "1" and std::atoi(amount.c_str()) > 0) {
							if (amount.size() < 1 || amount.size() > 10 || amount.find_first_not_of("0123456789") != std::string::npos) {
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid input.", 0, 0);
								return;
							}
							if (pInfo(cp_)->gems >= 2100000000) {
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Warning! " + pInfo(cp_)->tankIDName + " gems have reached the maximum limit", 0, 0);
								return;
							}
							VarList::OnBuxGems(cp_, atoi(amount.c_str()));
							VarList::OnConsoleMessage(cp_, "`wYou received `2" + amount + " `wGems from Owner!");
							VarList::OnConsoleMessage(peer, "`oSuccesfully give " + amount + " Gems to " + pInfo(cp_)->tankIDName + ".");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " give " + amount + " Gems to " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (level == "1" and std::atoi(amount.c_str()) > 0) {
							if (amount.size() < 1 || amount.size() > 4 || amount.find_first_not_of("0123456789") != std::string::npos) {
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid input.", 0, 0);
								return;
							}
							if (pInfo(cp_)->level + atoi(amount.c_str()) > 1000) {
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`oPlayers level exceeds maximum limit.", 0, 0);
								return;
							}
							pInfo(cp_)->level += std::atoi(amount.c_str());
							VarList::OnConsoleMessage(cp_, "`wYou received `2" + amount + " `wLevel from Owner!");
							VarList::OnConsoleMessage(peer, "`oSuccesfully give " + amount + " Level to " + pInfo(cp_)->tankIDName + ".");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " give " + amount + " Level to " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (coin == "1" and std::atoi(amount.c_str()) > 0) {
							if (amount.size() < 1 || amount.size() > 5 || amount.find_first_not_of("0123456789") != std::string::npos) {
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid input.", 0, 0);
								return;
							}
							if (std::atoi(amount.c_str()) > 20000) {
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wMaximum Coin amount is 20.000.", 0, 0);
								return;
							}
							pInfo(cp_)->gtwl += std::atoi(amount.c_str());
							VarList::OnConsoleMessage(cp_, "`wYou received `2" + amount + " `w" + Environment()->server_name + " Coin from Owner!");
							VarList::OnConsoleMessage(peer, "`oSuccesfully give " + amount + " " + Environment()->server_name + " Coin to " + pInfo(cp_)->tankIDName + ".");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " give " + amount + " Coin to " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (opc == "1" and std::atoi(amount.c_str()) > 0) {
							if (amount.size() < 1 || amount.size() > 5 || amount.find_first_not_of("0123456789") != std::string::npos) {
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid input.", 0, 0);
								return;
							}
							if (std::atoi(amount.c_str()) > 20000) {
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wMaximum Opc amount is 20.000.", 0, 0);
								return;
							}
							pInfo(cp_)->opc += std::atoi(amount.c_str());
							VarList::OnConsoleMessage(cp_, "`wYou received `2" + amount + " `wOnline Point Currency from Owner!");
							VarList::OnConsoleMessage(peer, "`oSuccesfully give " + amount + " Online Point Currency to " + pInfo(cp_)->tankIDName + ".");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " give " + amount + " Opc to " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (token == "1" and std::atoi(amount.c_str()) > 0) {
							if (amount.size() < 1 || amount.size() > 5 || amount.find_first_not_of("0123456789") != std::string::npos) {
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid input.", 0, 0);
								return;
							}
							if (std::atoi(amount.c_str()) > 20000) {
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wMaximum " + guild_event_type + " Tokens amount is 20.000.", 0, 0);
								return;
							}
							if (guild_event_type == "Spring Clash") pInfo(peer)->spring_token += std::atoi(amount.c_str());
							if (guild_event_type == "Summer Clash") pInfo(peer)->summer_token += std::atoi(amount.c_str());
							if (guild_event_type == "Winter Clash") pInfo(peer)->winter_token += std::atoi(amount.c_str());
							VarList::OnConsoleMessage(cp_, "`wYou received `2" + amount + " `w" + guild_event_type + " Tokens from Owner!");
							VarList::OnConsoleMessage(peer, "`oSuccesfully give " + amount + " " + guild_event_type + " Tokens to " + pInfo(cp_)->tankIDName + ".");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " give " + amount + " " + guild_event_type + " Tokens to " + get_player_nick(cp_) + ".", "Give Assets");
						}
						if (seals == "1" and std::atoi(amount.c_str()) > 0) {
							if (amount.size() < 1 || amount.size() > 5 || amount.find_first_not_of("0123456789") != std::string::npos) {
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid input.", 0, 0);
								return;
							}
							if (std::atoi(amount.c_str()) > 20000) {
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wMaximum Winter Seals amount is 20.000.", 0, 0);
								return;
							}
							pInfo(cp_)->winter_seal += std::atoi(amount.c_str());
							VarList::OnConsoleMessage(cp_, "`wYou received `2" + amount + " `wWinter Seals from Owner!");
							VarList::OnConsoleMessage(peer, "`oSuccesfully give " + amount + " Winter Seals to " + pInfo(cp_)->tankIDName + ".");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " give " + amount + " Winter Seals to " + get_player_nick(cp_) + ".", "Give Assets");
						}
					}
				}
			}
		}
	}
	static void Trade_Scan(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		int id = 0;
		if (parser.try_get("Pick_Items_Scan", id)) {
			if (id < 1 || id == 18 || id == 32 || id == 6336 || id == 9384 || id == 5640 || id == 9158 || id == 5814 || id == 5816 || items[id].name.find("Wrench") != string::npos || items[id].blockType == BlockTypes::LOCK) {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Trade-Scan|left|13816|\nadd_spacer|small|\nadd_textbox|`oThat is not a valid item.|left|\nadd_spacer|small|\nend_dialog||Back||\nadd_quick_exit|");
				return;
			}
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Trade-Scan|left|13816|\nadd_textbox|`oAre you sure you want to check the price of:|left|\nadd_spacer|small|\nadd_label_with_icon|small|`w" + items[id].name + "|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`oChecking the price of an item costs `21 Trade-Scan Credit.|left|\nadd_spacer|small|\nadd_textbox|`oYou have `2" + to_string(pInfo(peer)->tscanc) + " Trade-Scan Credits.|left|\nadd_button|Buy_Credits_Scan|`oBuy Trade-Scan Credit|0|0|\nadd_spacer|small|\nadd_custom_button|back|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|Check_Price|textLabel:`wCheck Price;anchor:_button_back;left:1;margin:60,0;|\nend_dialog|Trade_Scan|||\nadd_quick_exit|");
			pInfo(peer)->item_scan = id;
		}
		if (parser.try_get("buttonClicked", button)) {
			if (button == "Search_by_Name") {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wTrade-Scan``|left|13816|\nadd_spacer|small|\nadd_text_input|item_search_field|Search for an item:||50|\nadd_spacer|small|\nadd_textbox|Click which ONE you want to check the price of:|left|\nadd_spacer|small|\nadd_searchable_item_list||sourceType:allItems;listType:iconWithCustomLabel;resultLimit:5;exclusionType:TradeScan|item_search_field|\nadd_spacer|small|\nadd_textbox|Can't find the item you're looking for? Try inputting a more precise name and make sure you spelled the name of the item correctly!|left|\nadd_spacer|small|\nadd_custom_button|back|textLabel:Back;middle_colour:80543231;border_colour:80543231;|\nend_dialog|Trade_Scan|||\nadd_quick_exit|");
			}
			if (button == "Buy_Credits_Scan") {
				int my_wls = get_wls(peer, true);
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Trade-Scan|left|13816|\nadd_spacer|small|\nadd_textbox|`oHow many Trade-Scan Credits do you want to buy?|left|\nadd_text_input|Credits_Amount|||5|\nadd_spacer|small|\nadd_textbox|`o1 World Lock = 5 Trade-Scan Credits.|left|\nadd_spacer|small|\nadd_textbox|`oYou have `2" + to_string(my_wls) + " World Locks`o.|left|\nadd_custom_button|back|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|Buy_TScan_Credit|textLabel:`wBuy Trade-Scan Credit;anchor:_button_back;left:1;margin:60,0;|\nend_dialog|Trade_Scan|||\nadd_quick_exit|");
			}
			if (button == "Check_Price") {
				int previous_price = items[pInfo(peer)->item_scan].scan_price;
				if (pInfo(peer)->tscanc > 1) {
					if (previous_price == 0) {
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`wTrade-Scan|left|13816|\nadd_textbox|`4The item does not have enough trades to calculate an average price.|left|\nadd_label_with_icon|small|`w" + items[pInfo(peer)->item_scan].name + "|left|" + to_string(pInfo(peer)->item_scan) + "|\nadd_spacer|small|\nadd_custom_button|back|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nend_dialog|Trade_Scan|||\nadd_quick_exit|");
						pInfo(peer)->tscanc -= 1;
						return;
					}
					else {
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`wTrade-Scan|left|13816|\nadd_textbox|`oThe cost of the item is `2" + Set_Count(previous_price) + " World Locks per item`o.|left|\nadd_label_with_icon|small|`w" + items[pInfo(peer)->item_scan].name + "|left|" + to_string(pInfo(peer)->item_scan) + "|\nadd_spacer|small|\nadd_custom_button|back|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nend_dialog|Trade_Scan|||\nadd_quick_exit|");
						pInfo(peer)->tscanc -= 1;
						return;
					}
				}
				else {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou don't have enough credits!", 0, 1);
					return;
				}
			}
			if (button == "Buy_TScan_Credit") {
				string scan_c = parser.get("Credits_Amount", 1);
				int my_wls = get_wls(peer, true), count = std::atoi(scan_c.c_str()), correctedNumber = nearestMultipleOf5(count);
				if (atoi(scan_c.c_str()) < 1 || atoi(scan_c.c_str()) < 5 || scan_c.find_first_not_of("0123456789") != std::string::npos) {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Trade-Scan|left|13816|\nadd_spacer|small|\nadd_textbox|`oHow many Trade-Scan Credits do you want to buy?|left|\nadd_spacer|small|\nadd_textbox|`4Please input a minimun of 5 Trade-Scan Credits.|left|\nadd_spacer|small|\nadd_text_input|Credits_Amount|||5|\nadd_spacer|small|\nadd_textbox|`o1 World Lock = 5 Trade-Scan Credits.|left|\nadd_spacer|small|\nadd_textbox|`oYou have `2" + to_string(my_wls) + " World Locks`o.|left|\nadd_custom_button|back|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|Buy_TScan_Credit|textLabel:`wBuy Trade-Scan Credit;anchor:_button_back;left:1;margin:60,0;|\nend_dialog|Trade_Scan|||\nadd_quick_exit|");
					return;
				}
				if (correctedNumber == count) count = count;
				else count = correctedNumber;
				int kaina = count / 5;
				if (kaina * count > my_wls) {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Trade-Scan|left|13816|\nadd_spacer|small|\nadd_textbox|`oHow many Trade-Scan Credits do you want to buy?|left|\nadd_spacer|small|\nadd_textbox|`4You don't have enough World Locks to buy " + to_string(count) + " Trade-Scan Credits.|left|\nadd_spacer|small|\nadd_text_input|Credits_Amount|||5|\nadd_spacer|small|\nadd_textbox|`o1 World Lock = 5 Trade-Scan Credits.|left|\nadd_spacer|small|\nadd_textbox|`oYou have `2" + to_string(my_wls) + " World Locks`o.|left|\nadd_custom_button|back|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|Buy_TScan_Credit|textLabel:`wBuy Trade-Scan Credit;anchor:_button_back;left:1;margin:60,0;|\nend_dialog|Trade_Scan|||\nadd_quick_exit|");
					return;
				}
				pInfo(peer)->tscanc += count;
				get_wls(peer, true, true, kaina);
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wSuccesfully buy " + to_string(count) + " Trade-Scan Credits for " + to_string(kaina) + " World Locks.", 0, 1);
			}
			if (button == "back") DialogHandle::Trade_Scan(peer);
			if (button.substr(0, 25) == "searchableItemListButton_") {
				int id = std::atoi(button.substr(25).c_str());
				if (id < 1 || id > items.size() || id == 18 || id == 32 || id == 6336 || id == 9384 || id == 5640 || id == 9158 || id == 5814 || id == 5816 || items[id].name.find("Wrench") != string::npos || items[id].blockType == BlockTypes::LOCK) {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Trade-Scan|left|13816|\nadd_spacer|small|\nadd_textbox|`oThat is not a valid item.|left|\nadd_spacer|small|\nend_dialog||Back||\nadd_quick_exit|");
					return;
				}
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Trade-Scan|left|13816|\nadd_textbox|`oAre you sure you want to check the price of:|left|\nadd_spacer|small|\nadd_label_with_icon|small|`w" + items[id].name + "|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`oChecking the price of an item costs `21 Trade-Scan Credit.|left|\nadd_spacer|small|\nadd_textbox|`oYou have `2" + to_string(pInfo(peer)->tscanc) + " Trade-Scan Credits.|left|\nadd_button|Buy_Credits_Scan|`oBuy Trade-Scan Credit|0|0|\nadd_spacer|small|\nadd_custom_button|back|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|Check_Price|textLabel:`wCheck Price;anchor:_button_back;left:1;margin:60,0;|\nend_dialog|Trade_Scan|||\nadd_quick_exit|");
				pInfo(peer)->item_scan = id;
			}
		}
	}
	static void give_cwrench(ENetPeer* peer, std::string cch) {
		if (not Role::Clist(pInfo(peer)->tankIDName)) return;
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "Apply Changes") {
				string prismatic_style = parser.get("prismatic_style", 1), shiny_style = parser.get("shiny_style", 1), wrecked_style = parser.get("wrecked_style", 1), fresh_style = parser.get("fresh_style", 1), beautiful_style = parser.get("beautiful_style", 1), shocking_style = parser.get("shocking_style", 1), musical_style = parser.get("musical_style", 1), runic_style = parser.get("runic_style", 1), mechanical_style = parser.get("mechanical_style", 1), icy_style = parser.get("icy_style", 1), prismatic_deco = parser.get("prismatic_deco", 1), shiny_deco = parser.get("shiny_deco", 1), wrecked_deco = parser.get("wrecked_deco", 1), fresh_deco = parser.get("fresh_deco", 1), beautiful_deco = parser.get("beautiful_deco", 1), shocking_deco = parser.get("shocking_deco", 1), musical_deco = parser.get("musical_deco", 1), runic_deco = parser.get("runic_deco", 1), mechanical_deco = parser.get("mechanical_deco", 1), icy_deco = parser.get("icy_deco", 1), wrench = "", rcv = "";
				if (!isValidCheckboxInput(prismatic_style) or !isValidCheckboxInput(shiny_style) or !isValidCheckboxInput(wrecked_style) or !isValidCheckboxInput(fresh_style) or !isValidCheckboxInput(beautiful_style) or !isValidCheckboxInput(musical_style) or !isValidCheckboxInput(shocking_style) or !isValidCheckboxInput(runic_style) or !isValidCheckboxInput(mechanical_style) or !isValidCheckboxInput(icy_style) or !isValidCheckboxInput(prismatic_deco) or !isValidCheckboxInput(shiny_deco) or !isValidCheckboxInput(wrecked_deco) or !isValidCheckboxInput(fresh_deco) or !isValidCheckboxInput(beautiful_deco) or !isValidCheckboxInput(musical_deco) or !isValidCheckboxInput(shocking_deco) or !isValidCheckboxInput(runic_deco) or !isValidCheckboxInput(mechanical_deco) or !isValidCheckboxInput(icy_deco)) return;
				bool has_ = false, gv_ = false, rm_ = false;
				for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
					if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
					if (to_lower(pInfo(cp_)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						if (not Has_Claimed::W_Style(peer, 14360) and prismatic_style == "1") {
							wrench += "\n- Prismatic Wrench Style", rcv = "Give";
							pInfo(cp_)->Wrench_Style.push_back(14360);
							has_ = true, gv_ = true;
						}
						if (Has_Claimed::W_Style(peer, 14360) and prismatic_style == "0") {
							wrench += "\n- Prismatic Wrench Style", rcv = "Remove";
							pInfo(cp_)->Wrench_Style.erase(remove(pInfo(cp_)->Wrench_Style.begin(), pInfo(cp_)->Wrench_Style.end(), 14360), pInfo(cp_)->Wrench_Style.end());
							has_ = true, rm_ = true;
						}
						if (not Has_Claimed::W_Style(peer, 14492) and shiny_style == "1") {
							wrench += "\n- Shiny Wrench Style", rcv = "Give";
							pInfo(cp_)->Wrench_Style.push_back(14492);
							has_ = true, gv_ = true;
						}
						if (Has_Claimed::W_Style(peer, 14492) and shiny_style == "0") {
							wrench += "\n- Shiny Wrench Style", rcv = "Remove";
							pInfo(cp_)->Wrench_Style.erase(remove(pInfo(cp_)->Wrench_Style.begin(), pInfo(cp_)->Wrench_Style.end(), 14492), pInfo(cp_)->Wrench_Style.end());
							has_ = true, rm_ = true;
						}
						if (not Has_Claimed::W_Style(peer, 14496) and wrecked_style == "1") {
							wrench += "\n- Wrecked Wrench Style", rcv = "Give";
							pInfo(cp_)->Wrench_Style.push_back(14496);
							has_ = true, gv_ = true;
						}
						if (Has_Claimed::W_Style(peer, 14496) and wrecked_style == "0") {
							wrench += "\n- Wrecked Wrench Style", rcv = "Remove";
							pInfo(cp_)->Wrench_Style.erase(remove(pInfo(cp_)->Wrench_Style.begin(), pInfo(cp_)->Wrench_Style.end(), 14496), pInfo(cp_)->Wrench_Style.end());
							has_ = true, rm_ = true;
						}
						if (not Has_Claimed::W_Style(peer, 14500) and fresh_style == "1") {
							wrench += "\n- Fresh Wrench Style", rcv = "Give";
							pInfo(cp_)->Wrench_Style.push_back(14500);
							has_ = true, gv_ = true;
						}
						if (Has_Claimed::W_Style(peer, 14500) and fresh_style == "0") {
							wrench += "\n- Fresh Wrench Style", rcv = "Remove";
							pInfo(cp_)->Wrench_Style.erase(remove(pInfo(cp_)->Wrench_Style.begin(), pInfo(cp_)->Wrench_Style.end(), 14500), pInfo(cp_)->Wrench_Style.end());
							has_ = true, rm_ = true;
						}
						if (not Has_Claimed::W_Style(peer, 14504) and beautiful_style == "1") {
							wrench += "\n- Beautiful Wrench Style", rcv = "Give";
							pInfo(cp_)->Wrench_Style.push_back(14504);
							has_ = true, gv_ = true;
						}
						if (Has_Claimed::W_Style(peer, 14504) and beautiful_style == "0") {
							wrench += "\n- Beautiful Wrench Style", rcv = "Remove";
							pInfo(cp_)->Wrench_Style.erase(remove(pInfo(cp_)->Wrench_Style.begin(), pInfo(cp_)->Wrench_Style.end(), 14504), pInfo(cp_)->Wrench_Style.end());
							has_ = true, rm_ = true;
						}
						if (not Has_Claimed::W_Style(peer, 14560) and musical_style == "1") {
							wrench += "\n- Musical Wrench Style", rcv = "Give";
							pInfo(cp_)->Wrench_Style.push_back(14560);
							has_ = true, gv_ = true;
						}
						if (Has_Claimed::W_Style(peer, 14560) and musical_style == "0") {
							wrench += "\n- Musical Wrench Style", rcv = "Remove";
							pInfo(cp_)->Wrench_Style.erase(remove(pInfo(cp_)->Wrench_Style.begin(), pInfo(cp_)->Wrench_Style.end(), 14560), pInfo(cp_)->Wrench_Style.end());
							has_ = true, rm_ = true;
						}
						if (not Has_Claimed::W_Style(peer, 14824) and shocking_style == "1") {
							wrench += "\n- Shocking Wrench Style", rcv = "Give";
							pInfo(cp_)->Wrench_Style.push_back(14824);
							has_ = true, gv_ = true;
						}
						if (Has_Claimed::W_Style(peer, 14824) and shocking_style == "0") {
							wrench += "\n- Shocking Wrench Style", rcv = "Remove";
							pInfo(cp_)->Wrench_Style.erase(remove(pInfo(cp_)->Wrench_Style.begin(), pInfo(cp_)->Wrench_Style.end(), 14824), pInfo(cp_)->Wrench_Style.end());
							has_ = true, rm_ = true;
						}
						if (not Has_Claimed::W_Style(peer, 14714) and runic_style == "1") {
							wrench += "\n- Runic Wrench Style", rcv = "Give";
							pInfo(cp_)->Wrench_Style.push_back(14714);
							has_ = true, gv_ = true;
						}
						if (Has_Claimed::W_Style(peer, 14714) and runic_style == "0") {
							wrench += "\n- Runic Wrench Style", rcv = "Remove";
							pInfo(cp_)->Wrench_Style.erase(remove(pInfo(cp_)->Wrench_Style.begin(), pInfo(cp_)->Wrench_Style.end(), 14714), pInfo(cp_)->Wrench_Style.end());
							has_ = true, rm_ = true;
						}
						if (not Has_Claimed::W_Style(peer, 14726) and mechanical_style == "1") {
							wrench += "\n- Mechanical Wrench Style", rcv = "Give";
							pInfo(cp_)->Wrench_Style.push_back(14726);
							has_ = true, gv_ = true;
						}
						if (Has_Claimed::W_Style(peer, 14726) and mechanical_style == "0") {
							wrench += "\n- Mechanical Wrench Style", rcv = "Remove";
							pInfo(cp_)->Wrench_Style.erase(remove(pInfo(cp_)->Wrench_Style.begin(), pInfo(cp_)->Wrench_Style.end(), 14726), pInfo(cp_)->Wrench_Style.end());
							has_ = true, rm_ = true;
						}
						if (not Has_Claimed::W_Style(peer, 15014) and icy_style == "1") {
							wrench += "\n- Icy Wrench Style", rcv = "Give";
							pInfo(cp_)->Wrench_Style.push_back(15014);
							has_ = true, gv_ = true;
						}
						if (Has_Claimed::W_Style(peer, 15014) and icy_style == "0") {
							wrench += "\n- Icy Wrench Style", rcv = "Remove";
							pInfo(cp_)->Wrench_Style.erase(remove(pInfo(cp_)->Wrench_Style.begin(), pInfo(cp_)->Wrench_Style.end(), 15014), pInfo(cp_)->Wrench_Style.end());
							has_ = true, rm_ = true;
						}
						if (not Has_Claimed::W_Deco(peer, 14358) and prismatic_deco == "1") {
							wrench += "\n- Prismatic Wrench Decoration", rcv = "Give";
							pInfo(cp_)->Wrench_Decoration.push_back(14358);
							has_ = true, gv_ = true;
						}
						if (Has_Claimed::W_Deco(peer, 14358) and prismatic_deco == "0") {
							wrench += "\n- Prismatic Wrench Decoration", rcv = "Remove";
							pInfo(cp_)->Wrench_Decoration.erase(remove(pInfo(cp_)->Wrench_Decoration.begin(), pInfo(cp_)->Wrench_Decoration.end(), 14358), pInfo(cp_)->Wrench_Decoration.end());
							has_ = true, rm_ = true;
						}
						if (not Has_Claimed::W_Deco(peer, 14490) and shiny_deco == "1") {
							wrench += "\n- Shiny Wrench Decoration", rcv = "Give";
							pInfo(cp_)->Wrench_Decoration.push_back(14490);
							has_ = true, gv_ = true;
						}
						if (Has_Claimed::W_Deco(peer, 14490) and shiny_deco == "0") {
							wrench += "\n- Shiny Wrench Decoration", rcv = "Remove";
							pInfo(cp_)->Wrench_Decoration.erase(remove(pInfo(cp_)->Wrench_Decoration.begin(), pInfo(cp_)->Wrench_Decoration.end(), 14490), pInfo(cp_)->Wrench_Decoration.end());
							has_ = true, rm_ = true;
						}
						if (not Has_Claimed::W_Deco(peer, 14494) and wrecked_deco == "1") {
							wrench += "\n- Wrecked Wrench Decoration", rcv = "Give";
							pInfo(cp_)->Wrench_Decoration.push_back(14494);
							has_ = true, gv_ = true;
						}
						if (Has_Claimed::W_Deco(peer, 14494) and wrecked_deco == "0") {
							wrench += "\n- Wrecked Wrench Decoration", rcv = "Remove";
							pInfo(cp_)->Wrench_Decoration.erase(remove(pInfo(cp_)->Wrench_Decoration.begin(), pInfo(cp_)->Wrench_Decoration.end(), 14494), pInfo(cp_)->Wrench_Decoration.end());
							has_ = true, rm_ = true;
						}
						if (not Has_Claimed::W_Deco(peer, 14498) and fresh_deco == "1") {
							wrench += "\n- Fresh Wrench Decoration", rcv = "Give";
							pInfo(cp_)->Wrench_Decoration.push_back(14498);
							has_ = true, gv_ = true;
						}
						if (Has_Claimed::W_Deco(peer, 14498) and fresh_deco == "0") {
							wrench += "\n- Fresh Wrench Decoration", rcv = "Remove";
							pInfo(cp_)->Wrench_Decoration.erase(remove(pInfo(cp_)->Wrench_Decoration.begin(), pInfo(cp_)->Wrench_Decoration.end(), 14498), pInfo(cp_)->Wrench_Decoration.end());
							has_ = true, rm_ = true;
						}
						if (not Has_Claimed::W_Deco(peer, 14502) and beautiful_deco == "1") {
							wrench += "\n- Beautiful Wrench Decoration", rcv = "Give";
							pInfo(cp_)->Wrench_Decoration.push_back(14502);
							has_ = true, gv_ = true;
						}
						if (Has_Claimed::W_Deco(peer, 14502) and beautiful_deco == "0") {
							wrench += "\n- Beautiful Wrench Decoration", rcv = "Remove";
							pInfo(cp_)->Wrench_Decoration.erase(remove(pInfo(cp_)->Wrench_Decoration.begin(), pInfo(cp_)->Wrench_Decoration.end(), 14502), pInfo(cp_)->Wrench_Decoration.end());
							has_ = true, rm_ = true;
						}
						if (not Has_Claimed::W_Deco(peer, 14822) and shocking_deco == "1") {
							wrench += "\n- Shocking Wrench Decoration", rcv = "Give";
							pInfo(cp_)->Wrench_Decoration.push_back(14822);
							has_ = true, gv_ = true;
						}
						if (Has_Claimed::W_Deco(peer, 14822) and shocking_deco == "0") {
							wrench += "\n- Shocking Wrench Decoration", rcv = "Remove";
							pInfo(cp_)->Wrench_Decoration.erase(remove(pInfo(cp_)->Wrench_Decoration.begin(), pInfo(cp_)->Wrench_Decoration.end(), 14822), pInfo(cp_)->Wrench_Decoration.end());
							has_ = true, rm_ = true;
						}
						if (not Has_Claimed::W_Deco(peer, 14558) and musical_deco == "1") {
							wrench += "\n- Musical Wrench Decoration", rcv = "Give";
							pInfo(cp_)->Wrench_Decoration.push_back(14558);
							has_ = true, gv_ = true;
						}
						if (Has_Claimed::W_Deco(peer, 14558) and musical_deco == "0") {
							wrench += "\n- Musical Wrench Decoration", rcv = "Remove";
							pInfo(cp_)->Wrench_Decoration.erase(remove(pInfo(cp_)->Wrench_Decoration.begin(), pInfo(cp_)->Wrench_Decoration.end(), 14558), pInfo(cp_)->Wrench_Decoration.end());
							has_ = true, rm_ = true;
						}
						if (not Has_Claimed::W_Deco(peer, 14712) and runic_deco == "1") {
							wrench += "\n- Runic Wrench Decoration", rcv = "Give";
							pInfo(cp_)->Wrench_Decoration.push_back(14712);
							has_ = true, gv_ = true;
						}
						if (Has_Claimed::W_Deco(peer, 14712) and runic_deco == "0") {
							wrench += "\n- Runic Wrench Decoration", rcv = "Remove";
							pInfo(cp_)->Wrench_Decoration.erase(remove(pInfo(cp_)->Wrench_Decoration.begin(), pInfo(cp_)->Wrench_Decoration.end(), 14712), pInfo(cp_)->Wrench_Decoration.end());
							has_ = true, rm_ = true;
						}
						if (not Has_Claimed::W_Deco(peer, 14724) and mechanical_deco == "1") {
							wrench += "\n- Mechanical Wrench Decoration", rcv = "Give";
							pInfo(cp_)->Wrench_Decoration.push_back(14724);
							has_ = true, gv_ = true;
						}
						if (Has_Claimed::W_Deco(peer, 14724) and mechanical_deco == "0") {
							wrench += "\n- Mechanical Wrench Decoration", rcv = "Remove";
							pInfo(cp_)->Wrench_Decoration.erase(remove(pInfo(cp_)->Wrench_Decoration.begin(), pInfo(cp_)->Wrench_Decoration.end(), 14724), pInfo(cp_)->Wrench_Decoration.end());
							has_ = true, rm_ = true;
						}
						if (not Has_Claimed::W_Deco(peer, 15012) and icy_deco == "1") {
							wrench += "\n- Icy Wrench Decoration", rcv = "Give";
							pInfo(cp_)->Wrench_Decoration.push_back(15012);
							has_ = true, gv_ = true;
						}
						if (Has_Claimed::W_Deco(peer, 15012) and icy_deco == "0") {
							wrench += "\n- Icy Wrench Decoration", rcv = "Remove";
							pInfo(cp_)->Wrench_Decoration.erase(remove(pInfo(cp_)->Wrench_Decoration.begin(), pInfo(cp_)->Wrench_Decoration.end(), 15012), pInfo(cp_)->Wrench_Decoration.end());
							has_ = true, rm_ = true;
						}
						if (gv_) VarList::OnConsoleMessage(cp_, "System Give You Custom Wrench: " + wrench + "");
						if (rm_) VarList::OnConsoleMessage(cp_, "System Remove Your Custom Wrench: " + wrench + "");
						if (has_) {
							VarList::OnConsoleMessage(peer, "`o>> Successfully " + rcv + " Custom Wrench " + (rcv == "Remove" ? "from" : "to") + " " + pInfo(cp_)->tankIDName + ": " + wrench + "");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " " + rcv + " Custom Wrench to " + pInfo(cp_)->tankIDName + ": " + wrench + "", "Give Custom Wrench");
						}
					}
				}
			}
		}
	}
	static void give_role(ENetPeer* peer, std::string cch) {
		if (not Role::Clist(pInfo(peer)->tankIDName)) return;
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "Apply Changes") {
				string vip = parser.get("role_1", 1), mod = parser.get("role_2", 1), adm = parser.get("role_3", 1), dev = parser.get("role_4", 1), own = parser.get("role_5", 1), cht = parser.get("role_6", 1), boost = parser.get("role_7", 1), s_boost = parser.get("role_8", 1), god = parser.get("role_9", 1), unli = parser.get("role_10", 1), role = "", rcv = "";
				if (!isValidCheckboxInput(vip) or !isValidCheckboxInput(mod) or !isValidCheckboxInput(adm) or !isValidCheckboxInput(dev) or !isValidCheckboxInput(own) or !isValidCheckboxInput(cht) or !isValidCheckboxInput(god) or !isValidCheckboxInput(unli)) return;
				bool has_ = false, gv_ = false, rm_ = false;
				for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
					if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
					if (to_lower(pInfo(cp_)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						if (not Role::Vip(cp_) and vip == "1") {
							role += "\n- VIP", rcv = "Give";
							pInfo(cp_)->Role.Vip = true;
							has_ = true, gv_ = true;
						}
						if (Role::Vip(cp_) and vip == "0") {
							role += "\n- VIP", rcv = "Remove";
							pInfo(cp_)->Role.Vip = false;
							has_ = true, rm_ = true;
						}
						if (not Role::Moderator(cp_) and mod == "1") {
							role += "\n- Moderator", rcv = "Give";
							pInfo(cp_)->Role.Moderator = true;
							has_ = true, gv_ = true;
						}
						if (Role::Moderator(cp_) and mod == "0") {
							role += "\n- Moderator", rcv = "Remove";
							pInfo(cp_)->Role.Moderator = false;
							has_ = true, rm_ = true;
						}
						if (not Role::Administrator(cp_) and adm == "1") {
							role += "\n- Administrator", rcv = "Give";
							pInfo(cp_)->Role.Administrator = true;
							has_ = true, gv_ = true;
						}
						if (Role::Administrator(cp_) and adm == "0") {
							role += "\n- Administrator", rcv = "Remove";
							pInfo(cp_)->Role.Administrator = false;
							has_ = true, rm_ = true;
						}
						if (not Role::Developer(cp_) and dev == "1") {
							role += "\n- Developer", rcv = "Give";
							pInfo(cp_)->Role.Developer = true;
							has_ = true, gv_ = true;
						}
						if (Role::Developer(cp_) and dev == "0") {
							role += "\n- Developer", rcv = "Remove";
							pInfo(cp_)->Role.Developer = false;
							has_ = true, rm_ = true;
						}
						if (not Role::God(cp_) and god == "1") {
							role += "\n- God", rcv = "Give";
							pInfo(cp_)->Role.God = true;
							has_ = true, gv_ = true;
						}
						if (Role::God(cp_) and god == "0") {
							role += "\n- God", rcv = "Remove";
							pInfo(cp_)->Role.God = false;
							has_ = true, rm_ = true;
						}
						if (not Role::Unlimited(cp_) and unli == "1") {
							role += "\n- Unlimited", rcv = "Give";
							pInfo(cp_)->Role.Unlimited = true;
							has_ = true, gv_ = true;
						}
						if (Role::Unlimited(cp_) and unli == "0") {
							role += "\n- Unlimited", rcv = "Remove";
							pInfo(cp_)->Role.Unlimited = false;
							has_ = true, rm_ = true;
						}
						if (not Role::Owner(cp_) and own == "1") {
							role += "\n- Owner Server", rcv = "Give";
							pInfo(cp_)->Role.Owner_Server = true;
							has_ = true, gv_ = true;
						}
						if (Role::Owner(cp_) and own == "0") {
							role += "\n- Owner Server", rcv = "Remove";
							pInfo(cp_)->Role.Owner_Server = false;
							has_ = true, rm_ = true;
						}
						if (not Role::Cheater(cp_) and cht == "1") {
							role += "\n- Cheater", rcv = "Give";
							pInfo(cp_)->Role.Cheats = true;
							has_ = true, gv_ = true;
						}
						if (Role::Cheater(cp_) and cht == "0") {
							role += "\n- Cheater", rcv = "Remove";
							pInfo(cp_)->Role.Cheats = false;
							has_ = true, rm_ = true;
						}
						if (not pInfo(cp_)->Role.BOOST and boost == "1") {
							role += "\n- Boost (1 Weeks)", rcv = "Give";
							pInfo(cp_)->Role.BOOST = true;
							pInfo(cp_)->Role.BOOST_TIME = time(nullptr) + 604800;
							has_ = true, gv_ = true;
						}
						if (pInfo(cp_)->Role.BOOST and boost == "0") {
							role += "\n- Boost", rcv = "Remove";
							pInfo(cp_)->Role.BOOST = false;
							pInfo(cp_)->Role.BOOST_TIME = 0;
							has_ = true, rm_ = true;
						}
						if (not pInfo(cp_)->Role.SUPER_BOOST and s_boost == "1") {
							role += "\n- Super Boost (10 Days)", rcv = "Give";
							pInfo(cp_)->Role.SUPER_BOOST = true;
							pInfo(cp_)->Role.SUPER_BOOST_TIME = time(nullptr) + 864000;
							has_ = true, gv_ = true;
						}
						if (pInfo(cp_)->Role.SUPER_BOOST and s_boost == "0") {
							role += "\n- Super Boost", rcv = "Remove";
							pInfo(cp_)->Role.SUPER_BOOST = false;
							pInfo(cp_)->Role.SUPER_BOOST_TIME = 0;
							has_ = true, rm_ = true;
						}
						if (gv_) VarList::OnConsoleMessage(cp_, "System Give You Role: " + role + "");
						if (rm_) VarList::OnConsoleMessage(cp_, "System Demote Your Role: " + role + "");
						if (has_) {
							pInfo(cp_)->Role.Role_Level = Role::GetLevel(cp_);
							pInfo(cp_)->name_color = Role::Prefix(cp_);
							VisualHandle::Nick(cp_, NULL);
							VarList::OnConsoleMessage(peer, "`o>> Successfully " + rcv + " Role " + (rcv == "Remove" ? "from" : "to") + " " + pInfo(cp_)->tankIDName + ": " + role + "");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " " + rcv + " Role to " + pInfo(cp_)->tankIDName + ": " + role + "", "Give Role");
						}
					}
				}
			}
		}
	}
	static void creator_bank_option(ENetPeer* peer, std::string cch) {
		if (not Role::Clist(pInfo(peer)->tankIDName)) return;
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "Confirm_Transfer") {
				bool has_ = false; string amount = parser.get("amount", 1), tf_wl = parser.get("tf_wl", 1), tf_dl = parser.get("tf_dl", 1), tf_pgl = parser.get("tf_pgl", 1), tf_mgl = parser.get("tf_mgl", 1), tf_igl = parser.get("tf_igl", 1);
				if (!isValidCheckboxInput(tf_wl) or !isValidCheckboxInput(tf_dl) or !isValidCheckboxInput(tf_pgl) or !isValidCheckboxInput(tf_mgl) or !isValidCheckboxInput(tf_igl)) return;
				for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
					if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
					if (pInfo(cp_)->tankIDName == pInfo(peer)->last_wrenched) {
						if (not is_number(amount) or amount.size() < 1 or amount.size() > 7) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid Input in Amount!", 0, 1);
							return;
						}
						if (tf_wl == "1" and std::atoi(amount.c_str()) != 0) {
							pInfo(cp_)->wl_bank_amount += std::atoi(amount.c_str());
							has_ = true;
						}
						if (tf_dl == "1" and std::atoi(amount.c_str()) != 0) {
							pInfo(cp_)->dl_bank_amount += std::atoi(amount.c_str());
							has_ = true;
						}
						if (tf_pgl == "1" and std::atoi(amount.c_str()) != 0) {
							pInfo(cp_)->pgl_bank_amount += std::atoi(amount.c_str());
							has_ = true;
						}
						if (tf_mgl == "1" and std::atoi(amount.c_str()) != 0) {
							pInfo(cp_)->mgl_bank_amount += std::atoi(amount.c_str());
							has_ = true;
						}
						if (tf_igl == "1" and std::atoi(amount.c_str()) != 0) {
							pInfo(cp_)->igl_bank_amount += std::atoi(amount.c_str());
							has_ = true;
						}
						if (has_) {
							VarList::OnConsoleMessage(peer, "`oSuccesfully Transfer " + (tf_wl == "1" ? "" + Set_Count(std::atoi(amount.c_str())) + " World Locks, " : "") + (tf_dl == "1" ? "" + Set_Count(std::atoi(amount.c_str())) + " Diamond Locks, " : "") + (tf_pgl == "1" ? "" + Set_Count(std::atoi(amount.c_str())) + " Platinum Gem Locks, " : "") + (tf_mgl == "1" ? "" + Set_Count(std::atoi(amount.c_str())) + " " + Environment()->server_name + " Gem Locks, " : "") + (tf_igl == "1" ? "" + Set_Count(std::atoi(amount.c_str())) + " Infinity Gem Locks, " : "") + "to " + pInfo(cp_)->tankIDName + ".");
							VarList::OnConsoleMessage(cp_, "`oYou Received a Transfer " + (tf_wl == "1" ? "" + Set_Count(std::atoi(amount.c_str())) + " World Locks, " : "") + (tf_dl == "1" ? "" + Set_Count(std::atoi(amount.c_str())) + " Diamond Locks, " : "") + (tf_pgl == "1" ? "" + Set_Count(std::atoi(amount.c_str())) + " Platinum Gem Locks, " : "") + (tf_mgl == "1" ? "" + Set_Count(std::atoi(amount.c_str())) + " " + Environment()->server_name + " Gem Locks, " : "") + (tf_igl == "1" ? "" + Set_Count(std::atoi(amount.c_str())) + " Infinity Gem Locks, " : "") + "from " + pInfo(peer)->tankIDName + ".");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Transfered " + (tf_wl == "1" ? "" + Set_Count(std::atoi(amount.c_str())) + " World Locks, " : "") + (tf_dl == "1" ? "" + Set_Count(std::atoi(amount.c_str())) + " Diamond Locks, " : "") + (tf_pgl == "1" ? "" + Set_Count(std::atoi(amount.c_str())) + " Platinum Gem Locks, " : "") + (tf_mgl == "1" ? "" + Set_Count(std::atoi(amount.c_str())) + " " + Environment()->server_name + " Gem Locks, " : "") + (tf_igl == "1" ? "" + Set_Count(std::atoi(amount.c_str())) + " Infinity Gem Locks, " : "") + "to " + pInfo(cp_)->tankIDName, "Creator Bank Options");
						}
					}
				}
			}
			if (button == "Confirm_Remove") {
				bool has_ = false; string tf_wl = parser.get("tf_wl", 1), tf_dl = parser.get("tf_dl", 1), tf_pgl = parser.get("tf_pgl", 1), tf_mgl = parser.get("tf_mgl", 1), tf_igl = parser.get("tf_igl", 1);
				if (!isValidCheckboxInput(tf_wl) or !isValidCheckboxInput(tf_dl) or !isValidCheckboxInput(tf_pgl) or !isValidCheckboxInput(tf_mgl) or !isValidCheckboxInput(tf_igl)) return;
				for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
					if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
					if (pInfo(cp_)->tankIDName == pInfo(peer)->last_wrenched) {
						if (tf_wl == "1") {
							pInfo(cp_)->wl_bank_amount = 0;
							has_ = true;
						}
						if (tf_dl == "1") {
							pInfo(cp_)->dl_bank_amount = 0;
							has_ = true;
						}
						if (tf_pgl == "1") {
							pInfo(cp_)->pgl_bank_amount = 0;
							has_ = true;
						}
						if (tf_mgl == "1") {
							pInfo(cp_)->mgl_bank_amount = 0;
							has_ = true;
						}
						if (tf_igl == "1") {
							pInfo(cp_)->igl_bank_amount = 0;
							has_ = true;
						}
						if (has_) {
							VarList::OnConsoleMessage(peer, "`oSuccesfully Removed All " + a + (tf_wl == "1" ? "World Locks, " : "") + (tf_dl == "1" ? "Diamond Locks, " : "") + (tf_wl == "1" ? "Platinum Gem Locks, " : "") + (tf_mgl == "1" ? "" + Environment()->server_name + " Gem Locks, " : "") + (tf_igl == "1" ? "Infinity Gem Locks, " : "") + "from " + pInfo(cp_)->tankIDName + " Bank.");
							VarList::OnConsoleMessage(cp_, "`oYour Bank Balance " + a + (tf_wl == "1" ? "World Locks, " : "") + (tf_dl == "1" ? "Diamond Locks, " : "") + (tf_wl == "1" ? "Platinum Gem Locks, " : "") + (tf_mgl == "1" ? "" + Environment()->server_name + " Gem Locks, " : "") + (tf_igl == "1" ? "Infinity Gem Locks, " : "") + " has been Removed by " + pInfo(peer)->tankIDName + ".");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " Removed All " + (tf_wl == "1" ? "World Locks, " : "") + (tf_dl == "1" ? "Diamond Locks, " : "") + (tf_wl == "1" ? "Platinum Gem Locks, " : "") + (tf_mgl == "1" ? "" + Environment()->server_name + " Gem Locks, " : "") + (tf_igl == "1" ? "Infinity Gem Locks, " : "") + "from " + pInfo(cp_)->tankIDName + " Bank.", "Creator Bank Options");
						}
					}
				}
			}
		}
	}
	static void reset_option(ENetPeer* peer, std::string cch) {
		if (Role::Owner(peer)) {
			TextScanner parser(cch);
			std::string button = "";
			if (parser.try_get("buttonClicked", button)) {
				if (button == "Confirm_Reset") {
					string reset_all = parser.get("reset_all", 1), reset_lock = parser.get("reset_lock", 1), reset_inv = parser.get("reset_inv", 1), reset_gems = parser.get("reset_gems", 1), reset_level = parser.get("reset_level", 1), reset_strgems = parser.get("reset_strgems", 1), reset_coin = parser.get("reset_coin", 1), reset_cooldown = parser.get("reset_cooldown", 1);
					if (!isValidCheckboxInput(reset_all) or !isValidCheckboxInput(reset_lock) or !isValidCheckboxInput(reset_inv) or !isValidCheckboxInput(reset_gems) or !isValidCheckboxInput(reset_level) or !isValidCheckboxInput(reset_strgems) or !isValidCheckboxInput(reset_coin) or !isValidCheckboxInput(reset_cooldown)) return;
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (pInfo(cp_)->tankIDName == pInfo(peer)->last_wrenched) {
							if (reset_all == "1") {
								VarList::OnBuxGems(cp_, pInfo(cp_)->gems * -1);
								pInfo(cp_)->xp = 1;
								pInfo(cp_)->gtwl = 0;
								pInfo(cp_)->hair = 0;
								pInfo(cp_)->feet = 0;
								pInfo(cp_)->face = 0;
								pInfo(cp_)->hand = 0;
								pInfo(cp_)->back = 0;
								pInfo(cp_)->mask = 0;
								pInfo(cp_)->level = 1;
								pInfo(cp_)->shirt = 0;
								pInfo(cp_)->pants = 0;
								pInfo(cp_)->ances = 0;
								pInfo(cp_)->necklace = 0;
								pInfo(cp_)->Gems_Storage = 0;
								pInfo(cp_)->playmods.clear();
								Clothing_V2::Update(cp_);
								for (int i_ = 0, remove = 0; i_ < pInfo(cp_)->inv.size(); i_++) {
									if (items[pInfo(cp_)->inv[i_].first].untradeable == 0) {
										remove = pInfo(cp_)->inv[i_].second * -1;
										Inventory::Modify(cp_, pInfo(cp_)->inv[i_].first, remove);
										remove = 0;
									}
								}
								VarList::OnConsoleMessage(peer, "`2Succesfully reset all " + pInfo(cp_)->tankIDName + "");
								ServerPool::Logs::Add(pInfo(peer)->tankIDName + " use /reset > button reset all to [" + pInfo(cp_)->tankIDName + "]", "Reset");
							}
							if (reset_lock == "1") {
								pInfo(cp_)->wl_bank_amount = 0, pInfo(cp_)->dl_bank_amount = 0, pInfo(cp_)->pgl_bank_amount = 0, pInfo(cp_)->mgl_bank_amount = 0, pInfo(cp_)->igl_bank_amount = 0;
								if (!pInfo(cp_)->inv.empty()) {
									for (auto& inv : pInfo(cp_)->inv) {
										if (items[inv.first].blockType == BlockTypes::LOCK) {
											int total_inv = Inventory::Contains(cp_, inv.first);
											Inventory::Modify(cp_, inv.first, total_inv *= -1);
										}
									}
								}
								VarList::OnConsoleMessage(peer, "`2Succesfully reset all locks " + pInfo(cp_)->tankIDName + "");
								ServerPool::Logs::Add(pInfo(peer)->tankIDName + " use /reset > button reset all locks to [" + pInfo(cp_)->tankIDName + "]", "Reset");
							}
							if (reset_gems == "1") {
								VarList::OnBuxGems(cp_, pInfo(cp_)->gems * -1);
								VarList::OnConsoleMessage(peer, "`2Succesfully reset gems " + pInfo(cp_)->tankIDName + "");
								ServerPool::Logs::Add(pInfo(peer)->tankIDName + " use /reset > button reset gems to [" + pInfo(cp_)->tankIDName + "]", "Reset");
							}
							if (reset_level == "1") {
								pInfo(cp_)->level = 1;
								pInfo(cp_)->xp = 1;
								VarList::OnConsoleMessage(peer, "`2Succesfully reset level " + pInfo(cp_)->tankIDName + "");
								ServerPool::Logs::Add(pInfo(peer)->tankIDName + " use /reset > button reset level to [" + pInfo(cp_)->tankIDName + "]", "Reset");
							}
							if (reset_strgems == "1") {
								pInfo(cp_)->Gems_Storage = 0;
								VarList::OnConsoleMessage(peer, "`2Succesfully reset storage gems " + pInfo(cp_)->tankIDName + "");
								ServerPool::Logs::Add(pInfo(peer)->tankIDName + " use /reset > button reset storage gems to [" + pInfo(cp_)->tankIDName + "]", "Reset");
							}
							if (reset_inv == "1") {
								pInfo(cp_)->hair = 0;
								pInfo(cp_)->shirt = 0;
								pInfo(cp_)->pants = 0;
								pInfo(cp_)->feet = 0;
								pInfo(cp_)->face = 0;
								pInfo(cp_)->hand = 0;
								pInfo(cp_)->back = 0;
								pInfo(cp_)->mask = 0;
								pInfo(cp_)->necklace = 0;
								pInfo(cp_)->ances = 0;
								Clothing_V2::Update(cp_);
								for (int i_ = 0, remove = 0; i_ < pInfo(cp_)->inv.size(); i_++) {
									if (items[pInfo(cp_)->inv[i_].first].untradeable == 0) {
										remove = pInfo(cp_)->inv[i_].second * -1;
										Inventory::Modify(cp_, pInfo(cp_)->inv[i_].first, remove);
										remove = 0;
									}
								}
								VarList::OnConsoleMessage(peer, "`2Succesfully reset inventory " + pInfo(cp_)->tankIDName + "");
								ServerPool::Logs::Add(pInfo(peer)->tankIDName + " use /reset > button reset inventory to [" + pInfo(cp_)->tankIDName + "]", "Reset");
							}
							if (reset_coin == "1") {
								pInfo(cp_)->gtwl = 0;
								VarList::OnConsoleMessage(peer, "`2Succesfully reset " + Environment()->server_name + " Coin " + pInfo(cp_)->tankIDName + "");
								ServerPool::Logs::Add(pInfo(peer)->tankIDName + " use /reset > button reset " + Environment()->server_name + " Coin to [" + pInfo(cp_)->tankIDName + "]", "Reset");
							}
							if (reset_cooldown == "1") {
								pInfo(cp_)->playmods.clear();
								VarList::OnConsoleMessage(peer, "`2Succesfully reset Cooldown/Playmods " + pInfo(cp_)->tankIDName + "");
								ServerPool::Logs::Add(pInfo(peer)->tankIDName + " use /reset > button reset Cooldown/Playmods to [" + pInfo(cp_)->tankIDName + "]", "Reset");
							}
						}
					}
				}
			}
		}
	}
	static void Buy_Items(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (pInfo(peer)->Has_In) {
				if (button == "back") {
					string list_ = "";
					for (const auto& item : Environment()->buy_item_list) {
						list_ += to_string(item.first) + ", " + to_string(item.second) + ", ";
					}
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Buy Item Finder|left|6016|\nadd_smalltext|`o(name of items to search, try \"Wings\"):|left|\nadd_text_input|item_search_field|Search By Name:||30|\nadd_spacer|small|\nadd_searchable_item_list|" + list_ + "|listType:iconGrid;resultLimit:55;|item_search_field|\nadd_spacer|small|\nend_dialog|Buy_Items|Close||");
					pInfo(peer)->Has_In = true;
				}
				if (button.substr(0, 25) == "searchableItemListButton_") {
					int item_id = std::atoi(button.substr(25).c_str());
					if (item_id == 2950 || item_id > items.size() || item_id < 0 || Gtps_Shop::Get_Price(item_id) == 0 || Gtps_Shop::Disable_Items(item_id) || items[item_id].untradeable || items[item_id].blockType == BlockTypes::LOCK || items[item_id].blockType == SEED || items[item_id].name.find("Phoenix") != string::npos || items[item_id].name.find("Golden") != string::npos || items[item_id].name.find("Legend") != string::npos || items[item_id].name.find("Legendary") != string::npos || items[item_id].name.find("Ancestral") != string::npos || items[item_id].name.find("Wrench") != string::npos || items[item_id].name.find("null_item") != string::npos || items[item_id].name.find("null") != string::npos || items[item_id].name.find("Guild Flag") != string::npos || items[item_id].name.find("Guild Entrance") != string::npos || items[item_id].name.find("Guild Banner") != string::npos || items[item_id].name.find("Guild Key") != string::npos || items[item_id].name.find("World Key") != string::npos || item_id == 5640 || item_id == 5814 || item_id == 1486 || item_id == 6802 || item_id == 5070 || item_id == 5072 || item_id == 5074 || item_id == 5076) return;
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`wBuy Item Finder|left|6016|\nadd_textbox|`o(Result of receiving finded items):|left|\nadd_spacer|small|\nadd_label_with_icon|small|`o1 " + items[item_id].name + "|left|" + to_string(item_id) + "|\nadd_smalltext|`o(For this item, you get charged (`2" + Set_Count(Gtps_Shop::Get_Price(item_id)) + " Gems``)|left|\nembed_data|id|" + to_string(item_id) + "\nembed_data|price|" + to_string(Gtps_Shop::Get_Price(item_id)) + "\nadd_spacer|small|\nadd_textbox|`o(How many " + items[item_id].name + " Would you want to purchase?)|left|\nadd_text_input|amount|`oAmount:||5|\nadd_spacer|small|\nadd_custom_button|back|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|Purchase_Items|textLabel:`wPurchase;anchor:_button_back;left:1;margin:60,0;|\nend_dialog|Buy_Items|||");
				}
				if (button == "Purchase_Items") {
					int id = std::atoi(get_embed(cch, "id").c_str()), price = std::atoi(get_embed(cch, "price").c_str()), free_slots = Inventory::Get_Slots(pInfo(peer));
					if (id == 2950 || id > items.size() || id < 0 || price == 0 || Gtps_Shop::Get_Price(id) == 0 || Gtps_Shop::Disable_Items(id) || items[id].untradeable || items[id].blockType == BlockTypes::LOCK || items[id].blockType == SEED || items[id].name.find("Phoenix") != string::npos || items[id].name.find("Golden") != string::npos || items[id].name.find("Legend") != string::npos || items[id].name.find("Legendary") != string::npos || items[id].name.find("Ancestral") != string::npos || items[id].name.find("Wrench") != string::npos || items[id].name.find("null_item") != string::npos || items[id].name.find("null") != string::npos || items[id].name.find("Guild Flag") != string::npos || items[id].name.find("Guild Entrance") != string::npos || items[id].name.find("Guild Banner") != string::npos || items[id].name.find("Guild Key") != string::npos || items[id].name.find("World Key") != string::npos || id == 5640 || id == 5814 || id == 1486 || id == 6802 || id == 5070 || id == 5072 || id == 5074 || id == 5076 || id == 7188 || id == 242 || id == 1796 || id == 8470) return;
					string amount = parser.get("amount", 1);
					if (amount.size() < 1 or amount.size() > 3 or std::atoi(amount.c_str()) < 1 or std::atoi(amount.c_str()) > 200 or not is_number(amount)) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid Input!", 0, true);
						return;
					}
					if (free_slots == 0) {
						VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
						return;
					}
					if (Inventory::Check_Max(peer, id, std::atoi(amount.c_str()))) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, true);
						return;
					}
					int total = price * std::atoi(amount.c_str());
					if (pInfo(peer)->gems >= total) {
						int add = 0;
						if (Inventory::Modify(peer, id, add = std::atoi(amount.c_str())) == 0) {
							VarList::OnMinGems(peer, total);
							VisualHandle::Trade(peer, id, 500);
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Succesfully bought " + to_string(std::atoi(amount.c_str())) + " " + items[id].name + " for " + Set_Count(total) + " (gems)", 0, true);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You already carrying " + to_string(Inventory::Contains(peer, id)) + " " + items[id].name + " in Inventory!", 0, 0);
						return;
					}
					else {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough gems!", 0, true);
						return;
					}
				}
			}
		}
	}
	static void TrovaOggettoClist(ENetPeer* peer, std::string cch) {
		if (Role::Clist(pInfo(peer)->tankIDName)) {
			std::vector<std::string> t_ = explode("|", cch);
			if (t_.size() < 3) return;
			int free_slots = Inventory::Get_Slots(pInfo(peer));
			if (free_slots == 0) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!");
				return;
			}
			for (int i_ = 2; i_ < t_.size(); i_++) {
				if (t_.size() - i_ <= 1) return;
				if (atoi(explode("\n", t_[i_ + 1])[0].c_str())) {
					int item_id = std::atoi(explode("\n", t_[i_])[1].c_str());
					if (pInfo(peer)->tankIDName != "Vallen") if (item_id == 9506) return;
					if (item_id == 2950 || item_id > items.size() || item_id < 0 || item_id == 6 || item_id == 6548 || items[item_id].blocked_place || items[item_id].blockType == SEED || items[item_id].name.find("Data Bedrock") != string::npos || items[item_id].name.find("Wrench") != string::npos || items[item_id].name.find("null_item") != string::npos || items[item_id].name.find("null") != string::npos || items[item_id].name.find("Guild Flag") != string::npos || items[item_id].name.find("Guild Entrance") != string::npos || items[item_id].name.find("Guild Banner") != string::npos || items[item_id].name.find("Guild Key") != string::npos || items[item_id].name.find("World Key") != string::npos || item_id == 5640 || item_id == 5814 || item_id == 1486 || item_id == 6802 || item_id == 5070 || item_id == 5072 || item_id == 5074 || item_id == 5076 || item_id == 18 || item_id == 32 || item_id == 6336 || item_id == 9384 || item_id == 9158) return;
					int a_ = 1;
					int jau_turi = 0;
					Inventory::Modify(peer, item_id, jau_turi);
					a_ = 200 - jau_turi;
					if (Inventory::Modify(peer, item_id, a_) == 0) {
						VarList::OnConsoleMessage(peer, "`oSuccesfully added 200 " + items[item_id].ori_name + " to your inventory.");
						ServerPool::Logs::Add(pInfo(peer)->tankIDName + " succesfully add 200 " + items[item_id].ori_name + " to inventory [/find]", "Find Items");
					}
				}
			}
		}
	}
	static void TrovaOggetto(ENetPeer* peer, std::string cch) {
		if (Role::Unlimited(peer) or Role::Owner(peer) or Role::Clist(pInfo(peer)->tankIDName)) {
			TextScanner parser(cch);
			std::string button = "";
			if (parser.try_get("buttonClicked", button)) {
				if (pInfo(peer)->Has_In) {
					if (button.substr(0, 25) == "searchableItemListButton_") {
						int item_id = std::atoi(button.substr(25).c_str());
						if (pInfo(peer)->tankIDName != "Vallen") if (item_id == 9506) return;
						if (not Role::Clist(pInfo(peer)->tankIDName)) {
							/*Locks*/if (item_id == 5980 or item_id == 9640 or item_id == 7188 or item_id == 8470 or item_id == 5980 or item_id == 13200) return;
							/*Mines*/if (item_id == 6994 or item_id == 20220 or item_id == 20222 or item_id == 20224 or item_id == 20226 or item_id == 20228 or item_id == 14528 or item_id == 14530 or item_id == 14532) return;
							/*Gacha Items*/if (item_id == 5136 || item_id == 14084 || item_id == 9986 || item_id == 10382 || item_id == 1458 || item_id == 7960 || item_id == 9386 || item_id == 9902 || item_id == 9350 || item_id == 10004 || item_id == 9814 || item_id == 9862) return;
							/*rare*/if (item_id == 5930 || item_id == 9772) return;
						}
						if (not Role::Owner(peer)) {
							/*items purchase*/if (item_id == 1486 || item_id == 6802 || item_id == 14578 || item_id == 14580 || item_id == 14582 || item_id == 14584 || item_id == 14586 || item_id == 14564 || item_id == 14566 || item_id == 14568 || item_id == 14570 || item_id == 14572 || item_id == 14574 || item_id == 14562 || item_id == 9186 || item_id == 9852 || item_id == 9854 || item_id == 9882 || item_id == 9726 || item_id == 10400 || item_id == 10176 || item_id == 13200 || item_id == 8440 || item_id == 9874 || item_id == 10020 || item_id == 9916 || item_id == 10366 || item_id == 9766 || item_id == 9574 || item_id == 5862 || item_id == 9914 || item_id == 5854 || item_id == 13710 || item_id == 9586 || item_id == 11118 || item_id == 9546 || item_id == 9548 || item_id == 5824 || item_id == 5910 || item_id == 14026 || item_id == 5852 || item_id == 13638 || item_id == 9784 || item_id == 5906 || item_id == 5860 || item_id == 9912 || item_id == 9344 || item_id == 2386 || item_id == 7834 || item_id == 12188 || item_id == 13566 || item_id == 11218 || item_id == 10400 || item_id == 9726 || item_id == 6016 || item_id == 6950 || item_id == 6946 || item_id == 6948 || item_id == 6952 || item_id == 5930 || item_id == 8358 || item_id == 9838 || item_id == 9920 || item_id == 8428 || item_id == 5878 || item_id == 10118 || item_id == 10124 || item_id == 9488 || item_id == 9542 || item_id == 5480 || item_id == 10362 || item_id == 9772 || item_id == 9906 || item_id == 9770 || item_id == 9908 || item_id == 9918 || item_id == 10290 || item_id == 9846 || item_id == 5928 || item_id == 9984 || item_id == 10384 || item_id == 5828) return;
							/*Item Rare*/if (item_id == 14594 or item_id == 14538 or item_id == 14540 or item_id == 242 or item_id == 1796) return;
							/*Locks*/if (item_id == 4428 or item_id == 4802 or item_id == 2950 or item_id == 14508 or item_id == 14506 or item_id == 2408 or item_id == 5206) return;
						}
						if (not Role::Unlimited(peer)) {
							/*Items Daily Quest*/if (item_id == Environment()->Dq_Item1 or item_id == Environment()->Dq_Item2) return;
							/*All Rings*/if (item_id == 1874 || item_id == 1876 || item_id == 1996 || item_id == 2970 || item_id == 1904 || item_id == 3174 || item_id == 8962 || item_id == 6846 || item_id == 6028 || item_id == 3140) return;
							if (items[item_id].name.find("Legendary") != string::npos || items[item_id].name.find("Legend") != string::npos || items[item_id].name.find("Phoenix") != string::npos || items[item_id].name.find("Golden") != string::npos || items[item_id].name.find("Subscription") != string::npos || items[item_id].name.find("Growtoken") != string::npos || item_id == 6280) return;
							if (items[item_id].blockType == FISH) return;
							if (items[item_id].name.find("Ancestral") != string::npos || items[item_id].name.find("Anomalizing") != string::npos || items[item_id].name.find("Blast") != string::npos || items[item_id].name.find("Supply") != string::npos || items[item_id].name.find("Wand") != string::npos || items[item_id].name.find("Weather Machine") != string::npos || items[item_id].name.find("Storage Box") != string::npos || items[item_id].blockType == FISH || item_id == 14086 || item_id == 11480 || item_id == 11050 || item_id == 9408 || item_id == 8286 || item_id == 8552 || item_id == 11478 || item_id == 10424 || item_id == 7190 || item_id == 4490 || item_id == 5138 || item_id == 5140 || item_id == 5142 || item_id == 9886 || item_id == 408 || item_id == 6240 || item_id == 6246 || item_id == 6252 || item_id == 6258 || item_id == 6830 || item_id == 6836) return;
							/*Materials Upgrade Ances*/if (items[item_id].name.find("Crystallized") != string::npos || item_id == 5106 || item_id == 5204 || item_id == 5104) return;
							/*Mag 5k*/if (item_id == 5638) return;
							/*World Wolf Prize*/if (item_id == 13076 || item_id == 11650 || item_id == 13042 || item_id == 12782 || item_id == 4354 || item_id == 122 || item_id == 124 || item_id == 1188 || item_id == 4346 || item_id == 8544 || item_id == 2996 || item_id == 4342 || item_id == 3136 || item_id == 10082 || item_id == 12486 || item_id == 4352 || item_id == 8262 || item_id == 8264 || item_id == 8266 || item_id == 8268 || item_id == 2998 || item_id == 3538 || item_id == 2986 || item_id == 2984 || item_id == 4348 || item_id == 4350 || item_id == 6842 || item_id == 3774 || item_id == 4344 || item_id == 3176 || item_id == 7146 || item_id == 11338) return;
							/*Guild Event Reward*/if (items[item_id].name.find("Guild Potion") != string::npos or items[item_id].name.find("Medal:") != string::npos || items[item_id].name.find("Lucky Clover") != string::npos || item_id == 6280 || item_id == 6198 || item_id == 7328 || item_id == 7844 || item_id == 14414 || item_id == 7934 || item_id == 7936 || item_id == 7944 || item_id == 7946 || item_id == 8014 || item_id == 8016 || item_id == 8296 || item_id == 8298 || item_id == 9220 || item_id == 7954 || item_id == 7936 || item_id == 7952 || item_id == 8020 || item_id == 8300 || item_id == 6264 || item_id == 6266 || item_id == 6268 || item_id == 6270 || item_id == 6302 || item_id == 6304 || item_id == 6750 || item_id == 6752 || item_id == 8774 || item_id == 6154 || item_id == 6156 || item_id == 6296 || item_id == 6772 || item_id == 6200 || item_id == 7484 || item_id == 7198 || item_id == 7200 || item_id == 7208 || item_id == 7210 || item_id == 7386 || item_id == 7388 || item_id == 7576 || item_id == 7578 || item_id == 7580 || item_id == 7394 || item_id == 7212 || item_id == 7202) return;
						}
						if (item_id > items.size() || item_id == 2950 || item_id < 0 || item_id == 6 || item_id == 6548 || items[item_id].blocked_place || items[item_id].blockType == SEED || items[item_id].name.find("Data Bedrock") != string::npos || items[item_id].name.find("Wrench") != string::npos || items[item_id].name.find("null_item") != string::npos || items[item_id].name.find("null") != string::npos || items[item_id].name.find("Guild Flag") != string::npos || items[item_id].name.find("Guild Entrance") != string::npos || items[item_id].name.find("Guild Banner") != string::npos || items[item_id].name.find("Guild Key") != string::npos || items[item_id].name.find("World Key") != string::npos || item_id == 5640 || item_id == 5814 || item_id == 5070 || item_id == 5072 || item_id == 5074 || item_id == 5076 || item_id == 18 || item_id == 32 || item_id == 6336 || item_id == 9384 || item_id == 9158) return;
						int free_slots = Inventory::Get_Slots(pInfo(peer));
						if (free_slots == 0) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!");
							return;
						}
						int a_ = 1, Contains = Inventory::Contains(peer, item_id);
						a_ = 200 - Contains;
						int cnt = a_;
						if (Inventory::Modify(peer, item_id, a_) == 0) {
							VisualHandle::Trade(peer, item_id, 500);
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Succesfully added " + to_string(cnt) + " " + items[item_id].ori_name + " to your inventory.", 0, true);
							VarList::OnConsoleMessage(peer, "`oSuccesfully added " + to_string(cnt) + " " + items[item_id].ori_name + " to your inventory.");
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " succesfully add " + to_string(cnt) + " " + items[item_id].ori_name + " to inventory [/find]", "Find Items");
						}
						else {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You already reach max of this items!");
							return;
						}
					}
				}
			}
		}
	}
	static void fishtankport(ENetPeer* peer, std::string cch) {
		string nowan = pInfo(peer)->world;
		std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [nowan](const World& a) { return a.name == nowan; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			int x_ = std::atoi(explode("\n", explode("tilex|", cch)[1])[0].c_str()), y_ = std::atoi(explode("\n", explode("tiley|", cch)[1])[0].c_str());
			WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
			if (Only_Access(peer, world_, block_) and block_->fg == 3002) {
				int highlight = std::atoi(explode("\n", explode("chk_highlight|", cch)[1])[0].c_str());
				if (highlight) block_->pr = 16;
				else block_->pr = 0;
				update_block(world_, block_, x_, y_);
			}
		}
		if (cch.find("add_fish") != std::string::npos) {
			std::vector<std::string> t_ = explode("|", cch);
			if (t_.size() < 4) return;
			int trainitem = std::atoi(explode("\n", explode("add_fish|", cch)[1])[0].c_str());
			if (trainitem > 0 && trainitem < items.size()) {
				int got = 0;
				Inventory::Modify(peer, trainitem, got);
				if (got == 0) return;
				int wtf = 0;
				bool error = false;
				string errorm = "";
				if (items[trainitem].blockType != BlockTypes::FISH) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wErr, that's not a fish.", 0, 1);
					return;
				}
				else {
					std::string name_ = pInfo(peer)->world;
					std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
					if (p != worlds.end()) {
						World* world_ = &worlds[p - worlds.begin()];
						int x_ = std::atoi(explode("\n", explode("tilex|", cch)[1])[0].c_str()), y_ = std::atoi(explode("\n", explode("tiley|", cch)[1])[0].c_str());
						WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
						if (Only_Access(peer, world_, block_) and block_->fg == 3002) {
							if (block_->c_ < 5) {
								int jumlah = got;
								block_->txt += to_string(trainitem) + "|" + to_string(jumlah) + ",";
								block_->c_++;
								update_block(world_, block_, x_, y_);
								Inventory::Modify(peer, trainitem, wtf = -got);
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou put in a " + to_string(jumlah) + "lb. " + items[trainitem].name + ".", 0, 1);
							}
							else {
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "This fish tank seems to be full!");
							}
						}
					}
				}
			}
		}
		else if (cch.find("removefish") != std::string::npos) {
			int first = 0, second = 0, third = 0;
			int fourth = 0, fifth = 0;
			int x_ = std::atoi(explode("\n", explode("tilex|", cch)[1])[0].c_str()), y_ = std::atoi(explode("\n", explode("tiley|", cch)[1])[0].c_str());
			if (cch.find("fish_1|") != string::npos) first = std::atoi(explode("\n", explode("fish_1|", cch)[1])[0].c_str());
			if (cch.find("fish_2|") != string::npos) second = std::atoi(explode("\n", explode("fish_2|", cch)[1])[0].c_str());
			if (cch.find("fish_3|") != string::npos) third = std::atoi(explode("\n", explode("fish_3|", cch)[1])[0].c_str());
			if (cch.find("fish_4|") != string::npos) fourth = std::atoi(explode("\n", explode("fish_4|", cch)[1])[0].c_str());
			if (cch.find("fish_5|") != string::npos) fifth = std::atoi(explode("\n", explode("fish_5|", cch)[1])[0].c_str());
			std::string name_ = pInfo(peer)->world;
			std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
				if (Only_Access(peer, world_, block_) and block_->fg == 3002) {
					const auto pi = explode(",", block_->txt);
					int f1 = -1, lb1 = 0, f2 = -1, lb2 = 0, f3 = -1, lb3 = 0, f4 = -1, lb4 = 0, f5 = -1, lb5 = 0, f6 = -1, f7 = -1, f8 = -1, f9 = -1, f10 = -1, lb6 = 0, lb7 = 0, lb8 = 0, lb9 = 0, lb10 = 0;
					for (auto& a : pi) {
						if (a.empty()) continue;
						else {
							const auto xd = explode("|", a);
							if (f1 == -1) { f1 = std::atoi(xd.at(0).c_str()); lb1 = std::atoi(xd.at(1).c_str()); }
							else if (f2 == -1) { f2 = std::atoi(xd.at(0).c_str()); lb2 = std::atoi(xd.at(1).c_str()); }
							else if (f3 == -1) { f3 = std::atoi(xd.at(0).c_str()); lb3 = std::atoi(xd.at(1).c_str()); }
							else if (f4 == -1) { f4 = std::atoi(xd.at(0).c_str()); lb4 = std::atoi(xd.at(1).c_str()); }
							else if (f5 == -1) { f5 = std::atoi(xd.at(0).c_str()); lb5 = std::atoi(xd.at(1).c_str()); }
						}
					}
					if (f1 == -1) f1 = 0;
					if (f2 == -1) f2 = 0;
					if (f3 == -1) f3 = 0;
					if (f4 == -1) f4 = 0;
					if (f5 == -1) f5 = 0;
					struct Flb { int id; int lb; int place; };
					vector<Flb> fishs;
					if (first != 0) {
						Flb MyFish;
						MyFish.id = f1;
						MyFish.lb = lb1;
						MyFish.place = 0;
						fishs.push_back(MyFish);
					}
					if (second != 0) {
						Flb MyFish;
						MyFish.id = f2;
						MyFish.lb = lb2;
						MyFish.place = 1;
						fishs.push_back(MyFish);
					}
					if (third != 0) {
						Flb MyFish;
						MyFish.id = f3;
						MyFish.lb = lb3;
						MyFish.place = 2;
						fishs.push_back(MyFish);
					}
					if (fourth != 0) {
						Flb MyFish;
						MyFish.id = f4;
						MyFish.place = 3;
						MyFish.lb = lb4;
						fishs.push_back(MyFish);
					}
					if (fifth != 0) {
						Flb MyFish;
						MyFish.id = f5;
						MyFish.lb = lb5;
						MyFish.place = 4;
						fishs.push_back(MyFish);
					}
					int first = 0, last = 0;
					for (int i = 0; i < fishs.size(); i++) {
						int cum = 0;
						Inventory::Modify(peer, fishs[i].id, cum);
						if (cum == 0) {
							int rum = 0;
							Inventory::Modify(peer, fishs[i].id, rum = fishs[i].lb);
							block_->c_ -= 1;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Removed " + items[fishs[i].id].name + " from Fish Tank Port.");
							std::string delimiter = ",";
							size_t start = 0;
							size_t end = 0;
							int rnn = 0;
							string eraser = "";
							while ((end = block_->txt.find(delimiter, start)) != std::string::npos) {
								rnn++;
								if (rnn != fishs[i].place + 1) {
									start = end + 1;
									continue;
								}
								if (first == 0) first = start;
								if (i == fishs.size()) last = end;
								eraser += block_->txt.substr(start, (end + 1) - start);
								return;
							}
						}
						block_->txt.erase(first, (last + 1) - first);
						if (block_->c_ == 0) block_->txt = "";
					}
					update_block(world_, block_, x_, y_);
				}
			}
		}
		else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Updated fish tank port");
	}
	static void OnlinePointCurrency_Shop(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "Back") {
				DialogHandle::Opc_Shop(peer);
			}
			else if (button == "BackToStore") {
				shop_tab(peer, "tab1_opc_shop");
			}
			else if (button.substr(0, 8) == "itemopc_") {
				int id_ = std::atoi(button.substr(8).c_str()), price_ = items[id_].oprc;
				if (id_ < 0 or id_ >= items.size() or price_ == 0) return;
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label|big|`9Buy " + items[id_].name + "?|left|\nadd_spacer|small|\nadd_custom_margin|x:0;y:-30|\nadd_custom_button||icon:" + to_string(id_) + ";display:inline_free;width:0.40;state:disabled;|\nadd_spacer|small|\nadd_custom_margin|x:20;y:-20|\nadd_smalltext|`1ITEM DESCRIPTION`o: " + items[id_].description + "|left|\nadd_smalltext|`1ITEM PRICE`o: " + Set_Count(price_) + "|left|\nadd_smalltext|`1ITEM RARITY`o: " + to_string(items[id_].rarity) + "|left|\nadd_custom_margin|x:-10;y:0|\nreset_placement_x|\nadd_spacer|small|\nadd_spacer|small|\nadd_text_input|amount|||3|\nadd_spacer|small|\nadd_custom_textbox|`oYou have `2" + Set_Count(pInfo(peer)->opc) + " Online Point Currency`o.|size:small;icon:10668;|\nadd_spacer|small|\nadd_custom_button|Back|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|PurchaseOpc_" + to_string(id_) + "|textLabel:`wPurchase;anchor:_button_Back;left:1;margin:60,0;|\nend_dialog|OnlinePointCurrency_Shop|||\nadd_quick_exit|");
			}
			else if (button.substr(0, 12) == "PurchaseOpc_") {
				string amount = parser.get("amount", 1);
				int id_ = std::atoi(button.substr(12).c_str()), price_ = items[id_].oprc;
				if (id_ < 0 or id_ >= items.size() or price_ == 0) return;
				if (atoi(amount.c_str()) < 1 || atoi(amount.c_str()) < 0 || atoi(amount.c_str()) > 200 || amount.find_first_not_of("0123456789") != std::string::npos) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in amount!", 0, 1);
					return;
				}
				int free_slots = Inventory::Get_Slots(pInfo(peer)), total = price_ * atoi(amount.c_str()), add = 0, cnt = std::atoi(amount.c_str());
				if (free_slots == 0) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
					return;
				}
				if (total > pInfo(peer)->opc) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wthe amount you entered is not sufficient for what you have!", 0, 1);
					return;
				}
				if (pInfo(peer)->opc >= total) {
					if (Inventory::Modify(peer, id_, add += cnt) == 0) {
						pInfo(peer)->opc -= total;
						VisualHandle::Trade(peer, id_, 500);
						CAction::Log(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
						CAction::Positioned(peer, pInfo(peer)->netID, "audio/keypad_hit.wav", 450);
						VarList::OnConsoleMessage(peer, "`1@System traded " + to_string(cnt) + " " + items[id_].name + " to " + fixchar2(get_player_nick(peer)) + ".``");
						VarList::OnConsoleMessage(peer, "`1" + fixchar2(get_player_nick(peer)) + " traded " + Set_Count(total) + " Online Point Currency to @System.``");
					}
				}
			}
		}
	}
	static void MarketPlace_Npc(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "Back") {
				string item_list = ""; int total = 0;
				for (const auto& item : Environment()->Npc_MarketPlace) {
					total++;
					item_list += "\nadd_button_with_icon|searchableItemListButton_" + to_string(std::get<0>(item)) + "_" + to_string(std::get<1>(item)) + "_" + to_string(std::get<2>(item)) + "|" + items[std::get<0>(item)].name + "|staticYellowFrame|" + to_string(std::get<0>(item)) + "|";
				}
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w[`2NPC`w] MarketPlace|left|9922|\nadd_spacer|small|\nadd_smalltext|`5Hello and welcome! I’m [NPC] MarketPlace, and this is the best place to sell everything you have! From unique treasures to everyday essentials, I have it all right here. Feel free to browse my collection!<CR>If you have any questions, I’m here to help.|left|\nadd_smalltext|`5I hope you find what you’re looking for and enjoy your time here!|left|\nadd_spacer|small|\nadd_textbox|`2Items available:|left|\ntext_scaling_string|Subscribtions++++++++|\nadd_spacer|small|" + (total >= 1 ? item_list + "\nadd_button_with_icon||END_LIST|noflags|0||" : "") + "\nadd_spacer|small|\nend_dialog|MarketPlace_Npc|Close||", 700);
			}
			else if (button.find("searchableItemListButton") != string::npos) {
				std::regex number_regex("\\d+");
				std::smatch matches;
				int id = 0, price_type = 0, price = 0;
				auto search_start = button.cbegin();
				for (int match_index = 0; std::regex_search(search_start, button.cend(), matches, number_regex); ++match_index) {
					int number = std::stoi(matches[0]);
					if (match_index == 0) id = number;
					else if (match_index == 1) price_type = number;
					else if (match_index == 2) price = number;
					search_start = matches.suffix().first;
				}
				if (not Npc_MarketPlace::Has(id) or id < 0 or id > items.size() or price < 0 or price_type != 112 and price_type != 242 and price_type != 1795 and price_type != 7188 and price_type != 8470 and price_type != 13200) return;
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label|big|`9Sell " + items[id].name + "?|left|\nembed_data|itemid|" + to_string(id) + "\nembed_data|price_type|" + to_string(price_type) + "\nembed_data|price|" + to_string(price) + "\nadd_spacer|small|\nadd_custom_margin|x:0;y:-30|\nadd_custom_button||icon:" + to_string(id) + ";display:inline_free;width:0.40;state:disabled;|\nadd_spacer|small|\nadd_custom_margin|x:20;y:-20|\nadd_smalltext|`1ITEM DESCRIPTION`o: " + items[id].description + "|left|\nadd_smalltext|`1ITEM PRICE`o: " + Set_Count(price) + " " + to_upper(items[price_type].name) + "|left|\nadd_smalltext|`1ITEM RARITY`o: " + to_string(items[id].rarity) + "|left|\nadd_custom_margin|x:-10;y:0|\nreset_placement_x|\nadd_spacer|small|\nadd_spacer|small|\nadd_text_input|amount|||3|\nadd_spacer|small|\nadd_custom_textbox|`oYou have `2" + Set_Count(Inventory::Contains(peer, id)) + " " + items[id].name + " ``in your Inventory.|size:small;icon:" + to_string(id) + ";|\nadd_spacer|small|\nadd_custom_button|Back|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|ConfirmSellItem|textLabel:`wSell Item;anchor:_button_Back;left:1;margin:60,0;|\nend_dialog|MarketPlace_Npc|||\nadd_quick_exit|");
			}
			else if (button == "ConfirmSellItem") {
				int add = 0, id = std::atoi(get_embed(cch, "id").c_str()), price_type = std::atoi(get_embed(cch, "price_type").c_str()), price = std::atoi(get_embed(cch, "price").c_str()), free_slots = Inventory::Get_Slots(pInfo(peer));
				if (Inventory::Contains(peer, id) == 0 or not Npc_MarketPlace::Has(id) or id < 0 or id > items.size() or price < 0 or price_type != 112 and price_type != 242 and price_type != 1795 and price_type != 7188 and price_type != 8470 and price_type != 13200) return;
				string amount = parser.get("amount", 1);
				if (atoi(amount.c_str()) < 1 || atoi(amount.c_str()) < 0 || atoi(amount.c_str()) > 200 || amount.find_first_not_of("0123456789") != std::string::npos) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in amount!", 0, 1);
					return;
				}
				if (atoi(amount.c_str()) > Inventory::Contains(peer, id)) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wthe amount you entered is not sufficient for what you have!", 0, 1);
					return;
				}
				if (free_slots == 0) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
					return;
				}
				int total = std::atoi(amount.c_str()) * price;
				if (price_type == 112) {
					if (pInfo(peer)->gems + total >= MAX_GEMS) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your Gems has reached maxed!", 0, true);
						return;
					}
				}
				else {
					if (Inventory::Check_Max(peer, price_type, total)) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, true);
						return;
					}
				}
				if (Inventory::Contains(peer, id) >= std::atoi(amount.c_str())) {
					if (Inventory::Modify(peer, id, add = -atoi(amount.c_str())) == 0) {
						if (price_type == 112) VarList::OnBuxGems(peer, total);
						else Inventory::Modify(peer, price_type, add = total);
						if (pInfo(peer)->world == "MARKETPLACE" and pInfo(peer)->last_netid == int(GTPS_NPC::NPC_MARKETPLACE)) {
							PlayerMoving data_{};
							data_.packetType = 19, data_.plantingTree = 450, data_.netID = -888;
							data_.punchX = id, data_.punchY = id;
							int32_t to_netid = pInfo(peer)->netID;
							BYTE* raw = packPlayerMoving(&data_);
							raw[3] = 3;
							Memory_Copy(raw + 8, &to_netid, 4);
							for (ENetPeer* cp_2 = server->peers; cp_2 < &server->peers[server->peerCount]; ++cp_2) {
								if (cp_2->state != ENET_PEER_STATE_CONNECTED or cp_2->data == NULL) continue;
								if (pInfo(cp_2)->world == "MARKETPLACE") {
									CAction::Positioned(cp_2, pInfo(peer)->netID, "audio/keypad_hit.wav", 450);
									VarList::OnConsoleMessage(cp_2, "`1[NPC] MarketPlace traded " + to_string(total) + " " + items[price_type].name + " to " + fixchar2(get_player_nick(peer)) + ".``");
									VarList::OnConsoleMessage(cp_2, "`1" + fixchar2(get_player_nick(peer)) + " traded " + to_string(atoi(amount.c_str())) + " " + items[id].name + " to [NPC] MarketPlace.``");
									send_raw(cp_2, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[]raw;
							{
								PlayerMoving data_{};
								data_.packetType = 19, data_.plantingTree = 2 * 450, data_.netID = pInfo(peer)->netID;
								data_.punchX = price_type, data_.punchY = price_type;
								int32_t to_netid = -888;
								BYTE* raw = packPlayerMoving(&data_);
								raw[3] = 3;
								Memory_Copy(raw + 8, &to_netid, 4);
								for (ENetPeer* cp_2 = server->peers; cp_2 < &server->peers[server->peerCount]; ++cp_2) {
									if (cp_2->state != ENET_PEER_STATE_CONNECTED or cp_2->data == NULL) continue;
									if (pInfo(cp_2)->world == "MARKETPLACE") {
										send_raw(cp_2, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[]raw;
							}
						}
					}
				}
			}
		}
		else {
			if (not Role::Clist(pInfo(peer)->tankIDName)) return;
			int type = 0, id = std::atoi(get_embed(cch, "id").c_str());
			if (not Npc_MarketPlace::Has(id)) {
				string wl = parser.get("wl", 1), dl = parser.get("dl", 1), pgl = parser.get("pgl", 1), mgl = parser.get("mgl", 1), igl = parser.get("igl", 1), gems = parser.get("gems", 1), price = parser.get("price", 1);
				if (id < 0 or id > items.size() or !isValidCheckboxInput(wl) or !isValidCheckboxInput(dl) or !isValidCheckboxInput(pgl) or !isValidCheckboxInput(mgl) or !isValidCheckboxInput(igl) or !isValidCheckboxInput(gems)) return;
				if (wl == "0" and dl == "0" and pgl == "0" and mgl == "0" and igl == "0" and gems == "0") {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Select one type of Price!", 0, 1);
					return;
				}
				if (gems == "1" and (atoi(price.c_str()) < 0 or atoi(price.c_str()) > 2'000'000'000)) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid input!", 0, 1);
					return;
				}
				if ((wl == "1" or dl == "1" or pgl == "1" or mgl == "1" or igl == "1") and (atoi(price.c_str()) < 0 or atoi(price.c_str()) > 200)) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid input!", 0, 1);
					return;
				}
				int price_ = atoi(price.c_str());
				if (wl == "1") type = 242;
				if (dl == "1") type = 1796;
				if (pgl == "1") type = 7188;
				if (mgl == "1") type = 8470;
				if (igl == "1") type = 13200;
				if (gems == "1") type = 112;
				Environment()->Npc_MarketPlace.emplace_back(id, type, price_);
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`2Successfully added " + items[id].name + " to [NPC] MarketPlace!", 0, 1);
				VarList::OnConsoleMessage(peer, "Ď `2EXCHANGE ITEMS``: New Items has been Added -> " + items[id].name + " with Price -> " + Set_Count(price_) + " " + items[type].name + " GO `5'MARKETPLACE'`` to Sell Your Items!", true);
			}
		}
	}
	static void Exchange_Npc(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "Back") {
				string fish = "", crystal = "";
				for (int i_ = 0; i_ < items.size(); i_++) {
					int item_id = items[i_].id;
					if (items[item_id].blockType == BlockTypes::FISH) {
						fish += "\nadd_button_with_icon|item_" + to_string(item_id) + "|" + items[item_id].name + "|staticPurpleFrame|" + to_string(item_id) + "||\n";
					}
					if (items[item_id].blockType == BlockTypes::CRYSTAL) {
						crystal += "\nadd_button_with_icon|item_" + to_string(item_id) + "|" + items[item_id].name + "|staticPurpleFrame|" + to_string(item_id) + "||\n";
					}
				}
				VarList::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`w[`2NPC`w] Exchange Place|left|9922|\nadd_spacer|small|\nadd_textbox|`wGreetings, Traveler! Welcome to the Exchange Place. I am here to assist you in Trading your treasures for valuable rewards<CR>If you'd like to strike a dead, simply browse the list below and choose the item you wish to offer. I'll ensure you get a fair trade in return!|left|\nadd_spacer|small|\nadd_textbox|`wItems available for exchange:|left|\nadd_spacer|small|\nadd_textbox|`5Fish:|left|\ntext_scaling_string|Subscribtions++++++++|\nadd_spacer|small|" + fish + "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|\nadd_textbox|`5Crystal:|left|\nadd_spacer|small|" + crystal + "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|\nend_dialog|Exchange_Npc|Close||", 700);
			}
			else if (button.substr(0, 5) == "item_") {
				int id_ = std::atoi(button.substr(5).c_str()), price_ = 0;
				if (items[id_].blockType != BlockTypes::FISH and items[id_].blockType != BlockTypes::CRYSTAL or id_ < 0 or id_ >= items.size()) return;
				int total = Inventory::Contains(peer, id_);
				/*Crystal*/
				if (id_ == 2242) price_ = 3;
				if (id_ == 2244) price_ = 2;
				if (id_ == 2246) price_ = 3;
				if (id_ == 2248) price_ = 25;
				if (id_ == 2250) price_ = 35;
				/*Fish*/
				if ((id_ == 3820 or id_ == 4958 or id_ == 5100 or id_ == 5448 or id_ == 5450 or id_ == 5538 or id_ == 5542 or id_ == 5548 or id_ == 5552 or id_ == 5574 or id_ == 5580 or id_ == 7472 or id_ == 7744 or id_ == 8460 or id_ == 10264) and total <= 100 or (id_ == 3450 or id_ == 3452 or id_ == 3454 or id_ == 3456 or id_ == 3458 or id_ == 3460 or id_ == 3544 or id_ == 3550 or id_ == 3620 or id_ == 3746 or id_ == 3814) and total >= 100) price_ = 5;
				if ((id_ == 3820 or id_ == 4958 or id_ == 5100 or id_ == 5448 or id_ == 5450 or id_ == 5538 or id_ == 5542 or id_ == 5548 or id_ == 5552 or id_ == 5574 or id_ == 5580 or id_ == 7472 or id_ == 7744 or id_ == 8460 or id_ == 10264) and total >= 100) price_ = 6;
				if ((id_ == 3220 or id_ == 3222 or id_ == 3224 or id_ == 3226 or id_ == 3434 or id_ == 3436 or id_ == 3438 or id_ == 3440) and total <= 100 or (id_ == 3024 or id_ == 3092 or id_ == 3094 or id_ == 3096) and total >= 100) price_ = 3;
				if ((id_ == 3220 or id_ == 3222 or id_ == 3224 or id_ == 3226 or id_ == 3434 or id_ == 3436 or id_ == 3438 or id_ == 3440) and total >= 100 or (id_ == 3450 or id_ == 3452 or id_ == 3454 or id_ == 3456 or id_ == 3458 or id_ == 3460 or id_ == 3544 or id_ == 3550 or id_ == 3620 or id_ == 3746 or id_ == 3814) and total <= 100) price_ = 4;
				if ((id_ == 3000 or id_ == 3026 or id_ == 3030 or id_ == 3032 or id_ == 3034 or id_ == 3036 or id_ == 3038) and total <= 100) price_ = 1;
				if ((id_ == 3000 or id_ == 3026 or id_ == 3030 or id_ == 3032 or id_ == 3034 or id_ == 3036 or id_ == 3038) and total >= 100 or (id_ == 3024 or id_ == 3092 or id_ == 3094 or id_ == 3096) and total <= 100) price_ = 2;
				price_ *= (Event()->Exchange_Event ? Event()->X_Exchange : 1);
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`w" + items[id_].name + "|left|" + to_string(id_) + "|\nembed_data|id|" + to_string(id_) + "\nembed_data|price|" + to_string(price_) + "\nembed_data|total|" + to_string(total) + "\nadd_spacer|small|\nadd_smalltext|`1ITEM DATA: ``" + items[id_].description + "<CR>`1ITEM RARITY: ``" + to_string(items[id_].rarity) + "<CR>`1ITEM PRICE: ``" + to_string(price_) + " World Locks / " + (items[id_].blockType == BlockTypes::FISH ? "Fish" : "Items") + "|left|\nadd_spacer|small|" + (items[id_].blockType == BlockTypes::FISH ? "\nadd_textbox|`2Your current " + items[id_].name + ": " + to_string(total) + "lbs|left|" : "\nadd_textbox|`2Your current " + items[id_].name + ": " + to_string(total) + "|left|\nadd_spacer|small|\nadd_text_input|amount|Amount:||3|") + "\nadd_spacer|small|\nadd_custom_button|Back|textLabel:`wBack;middle_colour:2415764;border_colour:2415764;|" + (total >= 1 ? "\nadd_custom_button|Apply ExChanges|textLabel:`wApply ExChanges;anchor:_button_Nevermind;left:1;margin:60,0;middle_colour:434431310;border_colour:434438350;" + a + (total >= 1 ? "state:enabled;" : "state:disabled;") + "|" : "") + "\nend_dialog|Exchange_Npc|||");
			}
			else if (button == "Apply ExChanges") {
				bool Has_In = false;
				string amount = "";
				int rem = 0, total_ = std::atoi(get_embed(cch, "total").c_str()), id_ = std::atoi(get_embed(cch, "id").c_str()), price_ = std::atoi(get_embed(cch, "price").c_str());
				if (items[id_].blockType == BlockTypes::CRYSTAL) {
					amount = parser.get("amount", 1);
					if (atoi(amount.c_str()) < 1 || atoi(amount.c_str()) < 0 || atoi(amount.c_str()) > 200 || amount.find_first_not_of("0123456789") != std::string::npos) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in amount!", 0, 1);
						return;
					}
					if (atoi(amount.c_str()) > Inventory::Contains(peer, id_)) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "the amount you entered is not sufficient for what you have!", 0, 1);
						return;
					}
				}
				if (items[id_].blockType != BlockTypes::FISH and items[id_].blockType != BlockTypes::CRYSTAL or price_ == 0 or total_ == 0) return;
				int free_slots = Inventory::Get_Slots(pInfo(peer));
				if (free_slots == 0) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
					return;
				}
				int total = price_ * atoi(amount.c_str()), cnt = total;
				int jumlahDiamondLocks = total / 100;
				int sisaWorldLocks = total % 100;
				if (items[id_].blockType == BlockTypes::CRYSTAL) {
					if (jumlahDiamondLocks > 0) {
						if (Inventory::Check_Max(peer, 1796, jumlahDiamondLocks)) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, true);
							return;
						}
						if (Inventory::Modify(peer, 1796, rem = jumlahDiamondLocks) != 0) {
							WorldDrop drop_block_{};
							drop_block_.id = 1796, drop_block_.count = jumlahDiamondLocks, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
							std::string name_ = pInfo(peer)->world;
							std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						Has_In = true;
					}
					if (sisaWorldLocks > 0) {
						if (Inventory::Check_Max(peer, 242, sisaWorldLocks)) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, true);
							return;
						}
						if (Inventory::Modify(peer, 242, rem = sisaWorldLocks) != 0) {
							WorldDrop drop_block_{};
							drop_block_.id = 242, drop_block_.count = sisaWorldLocks, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
							std::string name_ = pInfo(peer)->world;
							std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						Has_In = true;
					}
				}
				else {
					if (Inventory::Check_Max(peer, 242, price_)) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, true);
						return;
					}
					if (total_ > Inventory::Contains(peer, id_) or total_ < Inventory::Contains(peer, id_)) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "the amount you entered is not sufficient for what you have!", 0, 1);
						return;
					}
					if (Inventory::Modify(peer, 242, rem = price_) != 0) {
						WorldDrop drop_block_{};
						drop_block_.id = 242, drop_block_.count = price_, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
						std::string name_ = pInfo(peer)->world;
						std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
						if (p != worlds.end()) {
							World* world_ = &worlds[p - worlds.begin()];
							VisualHandle::Drop(world_, drop_block_);
						}
					}
					Has_In = true;
				}
				if (Has_In) {
					rem = (items[id_].blockType == BlockTypes::CRYSTAL ? atoi(amount.c_str()) : total_) * -1;
					if (Inventory::Modify(peer, id_, rem) == 0) {
						if (pInfo(peer)->world == "TRADE" and pInfo(peer)->last_netid == int(GTPS_NPC::NPC_EXCHANGE)) {
							PlayerMoving data_{};
							data_.packetType = 19, data_.plantingTree = 450, data_.netID = -777;
							data_.punchX = id_, data_.punchY = id_;
							int32_t to_netid = pInfo(peer)->netID;
							BYTE* raw = packPlayerMoving(&data_);
							raw[3] = 3;
							Memory_Copy(raw + 8, &to_netid, 4);
							for (ENetPeer* cp_2 = server->peers; cp_2 < &server->peers[server->peerCount]; ++cp_2) {
								if (cp_2->state != ENET_PEER_STATE_CONNECTED or cp_2->data == NULL) continue;
								if (pInfo(cp_2)->world == "TRADE") {
									CAction::Positioned(cp_2, pInfo(peer)->netID, "audio/keypad_hit.wav", 450);
									VarList::OnConsoleMessage(cp_2, "`1[NPC] Exchange Place traded " + (items[id_].blockType == BlockTypes::FISH ? to_string(price_) + " World Locks" : jumlahDiamondLocks > 0 and sisaWorldLocks > 0 ? to_string(jumlahDiamondLocks) + " Diamond Locks and " + to_string(sisaWorldLocks) + " World Locks" : jumlahDiamondLocks > 0 and sisaWorldLocks == 0 ? to_string(jumlahDiamondLocks) + " Diamond Locks" : to_string(sisaWorldLocks) + " World Locks") + " to " + fixchar2(get_player_nick(peer)) + ".``");
									VarList::OnConsoleMessage(cp_2, "`1" + fixchar2(get_player_nick(peer)) + " traded " + (items[id_].blockType == BlockTypes::CRYSTAL ? to_string(atoi(amount.c_str())) : to_string(total_) + "lb") + " " + items[id_].name + " to [NPC] Exchange Place.``");
									send_raw(cp_2, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[]raw;
							{
								PlayerMoving data_{};
								data_.packetType = 19, data_.plantingTree = 2 * 450, data_.netID = pInfo(peer)->netID;
								data_.punchX = (jumlahDiamondLocks > 0 ? 1796 : 242), data_.punchY = (jumlahDiamondLocks > 0 ? 1796 : 242);
								int32_t to_netid = -777;
								BYTE* raw = packPlayerMoving(&data_);
								raw[3] = 3;
								Memory_Copy(raw + 8, &to_netid, 4);
								for (ENetPeer* cp_2 = server->peers; cp_2 < &server->peers[server->peerCount]; ++cp_2) {
									if (cp_2->state != ENET_PEER_STATE_CONNECTED or cp_2->data == NULL) continue;
									if (pInfo(cp_2)->world == "TRADE") {
										send_raw(cp_2, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[]raw;
							}
						}
						else {
							VisualHandle::Trade(peer, id_, 500);
							CAction::Positioned(peer, pInfo(peer)->netID, "audio/keypad_hit.wav", 450);
							VarList::OnConsoleMessage(peer, "`1[NPC] Exchange Place traded " + (items[id_].blockType == BlockTypes::FISH ? to_string(price_) + " World Locks" : jumlahDiamondLocks > 0 and sisaWorldLocks > 0 ? to_string(jumlahDiamondLocks) + " Diamond Locks and " + to_string(sisaWorldLocks) + " World Locks" : jumlahDiamondLocks > 0 and sisaWorldLocks == 0 ? to_string(jumlahDiamondLocks) + " Diamond Locks" : to_string(sisaWorldLocks) + " World Locks") + " to " + fixchar2(get_player_nick(peer)) + ".``");
							VarList::OnConsoleMessage(peer, "`1" + fixchar2(get_player_nick(peer)) + " traded " + (items[id_].blockType == BlockTypes::CRYSTAL ? to_string(atoi(amount.c_str())) : to_string(total_) + "lb") + " " + items[id_].name + " to [NPC] Exchange Place.``");
						}
					}
				}
			}
		}
	}
	static void sewing(ENetPeer* peer, std::string cch) {
		int lastsew = pInfo(peer)->lastsew; bool finish_sewing = false;
		if (lastsew == 3350 || lastsew == 8940 || lastsew == 8938 || lastsew == 3344 || lastsew == 3336 || lastsew == 3892 || lastsew == 3338 || lastsew == 3340 || lastsew == 3342 || lastsew == 3346 || lastsew == 3348 || lastsew == 3352 || lastsew == 4804) {
			std::string type = "", button = "";
			TextScanner parser(cch);
			if (parser.try_get("buttonClicked", button)) {
				if (button == "triplesew") type = "Triple Stretch";
				else if (button == "Sew_Zigzag") type = "Zigzag";
				else if (button == "Sew_Overcasting") type = "Overcasting";
				else if (button == "Sew_Saddle") type = "Saddle";
				else if (button == "Sew_Blind") type = "Blind";
				else if (button == "Sew_Locking") type = "Locking";
				else if (button == "Sew_Straight") type = "Straight";
				if (type != "") {
					if (Inventory::Get_Slots(pInfo(peer)) >= 3) {
						int arr = 0;
						PlayerMoving data_{};
						data_.packetType = 19, data_.netID = -1, data_.plantingTree = 0;
						data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16;
						data_.XSpeed = pInfo(peer)->x + 16, data_.YSpeed = pInfo(peer)->y + 16;
						data_.punchX = lastsew;
						BYTE* raw = packPlayerMoving(&data_);
						raw[3] = 6;
						send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						delete[] raw;
						Inventory::Modify(peer, lastsew, arr = -1);
						if (pInfo(peer)->sew1 == "") pInfo(peer)->sew1 = type + " " + items[lastsew].name;
						else {
							if (pInfo(peer)->sew2 == "") pInfo(peer)->sew2 = type + " " + items[lastsew].name;
							else {
								if (pInfo(peer)->sew3 == "") pInfo(peer)->sew3 = type + " " + items[lastsew].name;
								if (pInfo(peer)->sew1 != "" and pInfo(peer)->sew2 != "" and pInfo(peer)->sew3 != "") {
									finish_sewing = true;
								}
							}
						}
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You need at least 2 Free Space", 0, 1);
				}
				if (finish_sewing) {
					int receive = 1, item = 0, got = 1;
					bool sew_ = 0;
					string sew1 = pInfo(peer)->sew1, sew2 = pInfo(peer)->sew2, sew3 = pInfo(peer)->sew3;
					string Ow = "Overcasting Silk Bolt - White", Stw = "Straight Silk Bolt - White", Nw = "Normal Silk Bolt - White", Zw = "Zigzag Silk Bolt - White", Sw = "Saddle Silk Bolt - White", Bw = "Blind Silk Bolt - White", Tw = "Triple Stretch Silk Bolt - White", Lw = "Locking Silk Bolt - White";
					string Op = "Overcasting Silk Bolt - Purple", Stp = "Straight Silk Bolt - Purple", Np = "Normal Silk Bolt - Purple", Zp = "Zigzag Silk Bolt - Purple", Sp = "Saddle Silk Bolt - Purple", Bp = "Blind Silk Bolt - Purple", Tp = "Triple Stretch Silk Bolt - Purple", Lp = "Locking Silk Bolt - Purple";
					string Or = "Overcasting Silk Bolt - Red", Str = "Straight Silk Bolt - Red", Nr = "Normal Silk Bolt - Red", Zr = "Zigzag Silk Bolt - Red", Sr = "Saddle Silk Bolt - Red", Br = "Blind Silk Bolt - Red", Tr = "Triple Stretch Silk Bolt - Red", Lr = "Locking Silk Bolt - Red";
					string Og = "Overcasting Silk Bolt - Green", Stg = "Straight Silk Bolt - Green", Ng = "Normal Silk Bolt - Green", Zg = "Zigzag Silk Bolt - Green", Sg = "Saddle Silk Bolt - Green", Bg = "Blind Silk Bolt - Green", Tg = "Triple Stretch Silk Bolt - Green", Lg = "Locking Silk Bolt - Green";
					string Ob = "Overcasting Silk Bolt - Blue", Stb = "Straight Silk Bolt - Blue", Nb = "Normal Silk Bolt - Blue", Zb = "Zigzag Silk Bolt - Blue", Sb = "Saddle Silk Bolt - Blue", Bb = "Blind Silk Bolt - Blue", Tb = "Triple Stretch Silk Bolt - Blue", Lb = "Locking Silk Bolt - Blue";
					string Ok = "Overcasting Silk Bolt - Black", Stk = "Straight Silk Bolt - Black", Nk = "Normal Silk Bolt - Black", Zk = "Zigzag Silk Bolt - Black", Sk = "Saddle Silk Bolt - Black", Bk = "Blind Silk Bolt - Black", Tk = "Triple Stretch Silk Bolt - Black", Lk = "Locking Silk Bolt - Black";
					string Oe = "Overcasting Silk Bolt - Grey", Ste = "Straight Silk Bolt - Grey", Ne = "Normal Silk Bolt - Grey", Ze = "Zigzag Silk Bolt - Grey", Se = "Saddle Silk Bolt - Grey", Be = "Blind Silk Bolt - Grey", Te = "Triple Stretch Silk Bolt - Grey", Le = "Locking Silk Bolt - Grey";
					string Oy = "Overcasting Silk Bolt - Yellow", Sty = "Straight Silk Bolt - Yellow", Ny = "Normal Silk Bolt - Yellow", Zy = "Zigzag Silk Bolt - Yellow", Sy = "Saddle Silk Bolt - Yellow", By = "Blind Silk Bolt - Yellow", Ty = "Triple Stretch Silk Bolt - Yellow", Ly = "Locking Silk Bolt - Yellow";
					string Oa = "Overcasting Silk Bolt - Aqua", Sta = "Straight Silk Bolt - Aqua", Na = "Normal Silk Bolt - Aqua", Za = "Zigzag Silk Bolt - Aqua", Sa = "Saddle Silk Bolt - Aqua", Ba = "Blind Silk Bolt - Aqua", Ta = "Triple Stretch Silk Bolt - Aqua", La = "Locking Silk Bolt - Aqua";
					string Of = "Overcasting Silk Bolt - Floral", Stf = "Straight Silk Bolt - Floral", Nf = "Normal Silk Bolt - Floral", Zf = "Zigzag Silk Bolt - Floral", Sf = "Saddle Silk Bolt - Floral", Bf = "Blind Silk Bolt - Floral", Tf = "Triple Stretch Silk Bolt - Floral", Lf = "Locking Silk Bolt - Floral";
					string Owo = "Overcasting Wool Bolt", Stwo = "Straight Wool Bolt", Nwo = "Normal Wool Bolt", Zwo = "Zigzag Wool Bolt", Swo = "Saddle Wool Bolt", Bwo = "Blind Wool Bolt", Two = "Triple Stretch Wool Bolt", Lwo = "Locking Wool Bolt";
					string Oww = "Overcasting Woven Wood Bolt", Stww = "Straight Woven Wood Bolt", Nww = "Normal Woven Wood Bolt", Zww = "Zigzag Woven Wood Bolt", Sww = "Saddle Woven Wood Bolt", Bww = "Blind Woven Wood Bolt", Tww = "Triple Stretch Woven Wood Bolt", Lww = "Locking Woven Wood Bolt";
					if (sew1 == Nwo and sew2 == Le and sew3 == Two) item = 3912, sew_ = 1;
					if (sew1 == Ng and sew2 == Zk and sew3 == Ok) item = 3376, sew_ = 1;
					if (sew1 == Ne and sew2 == Zb and sew3 == Ob) item = 3378, sew_ = 1;
					if (sew1 == Ne and sew2 == Ze and sew3 == Oe) item = 3380, sew_ = 1;
					if (sew1 == Nr and sew2 == Zr and sew3 == Or) item = 3372, sew_ = 1;
					if (sew1 == Ny and sew2 == Zy and sew3 == Oy) item = 3374, sew_ = 1;
					if (sew1 == Nw and sew2 == Op and sew3 == Stp) item = 13376, sew_ = 1;
					if (sew1 == Np and sew2 == Sy and sew3 == Lg) item = 3432, sew_ = 1;
					if (sew1 == Na and sew2 == Zp and sew3 == Oy) item = 3394, sew_ = 1;
					if (sew1 == Np and sew2 == Le and sew3 == Sp) item = 5190, sew_ = 1;
					if (sew1 == Nwo and sew2 == Zg and sew3 == Sg) item = 10276, sew_ = 1; // englightment
					if (sew1 == Nwo and sew2 == Sr and sew3 == Tg) item = 4274, sew_ = 1; // hideous holiday
					if (sew1 == Nr and sew2 == Tp and sew3 == Bk) item = 3514, sew_ = 1; // raspberry beret
					if (sew1 == Nww and sew2 == Ob and sew3 == Sww) item = 8908, sew_ = 1; // Tea Basket
					if (sew1 == "Normal Broken Tea Basket" and sew2 == Ob and sew3 == Sww) item = 8908, sew_ = 1; // Tea Basket 2.
					if (sew1 == Nw and sew2 == Bp and sew3 == Swo) item = 10772, sew_ = 1;
					if (sew1 == Np and sew2 == Lw and sew3 == Sf) item = 10770, sew_ = 1;
					if (sew1 == Nb and sew2 == Tb and sew3 == Bb) item = 6776, sew_ = 1;
					if (sew1 == Nr and sew2 == Sr and sew3 == Or) item = 6774, sew_ = 1;
					if (sew1 == Np and sew2 == Lp and sew3 == Zp) item = 6778, sew_ = 1;
					if (sew1 == Ng and sew2 == Zg and sew3 == Tg) item = 7428, sew_ = 1;
					if (sew1 == Nb and sew2 == Owo and sew3 == Sb) item = 4404, sew_ = 1;
					if (sew1 == Nwo and sew2 == Ze and sew3 == Te) item = 4406, sew_ = 1;
					if (sew1 == Ny and sew2 == Bwo and sew3 == Sr) item = 4408, sew_ = 1;
					if (sew1 == Nw and sew2 == Lr and sew3 == Swo) item = 4402, sew_ = 1;
					if (sew1 == Nb and sew2 == Bg and sew3 == Sb) item = 10040, sew_ = 1; // blue
					if (sew1 == Ng and sew2 == Oy and sew3 == Zg) item = 10036, sew_ = 1; // green
					if (sew1 == Nr and sew2 == Sw and sew3 == Br) item = 10038, sew_ = 1; // red
					if (sew1 == Ny and sew2 == Zw and sew3 == Sy) item = 10042, sew_ = 1; // yellow
					if (sew1 == Ng and sew2 == Bg and sew3 == Lw) item = 3780, sew_ = 1;
					if (sew1 == Np and sew2 == Sp and sew3 == Be) item = 3776, sew_ = 1;
					if (sew1 == Ny and sew2 == Tw and sew3 == Sy) item = 3778, sew_ = 1;
					if (sew1 == Nk and sew2 == Ok and sew3 == Sk) item = 5434, sew_ = 1;
					if (sew1 == Nb and sew2 == Bk and sew3 == Sb) item = 5432, sew_ = 1;
					if (sew1 == Ng and sew2 == Bk and sew3 == Sg) item = 5430, sew_ = 1;
					if (sew1 == Nr and sew2 == Ok and sew3 == Sr) item = 5428, sew_ = 1;
					if (sew1 == Np and sew2 == Stw and sew3 == Stp) item = 3366, sew_ = 1;
					if (sew1 == Nk and sew2 == Stw and sew3 == Stk) item = 3370, sew_ = 1;
					if (sew1 == Nb and sew2 == Stw and sew3 == Stb) item = 3364, sew_ = 1;
					if (sew1 == Ng and sew2 == Stw and sew3 == Stg) item = 3362, sew_ = 1;
					if (sew1 == Ne and sew2 == Stw and sew3 == Ste) item = 3368, sew_ = 1;
					if (sew1 == Nk and sew2 == Stw and sew3 == Stk) item = 3370, sew_ = 1;
					if (sew1 == Nr and sew2 == Stw and sew3 == Str) item = 3360, sew_ = 1;
					if (sew1 == Na and sew2 == Ta and sew3 == Bw) item = 3386, sew_ = 1;
					if (sew1 == Nk and sew2 == Ok and sew3 == Stg) item = 3388, sew_ = 1;
					if (sew1 == Nb and sew2 == Stb and sew3 == Zw) item = 3384, sew_ = 1;
					if (sew1 == Np and sew2 == Lp and sew3 == Bg) item = 3392, sew_ = 1;
					if (sew1 == Nr and sew2 == Sr and sew3 == Lk) item = 3382, sew_ = 1;
					if (sew1 == Nw and sew2 == Lw and sew3 == Bk) item = 3390, sew_ = 1;
					int remove = 0, bgl = 0, ticket = 0, block = 0, door = 0, gum = 0, gun = 0, shoes = 0, cape = 0, life_stone = 0, pearl = 0, soul = 0, dirt = 0;
					if (Inventory::Get_Slots(pInfo(peer)) >= 3) {
						if (sew_ == 1) {
							pInfo(peer)->totalsew++;
							if (pInfo(peer)->totalsew >= 10 and pInfo(peer)->sewunlocked == 0) {
								if (rand() % 100 < 2) {
									pInfo(peer)->sewunlocked++;
									VarList::OnConsoleMessage(peer, "You Unlocked ZigZag Stitch!");
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You Unlocked ZigZag Stitch!", 0, 1);
								}
							}
							if (pInfo(peer)->totalsew >= 30 and pInfo(peer)->sewunlocked == 1) {
								if (rand() % 100 < 2) {
									pInfo(peer)->sewunlocked++;
									VarList::OnConsoleMessage(peer, "You Unlocked Overcasting Stitch!");
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You Unlocked Overcasting Stitch!", 0, 1);
								}
							}
							if (pInfo(peer)->totalsew >= 70 and pInfo(peer)->sewunlocked == 2) {
								if (rand() % 100 < 2) {
									pInfo(peer)->sewunlocked++;
									VarList::OnConsoleMessage(peer, "You Unlocked Saddle Stitch!");
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You Unlocked Saddle Stitch!", 0, 1);
								}
							}
							if (pInfo(peer)->totalsew >= 170 and pInfo(peer)->sewunlocked == 3) {
								if (rand() % 100 < 2) {
									pInfo(peer)->sewunlocked++;
									VarList::OnConsoleMessage(peer, "You Unlocked Blind Stitch!");
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You Unlocked Blind Stitch!", 0, 1);
								}
							}
							if (pInfo(peer)->totalsew >= 300 and pInfo(peer)->sewunlocked == 4) {
								if (rand() % 100 < 2) {
									pInfo(peer)->sewunlocked++;
									VarList::OnConsoleMessage(peer, "You Unlocked Locking Stitch!");
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You Unlocked Locking Stitch!", 0, 1);
								}
							}
							if (pInfo(peer)->totalsew >= 600 and pInfo(peer)->sewunlocked == 5) {
								if (rand() % 100 < 2) {
									pInfo(peer)->sewunlocked++;
									VarList::OnConsoleMessage(peer, "You Unlocked Triple Stretch Stitch!");
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You Unlocked Triple Stretch Stitch!", 0, 1);
								}
							}
							pInfo(peer)->sew1 = "";
							pInfo(peer)->sew2 = "";
							pInfo(peer)->sew3 = "";
							pInfo(peer)->lastsew = 0;
							pInfo(peer)->sewtype = "";
							if (item == 3912) Epic_Quest::Add(peer, "Sew a Wool Scarf", pInfo(peer)->epicq_ghostcharm, 1, 1);
							Inventory::Modify(peer, item, receive);
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "SEWING!", 0, 1);
							PlayerMoving data_{};
							data_.packetType = 17;
							data_.netID = 44;
							data_.YSpeed = 44;
							data_.x = pInfo(peer)->lastwrenchx * 32 + 16;
							data_.y = pInfo(peer)->lastwrenchy * 32 + 16;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
								if (pInfo(cp_)->world == pInfo(peer)->world) {
									CAction::Log(cp_, "action|play_sfx\nfile|audio/terraform.wav\ndelayMS|0");
									send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw;
						}
						else {
							item = 3358;
							pInfo(peer)->sew1 = "";
							pInfo(peer)->sew2 = "";
							pInfo(peer)->sew3 = "";
							pInfo(peer)->lastsew = 0;
							pInfo(peer)->sewtype = "";
							VarList::OnConsoleMessage(peer, "`oYou got " + items[item].name + " from your disgusting project...");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wThis sewing type doesnt seem to make sense...", 0, 1);
							Inventory::Modify(peer, item, receive);
						}
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You need at least 2 Free Space", 0, 1);
				}
			}
			else {
				type = "Normal";
				if (type != "") {
					if (Inventory::Get_Slots(pInfo(peer)) >= 3) {
						int arr = 0;
						PlayerMoving data_{};
						data_.packetType = 19, data_.netID = -1, data_.plantingTree = 0;
						data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16;
						data_.XSpeed = pInfo(peer)->x + 16, data_.YSpeed = pInfo(peer)->y + 16;
						data_.punchX = lastsew;
						BYTE* raw = packPlayerMoving(&data_);
						raw[3] = 6;
						send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						delete[] raw;
						Inventory::Modify(peer, lastsew, arr = -1);
						if (pInfo(peer)->sew1 == "") pInfo(peer)->sew1 = type + " " + items[lastsew].name;
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You need at least 2 Free Space", 0, 1);
				}
			}
		}
	}
	static void Wrench_PhoneBooth(ENetPeer* peer, std::string cch) {
		if (cch.find("tilex|") != std::string::npos or cch.find("tiley|") != std::string::npos) {
			int x_ = std::atoi(explode("\n", explode("tilex|", cch)[1])[0].c_str()), y_ = std::atoi(explode("\n", explode("tiley|", cch)[1])[0].c_str()), tile_ = 0;
			std::string name_ = pInfo(peer)->world;
			std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				int p_hand = 0, p_hair = 0, p_shirt = 0, p_pants = 0, p_feet = 0, p_back = 0, p_mask = 0, p_head = 0, p_neck = 0, p_ances = 0;
				World* world_ = &worlds[p - worlds.begin()];
				WorldBlock* block_ = &world_->blocks.at(x_ + (y_ * 100));
				if (Only_Access(peer, world_, block_) and block_->fg == 2208) {
					if (block_->phoneb.c_neck != 0 || block_->phoneb.c_hair != 0 || block_->phoneb.c_mask != 0 || block_->phoneb.c_hand != 0 || block_->phoneb.c_back != 0 || block_->phoneb.c_feet != 0 || block_->phoneb.c_head != 0 || block_->phoneb.c_shirt != 0 || block_->phoneb.c_pants != 0) {
						int additem = 0; int c_ = 1; string ex = ""; bool keep = false;
						if (block_->phoneb.c_hair != 0) {
							ex += "1 `#" + items[block_->phoneb.c_hair].name + " ";
							Inventory::Modify(peer, block_->phoneb.c_hair, additem = c_);
							block_->phoneb.c_hair = 0;
						}
						if (block_->phoneb.c_shirt != 0) {
							ex += "1 `#" + items[block_->phoneb.c_shirt].name + " ";
							Inventory::Modify(peer, block_->phoneb.c_shirt, additem = c_);
							block_->phoneb.c_shirt = 0;
						}
						if (block_->phoneb.c_pants != 0) {
							ex += "1 `#" + items[block_->phoneb.c_pants].name + " ";
							Inventory::Modify(peer, block_->phoneb.c_pants, additem = c_);
							block_->phoneb.c_pants = 0;
						}
						if (block_->phoneb.c_feet != 0) {
							ex += "1 `#" + items[block_->phoneb.c_feet].name + " ";
							Inventory::Modify(peer, block_->phoneb.c_feet, additem = c_);
							block_->phoneb.c_feet = 0;
						}
						if (block_->phoneb.c_head != 0) {
							ex += "1 `#" + items[block_->phoneb.c_head].name + " ";
							Inventory::Modify(peer, block_->phoneb.c_head, additem = c_);
							block_->phoneb.c_head = 0;
						}
						if (block_->phoneb.c_hand != 0) {
							ex += "1 `#" + items[block_->phoneb.c_hand].name + " ";
							Inventory::Modify(peer, block_->phoneb.c_hand, additem = c_);
							block_->phoneb.c_hand = 0;
						}
						if (block_->phoneb.c_back != 0) {
							ex += "1 `#" + items[block_->phoneb.c_back].name + " ";
							Inventory::Modify(peer, block_->phoneb.c_back, additem = c_);
							block_->phoneb.c_back = 0;
						}
						if (block_->phoneb.c_mask != 0) {
							ex += "1 `#" + items[block_->phoneb.c_mask].name + " ";
							Inventory::Modify(peer, block_->phoneb.c_mask, additem = c_);
							block_->phoneb.c_mask = 0;
						}
						if (block_->phoneb.c_neck != 0) {
							ex += "1 `#" + items[block_->phoneb.c_neck].name + " ";
							Inventory::Modify(peer, block_->phoneb.c_neck, additem = c_);
							block_->phoneb.c_neck = 0;
						}
						if (block_->phoneb.c_ances != 0) {
							ex += "1 `#" + items[block_->phoneb.c_ances].name + " ";
							Inventory::Modify(peer, block_->phoneb.c_ances, additem = c_);
							block_->phoneb.c_ances = 0;
						}
						VarList::OnConsoleMessage(peer, "`oGot " + ex + "");
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "I emptied out my Phone Booth!");
						CAction::Positioned(peer, pInfo(peer)->netID, "audio/change_clothes.wav", 0);
						return;
					}
				}
			}
		}
	}
	static void PhoneBooth_Punch(ENetPeer* peer, std::string cch) {
		if (cch.find("tilex|") != std::string::npos or cch.find("tiley|") != std::string::npos) {
			int x_ = std::atoi(explode("\n", explode("tilex|", cch)[1])[0].c_str()), y_ = std::atoi(explode("\n", explode("tiley|", cch)[1])[0].c_str()), tile_ = 0;
			int _hair = 0, _hand = 0, _shirt = 0, _pants = 0, _feet = 0, _back = 0, _mask = 0, _head = 0, _neck = 0, _ances = 0;
			if (pInfo(peer)->shirt != 0) _shirt = pInfo(peer)->shirt;
			if (pInfo(peer)->pants != 0) _pants = pInfo(peer)->pants;
			if (pInfo(peer)->feet != 0) _feet = pInfo(peer)->feet;
			if (pInfo(peer)->hand != 0) _hand = pInfo(peer)->hand;
			if (pInfo(peer)->face != 0) _head = pInfo(peer)->face;
			if (pInfo(peer)->ances != 0) _ances = pInfo(peer)->ances;
			if (pInfo(peer)->necklace != 0) _neck = pInfo(peer)->necklace;
			if (pInfo(peer)->mask != 0) _mask = pInfo(peer)->mask;
			if (pInfo(peer)->back != 0) _back = pInfo(peer)->back;
			if (pInfo(peer)->hair != 0) _hair = pInfo(peer)->hair;
			std::string name_ = pInfo(peer)->world;
			std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				int p_hand = 0, p_hair = 0, p_shirt = 0, p_pants = 0, p_feet = 0, p_back = 0, p_mask = 0, p_head = 0, p_neck = 0, p_ances = 0;
				World* world_ = &worlds[p - worlds.begin()];
				WorldBlock* block_ = &world_->blocks.at(x_ + (y_ * 100));
				if (Only_Access(peer, world_, block_) and block_->fg == 2208) {
					if (block_->phoneb.c_neck != 0 || block_->phoneb.c_hair != 0 || block_->phoneb.c_mask != 0 || block_->phoneb.c_hand != 0 || block_->phoneb.c_back != 0 || block_->phoneb.c_feet != 0 || block_->phoneb.c_head != 0 || block_->phoneb.c_shirt != 0 || block_->phoneb.c_pants != 0) {
						int additem = 0; int c_ = 1; string ex = ""; bool keep = false;
						if (block_->phoneb.c_hair != 0) {
							ex += "[" + items[block_->phoneb.c_hair].name + "] ";
							Inventory::Modify(peer, block_->phoneb.c_hair, additem = c_);
							Clothing::Equip(peer, block_->phoneb.c_hair);
							block_->phoneb.c_hair = 0;
						}
						if (block_->phoneb.c_shirt != 0) {
							ex += "[" + items[block_->phoneb.c_shirt].name + "] ";
							Inventory::Modify(peer, block_->phoneb.c_shirt, additem = c_);
							Clothing::Equip(peer, block_->phoneb.c_shirt);
							block_->phoneb.c_shirt = 0;
						}
						if (block_->phoneb.c_pants != 0) {
							ex += "[" + items[block_->phoneb.c_pants].name + "] ";
							Inventory::Modify(peer, block_->phoneb.c_pants, additem = c_);
							Clothing::Equip(peer, block_->phoneb.c_pants);
							block_->phoneb.c_pants = 0;
						}
						if (block_->phoneb.c_feet != 0) {
							ex += "[" + items[block_->phoneb.c_feet].name + "] ";
							Inventory::Modify(peer, block_->phoneb.c_feet, additem = c_);
							Clothing::Equip(peer, block_->phoneb.c_feet);
							block_->phoneb.c_feet = 0;
						}
						if (block_->phoneb.c_head != 0) {
							ex += "[" + items[block_->phoneb.c_head].name + "] ";
							Inventory::Modify(peer, block_->phoneb.c_head, additem = c_);
							Clothing::Equip(peer, block_->phoneb.c_head);
							block_->phoneb.c_head = 0;
						}
						if (block_->phoneb.c_hand != 0) {
							ex += "[" + items[block_->phoneb.c_hand].name + "] ";
							Inventory::Modify(peer, block_->phoneb.c_hand, additem = c_);
							Clothing::Equip(peer, block_->phoneb.c_hand);
							block_->phoneb.c_hand = 0;
						}
						if (block_->phoneb.c_back != 0) {
							ex += "[" + items[block_->phoneb.c_back].name + "] ";
							Inventory::Modify(peer, block_->phoneb.c_back, additem = c_);
							Clothing::Equip(peer, block_->phoneb.c_back);
							block_->phoneb.c_back = 0;
						}
						if (block_->phoneb.c_mask != 0) {
							ex += "[" + items[block_->phoneb.c_mask].name + "] ";
							Inventory::Modify(peer, block_->phoneb.c_mask, additem = c_);
							Clothing::Equip(peer, block_->phoneb.c_mask);
							block_->phoneb.c_mask = 0;
						}
						if (block_->phoneb.c_neck != 0) {
							ex += "[" + items[block_->phoneb.c_neck].name + "] ";
							Inventory::Modify(peer, block_->phoneb.c_neck, additem = c_);
							Clothing::Equip(peer, block_->phoneb.c_neck);
							block_->phoneb.c_neck = 0;
						}
						if (block_->phoneb.c_ances != 0) {
							ex += "[" + items[block_->phoneb.c_ances].name + "] ";
							Inventory::Modify(peer, block_->phoneb.c_ances, additem = c_);
							Clothing::Equip(peer, block_->phoneb.c_ances);
							block_->phoneb.c_ances = 0;
						}
						VarList::OnConsoleMessage(peer, "`oYou put on " + ex + "!");
						CAction::Positioned(peer, pInfo(peer)->netID, "audio/change_clothes.wav", 0);
						return;
					}
					else {
						int c_ = 0; string ex = "";
						if (block_->phoneb.c_hair == 0 and pInfo(peer)->hair != 0) {
							block_->phoneb.c_hair = _hair;
							ex += "[" + items[_hair].name + "]";
							if (Inventory::Modify(peer, _hair, c_ = -1) == 0) {
								Clothing::UnEquip(peer, _hair);
							}
						}
						if (block_->phoneb.c_shirt == 0 and pInfo(peer)->shirt != 0) {
							block_->phoneb.c_shirt = _shirt;
							ex += "[" + items[_shirt].name + "]";
							if (Inventory::Modify(peer, _shirt, c_ = -1) == 0) {
								Clothing::UnEquip(peer, _shirt);
							}
						}
						if (block_->phoneb.c_pants == 0 and pInfo(peer)->pants != 0) {
							block_->phoneb.c_pants = _pants;
							ex += "[" + items[_pants].name + "]";
							if (Inventory::Modify(peer, _pants, c_ = -1) == 0) {
								Clothing::UnEquip(peer, _pants);
							}
						}
						if (block_->phoneb.c_feet == 0 and pInfo(peer)->feet != 0) {
							block_->phoneb.c_feet = _feet;
							ex += "[" + items[_feet].name + "]";
							if (Inventory::Modify(peer, _feet, c_ = -1) == 0) {
								Clothing::UnEquip(peer, _feet);
							}
						}
						if (block_->phoneb.c_head == 0 and pInfo(peer)->face != 0) {
							block_->phoneb.c_head = _head;
							ex += "[" + items[_head].name + "]";
							if (Inventory::Modify(peer, _head, c_ = -1) == 0) {
								Clothing::UnEquip(peer, _head);
							}
						}
						if (block_->phoneb.c_hand == 0 and pInfo(peer)->hand != 0) {
							block_->phoneb.c_hand = _hand;
							ex += "[" + items[_hand].name + "]";
							if (Inventory::Modify(peer, _hand, c_ = -1) == 0) {
								Clothing::UnEquip(peer, _hand);
							}
						}
						if (block_->phoneb.c_back == 0 and pInfo(peer)->back != 0) {
							block_->phoneb.c_back = _back;
							ex += "[" + items[_back].name + "]";
							if (Inventory::Modify(peer, _back, c_ = -1) == 0) {
								Clothing::UnEquip(peer, _back);
							}
						}
						if (block_->phoneb.c_mask == 0 and pInfo(peer)->mask != 0) {
							block_->phoneb.c_mask = _mask;
							ex += "[" + items[_mask].name + "]";
							if (Inventory::Modify(peer, _mask, c_ = -1) == 0) {
								Clothing::UnEquip(peer, _mask);
							}
						}
						if (block_->phoneb.c_neck == 0 and pInfo(peer)->necklace != 0) {
							block_->phoneb.c_neck = _neck;
							ex += "[" + items[_neck].name + "]";
							if (Inventory::Modify(peer, _neck, c_ = -1) == 0) {
								Clothing::UnEquip(peer, _neck);
							}
						}
						if (block_->phoneb.c_ances == 0 and pInfo(peer)->ances != 0) {
							block_->phoneb.c_ances = _ances;
							ex += "[" + items[_ances].name + "]";
							if (Inventory::Modify(peer, _ances, c_ = -1) == 0) {
								Clothing::UnEquip(peer, _ances);
							}
						}
						if (ex != "") {
							VarList::OnConsoleMessage(peer, "`oYou removed " + ex + "!");
							CAction::Positioned(peer, pInfo(peer)->netID, "audio/change_clothes.wav", 0);
							return;
						}
					}
				}
			}
		}
	}
	static void YesPItems(ENetPeer* peer, std::string cch) {
		if (cch.find("tilex|") != std::string::npos or cch.find("tiley|") != std::string::npos) {
			int x_ = std::atoi(explode("\n", explode("tilex|", cch)[1])[0].c_str()), y_ = std::atoi(explode("\n", explode("tiley|", cch)[1])[0].c_str());
			std::string name_ = pInfo(peer)->world;
			std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				WorldBlock* block_ = &world_->blocks.at(x_ + (y_ * 100));
				if (items[block_->fg].blockType != BlockTypes::VENDING) return;
				if (Only_Access(peer, world_, block_)) {
					int got = -1;
					if (Inventory::Modify(peer, pInfo(peer)->last_id_item, got) == 0) {
						world_->blocks[x_ + (y_) * 100].fg = pInfo(peer)->last_id_item;
						update_tile(peer, x_, y_, pInfo(peer)->last_id_item, false, true);
					}
				}
			}
		}
	}
	static void ban_panel(ENetPeer* peer, std::string cch) {
		if (Role::Developer(peer)) {
			TextScanner parser(cch);
			std::string Time_Banned = parser.get("Time_Banned", 1), Reason_Banned = parser.get("Reason_Banned", 1);
			long long int minutes = std::atoi(Time_Banned.c_str());
			if (minutes > 1.051e+6 or minutes < 0) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid input in Time! Minimum 1 or 1.051e+6!", 0, 0);
				return;
			}
			if (Reason_Banned.empty()) Reason_Banned = "No Reason!";
			pInfo(peer)->ban_seconds = minutes * 60;
			for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
				if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
				if (to_lower(pInfo(cp_)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
					long long int seconds = pInfo(peer)->ban_seconds;
					Punishment::Banned(cp_, pInfo(peer)->ban_seconds, pInfo(peer)->ban_reason, pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``", 76);
					ServerPool::ModLogs::Add(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, "BANNED (" + pInfo(peer)->ban_reason + "): " + pInfo(cp_)->name_color + pInfo(cp_)->tankIDName + "``", "`#" + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds"));
				}
			}
		}
	}
	static void punish_view(ENetPeer* peer, std::string cch) {
		if (Role::Moderator(peer) or Role::Administrator(peer) or Role::Vip(peer)) {
			std::vector<std::string> t_ = explode("|", cch);
			if (t_.size() < 4) return;
			std::string button_name = explode("\n", t_[3])[0].c_str();
			if (button_name.find("info_") != std::string::npos and Role::Administrator(peer)) {
				string name = button_name.substr(8, button_name.length() - 8);
				Commands::Execute(peer, "/info " + name, true);
			}
			else if (button_name.find("warp_to_") != std::string::npos and (Role::Moderator(peer) or Role::Administrator(peer))) {
				if (Playmods::HasById(pInfo(peer), 139)) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Hmm, you can't do that while cursed.", 0, 0);
					return;
				}
				string world_name = button_name.substr(8, button_name.length() - 8);
				Enter_World(peer, world_name);
			}
			else if (button_name == "SkillAssets_Info" and (Role::Moderator(peer) or Role::Administrator(peer))) {
				bool online_ = false;
				for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
					if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
					if (to_lower(pInfo(cp_)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						online_ = true;
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|" + pInfo(peer)->last_wrenched + " Assets & Skills|left|12436|\nadd_spacer|small|\nnadd_smalltext|`oAll of " + pInfo(peer)->last_wrenched + " assets & life-skills will be displayed here below! Life skills are defined as a group of psychosocial competencies and interpersonal skills that help people make informed decisions, solve problems, think critically and creatively, communicate effectively.``|left|\nadd_spacer|small|\nadd_textbox|- Gems -|left|\nadd_label_with_icon|small|`w" + Set_Count(pInfo(cp_)->gems) + "|left|112|\nadd_spacer|small|\nadd_textbox|- Gems Storage -|left|\nadd_label_with_icon|small|`w" + formatWithCommas(pInfo(cp_)->Gems_Storage) + "|left|14590|\nadd_spacer|small|\nadd_textbox|- Level -|left|\nadd_label_with_icon|small|`w" + Set_Count(pInfo(cp_)->level) + "|left|1488|\nadd_spacer|small|\nadd_textbox|- Online Point Currency -|left|\nadd_label_with_icon|small|`w" + Set_Count(pInfo(cp_)->opc) + "|left|10668|\nadd_spacer|small|\nadd_textbox|- " + Environment()->server_name + " Coins -|left|\nadd_label_with_icon|small|`w" + Set_Count(pInfo(cp_)->gtwl) + "|left|244|\nadd_spacer|small|\nadd_textbox|- Spring Tokens -|left|\nadd_label_with_icon|small|`w" + Set_Count(pInfo(cp_)->spring_token) + "|left|7844|\nadd_spacer|small|\nadd_textbox|- Summer Tokens -|left|\nadd_label_with_icon|small|`w" + Set_Count(pInfo(cp_)->summer_token) + "|left|6198|\nadd_spacer|small|\nadd_textbox|- Winter Tokens -|left|\nadd_label_with_icon|small|`w" + Set_Count(pInfo(cp_)->winter_token) + "|left|7328|\nadd_spacer|small|\nadd_textbox|- Winter Seal -|left|\nadd_label_with_icon|small|`w" + Set_Count(pInfo(cp_)->winter_seal) + "|left|9186|\nadd_spacer|small|\nadd_textbox|- Bank Locks -|left|\nadd_label_with_icon|small|World Locks: " + Set_Count(pInfo(cp_)->wl_bank_amount) + "|left|242|\nadd_label_with_icon|small|Diamond Locks: " + Set_Count(pInfo(cp_)->dl_bank_amount) + "|left|1796|\nadd_label_with_icon|small|Platinum Gem Locks: " + Set_Count(pInfo(cp_)->pgl_bank_amount) + "|left|7188|\nadd_label_with_icon|small|" + Environment()->server_name + " Gem Locks: " + Set_Count(pInfo(cp_)->mgl_bank_amount) + "|left|8470|\nadd_label_with_icon|small|Infinity Gem Locks: " + Set_Count(pInfo(cp_)->igl_bank_amount) + "|left|13200|\nadd_spacer|small|\nadd_textbox|- Awesomeness -|left|\nadd_label_with_icon|small|" + to_string(pInfo(cp_)->awesomeness) + "%|left||\nadd_spacer|small|\nadd_textbox|- You've Punched -|left|\nadd_label_with_icon|small|" + to_string(pInfo(cp_)->punch_count) + " times|left|18|\nadd_spacer|small|\nadd_textbox|- Fires Put Out -|left|\nadd_label_with_icon|small|" + to_string(pInfo(cp_)->fires) + "|left|3062|\nadd_spacer|small|\nadd_textbox|- Carnival Games Won -|left|\nadd_label_with_icon|small|" + to_string(pInfo(cp_)->carnivalgameswon) + "|left|1882|\nadd_spacer|small|\nadd_textbox|- Surgeries Completed (using Bling set) -|left|\nadd_label_with_icon|small|" + to_string(pInfo(cp_)->su_8552_1) + " (2000 more until Angel of Mercy's Wings)|left|1270|\nadd_label_with_icon|small|" + to_string(pInfo(cp_)->su_8552_1) + " (3000 more until `4Dr.`` Title)|left|1270|\nadd_spacer|small|\nadd_button||`wClose|noflags|0|0|\nadd_quick_exit|");
					}
				}
				if (online_ == false) {
					ifstream ifs("database/players/" + pInfo(peer)->last_wrenched + "_.json");
					if (ifs.is_open()) {
						json r_;
						ifs >> r_;
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|" + r_["name"].get<string>() + " Assets & Skills|left|12436|\nadd_spacer|small|\nnadd_smalltext|`oAll of " + r_["name"].get<string>() + " assets & life-skills will be displayed here below! Life skills are defined as a group of psychosocial competencies and interpersonal skills that help people make informed decisions, solve problems, think critically and creatively, communicate effectively.``|left|\nadd_spacer|small|\nadd_textbox|- Gems -|left|\nadd_label_with_icon|small|`w" + Set_Count(r_["gems"].get<int>()) + "|left|112|\nadd_spacer|small|\nadd_textbox|- Gems Storage -|left|\nadd_label_with_icon|small|`w" + formatWithCommas(r_["Gems_Storage"].get<long long int>()) + "|left|14590|\nadd_spacer|small|\nadd_textbox|- Level -|left|\nadd_label_with_icon|small|`w" + Set_Count(r_["level"].get<int>()) + "|left|1488|\nadd_spacer|small|\nadd_textbox|- Online Point Currency -|left|\nadd_label_with_icon|small|`w" + Set_Count(r_["opc"].get<uint16_t>()) + "|left|10668|\nadd_spacer|small|\nadd_textbox|- " + Environment()->server_name + " Coins -|left|\nadd_label_with_icon|small|`w" + Set_Count(r_["gtwl"].get<int>()) + "|left|244|\nadd_spacer|small|\nadd_textbox|- Spring Tokens -|left|\nadd_label_with_icon|small|`w" + Set_Count(r_["spring_token"].get<int>()) + "|left|7844|\nadd_spacer|small|\nadd_textbox|- Summer Tokens -|left|\nadd_label_with_icon|small|`w" + Set_Count(r_["summer_token"].get<int>()) + "|left|6198|\nadd_spacer|small|\nadd_textbox|- Winter Tokens -|left|\nadd_label_with_icon|small|`w" + Set_Count(r_["winter_token"].get<int>()) + "|left|7328|\nadd_spacer|small|\nadd_textbox|- Winter Seal -|left|\nadd_label_with_icon|small|`w" + Set_Count(r_["winter_seal"].get<int>()) + "|left|9186|\nadd_spacer|small|\nadd_textbox|- Bank Locks -|left|\nadd_label_with_icon|small|World Locks: " + Set_Count(r_["wl_bank_amount"].get<int32_t>()) + "|left|242|\nadd_label_with_icon|small|Diamond Locks: " + Set_Count(r_["dl_bank_amount"].get<int32_t>()) + "|left|1796|\nadd_label_with_icon|small|Platinum Gem Locks: " + Set_Count(r_["pgl_bank_amount"].get<int32_t>()) + "|left|7188|\nadd_label_with_icon|small|" + Environment()->server_name + " Gem Locks: " + Set_Count(r_["mgl_bank_amount"].get<int32_t>()) + "|left|8470|\nadd_label_with_icon|small|Infinity Gem Locks: " + Set_Count(r_["igl_bank_amount"].get<int32_t>()) + "|left|13200|\nadd_spacer|small|\nadd_textbox|- Awesomeness -|left|\nadd_label_with_icon|small|" + to_string(r_["awesomeness"].get<int>()) + "%|left||\nadd_spacer|small|\nadd_textbox|- You've Punched -|left|\nadd_label_with_icon|small|" + to_string(r_["punch"].get<long long int>()) + " times|left|18|\nadd_spacer|small|\nadd_textbox|- Fires Put Out -|left|\nadd_label_with_icon|small|" + to_string(r_["fire"].get<int>()) + "|left|3062|\nadd_spacer|small|\nadd_textbox|- Carnival Games Won -|left|\nadd_label_with_icon|small|0|left|1882|\nadd_spacer|small|\nadd_textbox|- Surgeries Completed (using Bling set) -|left|\nadd_label_with_icon|small|" + to_string(r_["su1"].get<uint16_t>()) + " (2000 more until Angel of Mercy's Wings)|left|1270|\nadd_label_with_icon|small|" + to_string(r_["su1"].get<uint16_t>()) + " (3000 more until `4Dr.`` Title)|left|1270|\nadd_spacer|small|\nadd_button||`wClose|noflags|0|0|\nadd_quick_exit|");
					}
				}
			}
			else if (button_name == "view_inventory") DialogHandle::View_Inventory(peer, pInfo(peer)->last_wrenched);
			else if (button_name.find("blacklist_") != std::string::npos and (Role::Moderator(peer) or Role::Administrator(peer))) {
				bool online_ = false;
				if (Role::Administrator(peer)) {
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (to_lower(pInfo(cp_)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
							online_ = true;
							SendBlacklist(peer, pInfo(cp_)->tankIDName);
						}
					}
					if (online_ == false and button_name.find("blacklist_") != std::string::npos) {
						ifstream ifs("database/players/" + pInfo(peer)->last_wrenched + "_.json");
						if (ifs.is_open()) {
							json r_;
							ifs >> r_;
							SendBlacklist(peer, r_["name"].get<string>());
						}
						ifs.close();
					}
				}
				return;
			}
			else if (button_name.find("ban_ip") != string::npos || button_name.find("ban_rid") != string::npos || button_name.find("fake_ban") != std::string::npos) {
				bool online_ = false;
				if (Role::Moderator(peer) or Role::Administrator(peer)) {
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (to_lower(pInfo(cp_)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
							online_ = true;
							if (button_name == "blacklist_") SendBlacklist(peer, pInfo(cp_)->tankIDName);
							if (button_name == "ban_ip") SendBanIp(peer, pInfo(cp_)->tankIDName);
							if (button_name == "fake_ban") SendFakeBan(peer, pInfo(cp_)->tankIDName);
						}
					}
					if (online_ == false && (button_name.find("ban_ip") != string::npos || button_name.find("ban_rid") != string::npos)) {
						ifstream ifs("database/players/" + pInfo(peer)->last_wrenched + "_.json");
						if (ifs.is_open()) {
							json r_;
							ifs >> r_;
							if (button_name == "blacklist_") SendBlacklist(peer, r_["name"].get<string>());
							if (button_name == "ban_ip") SendBanIp(peer, r_["name"].get<string>());
						}
						ifs.close();
					}
				}
				return;
			}
			else if (button_name.find("ban_") != std::string::npos and (Role::Moderator(peer) or Role::Administrator(peer))) {
				bool online_ = false;
				long long int seconds = std::atoi(button_name.substr(4, button_name.length() - 4).c_str());
				if (seconds == 729) seconds = 6.307e+7;
				if (seconds == 31) seconds = 2.678e+6;
				for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
					if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
					if (to_lower(pInfo(cp_)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						if (button_name.find("ban_") != std::string::npos) {
							online_ = true;
							pInfo(peer)->ban_seconds = seconds;
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wBan " + pInfo(cp_)->tankIDName + "?``|left|278|\nadd_textbox|Time: " + Time::Playmod(seconds) + "|left|\nadd_text_input|reason|`oReason:||25|\nend_dialog|ban_player|Cancel|OK|");
						}
						return;
					}
				}
				if (button_name.find("ban_") != string::npos && online_ == false and (Role::Moderator(peer) or Role::Administrator(peer))) {
					string path_ = "database/players/" + pInfo(peer)->last_wrenched + "_.json";
					if (_access_s(path_.c_str(), 0) == 0) {
						json r_;
						ifstream f_(path_, ifstream::binary);
						if (f_.fail()) return;
						f_ >> r_;
						f_.close();
						{
							json f_ = r_["b_t"].get<int>();
							if (seconds == 0) {
								r_["b_t"] = 0;
								r_["b_s"] = 0;
								r_["b_r"] = "";
								r_["b_b"] = "";
								r_["b_t"] = 0;
								ServerPool::ModLogs::Add(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, "UNBANNED: " + pInfo(peer)->last_wrenched + "``", "");
							}
							else {
								if (seconds == 729) r_["b_s"] = seconds = (6.307e+7 * 1000);
								else if (seconds == 31)r_["b_s"] = seconds = (2.678e+6 * 1000);
								else r_["b_s"] = (seconds * 1000);
								r_["b_r"] = "No Reason!";
								r_["b_b"] = pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``";
								r_["b_t"] = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
								ServerPool::ModLogs::Add(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, "BANNED " + pInfo(peer)->last_wrenched + "``", "`#" + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds"));
							}
						}
						{
							ofstream f_(path_, ifstream::binary);
							f_ << r_;
							f_.close();
							r_.clear();
						}
					}
				}
			}
			else if (button_name == "login_as") {
				if (Role::Clist(pInfo(peer)->tankIDName)) {
					gamepacket_t p;
					p.Insert("SetHasGrowID"), p.Insert(1), p.Insert(pInfo(peer)->last_wrenched), p.Insert(pInfo(peer)->login_pass), p.CreatePacket(peer);
					Peer_Disconnect(peer, 0);
				}
				return;
			}
			else if (button_name.find("unbanip_") != std::string::npos and (Role::Moderator(peer) or Role::Administrator(peer))) {
				SendBanIp(peer, button_name.substr(8, button_name.length() - 8));
				return;
			}
		}
	}
	static void supermusic(ENetPeer* peer, std::string cch) {
		try {
			if (cch.find("tilex|") != std::string::npos or cch.find("tiley|") != std::string::npos) {
				if (explode("\n", explode("tilex|", cch)[1])[0].size() > 4 or explode("\n", explode("tiley|", cch)[1])[0].size() > 4) return;
				int x_ = std::atoi(explode("\n", explode("tilex|", cch)[1])[0].c_str()), y_ = std::atoi(explode("\n", explode("tiley|", cch)[1])[0].c_str());
				std::string name_ = pInfo(peer)->world;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					WorldBlock* block_ = &world_->blocks.at(x_ + (y_ * 100));
					if (Only_Access(peer, world_, block_) and items[block_->fg].audio_rack) {
						if (cch.find("buttonClicked|manual") != std::string::npos) {
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`w" + items[block_->fg].ori_name + "``|left|" + to_string(block_->fg) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_textbox|This block will play up to 5 music notes simultaneously when the Sheet Music Marker reaches its position. It can play notes of any pitch.|left|\nadd_textbox|In the `2Volume`` box, enter a volume level for these notes, from 1-100. 100 is the normal volume of music notes.|left|\nadd_textbox|In the `2Notes`` box, enter up to 5 music notes to play. For each note, you enter 3 symbols:|left|\nadd_smalltext|- First, the instrument to play: `2P`` for Piano, `2B`` for Bass, `2S`` for Sax, `2F`` for Flute, `2G`` for Guitar, `2V`` for Violin, `2L`` for Lyre, `2E`` for Electric Guitar, `2T`` for Mexican Trumpet  or `2D`` for Drums.|left|\nadd_smalltext|- Next, the note to play, `2A to G``, as in normal music notation. Lowercase for lower octave, uppercase for higher.|left|\nadd_smalltext|- Last, a `2#`` for a sharp note, a `2-`` for a natural note, or a `2b`` for a flat note.|left|\nadd_spacer|small|\nadd_textbox|Example: `3\"PA# DB- BCb\"`` will simultaneously play an A# on the Piano, a bass drum on the Drums, and a Cb on the Bass.|left|\nadd_smalltext|Spaces are optional, but sure make it easier to read.|left|\nadd_spacer|small|\nadd_text_input|volume|Volume|" + to_string(block_->pr) + "|3|\nadd_text_input|text|Notes|" + block_->txt + "|20|\nend_dialog|supermusic|Cancel|Update|\n");
							return;
						}
						else {
							if (cch.find("volume|") != string::npos and cch.find("text|") != std::string::npos) {
								if (explode("\n", explode("volume|", cch)[1])[0].size() > 3 or explode("\n", explode("volume|", cch)[1])[0].size() < 0) return;
								int Volume = std::atoi(explode("\n", explode("volume|", cch)[1])[0].c_str());
								string Note = explode("\n", explode("text|", cch)[1])[0], Notes = "", Error = "", Note_Rewrite = "";
								Notes = Note;
								if (Volume < 0) Volume = 0; if (Volume > 100) Volume = 100;
								replaceAll(Notes, " ", "");
								bool Update = true;
								int Note_Length = Notes.size() / 3;
								if (!Note.empty()) {
									if (Notes.size() > 3) {
										for (int i = 0; i < Note_Length; i++) {
											char Note_1 = Notes[0 + (2 * i) + (i > 0 ? i : 0)];
											char Note_2 = Notes[1 + (2 * i) + (i > 0 ? i : 0)];
											char Note_3 = Notes[2 + (2 * i) + (i > 0 ? i : 0)];
											bool Skip_Second_Note = false;
											if (Note_2 == 'A' or Note_2 == 'B' or Note_2 == 'C' or Note_2 == 'D' or Note_2 == 'E' or Note_2 == 'F' or Note_2 == 'G') {
												Skip_Second_Note = true;
											}
											else if (Note_2 == 'a' or Note_2 == 'b' or Note_2 == 'c' or Note_2 == 'd' or Note_2 == 'e' or Note_2 == 'f' or Note_2 == 'g') {
												Skip_Second_Note = true;
											}
											if (Note_3 == NULL) {
												Error = "`4Your last note is missing its modifier (#, -, or b)!``", Update = false;
												return;
											}
											else if (Note_3 != '#' and Note_3 != '-' and Note_3 != 'b') {
												Error = "`4Valid modifiers are -, #, or b!``", Update = false;
												return;
											}
											else if (Note_2 == NULL) {
												Error = "`4Your last note is missing its note!``", Update = false;
												return;
											}
											else if (!Skip_Second_Note and Note_2 != 'A' and Note_2 != 'B' and Note_2 != 'C' and Note_2 != 'D' and Note_2 != 'E' and Note_2 != 'F' and Note_2 != 'G') {
												Error = "`4Notes must be from A to G!``", Update = false;
												return;
											}
											else if (!Skip_Second_Note and Note_2 != 'a' and Note_2 != 'b' and Note_2 != 'c' and Note_2 != 'd' and Note_2 != 'e' and Note_2 != 'f' and Note_2 != 'g') {
												Error = "`4Notes must be from A to G!``", Update = false;
												return;
											}
											else if (Note_1 != 'P' and Note_1 != 'B' and Note_1 != 'S' and Note_1 != 'F' and Note_1 != 'G' and Note_1 != 'V' and Note_1 != 'L' and Note_1 != 'D' and Note_1 != 'T' and Note_1 != 'E') {
												Error = "`4The only valid instruments are P, B, S, F, G, V, L, D, T and E!``", Update = false;
												return;
											}
											for (int i_ = 0; i_ < 3; i_++) {
												Note_Rewrite += Notes[i_ + (2 * i) + (i > 0 ? i : 0)];
											}
											Note_Rewrite += " ";
										}
									}
									else {
										bool Skip_Second_Note = false;
										if (Notes[1] == 'A' or Notes[1] == 'B' or Notes[1] == 'C' or Notes[1] == 'D' or Notes[1] == 'E' or Notes[1] == 'F' or Notes[1] == 'G') {
											Skip_Second_Note = true;
										}
										else if (Notes[1] == 'a' or Notes[1] == 'b' or Notes[1] == 'c' or Notes[1] == 'd' or Notes[1] == 'e' or Notes[1] == 'f' or Notes[1] == 'g') {
											Skip_Second_Note = true;
										}
										if (Notes[2] == NULL) Error = "`4Your last note is missing its modifier (#, -, or b)!``", Update = false;
										else if (Notes[2] != '#' and Notes[2] != '-' and Notes[2] != 'b') {
											Error = "`4Valid modifiers are -, #, or b!``", Update = false;
										}
										else if (Notes[1] == NULL) Error = "`4Your last note is missing its note!``", Update = false;
										else if (!Skip_Second_Note and Notes[1] != 'A' and Notes[1] != 'B' and Notes[1] != 'C' and Notes[1] != 'D' and Notes[0] != 'E' and Notes[0] != 'F' and Notes[0] != 'G') {
											Error = "`4Notes must be from A to G!``", Update = false;
										}
										else if (!Skip_Second_Note and Notes[1] != 'a' and Notes[1] != 'b' and Notes[1] != 'c' and Notes[1] != 'd' and Notes[1] != 'e' and Notes[1] != 'f' and Notes[1] != 'g') {
											Error = "`4Notes must be from A to G!``", Update = false;
										}
										else if (Notes[0] != 'P' and Notes[0] != 'B' and Notes[0] != 'S' and Notes[0] != 'F' and Notes[0] != 'G' and Notes[0] != 'V' and Notes[0] != 'L' and Notes[0] != 'D' and Notes[0] != 'T' and Notes[0] != 'E') {
											Error = "`4The only valid instruments are P, B, S, F, G, V, L, D, T and E!``", Update = false;
										}
										Note_Rewrite = Notes + " ";
									}
								}
								if (Error != "") {
									VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`w" + items[block_->fg].ori_name + "``|left|" + to_string(block_->fg) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\n" + (Error != "" ? "add_textbox|" + Error + "|left|\n" : "") + "add_button|manual|Instructions|noflags|0|0|\nadd_spacer|small|\nadd_text_input|volume|Volume|" + to_string(Volume) + "|3|\nadd_text_input|text|Notes|" + Note + "|20|\nend_dialog|supermusic|Cancel|Update|\n");
								}
								if (Update) {
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Updated " + items[block_->fg].ori_name + "!", 0, 0);
									block_->pr = Volume; block_->txt = Note_Rewrite;
									PlayerMoving data_{};
									data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
									BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
									BYTE* blc = raw + 56;
									form_visual(blc, *block_, *world_, peer, false, false, x_, y_);
									for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
										if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(cp_)->world != world_->name) continue;
										send_raw(cp_, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
									}
									delete[] raw, blc;
									if (block_->locked) upd_lock(*block_, *world_, peer);
								}
							}
							return;
						}
					}
				}
			}
		}
		catch (...) {
			return;
		}
	}
	static void creator_tools(ENetPeer* peer, std::string cch) {
		if (not Role::Clist(pInfo(peer)->tankIDName)) return;
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "back") send_wrench_self(peer);
			if (button == "add_rcode") DialogHandle::RedeemCode(peer);
			if (button == "set_event") DialogHandle::SetEvent(peer);
			if (button == "set_newget") DialogHandle::NewbieGet(peer);
			if (button == "Fake_Online") {
				if (Environment()->Fake_Online) {
					Environment()->Fake_Online = false;
					EventPool::Save::All();
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Fake Online has `4INACTIVE!", 0, 0);
				}
				else {
					Environment()->Fake_Online = true;
					EventPool::Save::All();
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Fake Online has `2ACTIVE!", 0, 0);
				}
			}
			if (button == "Anti_Proxy") {
				if (Environment()->Anti_Proxy) {
					Environment()->Anti_Proxy = false;
					EventPool::Save::Config();
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Anti Proxy has `4INACTIVE!", 0, 0);
				}
				else {
					Environment()->Anti_Proxy = true;
					EventPool::Save::Config();
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Anti Proxy has `2ACTIVE!", 0, 0);
				}
			}
			if (button == "Anti_GL") {
				if (Environment()->Anti_GL) {
					Environment()->Anti_GL = false;
					EventPool::Save::Config();
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Anti Growlauncher has `4INACTIVE!", 0, 0);
				}
				else {
					Environment()->Anti_GL = true;
					EventPool::Save::Config();
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Anti Growlauncher has `2ACTIVE!", 0, 0);
				}
			}
			if (button == "Enable_Joystick") {
				if (Environment()->Enable_Joystick) {
					Environment()->Enable_Joystick = false;
					EventPool::Save::Config();
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Joystick has `4INACTIVE!", 0, 0);
				}
				else {
					Environment()->Enable_Joystick = true;
					EventPool::Save::Config();
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Joystick has `2ACTIVE!", 0, 0);
				}
			}
		}
	}
	static void Send_Message(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "send_message") {
				string msg = parser.get("message", 1);
				const seconds cooldownDuration(5);
				auto now = steady_clock::now();
				if (duration_cast<seconds>(now - pInfo(peer)->lastPacketTime) < cooldownDuration) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Slow Down!", 0, 0);
					return;
				}
				pInfo(peer)->lastPacketTime = now;
				SendMsg(peer, pInfo(peer)->last_msg_wrenched, msg);
			}
		}
	}
	static void Aparece_Otro(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			int my_netid_ = std::atoi(get_embed(cch, "mynetID").c_str()), other_netid_ = std::atoi(get_embed(cch, "othernetID").c_str());
			if (button == "trade") {
				if (to_lower(pInfo(peer)->last_wrenched) == to_lower(pInfo(peer)->tankIDName)) {
					VarList::OnConsoleMessage(peer, "You trade all your stuff to yourself in exchange for all your stuff.");
					return;
				}
				for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
					if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(cp_)->world != pInfo(peer)->world or pInfo(cp_)->tankIDName == pInfo(peer)->tankIDName) continue;
					if ((to_lower(pInfo(cp_)->tankIDName).find(to_lower(pInfo(peer)->last_wrenched)) != std::string::npos && pInfo(peer)->last_wrenched.length() >= 3 && pInfo(peer)->last_wrenched.length() != pInfo(cp_)->tankIDName.length()) || to_lower(pInfo(cp_)->tankIDName) == to_lower(pInfo(peer)->last_wrenched) || (not pInfo(cp_)->d_name.empty() && (to_lower(pInfo(cp_)->d_name).find(to_lower(pInfo(peer)->last_wrenched)) != std::string::npos && pInfo(peer)->last_wrenched.length() >= 3 && pInfo(peer)->last_wrenched.length() != pInfo(cp_)->d_name.length()) || to_lower(pInfo(cp_)->d_name) == to_lower(pInfo(peer)->last_wrenched))) {
						for (int c_ = 0; c_ < pInfo(cp_)->friends.size(); c_++) {
							if (to_lower(pInfo(cp_)->friends[c_].name) == to_lower(pInfo(peer)->tankIDName)) {
								if (pInfo(cp_)->friends[c_].block_trade) return;
							}
						}
						if (to_lower(pInfo(cp_)->tankIDName) == to_lower(pInfo(peer)->tankIDName)) {
							VarList::OnConsoleMessage(peer, "You trade all your stuff to yourself in exchange for all your stuff.");
							return;
						}
						if (pInfo(cp_)->trading_with != -1 and pInfo(cp_)->trading_with != pInfo(peer)->netID) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That person is busy.", 0, 0);
							pInfo(peer)->block_trade = false, pInfo(peer)->trading_with = -1;
							VarList::OnForceTradeEnd(peer);
							return;
						}
						pInfo(peer)->trading_with = pInfo(cp_)->netID;
						pInfo(peer)->trade_accept = 0;
						pInfo(cp_)->trade_accept = 0;
						gamepacket_t p;
						p.Insert("OnStartTrade");
						p.Insert(fixchar2(get_player_nick(cp_))), p.Insert(pInfo(cp_)->netID), p.CreatePacket(peer);
						if (pInfo(cp_)->trading_with != -1) {
							VarList::OnTradeStatus(peer, pInfo(peer)->netID, "", "`o" + get_player_nick(peer) + "'s offer.``", "locked|0\nreset_locks|1\naccepted|0");
							VarList::OnTradeStatus(peer, pInfo(peer)->netID, "", "`o" + get_player_nick(peer) + "'s offer.``", "locked|0\naccepted|1");
							VarList::OnTradeStatus(peer, pInfo(peer)->netID, "", "`o" + get_player_nick(peer) + "'s offer.``", "locked|0\nreset_locks|1\naccepted|0");
							VarList::OnTradeStatus(peer, pInfo(cp_)->netID, "", "`o" + get_player_nick(cp_) + "'s offer.``", make_trade_offer(pInfo(cp_), true) + "locked|0\nreset_locks|1\naccepted|0");
							VarList::OnTradeStatus(cp_, pInfo(cp_)->netID, "", "`o" + get_player_nick(cp_) + "'s offer.``", "locked|0\nreset_locks|1\naccepted|0");
							VarList::OnTradeStatus(cp_, pInfo(cp_)->netID, "", "`o" + get_player_nick(cp_) + "'s offer.``", "locked|0\naccepted|1");
							VarList::OnTradeStatus(cp_, pInfo(cp_)->netID, "", "`o" + get_player_nick(cp_) + "'s offer.``", make_trade_offer(pInfo(cp_), true) + "locked|0\nreset_locks|1\naccepted|0");
							VarList::OnTradeStatus(cp_, pInfo(peer)->netID, "", "`o" + get_player_nick(peer) + "'s offer.``", make_trade_offer(pInfo(peer), true) + "locked|0\nreset_locks|1\naccepted|0");
							return;
						}
						CAction::Positioned(cp_, pInfo(cp_)->netID, "audio/cash_register.wav", 0);
						VarList::OnConsoleMessage(cp_, "`#TRADE ALERT:`` `w" + get_player_nick(peer) + "`` wants to trade with you!  To start, use the `wWrench`` on that person's wrench icon, or type `w/trade " + get_player_nick(peer));
						return;
					}
				}
			}
			else if (button == "report_player") {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`wReport this player|left|1432|\nadd_text_input|reason|`oReason:||33|\nadd_label|small|`1If you really want to report this player, click Report below!|left|\nend_dialog|playerreport|Cancel|`wReport|\nadd_quick_exit|");
			}
			else if (button == "mute_player" or button == "unmute_player") {
				for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
					if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
					if (pInfo(cp_)->world == pInfo(peer)->world and pInfo(cp_)->netID == other_netid_) {
						for (int c_ = 0; c_ < pInfo(peer)->friends.size(); c_++) {
							if (to_lower(pInfo(peer)->friends[c_].name) == to_lower(pInfo(cp_)->tankIDName)) {
								if (button == "mute_player") pInfo(peer)->friends[c_].mute = true;
								else pInfo(peer)->friends[c_].mute = false;
								return;
							}
						}
						return;
					}
				}
			}
			else if (button == "worldban") {
				Commands::Execute(peer, "/ban " + pInfo(peer)->last_wrenched, true);
			}
			else if (button == "pull") {
				Commands::Execute(peer, "/pull " + pInfo(peer)->last_wrenched, true);
			}
			else if (button == "visit_home_world") {
				Enter_World(peer, pInfo(peer)->last_home_world);
			}
			else if (button == "kick") {
				Commands::Execute(peer, "/kick " + pInfo(peer)->last_wrenched, true);
			}
			else if (button == "view_worn_clothes") {
				for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
					if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
					if (pInfo(cp_)->world == pInfo(peer)->world and pInfo(cp_)->netID == other_netid_) {
						VarList::OnDialogRequest(peer, SetColor(peer) + "\nadd_label_with_icon|big|`w" + (not pInfo(cp_)->d_name.empty() ? pInfo(cp_)->d_name : pInfo(cp_)->name_color + pInfo(cp_)->tankIDName) + "`o's Clothes List|left|1420|\nadd_spacer|small|" + (pInfo(cp_)->hair != 0 ? "\nadd_label_with_icon|small|`o" + items[pInfo(cp_)->hair].name + "|left|" + to_string(pInfo(cp_)->hair) + "|" : "") + a + (pInfo(cp_)->face != 0 ? "\nadd_label_with_icon|small|`o" + items[pInfo(cp_)->face].name + "|left|" + to_string(pInfo(cp_)->face) + "|" : "") + a + (pInfo(cp_)->necklace != 0 ? "\nadd_label_with_icon|small|`o" + items[pInfo(cp_)->necklace].name + "|left|" + to_string(pInfo(cp_)->necklace) + "|" : "") + a + (pInfo(cp_)->shirt != 0 ? "\nadd_label_with_icon|small|`o" + items[pInfo(cp_)->shirt].name + "|left|" + to_string(pInfo(cp_)->shirt) + "|" : "") + a + (pInfo(cp_)->back != 0 ? "\nadd_label_with_icon|small|`o" + items[pInfo(cp_)->back].name + "|left|" + to_string(pInfo(cp_)->back) + "|" : "") + a + (pInfo(cp_)->hand != 0 ? "\nadd_label_with_icon|small|`o" + items[pInfo(cp_)->hand].name + "|left|" + to_string(pInfo(cp_)->hand) + "|" : "") + a + (pInfo(cp_)->pants != 0 ? "\nadd_label_with_icon|small|`o" + items[pInfo(cp_)->pants].name + "|left|" + to_string(pInfo(cp_)->pants) + "|" : "") + a + (pInfo(cp_)->feet != 0 ? "\nadd_label_with_icon|small|`o" + items[pInfo(cp_)->feet].name + "|left|" + to_string(pInfo(cp_)->feet) + "|" : "") + a + (pInfo(cp_)->ances != 0 ? "\nadd_label_with_icon|small|`o" + items[pInfo(cp_)->ances].name + "|left|" + to_string(pInfo(cp_)->ances) + "|" : "") + a + "\nend_dialog||Close||");
						return;
					}
				}
			}
			else if (button == "ignore_player") {
				string name = pInfo(peer)->last_wrenched;
				if (to_lower(pInfo(peer)->tankIDName) == to_lower(name) or find(pInfo(peer)->ignored.begin(), pInfo(peer)->ignored.end(), to_lower(name)) != pInfo(peer)->ignored.end()) VarList::OnConsoleMessage(peer, (to_lower(pInfo(peer)->tankIDName) == to_lower(name) ? "Don't look now, but that person is `5IN YOUR HOUSE``!" : "That jerk `5" + name + "`` is already being ignored!"));
				else {
					string current_name = ""; bool playerfound = false;
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (to_lower(pInfo(cp_)->tankIDName.substr(0, 3)) == to_lower(name.substr(0, 3)) || name == to_lower(pInfo(cp_)->tankIDName)) {
							if (find(pInfo(peer)->ignored.begin(), pInfo(peer)->ignored.end(), to_lower(pInfo(cp_)->tankIDName)) != pInfo(peer)->ignored.end()) {
								VarList::OnConsoleMessage(peer, "You removed `5" + pInfo(cp_)->tankIDName + "`` from ignore list!");
								pInfo(peer)->ignored.erase(remove(pInfo(peer)->ignored.begin(), pInfo(peer)->ignored.end(), pInfo(cp_)->tankIDName), pInfo(peer)->ignored.end());
								return;
							}
							pInfo(peer)->ignored.push_back(to_lower(pInfo(cp_)->tankIDName));
							current_name = pInfo(cp_)->tankIDName;
							playerfound = true;
							return;
						}
					}
					if (playerfound) VarList::OnConsoleMessage(peer, "`4PERSON IGNORED!`` Ok, you won't see messages from `5" + current_name + "``. If you change your mind, you can remove him/her from ignore by using the `5Friends List``.");
					else VarList::OnConsoleMessage(peer, "Hmm, nobody is currently online with a name starting with `5" + name + "``.");
				}
			}
			else if (button == "send_msg") {
				VarList::OnDialogRequest(peer, SetColor(peer) + "\nadd_default_color|\nadd_label_with_icon|big|`5Message To `o" + pInfo(peer)->last_wrenched + "|left|660|\nadd_text_input|message|||200|\nadd_button|send_message|`5Send|0|0|\nadd_button|backtoplayerwrench|`oBack|\nend_dialog|Send_Message|||\nadd_quick_exit");
				pInfo(peer)->last_msg_wrenched = pInfo(peer)->last_wrenched;
			}
			else if (button == "send_gems") {
				VarList::OnDialogRequest(peer, SetColor(peer) + "\nadd_default_color|\nadd_label_with_icon|big|`5Send Gemd To `o(" + pInfo(peer)->last_wrenched + ")|left|112|\nadd_textbox|`$Your currently gems: `9" + to_string(pInfo(peer)->gems) + "|left|\nadd_textbox|`$How much do you want to pay " + pInfo(peer)->last_wrenched + "?|left|\nadd_text_input|CountGems|`$Count Gems:||10|\nend_dialog|PayDialog|Cancel|Send|");
			}
			else if (button == "punish_view") {
				if (Role::Moderator(peer) || Role::Administrator(peer)) {
					Commands::Execute(peer, "/info " + pInfo(peer)->last_wrenched, true);
				}
			}
			else if (button == "start_surg") {
				bool has_recovery = false;
				if (to_lower(pInfo(peer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
					VarList::OnConsoleMessage(peer, "`oDon't look now, but that person is `5IN YOUR HOUSE``!");
					return;
				}
				for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
					if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(cp_)->world != pInfo(peer)->world or pInfo(peer)->last_wrenched != pInfo(cp_)->tankIDName or pInfo(cp_)->hospital_bed == false) continue;
					if (Playmods::HasById(pInfo(cp_), 87)) has_recovery = true;
					if (has_recovery == false) {
						string name_ = pInfo(cp_)->world;
						std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
						if (p != worlds.end()) {
							World* world_ = &worlds[p - worlds.begin()];
							int x_ = (pInfo(cp_)->state == 16 ? (int)pInfo(cp_)->x / 32 : round((double)pInfo(cp_)->x / 32)), y_ = (int)pInfo(cp_)->y / 32;
							if (x_ < 0 or x_ >= world_->max_x or y_ < 0 or y_ >= world_->max_y) {
							}
							else {
								if (world_->blocks[x_ + (y_ * 100)].fg != 1256) {
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Player is not standing on hospital bed.", 0, 0);
								}
								else {
									if (setstats(peer, pInfo(cp_)->surgery_type, pInfo(cp_)->tankIDName, pInfo(cp_)->name_color + pInfo(cp_)->tankIDName + "``")) {
										int seconds = 3600;
										if (pInfo(cp_)->necklace == 8954) seconds *= 0.75;
										Playmods::Add(cp_, 87, seconds);
										pInfo(cp_)->surgery_type = rand() % 31;
									}
								}
							}
						}
					}
				}
			}
			else if (button == "invitetoguild") {
				if (pInfo(peer)->guild_id == 0) return;
				if (to_lower(pInfo(peer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
					VarList::OnConsoleMessage(peer, "`oDon't look now, but that person is `5IN YOUR HOUSE``!");
					return;
				}
				uint32_t guild_id = pInfo(peer)->guild_id; bool has_ = false;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					for (GuildMember member_search : guild_information->guild_members) {
						if (to_lower(member_search.member_name) == to_lower(pInfo(peer)->tankIDName)) {
							if (member_search.role_id != 3 and member_search.role_id != 2 and member_search.role_id != 1) continue;
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
								if (pInfo(cp_)->world == pInfo(peer)->world and pInfo(cp_)->netID == other_netid_) {
									if (pInfo(cp_)->guild_id != 0) return;
									has_ = true;
									if (guild_information->guild_members.size() >= guild_information->guild_level * 5) {
										VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Guild is at maximum capacity of " + to_string(guild_information->guild_level * 5) + " peoples!", 0, 0);
										VarList::OnConsoleMessage(peer, "Guild is at maximum capacity of " + to_string(guild_information->guild_level * 5) + " peoples!");
										return;
									}
									pInfo(cp_)->pending_guild = pInfo(peer)->guild_id;
									CAction::Log(cp_, "action|play_sfx\nfile|audio/tip_start.wav\ndelayMS|0");
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`5[``Guild request sent to " + get_player_nick(cp_) + "`5]``", 0, 0);
									VarList::OnConsoleMessage(cp_, "`5GUILD REQUEST:`` You've been invited to join `2" + guild_information->guild_name + " `` by " + get_player_nick(peer) + "! To accept, `wwrench yourself`` and then choose `2Join " + guild_information->guild_name + "``.");
									create_guild_log(guild_information, "`$" + pInfo(cp_)->tankIDName + "`` `wwas invited by`` `$" + get_player_nick(peer) + "``", 6);
									return;
								}
							}
						}
					}
				}
				if (not has_) VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Hmm, that person left.", 0, 0);
			}
			else if (button == "friend_add") {
				if (to_lower(pInfo(peer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
					VarList::OnConsoleMessage(peer, "`oDon't look now, but that person is `5IN YOUR HOUSE``!");
					return;
				}
				std::string name_ = pInfo(peer)->world; bool has_ = false;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (pInfo(cp_)->world == pInfo(peer)->world and pInfo(cp_)->netID == other_netid_) {
							if (find(pInfo(cp_)->pending_friends.begin(), pInfo(cp_)->pending_friends.end(), pInfo(peer)->tankIDName) != pInfo(cp_)->pending_friends.end()) {
								CAction::Log(peer, "action|play_sfx\nfile|audio/love_in.wav\ndelayMS|0");
								long long time_t = time(NULL);
								Friends new_friend_;
								new_friend_.name = pInfo(cp_)->tankIDName;
								new_friend_.mute = false;
								new_friend_.block_trade = false;
								new_friend_.last_seen = time_t;
								pInfo(peer)->friends.push_back(new_friend_);
								VarList::OnConsoleMessage(peer, "`3FRIEND ADDED:`` You're now friends with " + get_player_nick(cp_) + "!");
								CAction::Log(cp_, "action|play_sfx\nfile|audio/love_in.wav\ndelayMS|0");
								Friends new_friend;
								new_friend.name = pInfo(peer)->tankIDName;
								new_friend.mute = false;
								new_friend.block_trade = false;
								new_friend.last_seen = time_t;
								pInfo(cp_)->friends.push_back(new_friend);
								VarList::OnConsoleMessage(cp_, "`3FRIEND ADDED:`` You're now friends with " + get_player_nick(peer) + "!");
								if (pInfo(peer)->friends.size() == 10 || pInfo(peer)->friends.size() == 20 || pInfo(peer)->friends.size() == 30 || pInfo(peer)->friends.size() == 40 || pInfo(peer)->friends.size() == 50) form_emoji(peer, true);
								if (pInfo(cp_)->friends.size() == 10 || pInfo(peer)->friends.size() == 20 || pInfo(peer)->friends.size() == 30 || pInfo(peer)->friends.size() == 40 || pInfo(peer)->friends.size() == 50) form_emoji(cp_, true);
								pInfo(cp_)->pending_friends.erase(remove(pInfo(cp_)->pending_friends.begin(), pInfo(cp_)->pending_friends.end(), pInfo(peer)->tankIDName), pInfo(cp_)->pending_friends.end());
								if (pInfo(peer)->EarnFreeGems.Quest_3 < 10) pInfo(peer)->EarnFreeGems.Quest_3++;
								if (pInfo(cp_)->EarnFreeGems.Quest_3 < 10) pInfo(cp_)->EarnFreeGems.Quest_3++;
								has_ = true;
							}
							else {
								for (int c_ = 0; c_ < pInfo(peer)->friends.size(); c_++) {
									if (to_lower(pInfo(peer)->friends[c_].name) == to_lower(pInfo(cp_)->tankIDName)) {
										VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That's already my friend!", 0, 0);
										return;
									}
								}
								if (abs((pInfo(cp_)->x / 32) - (pInfo(peer)->x / 32)) >= 3) {
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`5[```4Too far away`` `0- Stand closer to`` " + get_player_nick(cp_) + "`0 first!```5]``", 0, 0);
									return;
								}
								pInfo(peer)->pending_friends.push_back(pInfo(cp_)->tankIDName);
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`5[``Friend request sent to " + get_player_nick(cp_) + "`5]``", 0, 0);
								CAction::Log(cp_, "action|play_sfx\nfile|audio/tip_start.wav\ndelayMS|0");
								VarList::OnConsoleMessage(cp_, "`3FRIEND REQUEST:`` You've received a `wfriend request`` from " + get_player_nick(peer) + "! To accept, press the `wwrench by his/her name`` and then choose `wAdd as friend``.");
								has_ = true;
							}
							return;
						}
					}
					if (not has_) VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Hmm, that person left.", 0, 0);
				}
			}
		}
	}
	static void fwallrora(ENetPeer* peer, std::string cch) {
		std::string name_ = pInfo(peer)->world;
		std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			int x_ = std::atoi(explode("\n", explode("tilex|", cch)[1])[0].c_str()), y_ = std::atoi(explode("\n", explode("tiley|", cch)[1])[0].c_str());
			WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
			if (items[block_->fg].blockType != BlockTypes::Fish_Mount) return;
			string fishsname = "";
			if (cch.find("fishsname|") != std::string::npos) {
				fishsname = cch.substr(97, cch.length() - 98).c_str();
			}
			if (cch.find("renamef") != std::string::npos) {
				std::vector<std::string> t_ = explode("|", cch);
				if (t_.size() < 4) return;
				block_->txt = fishsname;
			}
			else if (cch.find("mountaf") != std::string::npos) {
				std::vector<std::string> t_ = explode("|", cch);
				if (t_.size() < 4) return;
				int trainitem = std::atoi(explode("\n", explode("mountaf|", cch)[1])[0].c_str());
				if (items[trainitem].blockType != BlockTypes::FISH or trainitem < 0 or trainitem > items.size()) return;
				int hasm = 0;
				Inventory::Modify(peer, trainitem, hasm);
				if (hasm < items[trainitem].fish_max_lb) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your " + items[trainitem].name + " is not perfect enough to be on the wall!");
					VarList::OnConsoleMessage(peer, "Your " + items[trainitem].name + " is not perfect enough to be on the wall!");
					return;
				}
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You mounted your " + items[trainitem].name + " on the wall!");
				VarList::OnConsoleMessage(peer, "You mounted your " + items[trainitem].name + " on the wall!");
				block_->id = trainitem;
				block_->c_ = hasm;
				int rn = 0;
				Inventory::Modify(peer, trainitem, rn = -hasm);
			}
			PlayerMoving data_{};
			data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
			BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
			BYTE* blc = raw + 56;
			form_visual(blc, *block_, *world_, peer, false);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
				send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
			}
			delete[] raw, blc;
			if (block_->locked) upd_lock(*block_, *world_, peer);
		}
	}
	static void oven(ENetPeer* peer, std::string cch) {
		int foods = 0;
		if (cch.find("manual") != std::string::npos) {
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`2How To Cook``|left|4618|\nadd_spacer|small|\nembed_data|tilex|31\nembed_data|tiley|23\nadd_smalltext|Cooking is easy! Just use ingredients on your oven! The first ingredient you put in asks you to choose Low, Medium, or High heat. You can use whatever heat you like - higher heat gets the job done more quickly, but that also makes it harder to be accurate with your timing.|left|\nadd_spacer|small|\nadd_smalltext|When you think your food is perfectly cooked, just punch the oven to collect the results!|left|\nadd_spacer|small|\nadd_smalltext|Some ingredients, like Flour, don\'t cook at all. Throw those in at any time in the process. But most ingredients need a certain amount of cook time. Watch them as they cook. Your best food will be made when all ingredients are `8Perfect``, which means you\'ll need to put them in the oven at the right time.|left|\nadd_spacer|small|\nadd_smalltext|A few ingredients, like Lettuce, should not be cooked! If you throw in an ingredient and it says `8Perfect`` immediately, it will only go downhill from there! Save those ingredients for the last second.|left|\nadd_spacer|small|\nadd_smalltext|You also need to spice your food. There are three spices: `2Sugar``, `2Salt``, and `2Pepper``. Different dishes need different amounts of each. You\'ll figure it out!|left|\nadd_spacer|small|\nadd_smalltext|Some ingredients will combine with others to make new ingredients, like `1Water Bucket`` and `9Flour`` combine into `9Dough``. Be careful: ingredients won\'t combine if any of them are already cooked beyond a certain point, so put one in right after the other.|left|\nadd_spacer|small|\nadd_smalltext|If you just try random piles of ingredients, you probably won't make any food... so ask your friends for recipes! `9Good luck!``|left|\nend_dialog|oven|Exit||\n");
		}
		else {
			if (cch.find("cookthis|") != std::string::npos) foods = std::atoi(explode("\n", explode("cookthis|", cch)[1])[0].c_str());
			else return;
			int cooktype = 0;
			if (cch.find("|low") != std::string::npos) {
				cooktype = 3;
			}
			else if (cch.find("|med") != std::string::npos) {
				cooktype = 6;
			}
			else if (cch.find("|high") != std::string::npos) {
				cooktype = 9;
			}
			else return;
			if (foods < 0 or foods > items.size()) return;
			if (get_cook_id(foods) != 0 or get_cook_offset(foods) != 0) {
				int foodamk = 0;
				Inventory::Modify(peer, foods, foodamk);
				if (foodamk == 0) return;
				if (foods == 4570 || foods == 4572 || foods == 4568) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Ok... You love spices but... You cant start a food with that.");
					return;
				}
				string name = "";
				int fr = 0;
				Inventory::Modify(peer, foods, fr = -1);
				std::string name_ = pInfo(peer)->world;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					int x_ = std::atoi(explode("\n", explode("tilex|", cch)[1])[0].c_str()), y_ = std::atoi(explode("\n", explode("tiley|", cch)[1])[0].c_str());
					WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
					if (items[block_->fg].blockType != BlockTypes::OVEN) return;
					block_->pr = cooktype;
					int timer = std::atoi(explode("\n", explode("display_timer|", cch)[1])[0].c_str());
					block_->c_ = timer;
					gamepacket_t p3(0, pInfo(peer)->netID);
					p3.Insert("OnPlayPositioned"), p3.Insert("audio/burn.wav");
					FoodType food;
					food.time = std::chrono::duration_cast<std::chrono::seconds>(std::chrono::system_clock::now().time_since_epoch()).count();
					food.id = foods;
					block_->starttime = std::chrono::duration_cast<std::chrono::seconds>(std::chrono::system_clock::now().time_since_epoch()).count();
					block_->food.push_back(food);
					PlayerMoving data_{};
					data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
					BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
					BYTE* blc = raw + 56;
					form_visual(blc, *block_, *world_, peer, false);
					PlayerMoving data_i{};
					data_i.packetType = 19, data_i.netID = -1, data_i.plantingTree = 0;
					data_i.x = x_ * 32 + 16, data_i.y = y_ * 32 + 16;
					data_i.XSpeed = pInfo(peer)->x + 16, data_i.YSpeed = pInfo(peer)->y + 16;
					data_i.punchX = foods;
					BYTE* cum = packPlayerMoving(&data_i);
					cum[3] = 6;
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == pInfo(peer)->world) {
							send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
							p3.CreatePacket(peer);
							send_raw(currentPeer, 4, cum, 56, ENET_PACKET_FLAG_RELIABLE);
						}
					}
					VarList::OnConsoleMessage(peer, "You toss a `2" + items[foods].name + "`` into the oven!");
					delete[] cum;
					delete[] raw, blc;
					if (block_->locked) {
						upd_lock(*block_, *world_, peer);
					}
				}
			}
		}
	}
	static void unfavorite_items_dialog(ENetPeer* peer, std::string cch) {
		vector<int> favitems = pInfo(peer)->Fav_Items;
		int c = 0;
		for (int i = 0; i < items.size(); i++) {
			if (cch.find("unfav_" + to_string(i) + "|1") != std::string::npos) {
				for (int ie = 0; ie < favitems.size(); ie++) {
					if (favitems[ie] == i) {
						c++;
						favitems.erase(favitems.begin() + ie);
						return;
					}
				}
			}
		}
		VarList::OnConsoleMessage(peer, "Removed " + to_string(c) + " items from your favourite items list.");
		VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Removed " + to_string(c) + " items from your favourite items list.");
		pInfo(peer)->Fav_Items = favitems;
		string list = "";
		for (int i = 0; i < pInfo(peer)->Fav_Items.size(); i++) {
			list += to_string(pInfo(peer)->Fav_Items[i]) + ",";
		}
		VarList::OnSendFavItemsList(peer, list, 20);
	}
	static void marvelous_back(ENetPeer* peer, std::string cch) {
		if (pInfo(peer)->last_choose_tab == 1) DialogHandle::Marvelous_Mission(peer, "1");
		if (pInfo(peer)->last_choose_tab == 2) DialogHandle::Marvelous_Mission(peer, "2");
	}
	static void collectionQuests(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "back") send_wrench_self(peer);
			if (button == "tab_1") DialogHandle::Marvelous_Mission(peer, "1");
			if (button == "tab_2") DialogHandle::Marvelous_Mission(peer, "2");
			if (button.substr(0, 17) == "claim_seven_seas_") {
				std::string type = button.substr(17);
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label|big|`oMarvelous Mission|left|\nadd_spacer|small|\nadd_textbox|`oBy selecting claim, the items will be removed from your inventory and your reward will be added.|left|\nadd_spacer|small|\nadd_button|yes_claim_ss_" + type + "|`oClaim|noflags|0|0|\nadd_button|back|`wBack|\nend_dialog|collectionQuests|||");
			}
			if (button.substr(0, 11) == "claim_myth_") {
				std::string type = button.substr(11);
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label|big|`oMarvelous Mission|left|\nadd_spacer|small|\nadd_textbox|`oBy selecting claim, the items will be removed from your inventory and your reward will be added.|left|\nadd_spacer|small|\nadd_button|yes_claim_mm_" + type + "|`oClaim|noflags|0|0|\nadd_button|back|`wBack|\nend_dialog|collectionQuests|||");
			}
			if (button.substr(0, 13) == "yes_claim_mm_") {
				std::string type = button.substr(13);
				if (type == "1") {
					if (not pInfo(peer)->claim_myth_1) {
						int remove = 0, added = 0;
						int c_3166 = Inventory::Contains(peer, 3166), c_7428 = Inventory::Contains(peer, 7428), c_10030 = Inventory::Contains(peer, 10030), c_10028 = Inventory::Contains(peer, 10028), c_8390 = Inventory::Contains(peer, 8390), c_6984 = Inventory::Contains(peer, 6984);
						if (c_3166 >= 1 and c_7428 >= 1 and c_10030 >= 2 and c_10028 >= 2 and c_8390 >= 200 and c_6984 >= 100) {
							if (Inventory::Modify(peer, 10690, added = 1) == 0) {
								if (Inventory::Modify(peer, 10692, added = 1) == 0) {
									pInfo(peer)->claim_myth_1 = true;
									Inventory::Modify(peer, 3166, remove = -1), Inventory::Modify(peer, 7428, remove = -1), Inventory::Modify(peer, 10030, remove = -2), Inventory::Modify(peer, 10028, remove = -2), Inventory::Modify(peer, 8390, remove = -200), Inventory::Modify(peer, 6984, remove = -100);
									DialogHandle::Marvelous_Mission(peer, "1");
									VarList::OnAddNotification(peer, "`oMission Complete!", "interface/large/gui_cqst.rttex", "audio/piano_nice.wav");
								}
								else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 1);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 1);
						}
					}
				}
				if (type == "2") {
					if (not pInfo(peer)->claim_myth_2) {
						int remove = 0, added = 0;
						int c_10248 = Inventory::Contains(peer, 10248), c_9442 = Inventory::Contains(peer, 9442), c_4828 = Inventory::Contains(peer, 4828), c_7996 = Inventory::Contains(peer, 7996), c_822 = Inventory::Contains(peer, 822), c_2974 = Inventory::Contains(peer, 2974);
						if (c_10248 >= 1 and c_9442 >= 1 and c_4828 >= 1 and c_7996 >= 1 and c_822 >= 200 and c_2974 >= 10) {
							if (Inventory::Modify(peer, 10688, added = 1) == 0) {
								Inventory::Modify(peer, 10248, remove = -1), Inventory::Modify(peer, 9442, remove = -1), Inventory::Modify(peer, 4828, remove = -1), Inventory::Modify(peer, 7996, remove = -1), Inventory::Modify(peer, 822, remove = -200), Inventory::Modify(peer, 2974, remove = -10);
								pInfo(peer)->claim_myth_2 = true;
								DialogHandle::Marvelous_Mission(peer, "1");
								VarList::OnAddNotification(peer, "`oMission Complete!", "interface/large/gui_cqst.rttex", "audio/piano_nice.wav");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 1);
						}
					}
				}
				if (type == "3") {
					if (not pInfo(peer)->claim_myth_3) {
						int remove = 0, added = 0;
						int c_9734 = Inventory::Contains(peer, 9734), c_1150 = Inventory::Contains(peer, 1150), c_7948 = Inventory::Contains(peer, 7948), c_8394 = Inventory::Contains(peer, 8394), c_1954 = Inventory::Contains(peer, 1954), c_2035 = Inventory::Contains(peer, 2035);
						if (c_9734 >= 1 and c_1150 >= 1 and c_7948 >= 1 and c_8394 >= 200 and c_1954 >= 100 and c_2035 >= 10) {
							if (Inventory::Modify(peer, 10686, added = 1) == 0) {
								Inventory::Modify(peer, 9734, remove = -1), Inventory::Modify(peer, 1150, remove = -1), Inventory::Modify(peer, 7948, remove = -1), Inventory::Modify(peer, 8394, remove = -200), Inventory::Modify(peer, 1954, remove = -100), Inventory::Modify(peer, 2035, remove = -10);
								pInfo(peer)->claim_myth_3 = true;
								DialogHandle::Marvelous_Mission(peer, "1");
								VarList::OnAddNotification(peer, "`oMission Complete!", "interface/large/gui_cqst.rttex", "audio/piano_nice.wav");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 1);
						}
					}
				}
				if (type == "4") {
					if (not pInfo(peer)->claim_myth_4) {
						int remove = 0, added = 0;
						int c_10680 = Inventory::Contains(peer, 10680), c_6818 = Inventory::Contains(peer, 6818), c_7350 = Inventory::Contains(peer, 7350), c_9610 = Inventory::Contains(peer, 9610), c_1206 = Inventory::Contains(peer, 1206), c_10726 = Inventory::Contains(peer, 10726);
						if (c_10680 >= 1 and c_6818 >= 1 and c_7350 >= 1 and c_9610 >= 1 and c_1206 >= 1 and c_10726) {
							if (Inventory::Modify(peer, 10684, added = 1) == 0) {
								Inventory::Modify(peer, 10680, remove = -1), Inventory::Modify(peer, 6818, remove = -1), Inventory::Modify(peer, 7350, remove = -1), Inventory::Modify(peer, 9610, remove = -1), Inventory::Modify(peer, 1206, remove = -1), Inventory::Modify(peer, 10726, remove = -1);
								pInfo(peer)->claim_myth_4 = true;
								DialogHandle::Marvelous_Mission(peer, "1");
								VarList::OnAddNotification(peer, "`oMission Complete!", "interface/large/gui_cqst.rttex", "audio/piano_nice.wav");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 1);
						}
					}
				}
				if (type == "5") {
					if (not pInfo(peer)->claim_myth_5) {
						int remove = 0, added = 0;
						int c_9430 = Inventory::Contains(peer, 9430), c_10578 = Inventory::Contains(peer, 10578), c_6842 = Inventory::Contains(peer, 6842), c_2856 = Inventory::Contains(peer, 2856), c_1834 = Inventory::Contains(peer, 1834), c_2722 = Inventory::Contains(peer, 2722);
						if (c_9430 >= 1 and c_10578 >= 1 and c_6842 >= 1 and c_2856 >= 100 and c_1834 >= 100 and c_2722 >= 100) {
							if (Inventory::Modify(peer, 10694, added = 1) == 0) {
								Inventory::Modify(peer, 9430, remove = -1), Inventory::Modify(peer, 10578, remove = -1), Inventory::Modify(peer, 6842, remove = -1), Inventory::Modify(peer, 2856, remove = -100), Inventory::Modify(peer, 1834, remove = -100), Inventory::Modify(peer, 2722, remove = -100);
								pInfo(peer)->claim_myth_5 = true;
								DialogHandle::Marvelous_Mission(peer, "1");
								VarList::OnAddNotification(peer, "`oMission Complete!", "interface/large/gui_cqst.rttex", "audio/piano_nice.wav");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 1);
						}
					}
				}
				if (type == "6") {
					if (not pInfo(peer)->claim_myth_6) {
						int remove = 0, added = 0;
						int c_2714 = Inventory::Contains(peer, 2714), c_7044 = Inventory::Contains(peer, 7044), c_11098 = Inventory::Contains(peer, 11098), c_9690 = Inventory::Contains(peer, 9690), c_10676 = Inventory::Contains(peer, 10676), c_10144 = Inventory::Contains(peer, 10144);
						if (c_2714 >= 200 and c_7044 >= 2 and c_11098 >= 2 and c_9690 >= 200 and c_10676 >= 5 and c_10144 >= 10) {
							if (Inventory::Modify(peer, 11120, added = 1) == 0) {
								Inventory::Modify(peer, 2714, remove = -200), Inventory::Modify(peer, 7044, remove = -2), Inventory::Modify(peer, 11098, remove = -2), Inventory::Modify(peer, 9690, remove = -200), Inventory::Modify(peer, 10676, remove = -5), Inventory::Modify(peer, 10144, remove = -10);
								pInfo(peer)->claim_myth_6 = true;
								DialogHandle::Marvelous_Mission(peer, "1");
								VarList::OnAddNotification(peer, "`oMission Complete!", "interface/large/gui_cqst.rttex", "audio/piano_nice.wav");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 1);
						}
					}
				}
			}
			if (button.substr(0, 13) == "yes_claim_ss_") {
				std::string type = button.substr(13);
				if (type == "1") {
					if (not pInfo(peer)->claim_seven_seas_1) {
						int remove = 0, added = 0;
						int c_5612 = Inventory::Contains(peer, 5612), c_3812 = Inventory::Contains(peer, 3812), c_8814 = Inventory::Contains(peer, 8814), c_10226 = Inventory::Contains(peer, 10226), c_9732 = Inventory::Contains(peer, 9732), c_11264 = Inventory::Contains(peer, 11264);
						if (c_5612 >= 100 and c_3812 >= 200 and c_8814 >= 10 and c_10226 >= 10 and c_9732 >= 1 and c_11264 >= 10) {
							if (Inventory::Modify(peer, 12236, added = 1) == 0) {
								pInfo(peer)->claim_seven_seas_1 = true;
								Inventory::Modify(peer, 5612, remove = -100), Inventory::Modify(peer, 3812, remove = -200), Inventory::Modify(peer, 8814, remove = -10), Inventory::Modify(peer, 10226, remove = -10), Inventory::Modify(peer, 9732, remove = -1), Inventory::Modify(peer, 11264, remove = -10);
								DialogHandle::Marvelous_Mission(peer, "2");
								VarList::OnAddNotification(peer, "`oMission Complete!", "interface/large/gui_cqst.rttex", "audio/piano_nice.wav");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 1);
						}
					}
				}
				if (type == "2") {
					if (not pInfo(peer)->claim_seven_seas_2) {
						int remove = 0, added = 0;
						int c_5584 = Inventory::Contains(peer, 5584), c_11110 = Inventory::Contains(peer, 11110), c_5230 = Inventory::Contains(peer, 5230), c_9656 = Inventory::Contains(peer, 9656), c_10722 = Inventory::Contains(peer, 10722), c_11576 = Inventory::Contains(peer, 11576);
						if (c_5584 >= 10 and c_11110 >= 2 and c_5230 >= 10 and c_9656 >= 10 and c_10722 >= 1 and c_11576 >= 20) {
							if (Inventory::Modify(peer, 12232, added = 1) == 0) {
								pInfo(peer)->claim_seven_seas_2 = true;
								Inventory::Modify(peer, 5584, remove = -10), Inventory::Modify(peer, 11110, remove = -2), Inventory::Modify(peer, 5230, remove = -10), Inventory::Modify(peer, 9656, remove = -10), Inventory::Modify(peer, 10722, remove = -1), Inventory::Modify(peer, 11576, remove = -20);
								DialogHandle::Marvelous_Mission(peer, "2");
								VarList::OnAddNotification(peer, "`oMission Complete!", "interface/large/gui_cqst.rttex", "audio/piano_nice.wav");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 1);
						}
					}
				}
				if (type == "3") {
					if (not pInfo(peer)->claim_seven_seas_3) {
						int remove = 0, added = 0;
						int c_11128 = Inventory::Contains(peer, 11128), c_9404 = Inventory::Contains(peer, 9404), c_11418 = Inventory::Contains(peer, 11418), c_9034 = Inventory::Contains(peer, 9034), c_11144 = Inventory::Contains(peer, 11144), c_8604 = Inventory::Contains(peer, 8604);
						if (c_11128 >= 1 and c_9404 >= 1 and c_11418 >= 10 and c_9034 >= 10 and c_11144 >= 1 and c_8604 >= 1) {
							if (Inventory::Modify(peer, 12238, added = 1) == 0) {
								pInfo(peer)->claim_seven_seas_3 = true;
								Inventory::Modify(peer, 11128, remove = -1), Inventory::Modify(peer, 9404, remove = -1), Inventory::Modify(peer, 11418, remove = -10), Inventory::Modify(peer, 9034, remove = -10), Inventory::Modify(peer, 11144, remove = -1), Inventory::Modify(peer, 8604, remove = -1);
								DialogHandle::Marvelous_Mission(peer, "2");
								VarList::OnAddNotification(peer, "`oMission Complete!", "interface/large/gui_cqst.rttex", "audio/piano_nice.wav");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 1);
						}
					}
				}
				if (type == "4") {
					if (not pInfo(peer)->claim_seven_seas_4) {
						int remove = 0, added = 0;
						int c_11454 = Inventory::Contains(peer, 11454), c_6816 = Inventory::Contains(peer, 6816), c_11316 = Inventory::Contains(peer, 11316), c_10256 = Inventory::Contains(peer, 10256), c_10052 = Inventory::Contains(peer, 10052), c_11166 = Inventory::Contains(peer, 11166);
						if (c_11454 >= 10 and c_6816 >= 1 and c_11316 >= 1 and c_10256 >= 10 and c_10052 >= 1 and c_11166 >= 10) {
							if (Inventory::Modify(peer, 12230, added = 1) == 0) {
								pInfo(peer)->claim_seven_seas_4 = true;
								Inventory::Modify(peer, 11454, remove = -10), Inventory::Modify(peer, 6816, remove = -1), Inventory::Modify(peer, 11316, remove = -1), Inventory::Modify(peer, 10256, remove = -10), Inventory::Modify(peer, 10052, remove = -1), Inventory::Modify(peer, 11166, remove = -10);
								DialogHandle::Marvelous_Mission(peer, "2");
								VarList::OnAddNotification(peer, "`oMission Complete!", "interface/large/gui_cqst.rttex", "audio/piano_nice.wav");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 1);
						}
					}
				}
				if (type == "5") {
					if (not pInfo(peer)->claim_seven_seas_5) {
						int remove = 0, added = 0;
						int c_11544 = Inventory::Contains(peer, 11544), c_6986 = Inventory::Contains(peer, 6986), c_5604 = Inventory::Contains(peer, 5604), c_2802 = Inventory::Contains(peer, 2802), c_3584 = Inventory::Contains(peer, 3584), c_11350 = Inventory::Contains(peer, 11350);
						if (c_11544 >= 2 and c_6986 >= 200 and c_5604 >= 10 and c_2802 >= 1 and c_3584 >= 200 and c_11350 >= 1) {
							if (Inventory::Modify(peer, 12234, added = 1) == 0) {
								pInfo(peer)->claim_seven_seas_5 = true;
								Inventory::Modify(peer, 11544, remove = -2), Inventory::Modify(peer, 6986, remove = -200), Inventory::Modify(peer, 5604, remove = -10), Inventory::Modify(peer, 2802, remove = -1), Inventory::Modify(peer, 3584, remove = -200), Inventory::Modify(peer, 11350, remove = -1);
								DialogHandle::Marvelous_Mission(peer, "2");
								VarList::OnAddNotification(peer, "`oMission Complete!", "interface/large/gui_cqst.rttex", "audio/piano_nice.wav");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 1);
						}
					}
				}
				if (type == "6") {
					if (not pInfo(peer)->claim_seven_seas_6) {
						int remove = 0, added = 0;
						int c_10332 = Inventory::Contains(peer, 10332), c_9738 = Inventory::Contains(peer, 9738), c_10886 = Inventory::Contains(peer, 10886), c_10132 = Inventory::Contains(peer, 10132), c_9712 = Inventory::Contains(peer, 9712), c_11480 = Inventory::Contains(peer, 11480);
						if (c_10332 >= 1 and c_9738 >= 20 and c_10886 >= 1 and c_10132 >= 1 and c_9712 >= 1 and c_11480 >= 10) {
							if (Inventory::Modify(peer, 12240, added = 1) == 0) {
								pInfo(peer)->claim_seven_seas_6 = true;
								Inventory::Modify(peer, 11544, remove = -1), Inventory::Modify(peer, 6986, remove = -20), Inventory::Modify(peer, 5604, remove = -1), Inventory::Modify(peer, 2802, remove = -1), Inventory::Modify(peer, 3584, remove = -1), Inventory::Modify(peer, 11350, remove = -10);
								DialogHandle::Marvelous_Mission(peer, "2");
								VarList::OnAddNotification(peer, "`oMission Complete!", "interface/large/gui_cqst.rttex", "audio/piano_nice.wav");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 1);
						}
					}
				}
			}
			if (button.substr(0, 5) == "info_") {
				string extra_ = "";
				int id_ = std::atoi(button.substr(5).c_str());
				if (items[id_].r_1 == 0 or items[id_].r_2 == 0) {
					extra_ = "This item can't be spliced.";
				}
				else extra_ = "To grow, plant a `w" + items[id_ + 1].name + "``.   (Or splice a `w" + items[items[id_].r_1].name + "`` with a `w" + items[items[id_].r_2].name + "``)";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[id_].name + "|left|" + to_string(id_) + "|\nadd_spacer|small|\nadd_textbox|`o" + items[id_].description + "|left|\nadd_spacer|small|" + (items[id_].rarity != 999 ? "\nadd_textbox|`oRarity: `w" + to_string(items[id_].rarity) + "|left|" : "") + "\nadd_spacer|small|\nadd_textbox|`o" + extra_ + "|left|\nadd_spacer|small|\nend_dialog|marvelous_back|Close|Back|");
			}
		}
	}
	static void Bank_Central(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "Back") {
				send_wrench_self(peer);
			}
			if (button == "BackToDialog") {
				DialogHandle::BankCentral(peer);
			}
			if (button == "deposit") {
				VarList::OnDialogRequest(peer, SetColor(peer) + "\nadd_label_with_icon|big|`wDEPOSIT|left|13808|\nadd_spacer|small|\nadd_smalltext|`oYour balance:|left|\nadd_label_with_icon|small|`oWorld Lock : `2" + Set_Count(Inventory::Contains(peer, 242)) + "|left|242|\nadd_label_with_icon|small|`oDiamond Lock : `2" + Set_Count(Inventory::Contains(peer, 1796)) + "|left|1796|\nadd_label_with_icon|small|`oPlatinum Gem Lock : `2" + Set_Count(Inventory::Contains(peer, 7188)) + "|left|7188|\nadd_label_with_icon|small|`oGems : `2" + Set_Count(pInfo(peer)->gems) + "|left|14590|\nadd_label_with_icon|small|`o" + Environment()->server_name + " Gem Lock : `2" + Set_Count(Inventory::Contains(peer, 8470)) + "|left|8470|\nadd_label_with_icon|small|`oInfinity Gem Lock : `2" + Set_Count(Inventory::Contains(peer, 13200)) + "|left|13200|\nadd_spacer|small|\nmax_checks|1|\ntext_scaling_string|DEFIBRILLATOR|\nadd_smalltext|`oSelect type balance:|left|\nadd_checkicon|wl|WL|noflags|242||0|\nadd_checkicon|dl|DL|noflags|1796||0|\nadd_checkicon|pgl|PGL|noflags|7188||0|\nadd_checkicon|mgl|MGL|noflags|8470||0|\nadd_checkicon|igl|IGL|noflags|13200||0|\nadd_checkicon|gems|GEMS|noflags|14590||0|\nadd_button_with_icon||END_ROW|noflags|0||\nadd_spacer|small|\nadd_smalltext|`oAmount:|left|\nadd_text_input|amount|||13|\nadd_spacer|small|\nadd_button|BackToDialog|`wBack|noflags|0|0|\nadd_custom_button|Confirm_Depo|textLabel:`wDeposit;anchor:_button_BackToDialog;left:1;margin:40,0;|\nend_dialog|Bank_Central|||");
			}
			if (button == "withdraw") {
				VarList::OnDialogRequest(peer, SetColor(peer) + "\nadd_label_with_icon|big|`wWITHDRAW|left|13810|\nadd_spacer|small|\nadd_smalltext|`oYour balance in Bank:|left|\nadd_label_with_icon|small|`oWorld Lock : `2" + Set_Count(pInfo(peer)->wl_bank_amount) + "|left|242|\nadd_label_with_icon|small|`oDiamond Lock : `2" + Set_Count(pInfo(peer)->dl_bank_amount) + "|left|1796|\nadd_label_with_icon|small|`oPlatinum Gem Lock : `2" + Set_Count(pInfo(peer)->pgl_bank_amount) + "|left|7188|\nadd_label_with_icon|small|`o" + Environment()->server_name + " Gem Lock : `2" + Set_Count(pInfo(peer)->mgl_bank_amount) + "|left|8470|\nadd_label_with_icon|small|`oInfinity Gem Lock : `2" + Set_Count(pInfo(peer)->igl_bank_amount) + "|left|13200|\nadd_label_with_icon|small|`oGems : `2" + formatWithCommas(pInfo(peer)->Gems_Storage) + "|left|14590|\nadd_spacer|small|\nmax_checks|1|\ntext_scaling_string|DEFIBRILLATOR|\nadd_smalltext|`oSelect type balance:|left|\nadd_checkicon|wl|WL|noflags|242||0|\nadd_checkicon|dl|DL|noflags|1796||0|\nadd_checkicon|pgl|PGL|noflags|7188||0|\nadd_checkicon|mgl|MGL|noflags|8470||0|\nadd_checkicon|igl|IGL|noflags|13200||0|\nadd_checkicon|gems|GEMS|noflags|14590||0|\nadd_button_with_icon||END_ROW|noflags|0||\nadd_spacer|small|\nadd_smalltext|`oAmount:|left|\nadd_text_input|amount|||13|\nadd_spacer|small|\nadd_button|BackToDialog|`wBack|noflags|0|0|\nadd_custom_button|Confirm_Wd|textLabel:`wWithdraw;anchor:_button_BackToDialog;left:1;margin:40,0;|\nend_dialog|Bank_Central|||");
			}
			if (button == "transfer") {
				VarList::OnDialogRequest(peer, SetColor(peer) + "\nadd_label_with_icon|big|`wTRANSFER|left|13806|\nadd_spacer|small|\nadd_smalltext|`oYour balance in Bank:|left|\nadd_label_with_icon|small|`oWorld Lock : `2" + Set_Count(pInfo(peer)->wl_bank_amount) + "|left|242|\nadd_label_with_icon|small|`oDiamond Lock : `2" + Set_Count(pInfo(peer)->dl_bank_amount) + "|left|1796|\nadd_label_with_icon|small|`oPlatinum Gem Lock : `2" + Set_Count(pInfo(peer)->pgl_bank_amount) + "|left|7188|\nadd_label_with_icon|small|`o" + Environment()->server_name + " Gem Lock : `2" + Set_Count(pInfo(peer)->mgl_bank_amount) + "|left|8470|\nadd_label_with_icon|small|`oInfinity Gem Lock : `2" + Set_Count(pInfo(peer)->igl_bank_amount) + "|left|13200|\nadd_label_with_icon|small|`oGems : `2" + formatWithCommas(pInfo(peer)->Gems_Storage) + "|left|14590|\nadd_spacer|small|\nmax_checks|1|\ntext_scaling_string|DEFIBRILLATOR|\nadd_smalltext|`oSelect type balance:|left|\nadd_checkicon|wl|WL|noflags|242||0|\nadd_checkicon|dl|DL|noflags|1796||0|\nadd_checkicon|pgl|PGL|noflags|7188||0|\nadd_checkicon|mgl|MGL|noflags|8470||0|\nadd_checkicon|igl|IGL|noflags|13200||0|\nadd_checkicon|gems|GEMS|noflags|14590||0|\nadd_button_with_icon||END_ROW|noflags|0||\nadd_spacer|small|\nadd_smalltext|`oAmount:|left|\nadd_text_input|amount|||13|\nadd_spacer|small|\nadd_smalltext|`oPlease enter the name of the transfer destination:|left|\nadd_text_input|target_name|||20|\nadd_spacer|small|\nadd_button|BackToDialog|`wBack|noflags|0|0|\nadd_custom_button|Confirm_Transfer|textLabel:`wTransfer;anchor:_button_BackToDialog;left:1;margin:40,0;|\nend_dialog|Bank_Central|||");
			}
			if (button == "history") {
				string list = "";
				for (int i = 0; i < pInfo(peer)->Bank_History.size(); i++) list += "\nadd_smalltext|`o" + pInfo(peer)->Bank_History[i] + "|left|\n";
				if (list.empty()) list = "\nadd_textbox|`oBank History is empty.|left|";
				VarList::OnDialogRequest(peer, SetColor(peer) + "\nadd_label_with_icon|big|`wHISTORY|left|13802|\nadd_smalltext|`oYou can see the Bank history here, Bank history is updated after you make the transaction, if you don't see it here, please check back in a few moments.|left|\nadd_spacer|small|" + a + (pInfo(peer)->Bank_History.empty() ? "" : "\nadd_button|Clear_History|`4Clear History|noflags|0|0|") + "\nadd_spacer|small|" + list + "|\nadd_spacer|small|\nadd_button|BackToDialog|`wBack|noflags|0|0|\nend_dialog|Bank_Central|||");
			}
			if (button == "Clear_History") {
				pInfo(peer)->Bank_History.clear();
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "History has been cleared!", 0, 1);
				DialogHandle::BankCentral(peer, 700);
			}
			if (button == "Confirm_Depo") {
				if (pInfo(peer)->Has_Enter_Bank) {
					string gems = parser.get("gems", 1), wl = parser.get("wl", 1), dl = parser.get("dl", 1), pgl = parser.get("pgl", 1), mgl = parser.get("mgl", 1), igl = parser.get("igl", 1), amount = parser.get("amount", 1);
					if (gems == "0" and wl == "0" and dl == "0" and pgl == "0" and mgl == "0" and igl == "0") {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wPlease pick the type balance!", 0, 1);
						return;
					}
					if (gems == "1") {
						int count = std::atoi(amount.c_str()), PlayerGems = pInfo(peer)->gems;
						if (atoi(amount.c_str()) > PlayerGems) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou don't have enough gems to deposit", 0, 1);
							return;
						}
						else if (atoi(amount.c_str()) < 1 || amount.find_first_not_of("0123456789") != std::string::npos) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in amount!", 0, 1);
							return;
						}
						else {
							pInfo(peer)->Gems_Storage += count;
							VarList::OnMinGems(peer, count);
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Succesfully Deposit your " + Set_Count(count) + " Gems to Bank.", 0, 1);
							DialogHandle::BankCentral(peer, 700);
							pInfo(peer)->Bank_History.push_back(currentDateTime() + " You Deposit " + Set_Count(std::atoi(amount.c_str())) + " Gems to Bank Central");
						}
					}
					if (gems != "1") {
						if (amount.size() < 1 or not is_number(amount) or std::atoi(amount.c_str()) > 200) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in amount!", 0, 1);
							return;
						}
					}
					if (wl == "1" and std::atoi(amount.c_str()) > 0) {
						int rem = 0;
						if (std::atoi(amount.c_str()) > Inventory::Contains(peer, 242)) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough World Lock!", 0, 1);
							return;
						}
						if (Inventory::Modify(peer, 242, rem -= std::atoi(amount.c_str())) == 0) {
							pInfo(peer)->wl_bank_amount += std::atoi(amount.c_str());
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Succesfully Deposit your World Lock to Bank.", 0, 1);
							DialogHandle::BankCentral(peer, 700);
							pInfo(peer)->Bank_History.push_back(currentDateTime() + " You Deposit " + to_string(std::atoi(amount.c_str())) + " World Lock to Bank Central");
						}
					}
					if (dl == "1" and std::atoi(amount.c_str()) > 0) {
						int rem = 0;
						if (std::atoi(amount.c_str()) > Inventory::Contains(peer, 1796)) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Diamond Lock!", 0, 1);
							return;
						}
						if (Inventory::Modify(peer, 1796, rem -= std::atoi(amount.c_str())) == 0) {
							pInfo(peer)->dl_bank_amount += std::atoi(amount.c_str());
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Succesfully Deposit your Diamond Lock to Bank.", 0, 1);
							DialogHandle::BankCentral(peer, 700);
							pInfo(peer)->Bank_History.push_back(currentDateTime() + " You Deposit " + to_string(std::atoi(amount.c_str())) + " Diamond Lock to Bank Central");
						}
					}
					if (pgl == "1" and std::atoi(amount.c_str()) > 0) {
						int rem = 0;
						if (std::atoi(amount.c_str()) > Inventory::Contains(peer, 7188)) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Platinum Gem Lock!", 0, 1);
							return;
						}
						if (Inventory::Modify(peer, 7188, rem -= std::atoi(amount.c_str())) == 0) {
							pInfo(peer)->pgl_bank_amount += std::atoi(amount.c_str());
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Succesfully Deposit your Platinum Gem Lock to Bank.", 0, 1);
							DialogHandle::BankCentral(peer, 700);
							pInfo(peer)->Bank_History.push_back(currentDateTime() + " You Deposit " + to_string(std::atoi(amount.c_str())) + " Platinum Gem Lock to Bank Central");
						}
					}
					if (mgl == "1" and std::atoi(amount.c_str()) > 0) {
						int rem = 0;
						if (std::atoi(amount.c_str()) > Inventory::Contains(peer, 8470)) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough " + Environment()->server_name + " Gem Lock!", 0, 1);
							return;
						}
						if (Inventory::Modify(peer, 8470, rem -= std::atoi(amount.c_str())) == 0) {
							pInfo(peer)->mgl_bank_amount += std::atoi(amount.c_str());
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Succesfully Deposit your " + Environment()->server_name + " Gem Lock to Bank.", 0, 1);
							DialogHandle::BankCentral(peer, 700);
							pInfo(peer)->Bank_History.push_back(currentDateTime() + " You Deposit " + to_string(std::atoi(amount.c_str())) + " " + Environment()->server_name + " Gem Lock to Bank Central");
						}
					}
					if (igl == "1" and std::atoi(amount.c_str()) > 0) {
						int rem = 0;
						if (std::atoi(amount.c_str()) > Inventory::Contains(peer, 13200)) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Infinity Gem Lock!", 0, 1);
							return;
						}
						if (Inventory::Modify(peer, 13200, rem -= std::atoi(amount.c_str())) == 0) {
							pInfo(peer)->igl_bank_amount += std::atoi(amount.c_str());
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Succesfully Deposit your Infinity Gem Lock to Bank.", 0, 1);
							DialogHandle::BankCentral(peer, 700);
							pInfo(peer)->Bank_History.push_back(currentDateTime() + " You Deposit " + to_string(std::atoi(amount.c_str())) + " Infinity Gem Lock to Bank Central");
						}
					}
				}
			}
			if (button == "Confirm_Wd") {
				if (pInfo(peer)->Has_Enter_Bank) {
					string gems = parser.get("gems", 1), wl = parser.get("wl", 1), dl = parser.get("dl", 1), pgl = parser.get("pgl", 1), mgl = parser.get("mgl", 1), igl = parser.get("igl", 1), amount = parser.get("amount", 1);
					if (gems == "0" and wl == "0" and dl == "0" and pgl == "0" and mgl == "0" and igl == "0") {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wPlease pick the type balance!", 0, 1);
						return;
					}
					if (gems == "1") {
						int count = std::atoi(amount.c_str());
						long long int PlayerGems = pInfo(peer)->Gems_Storage;
						if (atoi(amount.c_str()) > PlayerGems) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou don't have many gems deposit!", 0, 1);
							return;
						}
						else if (pInfo(peer)->gems >= 2100000000) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYour gems have reached the maximum limit", 0, 1);
							return;
						}
						else if (atoi(amount.c_str()) < 1 || amount.find_first_not_of("0123456789") != std::string::npos) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in amount!", 0, 1);
							return;
						}
						else {
							pInfo(peer)->Gems_Storage = pInfo(peer)->Gems_Storage - count;
							VarList::OnBuxGems(peer, count);
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Succesfully Withdraw your " + Set_Count(count) + " Gems from Bank.", 0, 1);
							DialogHandle::BankCentral(peer, 700);
							pInfo(peer)->Bank_History.push_back(currentDateTime() + " You Withdraw " + Set_Count(std::atoi(amount.c_str())) + " Gems from Bank Central");
						}
					}
					if (gems != "1") {
						if (amount.size() < 1 or not is_number(amount) or std::atoi(amount.c_str()) > 200) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in amount!", 0, 1);
							return;
						}
						int free_slots = Inventory::Get_Slots(pInfo(peer));
						if (free_slots == 0) {
							VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
							return;
						}
					}
					if (wl == "1" and std::atoi(amount.c_str()) > 0) {
						int add = 0;
						if (atoi(amount.c_str()) > pInfo(peer)->wl_bank_amount) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou don't have many World Lock in Bank!", 0, 1);
							return;
						}
						if (Inventory::Check_Max(peer, 242, std::atoi(amount.c_str()))) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, true);
							return;
						}
						if (Inventory::Modify(peer, 242, add += std::atoi(amount.c_str())) == 0) {
							pInfo(peer)->wl_bank_amount -= std::atoi(amount.c_str());
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Succesfully Withdraw your World Lock from Bank.", 0, 1);
							DialogHandle::BankCentral(peer, 700);
							pInfo(peer)->Bank_History.push_back(currentDateTime() + " You Withdraw " + to_string(std::atoi(amount.c_str())) + " World Lock from Bank Central");
						}
					}
					if (dl == "1" and std::atoi(amount.c_str()) > 0) {
						int add = 0;
						if (atoi(amount.c_str()) > pInfo(peer)->dl_bank_amount) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou don't have many Diamond Lock in Bank!", 0, 1);
							return;
						}
						if (Inventory::Check_Max(peer, 1796, std::atoi(amount.c_str()))) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, true);
							return;
						}
						if (Inventory::Modify(peer, 1796, add += std::atoi(amount.c_str())) == 0) {
							pInfo(peer)->dl_bank_amount -= std::atoi(amount.c_str());
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Succesfully Withdraw your Diamond Lock from Bank.", 0, 1);
							DialogHandle::BankCentral(peer, 700);
							pInfo(peer)->Bank_History.push_back(currentDateTime() + " You Withdraw " + to_string(std::atoi(amount.c_str())) + " Diamond Lock from Bank Central");
						}
					}
					if (pgl == "1" and std::atoi(amount.c_str()) > 0) {
						int add = 0;
						if (atoi(amount.c_str()) > pInfo(peer)->pgl_bank_amount) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou don't have many Platinum Gem Lock in Bank!", 0, 1);
							return;
						}
						if (Inventory::Check_Max(peer, 7188, std::atoi(amount.c_str()))) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, true);
							return;
						}
						if (Inventory::Modify(peer, 7188, add += std::atoi(amount.c_str())) == 0) {
							pInfo(peer)->pgl_bank_amount -= std::atoi(amount.c_str());
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Succesfully Withdraw your Platinum Gem Lock from Bank.", 0, 1);
							DialogHandle::BankCentral(peer, 700);
							pInfo(peer)->Bank_History.push_back(currentDateTime() + " You Withdraw " + to_string(std::atoi(amount.c_str())) + " Platinum Gem Lock from Bank Central");
						}
					}
					if (mgl == "1" and std::atoi(amount.c_str()) > 0) {
						int add = 0;
						if (atoi(amount.c_str()) > pInfo(peer)->mgl_bank_amount) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou don't have many " + Environment()->server_name + " Gem Lock in Bank!", 0, 1);
							return;
						}
						if (Inventory::Check_Max(peer, 8470, std::atoi(amount.c_str()))) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, true);
							return;
						}
						if (Inventory::Modify(peer, 8470, add += std::atoi(amount.c_str())) == 0) {
							pInfo(peer)->mgl_bank_amount -= std::atoi(amount.c_str());
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Succesfully Withdraw your " + Environment()->server_name + " Gem Lock from Bank.", 0, 1);
							DialogHandle::BankCentral(peer, 700);
							pInfo(peer)->Bank_History.push_back(currentDateTime() + " You Withdraw " + to_string(std::atoi(amount.c_str())) + " " + Environment()->server_name + " Gem Lock from Bank Central");
						}
					}
					if (igl == "1" and std::atoi(amount.c_str()) > 0) {
						int add = 0;
						if (atoi(amount.c_str()) > pInfo(peer)->igl_bank_amount) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou don't have many Infinity Gem Lock in Bank!", 0, 1);
							return;
						}
						if (Inventory::Check_Max(peer, 13200, std::atoi(amount.c_str()))) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, true);
							return;
						}
						if (Inventory::Modify(peer, 13200, add += std::atoi(amount.c_str())) == 0) {
							pInfo(peer)->igl_bank_amount -= std::atoi(amount.c_str());
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Succesfully Withdraw your Infinity Gem Lock from Bank.", 0, 1);
							DialogHandle::BankCentral(peer, 700);
							pInfo(peer)->Bank_History.push_back(currentDateTime() + " You Withdraw " + to_string(std::atoi(amount.c_str())) + " Infinity Gem Lock from Bank Central");
						}
					}
				}
			}
			if (button == "Confirm_Transfer") {
				if (pInfo(peer)->Has_Enter_Bank) {
					bool founded = false;
					string gems = parser.get("gems", 1), wl = parser.get("wl", 1), dl = parser.get("dl", 1), pgl = parser.get("pgl", 1), mgl = parser.get("mgl", 1), igl = parser.get("igl", 1), amount = parser.get("amount", 1), target_name = parser.get("target_name", 1);
					if (gems == "0" and wl == "0" and dl == "0" and pgl == "0" and igl == "0" and igl == "0") {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wPlease pick the type balance!", 0, 1); founded = true;
						return;
					}
					if (target_name.empty() or to_lower(target_name) == to_lower(pInfo(peer)->tankIDName)) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, (target_name.empty() ? "`wdestination name cannot be empty!" : "huh? you can't transfer it to yourself"), 0, 1); founded = true;
						return;
					}
					if (gems != "1") {
						if (amount.size() < 1 or not is_number(amount) or std::atoi(amount.c_str()) > 200) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in amount!", 0, 1); founded = true;
							return;
						}
					}
					if (gems == "1") {
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
							if (to_lower(pInfo(cp_)->tankIDName) == to_lower(target_name)) {
								founded = true;
								int count = std::atoi(amount.c_str());
								long long int PlayerGems = pInfo(peer)->Gems_Storage;
								if (atoi(amount.c_str()) > PlayerGems) {
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou don't have many Gems in Bank!", 0, 1);
									return;
								}
								else if (pInfo(cp_)->gems >= 2100000000) {
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`w" + target_name + " gems have reached the maximum limit", 0, 1);
									return;
								}
								else if (atoi(amount.c_str()) < 1 || amount.find_first_not_of("0123456789") != std::string::npos) {
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in amount!", 0, 1);
									return;
								}
								else {
									pInfo(cp_)->Gems_Storage += count;
									pInfo(peer)->Gems_Storage -= count;
									VarList::OnMinGems(peer, count), VarList::OnBuxGems(cp_, count);
									VarList::OnConsoleMessage(cp_, "You receive a transfer in the form of " + Set_Count(count) + " Gems from " + pInfo(peer)->tankIDName + "");
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Succesfully Transfer your " + Set_Count(count) + " Gems to " + target_name + ".", 0, 1);
									DialogHandle::BankCentral(peer, 700);
									pInfo(peer)->Bank_History.push_back(currentDateTime() + " You Transfer " + Set_Count(std::atoi(amount.c_str())) + " Gems to " + target_name + "");
									PlayerMoving data_{};
									data_.packetType = 19, data_.plantingTree = 500, data_.netID = pInfo(cp_)->netID;
									data_.punchX = 112, data_.punchY = 112;
									int32_t to_netid = pInfo(peer)->netID;
									BYTE* raw = packPlayerMoving(&data_);
									raw[3] = 3;
									Memory_Copy(raw + 8, &to_netid, 4);
									for (ENetPeer* cp_2 = server->peers; cp_2 < &server->peers[server->peerCount]; ++cp_2) {
										if (cp_2->state != ENET_PEER_STATE_CONNECTED or cp_2->data == NULL) continue;
										if (pInfo(cp_2)->world == pInfo(peer)->world) {
											send_raw(cp_2, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[]raw;
								}
							}
						}
					}
					if (wl == "1" and std::atoi(amount.c_str()) > 0) {
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
							if (to_lower(pInfo(cp_)->tankIDName) == to_lower(target_name)) {
								founded = true;
								int add = 0;
								if (atoi(amount.c_str()) > pInfo(peer)->wl_bank_amount) {
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou don't have many World Lock in Bank!", 0, 1);
									return;
								}
								if (Inventory::Check_Max(cp_, 242, std::atoi(amount.c_str()))) {
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into " + target_name + " inventory!", 0, true);
									return;
								}
								if (Inventory::Modify(cp_, 242, add += std::atoi(amount.c_str())) == 0) {
									pInfo(cp_)->wl_bank_amount += std::atoi(amount.c_str());
									pInfo(peer)->wl_bank_amount -= std::atoi(amount.c_str());
									VarList::OnConsoleMessage(cp_, "You receive a transfer in the form of " + Set_Count(std::atoi(amount.c_str())) + " World Lock from " + pInfo(peer)->tankIDName + "");
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Succesfully Transfer " + Set_Count(std::atoi(amount.c_str())) + " World Lock to " + target_name + ".", 0, 1);
									DialogHandle::BankCentral(peer, 700);
									pInfo(peer)->Bank_History.push_back(currentDateTime() + " You Transfer " + to_string(std::atoi(amount.c_str())) + " World Lock to " + target_name + ".");
									PlayerMoving data_{};
									data_.packetType = 19, data_.plantingTree = 500, data_.netID = pInfo(cp_)->netID;
									data_.punchX = 242, data_.punchY = 242;
									int32_t to_netid = pInfo(peer)->netID;
									BYTE* raw = packPlayerMoving(&data_);
									raw[3] = 3;
									Memory_Copy(raw + 8, &to_netid, 4);
									for (ENetPeer* cp_2 = server->peers; cp_2 < &server->peers[server->peerCount]; ++cp_2) {
										if (cp_2->state != ENET_PEER_STATE_CONNECTED or cp_2->data == NULL) continue;
										if (pInfo(cp_2)->world == pInfo(peer)->world) {
											send_raw(cp_2, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[]raw;
								}
							}
						}
					}
					if (dl == "1" and std::atoi(amount.c_str()) > 0) {
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
							if (to_lower(pInfo(cp_)->tankIDName) == to_lower(target_name)) {
								founded = true;
								int add = 0;
								if (atoi(amount.c_str()) > pInfo(peer)->dl_bank_amount) {
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou don't have many Diamond Lock in Bank!", 0, 1);
									return;
								}
								if (Inventory::Check_Max(cp_, 1796, std::atoi(amount.c_str()))) {
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into " + target_name + " inventory!", 0, true);
									return;
								}
								if (Inventory::Modify(cp_, 1796, add += std::atoi(amount.c_str())) == 0) {
									pInfo(cp_)->dl_bank_amount += std::atoi(amount.c_str());
									pInfo(peer)->dl_bank_amount -= std::atoi(amount.c_str());
									VarList::OnConsoleMessage(cp_, "You receive a transfer in the form of " + Set_Count(std::atoi(amount.c_str())) + " Diamond Lock from " + pInfo(peer)->tankIDName + "");
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Succesfully Transfer " + Set_Count(std::atoi(amount.c_str())) + " Diamond Lock to " + target_name + ".", 0, 1);
									DialogHandle::BankCentral(peer, 700);
									pInfo(peer)->Bank_History.push_back(currentDateTime() + " You Transfer " + Set_Count(std::atoi(amount.c_str())) + " Diamond Lock to " + target_name + ".");
									PlayerMoving data_{};
									data_.packetType = 19, data_.plantingTree = 500, data_.netID = pInfo(cp_)->netID;
									data_.punchX = 1796, data_.punchY = 1796;
									int32_t to_netid = pInfo(peer)->netID;
									BYTE* raw = packPlayerMoving(&data_);
									raw[3] = 3;
									Memory_Copy(raw + 8, &to_netid, 4);
									for (ENetPeer* cp_2 = server->peers; cp_2 < &server->peers[server->peerCount]; ++cp_2) {
										if (cp_2->state != ENET_PEER_STATE_CONNECTED or cp_2->data == NULL) continue;
										if (pInfo(cp_2)->world == pInfo(peer)->world) {
											send_raw(cp_2, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[]raw;
								}
							}
						}
					}
					if (pgl == "1" and std::atoi(amount.c_str()) > 0) {
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
							if (to_lower(pInfo(cp_)->tankIDName) == to_lower(target_name)) {
								founded = true;
								int add = 0;
								if (atoi(amount.c_str()) > pInfo(peer)->pgl_bank_amount) {
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou don't have many Platinum Gem Lock in Bank!", 0, 1);
									return;
								}
								if (Inventory::Check_Max(cp_, 7188, std::atoi(amount.c_str()))) {
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into " + target_name + " inventory!", 0, true);
									return;
								}
								if (Inventory::Modify(cp_, 7188, add += std::atoi(amount.c_str())) == 0) {
									pInfo(cp_)->pgl_bank_amount += std::atoi(amount.c_str());
									pInfo(peer)->pgl_bank_amount -= std::atoi(amount.c_str());
									VarList::OnConsoleMessage(cp_, "You receive a transfer in the form of " + Set_Count(std::atoi(amount.c_str())) + " Platinum Gem Lock from " + pInfo(peer)->tankIDName + "");
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Succesfully Transfer " + Set_Count(std::atoi(amount.c_str())) + " Platinum Gem Lock to " + target_name + ".", 0, 1);
									DialogHandle::BankCentral(peer, 700);
									pInfo(peer)->Bank_History.push_back(currentDateTime() + " You Transfer " + Set_Count(std::atoi(amount.c_str())) + " Platinum Gem Lock to " + target_name + ".");
									PlayerMoving data_{};
									data_.packetType = 19, data_.plantingTree = 500, data_.netID = pInfo(cp_)->netID;
									data_.punchX = 7188, data_.punchY = 7188;
									int32_t to_netid = pInfo(peer)->netID;
									BYTE* raw = packPlayerMoving(&data_);
									raw[3] = 3;
									Memory_Copy(raw + 8, &to_netid, 4);
									for (ENetPeer* cp_2 = server->peers; cp_2 < &server->peers[server->peerCount]; ++cp_2) {
										if (cp_2->state != ENET_PEER_STATE_CONNECTED or cp_2->data == NULL) continue;
										if (pInfo(cp_2)->world == pInfo(peer)->world) {
											send_raw(cp_2, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[]raw;
								}
							}
						}
					}
					if (mgl == "1" and std::atoi(amount.c_str()) > 0) {
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
							if (to_lower(pInfo(cp_)->tankIDName) == to_lower(target_name)) {
								founded = true;
								int add = 0;
								if (atoi(amount.c_str()) > pInfo(peer)->mgl_bank_amount) {
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou don't have many " + Environment()->server_name + " Gem Lock in Bank!", 0, 1);
									return;
								}
								if (Inventory::Check_Max(cp_, 8470, std::atoi(amount.c_str()))) {
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into " + target_name + " inventory!", 0, true);
									return;
								}
								if (Inventory::Modify(cp_, 8470, add += std::atoi(amount.c_str())) == 0) {
									pInfo(cp_)->mgl_bank_amount += std::atoi(amount.c_str());
									pInfo(peer)->mgl_bank_amount -= std::atoi(amount.c_str());
									VarList::OnConsoleMessage(cp_, "You receive a transfer in the form of " + Set_Count(std::atoi(amount.c_str())) + " " + Environment()->server_name + " Gem Lock from " + pInfo(peer)->tankIDName + "");
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Succesfully Transfer " + Set_Count(std::atoi(amount.c_str())) + " " + Environment()->server_name + " Gem Lock to " + target_name + ".", 0, 1);
									DialogHandle::BankCentral(peer, 700);
									pInfo(peer)->Bank_History.push_back(currentDateTime() + " You Transfer " + Set_Count(std::atoi(amount.c_str())) + " " + Environment()->server_name + " Gem Lock to " + target_name + ".");
									PlayerMoving data_{};
									data_.packetType = 19, data_.plantingTree = 500, data_.netID = pInfo(cp_)->netID;
									data_.punchX = 8470, data_.punchY = 8470;
									int32_t to_netid = pInfo(peer)->netID;
									BYTE* raw = packPlayerMoving(&data_);
									raw[3] = 3;
									Memory_Copy(raw + 8, &to_netid, 4);
									for (ENetPeer* cp_2 = server->peers; cp_2 < &server->peers[server->peerCount]; ++cp_2) {
										if (cp_2->state != ENET_PEER_STATE_CONNECTED or cp_2->data == NULL) continue;
										if (pInfo(cp_2)->world == pInfo(peer)->world) {
											send_raw(cp_2, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[]raw;
								}
							}
						}
					}
					if (igl == "1" and std::atoi(amount.c_str()) > 0) {
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
							if (to_lower(pInfo(cp_)->tankIDName) == to_lower(target_name)) {
								founded = true;
								int add = 0;
								if (atoi(amount.c_str()) > pInfo(peer)->igl_bank_amount) {
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou don't have many Infinity Gem Lock in Bank!", 0, 1);
									return;
								}
								if (Inventory::Check_Max(cp_, 13200, std::atoi(amount.c_str()))) {
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into " + target_name + " inventory!", 0, true);
									return;
								}
								if (Inventory::Modify(cp_, 13200, add += std::atoi(amount.c_str())) == 0) {
									pInfo(cp_)->igl_bank_amount += std::atoi(amount.c_str());
									pInfo(peer)->igl_bank_amount -= std::atoi(amount.c_str());
									VarList::OnConsoleMessage(cp_, "You receive a transfer in the form of " + Set_Count(std::atoi(amount.c_str())) + " Infinity Gem Lock from " + pInfo(peer)->tankIDName + "");
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Succesfully Transfer " + Set_Count(std::atoi(amount.c_str())) + " Infinity Gem Lock to " + target_name + ".", 0, 1);
									DialogHandle::BankCentral(peer, 700);
									pInfo(peer)->Bank_History.push_back(currentDateTime() + " You Transfer " + Set_Count(std::atoi(amount.c_str())) + " Infinity Gem Lock to " + target_name + ".");
									PlayerMoving data_{};
									data_.packetType = 19, data_.plantingTree = 500, data_.netID = pInfo(cp_)->netID;
									data_.punchX = 8470, data_.punchY = 8470;
									int32_t to_netid = pInfo(peer)->netID;
									BYTE* raw = packPlayerMoving(&data_);
									raw[3] = 3;
									Memory_Copy(raw + 8, &to_netid, 4);
									for (ENetPeer* cp_2 = server->peers; cp_2 < &server->peers[server->peerCount]; ++cp_2) {
										if (cp_2->state != ENET_PEER_STATE_CONNECTED or cp_2->data == NULL) continue;
										if (pInfo(cp_2)->world == pInfo(peer)->world) {
											send_raw(cp_2, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[]raw;
								}
							}
						}
					}
					if (not founded) VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wThe player with the target name was not found!", 0, 1);
				}
			}
			if (button == "Create_Pin") {
				string pin_bank = parser.get("pin_bank", 1);
				if (pin_bank.size() < 6 or not is_number(pin_bank)) {
					DialogHandle::BankCentral(peer, 0, "Invalid input in PIN!");
					return;
				}
				pInfo(peer)->bank_password = std::atoi(pin_bank.c_str());
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Succesfully Created Pin Bank!", 0, 1);
				DialogHandle::BankCentral(peer, 500);
			}
			if (button == "Enter_Pin") {
				string pin_bank = parser.get("pin_bank", 1);
				if (pin_bank.size() < 6 or not is_number(pin_bank)) {
					DialogHandle::BankCentral(peer, 0, "Invalid input in PIN!");
					return;
				}
				if (std::atoi(pin_bank.c_str()) != pInfo(peer)->bank_password) {
					DialogHandle::BankCentral(peer, 0, "You entered the wrong PIN!");
					return;
				}
				pInfo(peer)->Has_Enter_Bank = true;
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Welcome To Bank Central!", 0, 1);
				DialogHandle::BankCentral(peer, 500);
			}
		}
	}
	static void Miner_ExPlace(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (pInfo(peer)->world == "MINING") {
				if (button == "BackToDialog") {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wAlbert - Exchange Place|left|14514|\nadd_spacer|small|\nadd_smalltext|Hello Miners, welcome to the coin exchange place!|left|\nadd_spacer|small|\nadd_smalltext|In this place you can exchange your mining results in the form of coins into several valuable items and can also be exchanged for gems or locks.|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour current Mines Coin: `2" + Set_Count(pInfo(peer)->mines_coin) + "|left|20192|\nadd_label_with_icon|small|`wYour current Mines Crystal: `2" + Set_Count(Inventory::Contains(peer, 14536)) + "|left|14536|\nadd_spacer|small|\nadd_label|small|Price:|left|\nadd_smalltext|[1 Mines Coin : 2,000 Gems ė]|left|\nadd_smalltext|[1 Mines Coin : 1 World Lock ā]|left|\nadd_smalltext|[1 Mines Crystal : 100 World Locks ā]|left|\nadd_spacer|small|\ntext_scaling_string|aaaaaaaaaaaaaaa|\nadd_custom_button|worldlock|image:interface/large/store_buttons/tianvan_store.rttex;image_size:256,160;frame:8,1;width:0.25;state:enable;|\nadd_custom_label|`b1 MINES COIN > 1 WL|target:worldlock;top:0.80;left:0.50;size:tiny|\nadd_custom_button|gems|image:interface/large/store_buttons/tianvan_store.rttex;image_size:256,160;frame:9,0;width:0.25;state:enable;|\nadd_custom_label|`#1 MINES COIN > 2000 GEMS|target:gems;top:0.80;left:0.50;size:tiny|\nadd_custom_button|crystal|image:interface/large/store_buttons/tianvan_store.rttex;image_size:256,160;frame:8,0;width:0.25;state:enable;|\nadd_custom_label|`41 CRYSTAL > 100 WL|target:crystal;top:0.80;left:0.50;size:tiny|\nadd_custom_break|\nadd_spacer|small|"
						"\nadd_label|small|Ores:|left|\nadd_spacer|small|"
						"\nadd_button_with_icon|ores_20056|DIAMOND|frame|20056|"
						"\nadd_button_with_icon|ores_20060|PLATINUM|frame|20060|"
						"\nadd_button_with_icon|ores_20054|GOLDEN|frame|20054|"
						"\nadd_button_with_icon|ores_20044|SILVER|frame|20044|"
						"\nadd_button_with_icon|ores_20062|TITANIUM|frame|20062|"
						"\nadd_button_with_icon|ores_20064|VANADIUM|frame|20064|"
						"\nadd_button_with_icon|ores_20042|COPPER|frame|20042|"
						"\nadd_button_with_icon|ores_20066|TIN|frame|20066|"
						"\nadd_button_with_icon|ores_20052|CELESTINE|frame|20052|"
						"\nadd_button_with_icon||END_ROW|noflags|0||\nadd_spacer|small|\nend_dialog|Miner_ExPlace|Close||\nadd_quick_exit|");
				}
				if (button == "gems") {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Gems|left|112|\nadd_spacer|small|\nadd_textbox|`oHow many Mines Coin do you want to Exchange to Gems?|left|\nadd_text_input|Credits_Amount|||3|\nadd_spacer|small|\nadd_textbox|`o1 Mines Coin = 2,000 Gems.|left|\nadd_spacer|small|\nadd_custom_textbox|`oYou have `2" + Set_Count(pInfo(peer)->mines_coin) + " Mines Coin`o.|size:small;icon:20192;|\nadd_button|BackToDialog|`wBack|noflags|\nadd_custom_button|Exchange_Gems|textLabel:`wExchange;anchor:_button_BackToDialog;left:1;margin:40,0;|\nend_dialog|Miner_ExPlace|||");
				}
				if (button == "worldlock") {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|World Lock|left|242|\nadd_spacer|small|\nadd_textbox|`oHow many World Lock do you want to Buy?|left|\nadd_text_input|Credits_Amount|||3|\nadd_spacer|small|\nadd_textbox|`o1 Mines Coin = 1 World Lock.|left|\nadd_spacer|small|\nadd_custom_textbox|`oYou have `2" + Set_Count(pInfo(peer)->mines_coin) + " Mines Coin`o.|size:small;icon:20192;|\nadd_button|BackToDialog|`wBack|noflags|\nadd_custom_button|Exchange_Wls|textLabel:`wExchange;anchor:_button_BackToDialog;left:1;margin:40,0;|\nend_dialog|Miner_ExPlace|||");
				}
				if (button == "crystal") {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Mines Crystal|left|14536|\nadd_spacer|small|\nadd_textbox|`oHow many Mines Crystal do you want to Sell?|left|\nadd_text_input|Credits_Amount|||3|\nadd_spacer|small|\nadd_textbox|`o1 Crystal = 100 World Lock.|left|\nadd_spacer|small|\nadd_custom_textbox|`oYou have `2" + Set_Count(Inventory::Contains(peer, 14536)) + " Mines Crystal`o.|size:small;icon:14536;|\nadd_button|BackToDialog|`wBack|noflags|\nadd_custom_button|Sell_Crystal|textLabel:`wExchange;anchor:_button_BackToDialog;left:1;margin:40,0;|\nend_dialog|Miner_ExPlace|||");
				}
				if (button == "Exchange_Gems") {
					string scan_c = parser.get("Credits_Amount", 1);
					if (atoi(scan_c.c_str()) < 1 || atoi(scan_c.c_str()) < 0 || scan_c.find_first_not_of("0123456789") != std::string::npos) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in amount!", 0, 1);
						return;
					}
					int kaina = 2000, count = std::atoi(scan_c.c_str());
					if (count > pInfo(peer)->mines_coin) {
						VarList::OnConsoleMessage(peer, "You don't have enough Mines Coin!");
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Mines Coin!", 0, 1);
						return;
					}
					int is_viso = kaina * count;
					PlayerMoving data_{}; PlayerMoving data{};
					data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = 112, data_.punchY = pInfo(peer)->netID;
					int32_t to_netid = pInfo(peer)->netID;
					BYTE* raw = packPlayerMoving(&data_);
					raw[3] = 5;
					Memory_Copy(raw + 8, &to_netid, 4);
					data.packetType = 19, data.netID = -1, data.plantingTree = 0;
					data.x = pInfo(peer)->lastwrenchx * 32 + 16, data.y = pInfo(peer)->lastwrenchy * 32 + 16;
					data.XSpeed = pInfo(peer)->x + 16, data.YSpeed = pInfo(peer)->y + 16;
					data.punchX = 20192;
					BYTE* raw_ = packPlayerMoving(&data);
					raw_[3] = 6;
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; cp_++) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL) return;
						if (pInfo(cp_)->world == "MINING") {
							send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							send_raw(cp_, 4, raw_, 56, ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[] raw, raw_;
					pInfo(peer)->mines_coin -= count;
					VarList::OnBuxGems(peer, is_viso);
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wSuccesfully Exchange " + to_string(count) + " Mines Coin to " + Set_Count(is_viso) + " Gems.", 0, 1);
				}
				if (button == "Exchange_Wls") {
					string scan_c = parser.get("Credits_Amount", 1);
					if (atoi(scan_c.c_str()) < 1 || atoi(scan_c.c_str()) < 0 || atoi(scan_c.c_str()) > 200 || scan_c.find_first_not_of("0123456789") != std::string::npos) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in amount!", 0, 1);
						return;
					}
					int mdf = 0, kaina = 1, count = std::atoi(scan_c.c_str());
					if (count > pInfo(peer)->mines_coin) {
						VarList::OnConsoleMessage(peer, "You don't have enough Mines Coin!");
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Mines Coin!", 0, 1);
						return;
					}
					if (Inventory::Check_Max(peer, 242, count)) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, true);
						return;
					}
					int free_slots = Inventory::Get_Slots(pInfo(peer));
					if (free_slots == 0) {
						VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
						return;
					}
					int is_viso = kaina * count;
					if (Inventory::Modify(peer, 242, mdf = +count) == 0) {
						pInfo(peer)->mines_coin -= is_viso;
						PlayerMoving data_{}; PlayerMoving data{};
						data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = 242, data_.punchY = pInfo(peer)->netID;
						int32_t to_netid = pInfo(peer)->netID;
						BYTE* raw = packPlayerMoving(&data_);
						raw[3] = 5;
						Memory_Copy(raw + 8, &to_netid, 4);
						data.packetType = 19, data.netID = -1, data.plantingTree = 0;
						data.x = pInfo(peer)->lastwrenchx * 32 + 16, data.y = pInfo(peer)->lastwrenchy * 32 + 16;
						data.XSpeed = pInfo(peer)->x + 16, data.YSpeed = pInfo(peer)->y + 16;
						data.punchX = 20192;
						BYTE* raw_ = packPlayerMoving(&data);
						raw_[3] = 6;
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; cp_++) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL) return;
							if (pInfo(cp_)->world == "MINING") {
								send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								send_raw(cp_, 4, raw_, 56, ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, raw_;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wSuccesfully Exchange " + to_string(is_viso) + " Mines Coin to " + Set_Count(count) + " World Locks.", 0, 1);
					}
				}
				if (button == "Sell_Crystal") {
					string scan_c = parser.get("Credits_Amount", 1);
					if (atoi(scan_c.c_str()) < 1 || atoi(scan_c.c_str()) < 0 || atoi(scan_c.c_str()) > 200 || scan_c.find_first_not_of("0123456789") != std::string::npos) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in amount!", 0, 1);
						return;
					}
					int rem = 0, mdf = 0, kaina = 100, count = std::atoi(scan_c.c_str());
					if (count > Inventory::Contains(peer, 14536)) {
						VarList::OnConsoleMessage(peer, "You don't have enough Mines Crystal!");
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Mines Crystal!", 0, 1);
						return;
					}
					if (Inventory::Check_Max(peer, 242, count)) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, true);
						return;
					}
					int free_slots = Inventory::Get_Slots(pInfo(peer));
					if (free_slots == 0) {
						VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
						return;
					}
					int is_viso = kaina * count;
					if (Inventory::Modify(peer, 14536, rem = -count) == 0) {
						if (Inventory::Modify(peer, 242, mdf = +is_viso) == 0) {
							PlayerMoving data_{}; PlayerMoving data{};
							data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = 242, data_.punchY = pInfo(peer)->netID;
							int32_t to_netid = pInfo(peer)->netID;
							BYTE* raw = packPlayerMoving(&data_);
							raw[3] = 5;
							Memory_Copy(raw + 8, &to_netid, 4);
							data.packetType = 19, data.netID = -1, data.plantingTree = 0;
							data.x = pInfo(peer)->lastwrenchx * 32 + 16, data.y = pInfo(peer)->lastwrenchy * 32 + 16;
							data.XSpeed = pInfo(peer)->x + 16, data.YSpeed = pInfo(peer)->y + 16;
							data.punchX = 14536;
							BYTE* raw_ = packPlayerMoving(&data);
							raw_[3] = 6;
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; cp_++) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL) return;
								if (pInfo(cp_)->world == "MINING") {
									send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									send_raw(cp_, 4, raw_, 56, ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw, raw_;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wSuccesfully Sell " + to_string(count) + " Mines Crytal for " + Set_Count(is_viso) + " World Locks.", 0, 1);
						}
						else {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, true);
							return;
						}
					}
				}
				if (button.substr(0, 5) == "ores_") {
					int id_ = std::atoi(button.substr(5).c_str()), price = 0;
					if (id_ < 0 or id_ >= items.size()) return;
					vector<int> list_{ 20056,20060,20054,20044,20062,20064,20042,20066,20052 };
					if (find(list_.begin(), list_.end(), id_) == list_.end()) return;
					if (id_ == 20056) price = 10000;
					if (id_ == 20060) price = 8000;
					if (id_ == 20054) price = 7000;
					if (id_ == 20044) price = 6000;
					if (id_ == 20062) price = 5000;
					if (id_ == 20064) price = 4000;
					if (id_ == 20042) price = 3000;
					if (id_ == 20066) price = 2000;
					if (id_ == 20052) price = 1000;
					if (price == 0) return;
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label|big|`1" + to_upper(items[id_].name) + "|left|\nadd_spacer|small|\nadd_custom_margin|x:0;y:-30|\nembed_data|price|" + to_string(price) + "\nadd_custom_button||icon:" + to_string(id_) + ";display:inline_free;width:0.40;state:disabled;|\nadd_spacer|small|\nadd_custom_margin|x:20;y:-20|\nadd_smalltext|`1ITEM DESCRIPTION`o: " + items[id_].description + "|left|\nadd_smalltext|`1ITEM PRICE`o: 1-" + Set_Count(price) + "ė|left|\nadd_smalltext|`1ITEM RARITY`o: " + to_string(items[id_].rarity) + "|left|\nadd_custom_margin|x:-10;y:0|\nreset_placement_x|\nadd_spacer|small|\nadd_spacer|small|\nadd_text_input|amount|||3|\nadd_spacer|small|\nadd_custom_textbox|`oYou have `2" + Set_Count(Inventory::Contains(peer, id_)) + " " + items[id_].name + "`o.|size:small;icon:" + to_string(id_) + ";|\nadd_spacer|small|\nadd_custom_button|BackToDialog|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|SellOres_" + to_string(id_) + "|textLabel:`2Sell Ores;anchor:_button_BackToDialog;left:1;margin:60,0;|\nend_dialog|Miner_ExPlace|||\nadd_quick_exit|");
				}
				if (button.substr(0, 9) == "SellOres_") {
					int id_ = std::atoi(button.substr(9).c_str()), price = std::atoi(get_embed(cch, "price").c_str());
					if (id_ < 0 or id_ >= items.size()) return;
					vector<int> list_{ 20056,20060,20054,20044,20062,20064,20042,20066,20052 };
					if (find(list_.begin(), list_.end(), id_) == list_.end() or price < 1000 or price > 10000) return;
					string amount = parser.get("amount", 1);
					if (atoi(amount.c_str()) < 1 || atoi(amount.c_str()) < 0 || atoi(amount.c_str()) > 200 || amount.find_first_not_of("0123456789") != std::string::npos) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in amount!", 0, 1);
						return;
					}
					int count = std::atoi(amount.c_str()), rem = count * rand() % price, mdf = 0;
					if (count > Inventory::Contains(peer, id_)) {
						VarList::OnConsoleMessage(peer, "You don't have enough " + items[id_].name + "!");
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough " + items[id_].name + "!", 0, 1);
						return;
					}
					if (pInfo(peer)->gems + rem >= MAX_GEMS) {
						VarList::OnConsoleMessage(peer, "Your gems have reached the maximum limit!");
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your gems have reached the maximum limit!", 0, 0);
						return;
					}
					if (Inventory::Modify(peer, id_, rem = -count) == 0) {
						VarList::OnBuxGems(peer, rem);
						PlayerMoving data_{}; PlayerMoving data{};
						data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = 112, data_.punchY = pInfo(peer)->netID;
						int32_t to_netid = pInfo(peer)->netID;
						BYTE* raw = packPlayerMoving(&data_);
						raw[3] = 5;
						Memory_Copy(raw + 8, &to_netid, 4);
						data.packetType = 19, data.netID = -1, data.plantingTree = 0;
						data.x = pInfo(peer)->lastwrenchx * 32 + 16, data.y = pInfo(peer)->lastwrenchy * 32 + 16;
						data.XSpeed = pInfo(peer)->x + 16, data.YSpeed = pInfo(peer)->y + 16;
						data.punchX = id_;
						BYTE* raw_ = packPlayerMoving(&data);
						raw_[3] = 6;
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; cp_++) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL) return;
							if (pInfo(cp_)->world == "MINING") {
								send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								send_raw(cp_, 4, raw_, 56, ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, raw_;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wSuccesfully Sell " + to_string(count) + " " + items[id_].name + " for " + Set_Count(rem) + " Gems.", 0, 1);
					}
				}
			}
		}
	}
	static void Miner_License(ENetPeer* peer, std::string cch) {
		int mdf = 0, item1 = Inventory::Contains(peer, 14516), item2 = Inventory::Contains(peer, 14518), item3 = Inventory::Contains(peer, 14520), item4 = Inventory::Contains(peer, 14522), item5 = Inventory::Contains(peer, 14524);
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "NEXT") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wMining Tips:|left|14512|\nadd_spacer|small|\nadd_smalltext|`oPlanning: Make a thorough plan before starting work, including calculating the best approach.|left|\nadd_image_button||interface/large/gui_mining_banner1.rttex|bannerlayout|||\nadd_spacer|small|\nadd_smalltext|`oYou can also get rare or legendary items if you find the Golden Mining Chest.|left|\nadd_spacer|small|\nadd_smalltext|`oRead all instructions carefully and carefully so that there is no confusion when you are in the mine, and don't forget to bring a lamp for lighting in the incomparable darkness.|left|\nadd_image_button||interface/large/gui_mining_banner2.rttex|bannerlayout|||\nadd_smalltext|`oConsuming the 'MINER'S LICENSE' will teleport you to one of the Mining Worlds according to the portal you choose.|left|\nadd_spacer|small|\nadd_custom_margin|x:250;y:0|\nadd_custom_button||image:interface/tutorial/taptocontinue.rttex;image_size:382,53;width:0.35;min_width:100;|", 500);
			if (button == "Submit") {
				if (pInfo(peer)->lastwrenchb != 14526) return;
				if (Playmods::HasById(pInfo(peer), 159)) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That's sort of hard to do while having a cooldown.", 2, 0);
					return;
				}
				bool has_ = false;
				string portal1 = parser.get("portal_1", 1), portal2 = parser.get("portal_2", 1), portal3 = parser.get("portal_3", 1), portal4 = parser.get("portal_4", 1), portal5 = parser.get("portal_5", 1);
				if (!isValidCheckboxInput(portal1) or !isValidCheckboxInput(portal2) or !isValidCheckboxInput(portal3) or !isValidCheckboxInput(portal4) or !isValidCheckboxInput(portal5)) return;
				if (portal1 == "0" and portal2 == "0" and portal3 == "0" and portal4 == "0" and portal5 == "0") {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wPlease select one of the portals.", 0, 1);
					return;
				}
				if (portal1 == "1") {
					has_ = true;
					if (item1 < 1) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wyour application is rejected! Read the instructions again before entering world mining.", 0, 1);
						return;
					}
					pInfo(peer)->In_World_Mining = true;
					string name = "GROWMINES1_" + pInfo(peer)->tankIDName;
					replace_str(name, "\n", "");
					transform(name.begin(), name.end(), name.begin(), ::toupper);
					Create::Mining_World1(peer, name);
					Enter_World(peer, name);
				}
				if (portal2 == "1") {
					has_ = true;
					if (item2 < 1) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wyour application is rejected! Read the instructions again before entering world mining.", 0, 1);
						return;
					}
					pInfo(peer)->In_World_Mining = true;
					string name = "GROWMINES2_" + pInfo(peer)->tankIDName;
					replace_str(name, "\n", "");
					transform(name.begin(), name.end(), name.begin(), ::toupper);
					Create::Mining_World2(peer, name);
					Enter_World(peer, name);
				}
				if (portal3 == "1") {
					has_ = true;
					if (item3 < 1) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wyour application is rejected! Read the instructions again before entering world mining.", 0, 1);
						return;
					}
					pInfo(peer)->In_World_Mining = true;
					string name = "GROWMINES3_" + pInfo(peer)->tankIDName;
					replace_str(name, "\n", "");
					transform(name.begin(), name.end(), name.begin(), ::toupper);
					Create::Mining_World3(peer, name);
					Enter_World(peer, name);
				}
				if (portal4 == "1") {
					has_ = true;
					if (item4 < 1) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wyour application is rejected! Read the instructions again before entering world mining.", 0, 1);
						return;
					}
					pInfo(peer)->In_World_Mining = true;
					string name = "GROWMINES4_" + pInfo(peer)->tankIDName;
					replace_str(name, "\n", "");
					transform(name.begin(), name.end(), name.begin(), ::toupper);
					Create::Mining_World4(peer, name);
					Enter_World(peer, name);
				}
				if (portal5 == "1") {
					has_ = true;
					if (item5 < 1) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wyour application is rejected! Read the instructions again before entering world mining.", 0, 1);
						return;
					}
					pInfo(peer)->In_World_Mining = true;
					string name = "GROWMINES5_" + pInfo(peer)->tankIDName;
					replace_str(name, "\n", "");
					transform(name.begin(), name.end(), name.begin(), ::toupper);
					Create::Mining_World5(peer, name);
					Enter_World(peer, name);
				}
				if (has_) {
					Inventory::Modify(peer, 14526, mdf = -1);
					pInfo(peer)->Number_License++;
					Playmods::Add(peer, 159);
					VarList::OnConsoleMessage(peer, "VallenSasukely warping to world of mining...");
					pInfo(peer)->MiningTime = (GetCurrentTimeInternalSeconds() + 900);
					VarList::OnSetMissionTimer(peer, 900, 400);
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Welcome to `2Mining World!``. I will give you `215`` minutes..", 0, 1, 900);
				}
			}
		}
	}
	static void Miner_Forging(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (pInfo(peer)->world == "MINING") {
				if (button == "BackToDialog") {
					string dialog = "";
					if (Miner::PickaxeLvl(peer) == 0) {
						int item1 = Inventory::Contains(peer, 98), item2 = Inventory::Contains(peer, 5070), item3 = Inventory::Contains(peer, 5024), item4 = Inventory::Contains(peer, 1796);
						dialog = "\nadd_button_with_icon||Pickaxe " + a + (item1 >= 1 ? "`2(YES!)" : "`4(NO!)") + "|staticYellowframe|98|1|\nadd_button_with_icon||Reality " + a + (item2 >= 15 ? "`2(YES!)" : "`4(NO!)") + "|staticYellowframe|5070|15|\nadd_button_with_icon||Fire Essence " + a + (item3 >= 100 ? "`2(YES!)" : "`4(NO!)") + "|staticYellowframe|5024|100|\nadd_button_with_icon||Diamond Lock " + a + (item4 >= 10 ? "`2(YES!)" : "`4(NO!)") + "|staticYellowframe|1796|10|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_textbox|`o- Pickaxe Preview:|left|\nadd_button_with_icon||LEVEL 1|noflags|14516|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_small_font_button|upgto_1|`2Upgrade to level 1|noflags|0|0|";
					}
					if (Miner::PickaxeLvl(peer) == 1) {
						int item1 = Inventory::Contains(peer, 14516), item2 = Inventory::Contains(peer, 7186), item3 = Inventory::Contains(peer, 5024), item4 = Inventory::Contains(peer, 1796);
						dialog = "\nadd_button_with_icon||Pickaxe Lvl 1 " + a + (item1 >= 1 ? "`2(YES!)" : "`4(NO!)") + "|staticYellowframe|14516|1|\nadd_button_with_icon||Time " + a + (item2 >= 15 ? "`2(YES!)" : "`4(NO!)") + "|staticYellowframe|7186|15|\nadd_button_with_icon||Fire Essence " + a + (item3 >= 100 ? "`2(YES!)" : "`4(NO!)") + "|staticYellowframe|5024|100|\nadd_button_with_icon||Diamond Lock " + a + (item4 >= 20 ? "`2(YES!)" : "`4(NO!)") + "|staticYellowframe|1796|20|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_textbox|`o- Pickaxe Preview:|left|\nadd_button_with_icon||LEVEL 2|noflags|14518|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_small_font_button|upgto_2|`2Upgrade to level 2|noflags|0|0|";
					}
					if (Miner::PickaxeLvl(peer) == 2) {
						int item1 = Inventory::Contains(peer, 14518), item2 = Inventory::Contains(peer, 5072), item3 = Inventory::Contains(peer, 5024), item4 = Inventory::Contains(peer, 1796);
						dialog = "\nadd_button_with_icon||Pickaxe Lvl 2 " + a + (item1 >= 1 ? "`2(YES!)" : "`4(NO!)") + "|staticYellowframe|14518|1|\nadd_button_with_icon||Wealth " + a + (item2 >= 20 ? "`2(YES!)" : "`4(NO!)") + "|staticYellowframe|5072|20|\nadd_button_with_icon||Fire Essence " + a + (item3 >= 100 ? "`2(YES!)" : "`4(NO!)") + "|staticYellowframe|5024|100|\nadd_button_with_icon||Diamond Lock " + a + (item4 >= 30 ? "`2(YES!)" : "`4(NO!)") + "|staticYellowframe|1796|30|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_textbox|`o- Pickaxe Preview:|left|\nadd_button_with_icon||LEVEL 3|noflags|14520|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_small_font_button|upgto_3|`2Upgrade to level 3|noflags|0|0|";
					}
					if (Miner::PickaxeLvl(peer) == 3) {
						int item1 = Inventory::Contains(peer, 14520), item2 = Inventory::Contains(peer, 5074), item3 = Inventory::Contains(peer, 5024), item4 = Inventory::Contains(peer, 1796);
						dialog = "\nadd_button_with_icon||Pickaxe Lvl 3 " + a + (item1 >= 1 ? "`2(YES!)" : "`4(NO!)") + "|staticYellowframe|14520|1|\nadd_button_with_icon||Brilliance " + a + (item2 >= 25 ? "`2(YES!)" : "`4(NO!)") + "|staticYellowframe|5074|25|\nadd_button_with_icon||Fire Essence " + a + (item3 >= 100 ? "`2(YES!)" : "`4(NO!)") + "|staticYellowframe|5024|100|\nadd_button_with_icon||Diamond Lock " + a + (item4 >= 40 ? "`2(YES!)" : "`4(NO!)") + "|staticYellowframe|1796|40|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_textbox|`o- Pickaxe Preview:|left|\nadd_button_with_icon||LEVEL 4|noflags|14522|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_small_font_button|upgto_4|`2Upgrade to level 4|noflags|0|0|";
					}
					if (Miner::PickaxeLvl(peer) == 4) {
						int item1 = Inventory::Contains(peer, 14522), item2 = Inventory::Contains(peer, 5076), item3 = Inventory::Contains(peer, 5024), item4 = Inventory::Contains(peer, 1796);
						dialog = "\nadd_button_with_icon||Pickaxe Lvl 4 " + a + (item1 >= 1 ? "`2(YES!)" : "`4(NO!)") + "|staticYellowframe|14522|1|\nadd_button_with_icon||Nature " + a + (item2 >= 30 ? "`2(YES!)" : "`4(NO!)") + "|staticYellowframe|5076|35|\nadd_button_with_icon||Fire Essence " + a + (item3 >= 100 ? "`2(YES!)" : "`4(NO!)") + "|staticYellowframe|5024|100|\nadd_button_with_icon||Diamond Lock " + a + (item4 >= 50 ? "`2(YES!)" : "`4(NO!)") + "|staticYellowframe|1796|50|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_textbox|`o- Pickaxe Preview:|left|\nadd_button_with_icon||LEVEL 5|noflags|14524|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_small_font_button|upgto_5|`2Upgrade to level 5|noflags|0|0|";
					}
					if (Miner::PickaxeLvl(peer) == 5) {
						dialog = "\nadd_textbox|`oLEVEL MAX!|left|";
					}
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wWagner - Forging|left|14510|\nadd_spacer|small|\nadd_smalltext|hello, welcome to Weapon Forging I am Wagner a blacksmith in this world. I will explain what forging is.|left|\nadd_spacer|small|\nadd_smalltext|`oForging is a Crafting Method where Players can use Forging Ores to forge Pickaxe Enhancement Materials, which are used to level up Pickaxe. Players can also use Billets (Northlander, Midlander or Borderland) and Forging Ores to forge pickaxe.|left|\nadd_spacer|small|\nadd_textbox|`o[Shop : Materials and some Miner Preparations]|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour current Mines Coin: `2" + Set_Count(pInfo(peer)->mines_coin) + "|left|20192|\nadd_spacer|small|\ntext_scaling_string|aaaaaaaaaaaaaaa|\nadd_button_with_icon|buy_torch|Hand Torch|noflags|3578|\nadd_button_with_icon|buy_cavetorch|Cave Torch|noflags|11602|\nadd_button_with_icon|buy_antigravity|Antigravity Gen|noflags|4992|\nadd_button_with_icon|buy_nightvision|Night Vision Goggles|noflags|3576|\nadd_button_with_icon|buy_dbattery|D Battery|noflags|3306|\nadd_button_with_icon|buy_elefire|Fire Essence|noflags|5024|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button_with_icon|buy_reality|Reality|noflags|5070|\nadd_button_with_icon|buy_wealth|Wealth|noflags|5072|\nadd_button_with_icon|buy_brilliance|Brilliance|noflags|5074|\nadd_button_with_icon|buy_nature|Nature|noflags|5076|\nadd_button_with_icon|buy_time|Time|noflags|7186|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|"
						"\nadd_textbox|`o[Forging your Pickaxe]|left|\nadd_spacer|small|"
						+ (Miner::Pickaxe(pInfo(peer)->hand) ? "\nadd_textbox|Pickaxe Level: " + to_string(Miner::PickaxeLvl(peer)) + "|left|\nadd_textbox|Ability: " + (Miner::PickaxeLvl(peer) == 1 ? "Can break level 1 Crystals" : Miner::PickaxeLvl(peer) == 2 ? "Can break Crystals level 2 and below" : Miner::PickaxeLvl(peer) == 3 ? "Can break Crystals level 3 and below" : Miner::PickaxeLvl(peer) == 4 ? "Can break Crystals level 24 and below" : Miner::PickaxeLvl(peer) == 5 ? "Can break all Crystals and Naval Mine" : "Nothing") + "|left|\nadd_spacer|small|\nadd_textbox|- Materials needed to upgrade your pickaxe:|left|\ntext_scaling_string|aaaaaaaaaaaaaaa|" + dialog : "\nadd_textbox|You must use the pickaxe that has been determined by the system to upgrade|left|") +
						"\nadd_spacer|small|\nend_dialog|Miner_Forging|Close||");
				}
				if (button.substr(0, 6) == "upgto_") {
					string btn = button.substr(6);
					if (btn == "1") {
						int mdf = 0, item1 = Inventory::Contains(peer, 98), item2 = Inventory::Contains(peer, 5070), item3 = Inventory::Contains(peer, 5024), item4 = Inventory::Contains(peer, 1796);
						if (item1 < 1 or item2 < 15 or item3 < 100 or item4 < 10) {
							VarList::OnConsoleMessage(peer, "The required items are not sufficient to upgrade!");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "The required items are not sufficient to upgrade!", 0, 1);
							return;
						}
						if (Inventory::Modify(peer, 14516, mdf = 1) == 0) {
							Inventory::Modify(peer, 98, mdf = -1), Inventory::Modify(peer, 5070, mdf = -15), Inventory::Modify(peer, 5024, mdf = -100), Inventory::Modify(peer, 1796, mdf = -10);
							Clothing::Equip(peer, 14516);
							PlayerMoving data_{};
							data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = 14516, data_.punchY = pInfo(peer)->netID;
							int32_t to_netid = pInfo(peer)->netID;
							BYTE* raw = packPlayerMoving(&data_);
							raw[3] = 5;
							Memory_Copy(raw + 8, &to_netid, 4);
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; cp_++) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL) return;
								if (pInfo(cp_)->world == "MINING") {
									send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "successfully upgraded the pickaxe!", 0, 1);
						}
						else {
							VarList::OnConsoleMessage(peer, "That wouldnt fit into my inventory!");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, 1);
							return;
						}
					}
					if (btn == "2") {
						int mdf = 0, item1 = Inventory::Contains(peer, 14516), item2 = Inventory::Contains(peer, 7186), item3 = Inventory::Contains(peer, 5024), item4 = Inventory::Contains(peer, 1796);
						if (item1 < 1 or item2 < 15 or item3 < 100 or item4 < 20) {
							VarList::OnConsoleMessage(peer, "The required items are not sufficient to upgrade!");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "The required items are not sufficient to upgrade!", 0, 1);
							return;
						}
						if (Inventory::Modify(peer, 14518, mdf = 1) == 0) {
							Inventory::Modify(peer, 14516, mdf = -1), Inventory::Modify(peer, 7186, mdf = -15), Inventory::Modify(peer, 5024, mdf = -100), Inventory::Modify(peer, 1796, mdf = -20);
							Clothing::Equip(peer, 14518);
							PlayerMoving data_{};
							data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = 14518, data_.punchY = pInfo(peer)->netID;
							int32_t to_netid = pInfo(peer)->netID;
							BYTE* raw = packPlayerMoving(&data_);
							raw[3] = 5;
							Memory_Copy(raw + 8, &to_netid, 4);
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; cp_++) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL) return;
								if (pInfo(cp_)->world == "MINING") {
									send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "successfully upgraded the pickaxe!", 0, 1);
						}
						else {
							VarList::OnConsoleMessage(peer, "That wouldnt fit into my inventory!");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, 1);
							return;
						}
					}
					if (btn == "3") {
						int mdf = 0, item1 = Inventory::Contains(peer, 14518), item2 = Inventory::Contains(peer, 5072), item3 = Inventory::Contains(peer, 5024), item4 = Inventory::Contains(peer, 1796);
						if (item1 < 1 or item2 < 20 or item3 < 100 or item4 < 30) {
							VarList::OnConsoleMessage(peer, "The required items are not sufficient to upgrade!");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "The required items are not sufficient to upgrade!", 0, 1);
							return;
						}
						if (Inventory::Modify(peer, 14520, mdf = 1) == 0) {
							Inventory::Modify(peer, 14518, mdf = -1), Inventory::Modify(peer, 5072, mdf = -20), Inventory::Modify(peer, 5024, mdf = -100), Inventory::Modify(peer, 1796, mdf = -30);
							Clothing::Equip(peer, 14520);
							PlayerMoving data_{};
							data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = 14520, data_.punchY = pInfo(peer)->netID;
							int32_t to_netid = pInfo(peer)->netID;
							BYTE* raw = packPlayerMoving(&data_);
							raw[3] = 5;
							Memory_Copy(raw + 8, &to_netid, 4);
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; cp_++) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL) return;
								if (pInfo(cp_)->world == "MINING") {
									send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "successfully upgraded the pickaxe!", 0, 1);
						}
						else {
							VarList::OnConsoleMessage(peer, "That wouldnt fit into my inventory!");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, 1);
							return;
						}
					}
					if (btn == "4") {
						int mdf = 0, item1 = Inventory::Contains(peer, 14520), item2 = Inventory::Contains(peer, 5074), item3 = Inventory::Contains(peer, 5024), item4 = Inventory::Contains(peer, 1796);
						if (item1 < 1 or item2 < 25 or item3 < 100 or item4 < 40) {
							VarList::OnConsoleMessage(peer, "The required items are not sufficient to upgrade!");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "The required items are not sufficient to upgrade!", 0, 1);
							return;
						}
						if (Inventory::Modify(peer, 14522, mdf = 1) == 0) {
							Inventory::Modify(peer, 14520, mdf = -1), Inventory::Modify(peer, 5074, mdf = -25), Inventory::Modify(peer, 5024, mdf = -100), Inventory::Modify(peer, 1796, mdf = -40);
							Clothing::Equip(peer, 14522);
							PlayerMoving data_{};
							data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = 14522, data_.punchY = pInfo(peer)->netID;
							int32_t to_netid = pInfo(peer)->netID;
							BYTE* raw = packPlayerMoving(&data_);
							raw[3] = 5;
							Memory_Copy(raw + 8, &to_netid, 4);
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; cp_++) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL) return;
								if (pInfo(cp_)->world == "MINING") {
									send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "successfully upgraded the pickaxe!", 0, 1);
						}
						else {
							VarList::OnConsoleMessage(peer, "That wouldnt fit into my inventory!");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, 1);
							return;
						}
					}
					if (btn == "6") {
						int mdf = 0, item1 = Inventory::Contains(peer, 14522), item2 = Inventory::Contains(peer, 5076), item3 = Inventory::Contains(peer, 5024), item4 = Inventory::Contains(peer, 1796);
						if (item1 < 1 or item2 < 30 or item3 < 100 or item4 < 50) {
							VarList::OnConsoleMessage(peer, "The required items are not sufficient to upgrade!");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "The required items are not sufficient to upgrade!", 0, 1);
							return;
						}
						if (Inventory::Modify(peer, 14524, mdf = 1) == 0) {
							Inventory::Modify(peer, 14522, mdf = -1), Inventory::Modify(peer, 5076, mdf = -30), Inventory::Modify(peer, 5024, mdf = -100), Inventory::Modify(peer, 1796, mdf = -50);
							Clothing::Equip(peer, 14524);
							PlayerMoving data_{};
							data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = 14524, data_.punchY = pInfo(peer)->netID;
							int32_t to_netid = pInfo(peer)->netID;
							BYTE* raw = packPlayerMoving(&data_);
							raw[3] = 5;
							Memory_Copy(raw + 8, &to_netid, 4);
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; cp_++) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL) return;
								if (pInfo(cp_)->world == "MINING") {
									send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "successfully upgraded the pickaxe!", 0, 1);
						}
						else {
							VarList::OnConsoleMessage(peer, "That wouldnt fit into my inventory!");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, 1);
							return;
						}
					}
				}
				if (button.substr(0, 4) == "buy_") {
					string btn = button.substr(4);
					if (btn == "torch") {
						string wk = ""; int item_id = 3578;
						if (pInfo(peer)->gems < 2500) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(pInfo(peer)->gems) + " Gems.|left|\nadd_button|BackToDialog|`oSee other items|0|0|";
						else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[item_id].name + " do you want to buy, for 2,500 Gems each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(pInfo(peer)->gems) + " Gems.|left|\nadd_button|yes_purchase_torch|`9Purchase|0|0|\nadd_button|BackToDialog|No Thanks|0|0|";
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[item_id].name + "?|left|" + to_string(item_id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[item_id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|Miner_Forging|||");
					}
					if (btn == "cavetorch") {
						string wk = ""; int item_id = 11602;
						if (pInfo(peer)->mines_coin < 2) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(pInfo(peer)->mines_coin) + " Mines Coin.|left|\nadd_button|BackToDialog|`oSee other items|0|0|";
						else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[item_id].name + " do you want to buy, for 2 Mines Coin each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(pInfo(peer)->mines_coin) + " Mines Coin.|left|\nadd_button|yes_purchase_cavetorch|`9Purchase|0|0|\nadd_button|BackToDialog|No Thanks|0|0|";
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[item_id].name + "?|left|" + to_string(item_id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[item_id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|Miner_Forging|||");
					}
					if (btn == "antigravity") {
						string wk = ""; int item_id = 4992;
						if (pInfo(peer)->mines_coin < 250) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(pInfo(peer)->mines_coin) + " Mines Coin.|left|\nadd_button|BackToDialog|`oSee other items|0|0|";
						else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[item_id].name + " do you want to buy, for 250 Mines Coin each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(pInfo(peer)->mines_coin) + " Mines Coin.|left|\nadd_button|yes_purchase_antigravity|`9Purchase|0|0|\nadd_button|BackToDialog|No Thanks|0|0|";
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[item_id].name + "?|left|" + to_string(item_id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[item_id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|Miner_Forging|||");
					}
					if (btn == "nightvision") {
						string wk = ""; int item_id = 3576;
						if (pInfo(peer)->mines_coin < 1000) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(pInfo(peer)->mines_coin) + " Mines Coin.|left|\nadd_button|BackToDialog|`oSee other items|0|0|";
						else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[item_id].name + " do you want to buy, for 1,000 Mines Coin each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(pInfo(peer)->mines_coin) + " Mines Coin.|left|\nadd_button|yes_purchase_nightvision|`9Purchase|0|0|\nadd_button|BackToDialog|No Thanks|0|0|";
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[item_id].name + "?|left|" + to_string(item_id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[item_id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|Miner_Forging|||");
					}
					if (btn == "dbattery") {
						string wk = ""; int item_id = 3306;
						if (pInfo(peer)->mines_coin < 10) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(pInfo(peer)->mines_coin) + " Mines Coin.|left|\nadd_button|BackToDialog|`oSee other items|0|0|";
						else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[item_id].name + " do you want to buy, for 10 Mines Coin each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(pInfo(peer)->mines_coin) + " Mines Coin.|left|\nadd_button|yes_purchase_dbattery|`9Purchase|0|0|\nadd_button|BackToDialog|No Thanks|0|0|";
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[item_id].name + "?|left|" + to_string(item_id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[item_id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|Miner_Forging|||");
					}
					if (btn == "elefire") {
						string wk = ""; int item_id = 5024;
						if (pInfo(peer)->mines_coin < 1) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(pInfo(peer)->mines_coin) + " Mines Coin.|left|\nadd_button|BackToDialog|`oSee other items|0|0|";
						else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[item_id].name + " do you want to buy, for 1 Mines Coin each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(pInfo(peer)->mines_coin) + " Mines Coin.|left|\nadd_button|yes_purchase_elefire|`9Purchase|0|0|\nadd_button|BackToDialog|No Thanks|0|0|";
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[item_id].name + "?|left|" + to_string(item_id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[item_id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|Miner_Forging|||");
					}
					if (btn == "reality") {
						string wk = ""; int item_id = 5070;
						if (pInfo(peer)->gems < 10000) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(pInfo(peer)->gems) + " Gems.|left|\nadd_button|BackToDialog|`oSee other items|0|0|";
						else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[item_id].name + " do you want to buy, for 2,500 Gems each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(pInfo(peer)->gems) + " Gems.|left|\nadd_button|yes_purchase_reality|`9Purchase|0|0|\nadd_button|BackToDialog|No Thanks|0|0|";
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[item_id].name + "?|left|" + to_string(item_id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[item_id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|Miner_Forging|||");
					}
					if (btn == "wealth") {
						string wk = ""; int item_id = 5072;
						if (pInfo(peer)->mines_coin < 100) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(pInfo(peer)->mines_coin) + " Mines Coin.|left|\nadd_button|BackToDialog|`oSee other items|0|0|";
						else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[item_id].name + " do you want to buy, for 1 Mines Coin each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(pInfo(peer)->mines_coin) + " Mines Coin.|left|\nadd_button|yes_purchase_wealth|`9Purchase|0|0|\nadd_button|BackToDialog|No Thanks|0|0|";
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[item_id].name + "?|left|" + to_string(item_id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[item_id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|Miner_Forging|||");
					}
					if (btn == "brilliance") {
						string wk = ""; int item_id = 5074;
						if (pInfo(peer)->mines_coin < 100) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(pInfo(peer)->mines_coin) + " Mines Coin.|left|\nadd_button|BackToDialog|`oSee other items|0|0|";
						else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[item_id].name + " do you want to buy, for 1 Mines Coin each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(pInfo(peer)->mines_coin) + " Mines Coin.|left|\nadd_button|yes_purchase_brilliance|`9Purchase|0|0|\nadd_button|BackToDialog|No Thanks|0|0|";
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[item_id].name + "?|left|" + to_string(item_id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[item_id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|Miner_Forging|||");
					}
					if (btn == "nature") {
						string wk = ""; int item_id = 5076;
						if (pInfo(peer)->mines_coin < 100) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(pInfo(peer)->mines_coin) + " Mines Coin.|left|\nadd_button|BackToDialog|`oSee other items|0|0|";
						else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[item_id].name + " do you want to buy, for 1 Mines Coin each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(pInfo(peer)->mines_coin) + " Mines Coin.|left|\nadd_button|yes_purchase_nature|`9Purchase|0|0|\nadd_button|BackToDialog|No Thanks|0|0|";
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[item_id].name + "?|left|" + to_string(item_id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[item_id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|Miner_Forging|||");
					}
					if (btn == "time") {
						string wk = ""; int item_id = 7186;
						if (pInfo(peer)->mines_coin < 100) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(pInfo(peer)->mines_coin) + " Mines Coin.|left|\nadd_button|BackToDialog|`oSee other items|0|0|";
						else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[item_id].name + " do you want to buy, for 1 Mines Coin each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(pInfo(peer)->mines_coin) + " Mines Coin.|left|\nadd_button|yes_purchase_time|`9Purchase|0|0|\nadd_button|BackToDialog|No Thanks|0|0|";
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[item_id].name + "?|left|" + to_string(item_id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[item_id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|Miner_Forging|||");
					}
				}
				if (button.substr(0, 13) == "yes_purchase_") {
					string btn = button.substr(13);
					if (btn == "torch" or btn == "cavetorch" or btn == "antigravity" or btn == "nightvision" or btn == "dbattery" or btn == "elefire" or btn == "reality" or btn == "wealth" or btn == "brilliance" or btn == "nature" or btn == "time") {
						string amount = parser.get("buy_amount", 1);
						int buyprice = std::atoi(amount.c_str()), id = 0, price = 0;
						if (buyprice <= 0 || buyprice > 200) return;
						if (btn == "torch") id = 3578, price = 2500;
						if (btn == "cavetorch") id = 11602, price = 2;
						if (btn == "antigravity") id = 4992, price = 250;
						if (btn == "nightvision") id = 3576, price = 1000;
						if (btn == "dbattery") id = 3306, price = 10;
						if (btn == "elefire") id = 5024, price = 1;
						if (btn == "reality") id = 5070, price = 10000;
						if (btn == "wealth") id = 5072, price = 100;
						if (btn == "brilliance") id = 5074, price = 100;
						if (btn == "nature") id = 5076, price = 100;
						if (btn == "time") id = 7186, price = 100;
						if (id == 0 or price == 0) return;
						auto kiekmoketi = buyprice * price;
						if (kiekmoketi > (btn == "torch" or btn == "reality" ? pInfo(peer)->gems : pInfo(peer)->mines_coin)) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You can't afford that many!", 0, true);
							return;
						}
						else {
							if (Inventory::Check_Max(peer, id, buyprice)) {
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, true);
								return;
							}
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, id, buyprice) == 0) {
								if (btn == "torch" or btn == "reality") VarList::OnMinGems(peer, kiekmoketi);
								else pInfo(peer)->mines_coin = pInfo(peer)->mines_coin - kiekmoketi;
								PlayerMoving data_{}; PlayerMoving data{};
								data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = id, data_.punchY = pInfo(peer)->netID;
								int32_t to_netid = pInfo(peer)->netID;
								BYTE* raw = packPlayerMoving(&data_);
								raw[3] = 5;
								Memory_Copy(raw + 8, &to_netid, 4);
								data.packetType = 19, data.netID = -1, data.plantingTree = 0;
								data.x = pInfo(peer)->lastwrenchx * 32 + 16, data.y = pInfo(peer)->lastwrenchy * 32 + 16;
								data.XSpeed = pInfo(peer)->x + 16, data.YSpeed = pInfo(peer)->y + 16;
								data.punchX = (btn == "torch" or btn == "reality" ? 112 : 20192);
								BYTE* raw_ = packPlayerMoving(&data);
								raw_[3] = 6;
								for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; cp_++) {
									if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL) return;
									if (pInfo(cp_)->world == "MINING") {
										send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										send_raw(cp_, 4, raw_, 56, ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[] raw, raw_;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You have bought " + to_string(buyprice) + " " + items[id].name + " for " + to_string(kiekmoketi) + (btn == "torch" or btn == "reality" ? " Gems" : " Mines Coin"), 0, 1);
							}
						}
					}
				}
			}
		}
	}
	static void change_name_pet(ENetPeer* peer, std::string cch) {
		if (not pInfo(peer)->LiyueHtouFly and not pInfo(peer)->AbyssMageFly or not pInfo(peer)->show_pets) return;
		if (Playmods::HasById(pInfo(peer), 157)) {
			VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That's sort of hard to do while having a cooldown.", 2, 0);
			return;
		}
		if (pInfo(peer)->gems >= 30000) {
			TextScanner parser(cch);
			string name = parser.get("name_pet", 1);
			if (name.find_first_not_of(" :_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890") != std::string::npos) {
				VarList::OnTalkBubble(peer, pInfo(peer)->pet_netID, "invalid input!", 2, 0);
				return;
			}
			if (name.size() > 15) {
				VarList::OnTalkBubble(peer, pInfo(peer)->pet_netID, "Pet's name is too long!", 2, 0);
				return;
			}
			if (name.size() < 5) {
				VarList::OnTalkBubble(peer, pInfo(peer)->pet_netID, "Pet's name is too short!", 2, 0);
				return;
			}
			pInfo(peer)->pet_name = name;
			Playmods::Add(peer, 158);
			VarList::OnMinGems(peer, 30000);
			VarList::OnTalkBubble(peer, pInfo(peer)->pet_netID, "Succesfully changed my Name.", 2, 0);
			Pet_Ai::Update(peer, pInfo(peer)->pet_netID, pInfo(peer)->pet_level, pInfo(peer)->master_pet, pInfo(peer)->active_bluename);
		}
		else {
			VarList::OnTalkBubble(peer, pInfo(peer)->pet_netID, "Sorry, you don't have enough gems!", 2, 0);
			return;
		}
	}
	static void Give_Feed_Pet(ENetPeer* peer, std::string cch) {
		if (not pInfo(peer)->LiyueHtouFly and not pInfo(peer)->AbyssMageFly or not pInfo(peer)->show_pets) return;
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "pet_food") Pet_Ai::Dialog(peer, "pet_food");
			if (button == "Give_Feed") {
				string amount = parser.get("amount_food", 1);
				int id = std::atoi(get_embed(cch, "foodid").c_str()), give = Pet_Food[id], have = Inventory::Contains(peer, id);
				if (id < 0 or id > items.size()) return;
				if (amount.size() < 1 or amount.size() > 3 or std::atoi(amount.c_str()) < 1 or std::atoi(amount.c_str()) > 200 or amount.find_first_not_of("0123456789") != std::string::npos) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid input!", 0, true);
					return;
				}
				if (std::atoi(amount.c_str()) > have) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You only have " + to_string(have) + " " + items[id].name + "!", 0, true);
					return;
				}
				if (pInfo(peer)->Pets_hunger == 150) {
					VarList::OnTalkBubble(peer, pInfo(peer)->pet_netID, "I am full..", 2, true);
					return;
				}
				int rem = std::atoi(amount.c_str()) * -1;
				if (pInfo(peer)->Pets_hunger + give * std::atoi(amount.c_str()) > 150) {
					pInfo(peer)->Pets_hunger = 150;
					VarList::OnTalkBubble(peer, pInfo(peer)->pet_netID, "`#YUM!", 2, true);
				}
				else {
					pInfo(peer)->Pets_hunger = pInfo(peer)->Pets_hunger + give * std::atoi(amount.c_str());
					if (pInfo(peer)->Pets_hunger >= 150) pInfo(peer)->Pets_hunger = 150;
					VarList::OnTalkBubble(peer, pInfo(peer)->pet_netID, "`#YUM!", 2, true);
				}
				if (pInfo(peer)->Pets_hunger >= 30) {
					if (pInfo(peer)->Pets_Not2) pInfo(peer)->Pets_Not2 = false;
				}
				Inventory::Modify(peer, id, rem);
			}
		}
	}
	static void My_PetAi(ENetPeer* peer, std::string cch) {
		if (not pInfo(peer)->LiyueHtouFly and not pInfo(peer)->AbyssMageFly) return;
		TextScanner parser(cch);
		std::string button = ""; int foodid;
		if (parser.try_get("foodid", foodid)) {
			if (foodid < 0 or foodid > items.size()) return;
			if (Pet_Ai::Food(foodid)) {
				int have = Inventory::Contains(peer, foodid);
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Feed your Pet's|left|" + to_string(pInfo(peer)->pet_ID) + "|\nembed_data|foodid|" + to_string(foodid) + "|\nadd_spacer|small|\nadd_label_with_icon|small|`o" + items[foodid].name + "|left|" + to_string(foodid) + "|\nadd_textbox|`oGive " + to_string(Pet_Food[foodid]) + "%|left|\nadd_smalltext|`oITEM DATA: " + items[foodid].description + "|left|\nadd_spacer|small|\nadd_textbox|`oPet Health: " + to_string(pInfo(peer)->Pets_health) + "%|left|\nadd_textbox|`oPet Hunger: " + to_string(pInfo(peer)->Pets_hunger) + "%|left|\nadd_spacer|small|\nadd_smalltext|`2You have " + to_string(have) + " " + items[foodid].name + ".|left|\nadd_text_input|amount_food|`oHow Many?||5|\nadd_button|pet_food|Nevermind|noflags|\nadd_custom_margin|x:15;y:0|\nadd_custom_button|Give_Feed|textLabel:`2Give Feed;anchor:_button_pet_food;left:1;margin:40,0;|\nend_dialog|Give_Feed_Pet|||");
			}
			else {
				VarList::OnTalkBubble(peer, pInfo(peer)->pet_netID, "Hmm, this item does not give any health..", 2, true);
				return;
			}
			return;
		}
		else if (parser.try_get("buttonClicked", button)) {
			if (button == "pet_info") Pet_Ai::Dialog(peer, "pet_info");
			if (button == "pet_settings") Pet_Ai::Dialog(peer, "pet_settings");
			if (button == "pet_upgrade") Pet_Ai::Dialog(peer, "pet_upgrade");
			if (button == "pet_food") Pet_Ai::Dialog(peer, "pet_food");
			if (button == "pet_ability") Pet_Ai::Dialog(peer, "pet_ability");
			if (button == "mypet_name") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Change Your Pet's Name|left|" + to_string(pInfo(peer)->pet_ID) + "|\nadd_text_input|name_pet|`oName|" + pInfo(peer)->pet_name + "|30|\nend_dialog|change_name_pet|Cancel|Update|");
			if (button == "change_pet") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label|big|`$Pet Ai You Have|left|\nadd_spacer|small|\nadd_textbox|`$Choose your Pet's:|left|\nadd_custom_margin|x:10;y:0|\ntext_scaling_string|Subscribtions++++++++|" + a + (pInfo(peer)->LiyueHtouFly ? "\nadd_button_with_icon|hutao_pet|Liyue H-Tou Fly|staticYellowFrame|9502||" : "") + (pInfo(peer)->AbyssMageFly ? "\nadd_button_with_icon|abyssmage_pet|Abyss Mage Fly|staticYellowFrame|9504||" : "") + "\nreset_placement_x|\nadd_button_with_icon||END_LIST|noflags|0||\nend_dialog|My_PetAi|Close||");
			if (button == "unequip_pet") {
				if (pInfo(peer)->show_pets) {
					pInfo(peer)->pet_ID = 0;
					pInfo(peer)->show_pets = false;
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (pInfo(peer)->world == pInfo(cp_)->world) {
							VarList::OnRemove(cp_, pInfo(peer)->pet_netID, 0);
						}
					}
				}
			}
			if (button == "Enable_Sentences") {
				if (pInfo(peer)->RandomSentences) {
					pInfo(peer)->RandomSentences = false;
					VarList::OnTalkBubble(peer, pInfo(peer)->pet_netID, "As long as im your beautiful pet i will still learn what you write, but i wont use it!", 2, 0);
				}
				else {
					pInfo(peer)->RandomSentences = true;
					VarList::OnTalkBubble(peer, pInfo(peer)->pet_netID, "I will now learn what you write", 2, 0);
				}
			}
			if (button == "Turn_Alive_Pets") {
				if (pInfo(peer)->gems < 150000) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough gems to turn alive your pet!", 0, 0);
					return;
				}
				string name = "";
				int id = std::atoi(get_embed(cch, "petid").c_str());
				if (id == 20088) name = "`b@Uuuzz_Fly";
				if (id == 9502) name = "`4@Liyue_HTouFly";
				if (id == 9504) name = "`e@AbyssMage_Fly";
				pInfo(peer)->pet_ID = id;
				pInfo(peer)->show_pets = true;
				pInfo(peer)->Pets_hunger = 150;
				pInfo(peer)->Pets_health = 100;
				pInfo(peer)->Pets_Dead = false;
				pInfo(peer)->pet_name = (pInfo(peer)->pet_name != "`b@Uuuzz_Fly" and pInfo(peer)->pet_name != "`b@Galaxy_Fly" and pInfo(peer)->pet_name != "`4@Liyue_HTouFly" ? pInfo(peer)->pet_name : name);
				for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
					if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
					if (pInfo(peer)->world == pInfo(cp_)->world) {
						VarList::OnSpawn(cp_, "spawn|avatar\nnetID|" + to_string(pInfo(peer)->pet_netID) + "\nuserID|0\ncolrect|0|0|20|30\nposXY|" + to_string((pInfo(peer))->x) + "|" + to_string((pInfo(peer))->y) + "\nname|`w" + pInfo(peer)->pet_name + " `4(" + (pInfo(peer)->pet_level == 50 ? "MAX" : to_string(pInfo(peer)->pet_level)) + ")``\ntitleIcon|{\"PlayerWorldID\":" + to_string(pInfo(peer)->pet_netID) + ",\"WrenchCustomization\":{\"WrenchForegroundID\":-1,\"WrenchIconID\":14360}}\ncountry|ccBadge\ninvis|0\nmstate|1\nsmstate|1\nonlineID|");
						Pet_Ai::Update(cp_, pInfo(peer)->pet_netID, pInfo(peer)->pet_level, pInfo(peer)->master_pet, pInfo(peer)->active_bluename);
						pInfo(peer)->pet_ClothesUpdated = false;
					}
				}
				Pet_Ai::Update_Ability(peer);
				VarList::OnMinGems(peer, 150000);
			}
			if (button == "uuuzz_pet") {
				if (pInfo(peer)->UuuzzFly) {
					if (pInfo(peer)->Pets_Dead) {
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label|big|`$Your Pet dies!|left|\nembed_data|petid|20088|\nadd_spacer|small|\nadd_label_with_icon|small|`o" + pInfo(peer)->pet_name + "|left|20088|\nadd_textbox|`oYou have to pay compensation to bring your pet back to life.|left|\nadd_textbox|`oCost: `4150,000 Gems|left|\nadd_spacer|small|\nadd_button|cancel|Nevermind|noflags|\nadd_custom_button|Turn_Alive_Pets|textLabel:`2Turn Alive;anchor:_button_cancel;left:1;margin:40,0;|\nend_dialog|My_PetAi|||");
						return;
					}
					if (pInfo(peer)->show_pets) {
						pInfo(peer)->pet_ID = 0;
						pInfo(peer)->show_pets = false;
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
							if (pInfo(peer)->world == pInfo(cp_)->world) {
								VarList::OnRemove(cp_, pInfo(peer)->pet_netID, 0);
							}
						}
					}
					pInfo(peer)->pet_ID = 20088;
					pInfo(peer)->show_pets = true;
					pInfo(peer)->pet_name = (pInfo(peer)->pet_name != "`b@Uuuzz_Fly" and pInfo(peer)->pet_name != "`b@Galaxy_Fly" and pInfo(peer)->pet_name != "`4@Liyue_HTouFly" ? pInfo(peer)->pet_name : "`b@Uuuzz_Fly");
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (pInfo(peer)->world == pInfo(cp_)->world) {
							VarList::OnSpawn(cp_, "spawn|avatar\nnetID|" + to_string(pInfo(peer)->pet_netID) + "\nuserID|0\ncolrect|0|0|20|30\nposXY|" + to_string((pInfo(peer))->x) + "|" + to_string((pInfo(peer))->y) + "\nname|`w" + pInfo(peer)->pet_name + " `4(" + (pInfo(peer)->pet_level == 50 ? "MAX" : to_string(pInfo(peer)->pet_level)) + ")``\ntitleIcon|{\"PlayerWorldID\":" + to_string(pInfo(peer)->pet_netID) + ",\"WrenchCustomization\":{\"WrenchForegroundID\":-1,\"WrenchIconID\":14360}}\ncountry|ccBadge\ninvis|0\nmstate|1\nsmstate|1\nonlineID|");
							Pet_Ai::Update(cp_, pInfo(peer)->pet_netID, pInfo(peer)->pet_level, pInfo(peer)->master_pet, pInfo(peer)->active_bluename);
							pInfo(peer)->pet_ClothesUpdated = false;
						}
					}
					Pet_Ai::Update_Ability(peer);
				}
				return;
			}
			if (button == "hutao_pet") {
				if (pInfo(peer)->LiyueHtouFly) {
					if (pInfo(peer)->Pets_Dead) {
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label|big|`$Your Pet dies!|left|\nembed_data|petid|9502|\nadd_spacer|small|\nadd_label_with_icon|small|`o" + pInfo(peer)->pet_name + "|left|9502|\nadd_textbox|`oYou have to pay compensation to bring your pet back to life.|left|\nadd_textbox|`oCost: `4150,000 Gems|left|\nadd_spacer|small|\nadd_button|cancel|Nevermind|noflags|\nadd_custom_button|Turn_Alive_Pets|textLabel:`2Turn Alive;anchor:_button_cancel;left:1;margin:40,0;|\nend_dialog|My_PetAi|||");
						return;
					}
					if (pInfo(peer)->show_pets) {
						pInfo(peer)->pet_ID = 0;
						pInfo(peer)->show_pets = false;
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
							if (pInfo(peer)->world == pInfo(cp_)->world) {
								VarList::OnRemove(cp_, pInfo(peer)->pet_netID, 0);
							}
						}
					}
					pInfo(peer)->pet_ID = 9502;
					pInfo(peer)->show_pets = true;
					pInfo(peer)->pet_name = (pInfo(peer)->pet_name != "`b@Uuuzz_Fly" and pInfo(peer)->pet_name != "`b@Galaxy_Fly" and pInfo(peer)->pet_name != "`4@Liyue_HTouFly" ? pInfo(peer)->pet_name : "`4@Liyue_HTouFly");
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (pInfo(peer)->world == pInfo(cp_)->world) {
							VarList::OnSpawn(cp_, "spawn|avatar\nnetID|" + to_string(pInfo(peer)->pet_netID) + "\nuserID|0\ncolrect|0|0|20|30\nposXY|" + to_string((pInfo(peer))->x) + "|" + to_string((pInfo(peer))->y) + "\nname|`w" + pInfo(peer)->pet_name + " `4(" + (pInfo(peer)->pet_level == 50 ? "MAX" : to_string(pInfo(peer)->pet_level)) + ")``\ntitleIcon|{\"PlayerWorldID\":" + to_string(pInfo(peer)->pet_netID) + ",\"WrenchCustomization\":{\"WrenchForegroundID\":-1,\"WrenchIconID\":14360}}\ncountry|ccBadge\ninvis|0\nmstate|1\nsmstate|1\nonlineID|");
							Pet_Ai::Update(cp_, pInfo(peer)->pet_netID, pInfo(peer)->pet_level, pInfo(peer)->master_pet, pInfo(peer)->active_bluename);
							pInfo(peer)->pet_ClothesUpdated = false;
						}
					}
					Pet_Ai::Update_Ability(peer);
				}
				return;
			}
			if (button == "abyssmage_pet") {
				if (pInfo(peer)->AbyssMageFly) {
					if (pInfo(peer)->Pets_Dead) {
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label|big|`$Your Pet dies!|left|\nembed_data|petid|9504|\nadd_spacer|small|\nadd_label_with_icon|small|`o" + pInfo(peer)->pet_name + "|left|9504|\nadd_textbox|`oYou have to pay compensation to bring your pet back to life.|left|\nadd_textbox|`oCost: `4150,000 Gems|left|\nadd_spacer|small|\nadd_button|cancel|Nevermind|noflags|\nadd_custom_button|Turn_Alive_Pets|textLabel:`2Turn Alive;anchor:_button_cancel;left:1;margin:40,0;|\nend_dialog|My_PetAi|||");
						return;
					}
					if (pInfo(peer)->show_pets) {
						pInfo(peer)->pet_ID = 0;
						pInfo(peer)->show_pets = false;
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
							if (pInfo(peer)->world == pInfo(cp_)->world) {
								VarList::OnRemove(cp_, pInfo(peer)->pet_netID, 0);
							}
						}
					}
					pInfo(peer)->pet_ID = 9504;
					pInfo(peer)->show_pets = true;
					pInfo(peer)->pet_name = (pInfo(peer)->pet_name != "`b@Uuuzz_Fly" and pInfo(peer)->pet_name != "`e@AbyssMage_Fly" and pInfo(peer)->pet_name != "`4@Liyue_HTouFly" ? pInfo(peer)->pet_name : "`4@Liyue_HTouFly");
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (pInfo(peer)->world == pInfo(cp_)->world) {
							VarList::OnSpawn(cp_, "spawn|avatar\nnetID|" + to_string(pInfo(peer)->pet_netID) + "\nuserID|0\ncolrect|0|0|20|30\nposXY|" + to_string((pInfo(peer))->x) + "|" + to_string((pInfo(peer))->y) + "\nname|`w" + pInfo(peer)->pet_name + " `4(" + (pInfo(peer)->pet_level == 50 ? "MAX" : to_string(pInfo(peer)->pet_level)) + ")``\ntitleIcon|{\"PlayerWorldID\":" + to_string(pInfo(peer)->pet_netID) + ",\"WrenchCustomization\":{\"WrenchForegroundID\":-1,\"WrenchIconID\":14360}}\ncountry|ccBadge\ninvis|0\nmstate|1\nsmstate|1\nonlineID|");
							Pet_Ai::Update(cp_, pInfo(peer)->pet_netID, pInfo(peer)->pet_level, pInfo(peer)->master_pet, pInfo(peer)->active_bluename);
							pInfo(peer)->pet_ClothesUpdated = false;
						}
					}
					Pet_Ai::Update_Ability(peer);
				}
				return;
			}
			if (button == "Pet_Upg_Builder") {
				if (pInfo(peer)->Pets_Builder_Lvl == 5) return;
				int cost = 0, x_l = 0;
				if (pInfo(peer)->pet_level >= 10) {
					if (pInfo(peer)->Pets_Builder_Lvl == 0) cost = 1500000, x_l = 1;
					if (pInfo(peer)->Pets_Builder_Lvl == 1) cost = 2000000, x_l = 2;
					if (pInfo(peer)->Pets_Builder_Lvl == 2) cost = 2500000, x_l = 3;
					if (pInfo(peer)->Pets_Builder_Lvl == 3) cost = 3000000, x_l = 4;
					if (pInfo(peer)->Pets_Builder_Lvl == 4) cost = 4500000, x_l = 5;
					if (pInfo(peer)->gems < cost) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough gems to upgrade!", 0, 0);
						return;
					}
					pInfo(peer)->Pets_Builder_Lvl = x_l;
					VarList::OnMinGems(peer, cost);
					Pet_Ai::Dialog(peer, "pet_upgrade");
					VarList::OnTalkBubble(peer, pInfo(peer)->pet_netID, "You have succesfully upgrade!", 2, true);
				}
				else VarList::OnTalkBubble(peer, pInfo(peer)->pet_netID, "Hmm, My level must be at least level 10 to upgrade.", 2, true);
				return;
			}
			if (button == "Pet_Upg_Farmer") {
				if (pInfo(peer)->Pets_Farmer_Lvl == 5) return;
				int cost = 0, x_l = 0;
				if (pInfo(peer)->pet_level >= 20) {
					if (pInfo(peer)->Pets_Farmer_Lvl == 0) cost = 2000000, x_l = 1;
					if (pInfo(peer)->Pets_Farmer_Lvl == 1) cost = 2500000, x_l = 2;
					if (pInfo(peer)->Pets_Farmer_Lvl == 2) cost = 3000000, x_l = 3;
					if (pInfo(peer)->Pets_Farmer_Lvl == 3) cost = 3500000, x_l = 4;
					if (pInfo(peer)->Pets_Farmer_Lvl == 4) cost = 5000000, x_l = 5;
					if (pInfo(peer)->gems < cost) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough gems to upgrade!", 0, 0);
						return;
					}
					pInfo(peer)->Pets_Farmer_Lvl = x_l;
					VarList::OnMinGems(peer, cost);
					Pet_Ai::Dialog(peer, "pet_upgrade");
					VarList::OnTalkBubble(peer, pInfo(peer)->pet_netID, "You have succesfully upgrade!", 2, true);
				}
				else VarList::OnTalkBubble(peer, pInfo(peer)->pet_netID, "Hmm, My level must be at least level 20 to upgrade.", 2, true);
				return;
			}
			return;
		}
		else {
			string active_bluename = parser.get("active_bluename", 1), master_pet = parser.get("master_pet", 1);
			if (!isValidCheckboxInput(active_bluename) or !isValidCheckboxInput(master_pet)) return;
			if (master_pet == "1") pInfo(peer)->master_pet = true;
			else pInfo(peer)->master_pet = false;
			if (active_bluename == "1") pInfo(peer)->active_bluename = true;
			else pInfo(peer)->active_bluename = false;
			for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; cp_++) {
				if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL) return;
				if (pInfo(cp_)->world == pInfo(peer)->world) {
					Pet_Ai::Update(cp_, pInfo(peer)->pet_netID, pInfo(peer)->pet_level, pInfo(peer)->master_pet, pInfo(peer)->active_bluename);
				}
			}
		}
	}
	static void Punch_Event(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "Seasonal_Clash") DialogHandle::Event_Leaderboard(peer, "Seasonal_Clash", 500);
			if (button == "Recycle_Lock") DialogHandle::Event_Leaderboard(peer, "Recycle_Lock", 500);
			if (button == "Richest") DialogHandle::Event_Leaderboard(peer, "Richest", 500);
			if (button == "Punched" or button == "backto_punchleaderboard") DialogHandle::Event_Leaderboard(peer, "Punched", 500);
			if (button == "punch_event_leaderboard") {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n\nadd_label_with_icon|big|`0Top Punch Players|left|18|\nadd_spacer|" + top_punch_list + "|\nadd_spacer|\nadd_button|backto_punchleaderboard|`oBack``|0|0|\nend_dialog|Punch_Event|||\n");
			}
			if (button == "punch_event_rewards") {
				string score = ""; string top1 = "", top2 = "", top3 = "", top4 = "", top5 = "";
				int my_point = 0;
				std::vector<std::pair<long long int, string>>::iterator p_ = find_if(top_punch.begin(), top_punch.end(), [&](const pair < long long int, string>& element) { return element.second == pInfo(peer)->tankIDName; });
				if (p_ != top_punch.end()) {
					my_point = top_punch[p_ - top_punch.begin()].first;
				}
				score += "\nadd_textbox|`$Your current Punch: " + Set_Count(my_point) + "|left|";
				if (my_point >= 500 and not pInfo(peer)->top_punch_1) top1 = "\nadd_textbox|`w#1 Earn 500 points to claim this rewards:|left|\nadd_label_with_icon|small|`225 World Locks|left|242|\nadd_label_with_icon|small|`26,800 Gems|left|112|\nadd_small_font_button|claim_toppunch_1|`$Claim Reward|0|0|";
				else if (pInfo(peer)->top_punch_1) top1 = "\nadd_textbox|`^#1 Earn 500 points to claim this rewards:|left|\nadd_label_with_icon|small|`^25 World Locks|left|242|\nadd_label_with_icon|small|`^6,800 Gems|left|112|";
				else top1 = "\nadd_textbox|`s#1 Earn 500 points to claim this rewards:|left|\nadd_label_with_icon|small|`s25 World Locks|left|242|\nadd_label_with_icon|small|`s6,800 Gems|left|112|";

				if (my_point >= 1500 and not pInfo(peer)->top_punch_2) top2 = "\nadd_textbox|`w#2 Earn 1,500 points to claim this rewards:|left|\nadd_label_with_icon|small|`245 World Locks|left|242|\nadd_label_with_icon|small|`218,500 Gems|left|112|\nadd_small_font_button|claim_toppunch_2|`$Claim Reward|0|0|";
				else if (pInfo(peer)->top_punch_2) top2 = "\nadd_textbox|`^#2 Earn 1,500 points to claim this rewards:|left|\nadd_label_with_icon|small|`^45 World Locks|left|242|\nadd_label_with_icon|small|`^18,500 Gems|left|112|";
				else top2 = "\nadd_textbox|`s#2 Earn 1,500 points to claim this rewards:|left|\nadd_label_with_icon|small|`s45 World Locks|left|242|\nadd_label_with_icon|small|`s18,500 Gems|left|112|";

				if (my_point >= 2500 and not pInfo(peer)->top_punch_3) top3 = "\nadd_textbox|`w#3 Earn 2,500 points to claim this rewards:|left|\nadd_label_with_icon|small|`265 World Locks|left|242|\nadd_label_with_icon|small|`224,900 Gems|left|112|\nadd_small_font_button|claim_toppunch_3|`$Claim Reward|0|0|";
				else if (pInfo(peer)->top_punch_3) top3 = "\nadd_textbox|`^#3 Earn 2,500 points to claim this rewards:|left|\nadd_label_with_icon|small|`^65 World Locks|left|242|\nadd_label_with_icon|small|`^24,900 Gems|left|112|";
				else top3 = "\nadd_textbox|`s#3 Earn 2,500 points to claim this rewards:|left|\nadd_label_with_icon|small|`s65 World Locks|left|242|\nadd_label_with_icon|small|`s24,900 Gems|left|112|";

				if (my_point >= 3500 and not pInfo(peer)->top_punch_4) top4 = "\nadd_textbox|`w#4 Earn 3,500 points to claim this rewards:|left|\nadd_label_with_icon|small|`285 World Locks|left|242|\nadd_label_with_icon|small|`236,700 Gems|left|112|\nadd_small_font_button|claim_toppunch_4|`$Claim Reward|0|0|";
				else if (pInfo(peer)->top_punch_4) top4 = "\nadd_textbox|`^#4 Earn 3,500 points to claim this rewards:|left|\nadd_label_with_icon|small|`^85 World Locks|left|242|\nadd_label_with_icon|small|`^36,700 Gems|left|112|";
				else top4 = "\nadd_textbox|`s#4 Earn 3,500 points to claim this rewards:|left|\nadd_label_with_icon|small|`s85 World Locks|left|242|\nadd_label_with_icon|small|`s36,700 Gems|left|112|";

				if (my_point >= 5000 and not pInfo(peer)->top_punch_5) top5 = "\nadd_textbox|`w#5 Earn 5,000 points to claim this rewards:|left|\nadd_label_with_icon|small|`21 Diamond Locks|left|1796|\nadd_label_with_icon|small|`250,000 Gems|left|112|\nadd_small_font_button|claim_toppunch_5|`$Claim Reward|0|0|";
				else if (pInfo(peer)->top_punch_5) top5 = "\nadd_textbox|`^#5 Earn 5,000 points to claim this rewards:|left|\nadd_label_with_icon|small|`^1 Diamond Locks|left|1796|\nadd_label_with_icon|small|`^50,000 Gems|left|112|";
				else top5 = "\nadd_textbox|`s#5 Earn 5,000 points to claim this rewards:|left|\nadd_label_with_icon|small|`s1 Diamond Locks|left|1796|\nadd_label_with_icon|small|`s50,000 Gems|left|112|";

				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Punch Event Rewards|left|18|\nadd_smalltext|`$Earn rewards by participating in Punch events! The point you earn by `2Breaking/Punch any blocks ``will unlock the milestones below.|left|\nadd_spacer|small|\nadd_button|backto_punchleaderboard|`wBack|noflags|0|0|\nadd_spacer|small|" + score + "\nadd_spacer|small|" + top1 + "|\nadd_spacer|small|" + top2 + "|\nadd_spacer|small|" + top3 + "|\nadd_spacer|small|" + top4 + "|\nadd_spacer|small|" + top5 + "|\nadd_spacer|small|\nadd_dialog|backto_punchleaderboard|`wBack|0|0|\nadd_quick_exit|\nadd_spacer|small|\nadd_textbox||left|\nadd_spacer|small|\nend_dialog|Punch_Event|||");
			}
			if (button.substr(0, 15) == "claim_toppunch_") {
				std::string type = button.substr(15);
				int my_point = 0;
				std::vector<std::pair<long long int, string>>::iterator p = find_if(top_punch.begin(), top_punch.end(), [&](const pair < long long int, string>& element) { return element.second == pInfo(peer)->tankIDName; });
				if (p != top_punch.end()) {
					my_point = top_punch[p - top_punch.begin()].first;
				}
				if (type == "1") {
					if (my_point >= 500 and not pInfo(peer)->top_punch_1) {
						VisualHandle::Trade(peer, 242, 500);
						pInfo(peer)->top_punch_1 = true;
						int itemid = 242, got = 25;
						VarList::OnBuxGems(peer, 6800);
						if (Inventory::Modify(peer, itemid, got) == 0) {
						}
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: 500 Points!", 0, 1);
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$25 World Locks|left|242|\nadd_label_with_icon|small|`$6,800 Gems|left|112|\nadd_custom_button|close|textLabel:`wClose;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|punch_event_rewards|textLabel:`wOk;anchor:_button_close;left:1;margin:60,0;|\nend_dialog|Punch_Event|||\nadd_quick_exit|");
					}
				}
				if (type == "2") {
					if (my_point >= 1500 and not pInfo(peer)->top_punch_2) {
						VisualHandle::Trade(peer, 242, 500);
						pInfo(peer)->top_punch_2 = true;
						int itemid = 242, got = 45;
						VarList::OnBuxGems(peer, 18500);
						if (Inventory::Modify(peer, itemid, got) == 0) {
						}
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: 1,500 Points!", 0, 1);
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$45 World Locks|left|242|\nadd_label_with_icon|small|`$18,500 Gems|left|112|\nadd_custom_button|close|textLabel:`wClose;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|punch_event_rewards|textLabel:`wOk;anchor:_button_close;left:1;margin:60,0;|\nend_dialog|Punch_Event|||\nadd_quick_exit|");
					}
				}
				if (type == "3") {
					if (my_point >= 2500 and not pInfo(peer)->top_punch_3) {
						VisualHandle::Trade(peer, 242, 500);
						pInfo(peer)->top_punch_3 = true;
						int itemid = 242, got = 65;
						VarList::OnBuxGems(peer, 24900);
						if (Inventory::Modify(peer, itemid, got) == 0) {
						}
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: 2,500 Points!", 0, 1);
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$65 World Locks|left|242|\nadd_label_with_icon|small|`$24,900 Gems|left|112|\nadd_custom_button|close|textLabel:`wClose;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|punch_event_rewards|textLabel:`wOk;anchor:_button_close;left:1;margin:60,0;|\nend_dialog|Punch_Event|||\nadd_quick_exit|");
					}
				}
				if (type == "4") {
					if (my_point >= 3500 and not pInfo(peer)->top_punch_4) {
						VisualHandle::Trade(peer, 242, 500);
						pInfo(peer)->top_punch_4 = true;
						int itemid = 242, got = 85;
						VarList::OnBuxGems(peer, 36700);
						if (Inventory::Modify(peer, itemid, got) == 0) {
						}
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: 3,500 Points!", 0, 1);
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$85 World Locks|left|242|\nadd_label_with_icon|small|`$36,700 Gems|left|112|\nadd_custom_button|close|textLabel:`wClose;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|punch_event_rewards|textLabel:`wOk;anchor:_button_close;left:1;margin:60,0;|\nend_dialog|Punch_Event|||\nadd_quick_exit|");
					}
				}
				if (type == "5") {
					if (my_point >= 5000 and not pInfo(peer)->top_punch_5) {
						VisualHandle::Trade(peer, 1796, 500);
						pInfo(peer)->top_punch_5 = true;
						int itemid = 1796, got = 1;
						VarList::OnBuxGems(peer, 50000);
						if (Inventory::Modify(peer, itemid, got) == 0) {
						}
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: 5,000 Points!", 0, 1);
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$21 Diamond Locks|left|1796|\nadd_label_with_icon|small|`$50,000 Gems|left|112|\nadd_custom_button|close|textLabel:`wClose;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|punch_event_rewards|textLabel:`wOk;anchor:_button_close;left:1;margin:60,0;|\nend_dialog|Punch_Event|||\nadd_quick_exit|");
					}
				}
			}
		}
	}
	static void Richest_Event(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "Seasonal_Clash") DialogHandle::Event_Leaderboard(peer, "Seasonal_Clash", 500);
			if (button == "Recycle_Lock") DialogHandle::Event_Leaderboard(peer, "Recycle_Lock", 500);
			if (button == "Richest" or button == "backto_richleaderboard") DialogHandle::Event_Leaderboard(peer, "Richest", 500);
			if (button == "Punched") DialogHandle::Event_Leaderboard(peer, "Punched", 500);
			if (button == "rich_leaderboard") {
				EventPool::Load::Rich_Leaderboard();
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n\nadd_label_with_icon|big|`0Top Rich Players|left|9474|\nadd_spacer|" + top_rich_list + "|\nadd_spacer|\nadd_button|backto_richleaderboard|`oBack``|0|0|\nend_dialog|Richest_Event|||\n");
			}
			if (button.substr(0, 9) == "userinfo_") {
				string username = button.substr(9);
				replace_str(username, "\n", "");
				bool foundacc = true;
				pInfo(peer)->last_wrenched = username;
				for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
					if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
					if (to_lower(pInfo(cp_)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						string clothes = "", score = ""; int world_lock = 0, diamond_lock = 0, blue_gem_lock = 0, golden_gem_lock = 0;
						Inventory::Modify(cp_, 242, world_lock), Inventory::Modify(cp_, 1796, diamond_lock), Inventory::Modify(cp_, 7188, blue_gem_lock);
						vector<pair<long long int, string>>::iterator p_ = find_if(top_richest.begin(), top_richest.end(), [&](const pair < long long int, string>& element) { return element.second == pInfo(cp_)->tankIDName; });
						if (p_ != top_richest.end()) {
							if (top_richest[p_ - top_richest.begin()].first >= 1) score += "\nadd_textbox|`oAccount Net. Worth: `$" + Set_Count(top_richest[p_ - top_richest.begin()].first) + " World Locks|left|\n";
						}
						if (pInfo(cp_)->mask != 0) clothes += "\nadd_label_with_icon|small|" + items[pInfo(cp_)->mask].ori_name + "|left|" + to_string(pInfo(cp_)->mask) + "|";
						if (pInfo(cp_)->face != 0) clothes += "\nadd_label_with_icon|small|" + items[pInfo(cp_)->face].ori_name + "|left|" + to_string(pInfo(cp_)->face) + "|";
						if (pInfo(cp_)->hair != 0) clothes += "\nadd_label_with_icon|small|" + items[pInfo(cp_)->hair].ori_name + "|left|" + to_string(pInfo(cp_)->hair) + "|";
						if (pInfo(cp_)->necklace != 0) clothes += "\nadd_label_with_icon|small|" + items[pInfo(cp_)->necklace].ori_name + "|left|" + to_string(pInfo(cp_)->necklace) + "|";
						if (pInfo(cp_)->shirt != 0) clothes += "\nadd_label_with_icon|small|" + items[pInfo(cp_)->shirt].ori_name + "|left|" + to_string(pInfo(cp_)->shirt) + "|";
						if (pInfo(cp_)->back != 0) clothes += "\nadd_label_with_icon|small|" + items[pInfo(cp_)->back].ori_name + "|left|" + to_string(pInfo(cp_)->back) + "|";
						if (pInfo(cp_)->pants != 0) clothes += "\nadd_label_with_icon|small|" + items[pInfo(cp_)->pants].ori_name + "|left|" + to_string(pInfo(cp_)->pants) + "|";
						if (pInfo(cp_)->feet != 0) clothes += "\nadd_label_with_icon|small|" + items[pInfo(cp_)->feet].ori_name + "|left|" + to_string(pInfo(cp_)->feet) + "|";
						if (pInfo(cp_)->hand != 0) clothes += "\nadd_label_with_icon|small|" + items[pInfo(cp_)->hand].ori_name + "|left|" + to_string(pInfo(cp_)->hand) + "|";
						if (pInfo(cp_)->ances != 0) clothes += "\nadd_label_with_icon|small|" + items[pInfo(cp_)->ances].ori_name + "|left|" + to_string(pInfo(cp_)->ances) + "|";
						foundacc = false;
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_progress_bar|`w" + get_player_nick(cp_) + "``|big|Level " + to_string(pInfo(cp_)->level) + "|" + (pInfo(cp_)->level == 1000 ? to_string(50 * ((pInfo(cp_)->level * pInfo(cp_)->level) + 2)) : to_string(pInfo(cp_)->xp)) + "|" + to_string(50 * ((pInfo(cp_)->level * pInfo(cp_)->level) + 2)) + "|" + (pInfo(cp_)->level > 999 ? "(MAX)" : "(" + to_string(pInfo(cp_)->xp) + "/" + to_string(50 * ((pInfo(cp_)->level * pInfo(cp_)->level) + 2)) + ")") + "|-3669761|\nadd_spacer|small|" + score + "\nadd_spacer|small|\nadd_textbox|`oStatus: `2ONLINE``|left|\nadd_spacer|small|\nadd_label_with_icon|small|`oTotal Gems: " + Set_Count(pInfo(cp_)->gems) + "|left|112|\nadd_spacer|small|\nadd_label_with_icon|small|`oTotal World Locks: " + Set_Count(get_wls(peer, true)) + "|left|242|\nadd_label_with_icon|small|`oTotal " + Environment()->server_name + " Gem Locks: " + Set_Count(Inventory::Contains(peer, 8470)) + "|left|8470|\nadd_spacer|small|\nadd_label_with_icon|small|`oTotal World Locks in Bank: " + Set_Count(pInfo(cp_)->wl_bank_amount) + "|left|242|\nadd_label_with_icon|small|`oTotal Diamond Locks in Bank: " + Set_Count(pInfo(cp_)->dl_bank_amount) + "|left|1796|\nadd_label_with_icon|small|`oTotal Platinum Gem Locks in Bank: " + Set_Count(pInfo(cp_)->pgl_bank_amount) + "|left|7188|\nadd_label_with_icon|small|`oTotal " + Environment()->server_name + " Gem Locks in Bank: " + Set_Count(pInfo(cp_)->mgl_bank_amount) + "|left|8470|\nadd_label_with_icon|small|`oTotal Infinity Gem Locks in Bank: " + Set_Count(pInfo(cp_)->igl_bank_amount) + "|left|13200|\nadd_spacer|small|\nadd_small_font_button||`oClothing/Set (press to copy)|0|0|" + clothes + "|\nadd_spacer|small|\nadd_smalltext|`5(Statistics refresh every minute in real-time)|left|\nadd_button|backto_richleaderboard|`oBack``|0|0|\nend_dialog|Richest_Event|||");
					}
				}
				if (foundacc) {
					string clothes = "", score = "", name = "";
					int clothHair = 0, clothMask = 0, clothFace = 0, clothNeck = 0, clothBack = 0, clothShirt = 0, clothPants = 0, clothFeet = 0, clothAnces = 0, clothHand = 0, total_wl = 0, total_dl = 0, total_bgl = 0, total_rgl = 0, my_wls = 0;
					ifstream ifs("database/players/" + username + "_.json");
					if (ifs.is_open()) {
						json j;
						ifs >> j;
						for (size_t i = 0; json & jObject : j["inventory"]) {
							if (jObject[0].get<int>() == 242) {
								total_wl = jObject[1].get<int>();
								my_wls += total_wl;
							}
							if (jObject[0].get<int>() == 1796) {
								total_dl = jObject[1].get<int>();
								my_wls += total_dl * 100;
							}
							if (jObject[0].get<int>() == 7188) {
								total_bgl = jObject[1].get<int>();
								my_wls += total_bgl * 10000;
							}
							if (jObject[0].get<int>() == 8470) {
								total_rgl = jObject[1].get<int>();
							}
						}
						if (j["Role.Owner_Server"] == true) name = "`b@" + j["name"].get<string>();
						else if (j["Role.Developer"] == true) name = "`6@" + j["name"].get<string>();
						else if (j["Role.Administrator"] == true) name = "`e@" + j["name"].get<string>();
						else if (j["Role.Moderator"] == true) name = "`#@" + j["name"].get<string>();
						else if (j["Role.Vip"] == true) name = "`w[`1VIP`w] " + j["name"].get<string>();
						else name = "`0" + j["name"].get<string>();
						clothHair = j["hair"].get<int>(), clothMask = j["mask"].get<int>(), clothFace = j["face"].get<int>(), clothNeck = j["necklace"].get<int>(), clothBack = j["back"].get<int>(), clothPants = j["pants"].get<int>(), clothShirt = j["shirt"].get<int>(), clothFeet = j["feet"].get<int>(), clothAnces = j["ances"].get<int>(), clothHand = j["hand"].get<int>();
						if (clothMask != 0) clothes += "\nadd_label_with_icon|small|" + items[clothMask].ori_name + "|left|" + to_string(clothMask) + "|";
						if (clothHair != 0) clothes += "\nadd_label_with_icon|small|" + items[clothHair].ori_name + "|left|" + to_string(clothHair) + "|";
						if (clothFace != 0) clothes += "\nadd_label_with_icon|small|" + items[clothFace].ori_name + "|left|" + to_string(clothFace) + "|";
						if (clothNeck != 0) clothes += "\nadd_label_with_icon|small|" + items[clothNeck].ori_name + "|left|" + to_string(clothNeck) + "|";
						if (clothBack != 0) clothes += "\nadd_label_with_icon|small|" + items[clothBack].ori_name + "|left|" + to_string(clothBack) + "|";
						if (clothShirt != 0) clothes += "\nadd_label_with_icon|small|" + items[clothShirt].ori_name + "|left|" + to_string(clothShirt) + "|";
						if (clothPants != 0) clothes += "\nadd_label_with_icon|small|" + items[clothPants].ori_name + "|left|" + to_string(clothPants) + "|";
						if (clothFeet != 0) clothes += "\nadd_label_with_icon|small|" + items[clothFeet].ori_name + "|left|" + to_string(clothFeet) + "|";
						if (clothAnces != 0) clothes += "\nadd_label_with_icon|small|" + items[clothAnces].ori_name + "|left|" + to_string(clothAnces) + "|";
						if (clothHand != 0) clothes += "\nadd_label_with_icon|small|" + items[clothHand].ori_name + "|left|" + to_string(clothHand) + "|";
						vector<pair<long long int, string>>::iterator p_ = find_if(top_richest.begin(), top_richest.end(), [&](const pair < long long int, string>& element) { return element.second == j["name"].get<string>(); });
						if (p_ != top_richest.end()) {
							if (top_richest[p_ - top_richest.begin()].first >= 1) score += "\nadd_textbox|`oAccount Net. Worth: `$" + Set_Count(top_richest[p_ - top_richest.begin()].first) + " World Locks|left|\n";
						}
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_progress_bar|`w" + name + "``|big|Level " + to_string(j["level"].get<int>()) + "|" + (j["level"].get<int>() == 1000 ? to_string(50 * ((j["level"].get<int>() * j["level"].get<int>()) + 2)) : to_string(j["xp"].get<int>())) + "|" + to_string(50 * ((j["level"].get<int>() * j["level"].get<int>()) + 2)) + "|" + (j["level"].get<int>() > 999 ? "(MAX)" : "(" + to_string(j["xp"].get<int>()) + "/" + to_string(50 * ((j["level"].get<int>() * j["level"].get<int>()) + 2)) + ")") + "|-3669761|\nadd_spacer|small|" + score + "|\nadd_spacer|small|\nadd_textbox|`oStatus: `4OFFLINE``|left|\nadd_spacer|small|\nadd_label_with_icon|small|`oTotal Gems: " + Set_Count(j["gems"].get<int>()) + "|left|112|\nadd_spacer|small|\nadd_label_with_icon|small|`oTotal World Locks: " + Set_Count(my_wls) + "|left|242|\nadd_label_with_icon|small|`oTotal " + Environment()->server_name + " Gem Locks: " + Set_Count(total_rgl) + "|left|8470|\nadd_spacer|small|\nadd_label_with_icon|small|`oTotal World Locks in Bank: " + Set_Count(j["wl_bank_amount"].get<int32_t>()) + "|left|242|\nadd_label_with_icon|small|`oTotal Diamond Locks in Bank: " + Set_Count(j["dl_bank_amount"].get<int32_t>()) + "|left|1796|\nadd_label_with_icon|small|`oTotal Platinum Gem Locks in Bank: " + Set_Count(j["pgl_bank_amount"].get<int32_t>()) + "|left|7188|\nadd_label_with_icon|small|`oTotal " + Environment()->server_name + " Gem Locks in Bank: " + Set_Count(j["mgl_bank_amount"].get<int32_t>()) + "|left|8470|\nadd_label_with_icon|small|`oTotal Infinity Gem Locks in Bank: " + Set_Count(j["igl_bank_amount"].get<int32_t>()) + "|left|13200|\nadd_spacer|small|\nadd_spacer|small|\nadd_small_font_button||`oClothing/Set (press to copy)|0|0|" + clothes + "|\nadd_spacer|small|\nadd_smalltext|`5(Statistics refresh every minute in real-time)|left|\nadd_button|backto_richleaderboard|`oBack``|0|0|\nend_dialog|Richest_Event|||");
						j.clear();
					}
					ifs.close();
				}
			}
		}
	}
	static void phoenix_returns(ENetPeer* peer, std::string cch) {
		shop_tab(peer, "tab1_1");
	}
	static void achieve_reply(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button.substr(0, 0) == "") {
				if (not is_number(std::string(get_embed(cch, "tilex"))) or not is_number(std::string(get_embed(cch, "tiley")))) return;
				int id = std::atoi(button.substr(0).c_str()), x = std::atoi(get_embed(cch, "tilex").c_str()), y = std::atoi(get_embed(cch, "tiley").c_str());
				std::string name_ = pInfo(peer)->world;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					WorldBlock* block_ = &world_->blocks[x + (y * 100)];
					if (block_->fg == 982) {
						block_->pr = id;
						block_->enabled = true;
						PlayerMoving data_{};
						data_.packetType = 5, data_.punchX = pInfo(peer)->lastwrenchx, data_.punchY = pInfo(peer)->lastwrenchy, data_.characterState = 0x8;
						BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
						BYTE* blc = raw + 56;
						form_visual(blc, *block_, *world_, peer, false);
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(peer)->world != pInfo(cp_)->world) continue;
							send_raw(cp_, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
						}
						delete[] raw, blc;
						if (block_->locked) upd_lock(*block_, *world_, peer);
					}
				}
			}
		}
		else {
			if (not is_number(std::string(get_embed(cch, "tilex"))) or not is_number(std::string(get_embed(cch, "tiley")))) return;
			int x = std::atoi(get_embed(cch, "tilex").c_str()), y = std::atoi(get_embed(cch, "tiley").c_str());
			std::string name_ = pInfo(peer)->world;
			std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				WorldBlock* block_ = &world_->blocks[x + (y * 100)];
				if (block_->fg == 982) {
					block_->pr = 0;
					block_->enabled = false;
					PlayerMoving data_{};
					data_.packetType = 5, data_.punchX = pInfo(peer)->lastwrenchx, data_.punchY = pInfo(peer)->lastwrenchy, data_.characterState = 0x8;
					BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
					BYTE* blc = raw + 56;
					form_visual(blc, *block_, *world_, peer, false);
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(peer)->world != pInfo(cp_)->world) continue;
						send_raw(cp_, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw, blc;
					if (block_->locked) upd_lock(*block_, *world_, peer);
				}
			}
		}
	}
	static void gacha_system(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (!parser.try_get("buttonClicked", button)) return;
		if (button == "banner_event") DialogHandle::Gacha(peer, "Event");
		if (button == "standar_banner") DialogHandle::Gacha(peer, "Standar");
		if (button == "BackToDialog") {
			if (pInfo(peer)->gacha_type == "Event") DialogHandle::Gacha(peer, "Event");
			if (pInfo(peer)->gacha_type == "Standar") DialogHandle::Gacha(peer, "Standar");
		}
		if (button == "Buy_Intertwined_Fate") {
			if (pInfo(peer)->Has_Type != "Intertwined") return;
			string scan_c = parser.get("Credits_Amount", 1);
			if (atoi(scan_c.c_str()) < 1 || atoi(scan_c.c_str()) < 0 || atoi(scan_c.c_str()) > 200 || scan_c.find_first_not_of("0123456789") != std::string::npos) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in amount!", 0, 1);
				return;
			}
			int kaina = 60, count = std::atoi(scan_c.c_str()), got = 0;
			if (kaina * count > pInfo(peer)->Masterless_Starglitter) {
				VarList::OnConsoleMessage(peer, "You don't have enough Masterless Starglitter!");
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Masterless Starglitter!", 0, 1);
				return;
			}
			int is_viso_worldlock = kaina * count;
			pInfo(peer)->Intertwined_Fate += count;
			pInfo(peer)->Masterless_Starglitter -= is_viso_worldlock;
			VisualHandle::Trade(peer, 9986, 500);
			VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wSuccesfully buy " + to_string(count) + " Intertwined Fate for " + Set_Count(is_viso_worldlock) + " Masterless Starglitter.", 0, 1);
			pInfo(peer)->Has_In = false;
			if (pInfo(peer)->gacha_type == "Event") DialogHandle::Gacha(peer, "Event");
			if (pInfo(peer)->gacha_type == "Standar") DialogHandle::Gacha(peer, "Standar");
		}
		if (button == "Buy_Acquaint_Fate") {
			if (pInfo(peer)->Has_Type != "Acquaint") return;
			string scan_c = parser.get("Credits_Amount", 1);
			if (atoi(scan_c.c_str()) < 1 || atoi(scan_c.c_str()) < 0 || atoi(scan_c.c_str()) > 200 || scan_c.find_first_not_of("0123456789") != std::string::npos) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in amount!", 0, 1);
				return;
			}
			int kaina = 60, count = std::atoi(scan_c.c_str()), got = 0;
			if (kaina * count > pInfo(peer)->Masterless_Starglitter) {
				VarList::OnConsoleMessage(peer, "You don't have enough Masterless Starglitter!");
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Masterless Starglitter!", 0, 1);
				return;
			}
			int is_viso_worldlock = kaina * count;
			pInfo(peer)->Acquaint_Fate += count;
			pInfo(peer)->Masterless_Starglitter -= is_viso_worldlock;
			VisualHandle::Trade(peer, 10382, 500);
			VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wSuccesfully buy " + to_string(count) + " Acquaint Fate for " + Set_Count(is_viso_worldlock) + " Masterless Starglitter.", 0, 1);
			pInfo(peer)->Has_In = false;
			if (pInfo(peer)->gacha_type == "Event") DialogHandle::Gacha(peer, "Event");
			if (pInfo(peer)->gacha_type == "Standar") DialogHandle::Gacha(peer, "Standar");
		}
		if (button == "Buy_Masterless_Starglitter") {
			if (pInfo(peer)->Has_Type != "Starglitter") return;
			string scan_c = parser.get("Credits_Amount", 1);
			if (atoi(scan_c.c_str()) < 1 || atoi(scan_c.c_str()) < 0 || atoi(scan_c.c_str()) > 200 || scan_c.find_first_not_of("0123456789") != std::string::npos) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in amount!", 0, 1);
				return;
			}
			int kaina = 50, count = std::atoi(scan_c.c_str()), got = 0, my_wls = get_wls(peer, true);
			if (kaina * count > my_wls) {
				VarList::OnConsoleMessage(peer, "You don't have enough World Locks!");
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough World Locks!", 0, 1);
				return;
			}
			int is_viso_worldlock = kaina * count;
			get_wls(peer, true, true, is_viso_worldlock);
			pInfo(peer)->Masterless_Starglitter += count;
			VisualHandle::Trade(peer, 14552, 500);
			VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wSuccesfully buy " + to_string(count) + " Masterless Starglitter for " + Set_Count(is_viso_worldlock) + " World Locks.", 0, 1);
			if (pInfo(peer)->gacha_type == "Event") DialogHandle::Gacha(peer, "Event");
			if (pInfo(peer)->gacha_type == "Standar") DialogHandle::Gacha(peer, "Standar");
		}
		if (button == "Buy_Intertwined") {
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label|big|Intertwined Fate|left|\nadd_spacer|small|\nadd_custom_margin|x:0;y:-30|\nadd_custom_button||icon:9986;display:inline_free;width:0.40;state:disabled;|\nadd_spacer|small|\nadd_custom_margin|x:20;y:-20|\nadd_smalltext|`oHow many Intertwined Fate do you want to buy?<CR>`o1 Intertwined Fate = 60 Masterless Starglitter.|left|\nadd_text_input|Credits_Amount|||3|\nadd_spacer|small|\nadd_custom_textbox|`oYou have `2" + Set_Count(pInfo(peer)->Masterless_Starglitter) + " Masterless Starglitter`o.|size:small;icon:14552;|\nadd_custom_margin|x:-10;y:0|\nreset_placement_x|\nadd_spacer|small|\nadd_custom_button|Gacha_Shop|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|Buy_Intertwined_Fate|textLabel:`wBuy Intertwined Fate;anchor:_button_Gacha_Shop;left:1;margin:60,0;|\nend_dialog|gacha_system|||\nadd_quick_exit|");
			pInfo(peer)->Has_Type = "Intertwined";
		}
		if (button == "Buy_Acquaint") {
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label|big|Acquaint Fate|left|\nadd_spacer|small|\nadd_custom_margin|x:0;y:-30|\nadd_custom_button||icon:10382;display:inline_free;width:0.40;state:disabled;|\nadd_spacer|small|\nadd_custom_margin|x:20;y:-20|\nadd_smalltext|`oHow many Intertwined Fate do you want to buy?<CR>`o1 Acquaint Fate = 60 Masterless Starglitter.|left|\nadd_text_input|Credits_Amount|||3|\nadd_spacer|small|\nadd_custom_textbox|`oYou have `2" + Set_Count(pInfo(peer)->Masterless_Starglitter) + " Masterless Starglitter`o.|size:small;icon:14552;|\nadd_custom_margin|x:-10;y:0|\nreset_placement_x|\nadd_spacer|small|\nadd_custom_button|Gacha_Shop|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|Buy_Acquaint_Fate|textLabel:`wBuy Acquaint Fate;anchor:_button_Gacha_Shop;left:1;margin:60,0;|\nend_dialog|gacha_system|||\nadd_quick_exit|");
			pInfo(peer)->Has_Type = "Acquaint";
		}
		if (button == "Buy_Starglitter") {
			int my_wls = get_wls(peer, true);
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label|big|Masterless Starglitter|left|\nadd_spacer|small|\nadd_custom_margin|x:0;y:-30|\nadd_custom_button||icon:14552;display:inline_free;width:0.40;state:disabled;|\nadd_spacer|small|\nadd_custom_margin|x:20;y:-20|\nadd_smalltext|`oHow many Masterless Starglitter do you want to buy?<CR>`o1 Masterless Starglitter = 50 World Locks.|left|\nadd_text_input|Credits_Amount|||3|\nadd_spacer|small|\nadd_custom_textbox|`oYou have `2" + Set_Count(my_wls) + " World Locks`o.|size:small;icon:242;|\nadd_custom_margin|x:-10;y:0|\nreset_placement_x|\nadd_spacer|small|\nadd_custom_button|Gacha_Shop|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|Buy_Masterless_Starglitter|textLabel:`wBuy Masterless Starglitter;anchor:_button_Gacha_Shop;left:1;margin:60,0;|\nend_dialog|gacha_system|||\nadd_quick_exit|");
			pInfo(peer)->Has_Type = "Starglitter";
		}
		if (button == "Gacha_Shop") {
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label|big|`wGacha Shop|left|\nadd_spacer|small|\nadd_smalltext|`9Welcome to Gacha Shop, Here you can exchange your Masterless Starglitter for Intertwined Fate / Acquaint Fate and you can also buy it using World Locks.|left|\nadd_spacer|small|\nadd_custom_textbox|`oYour Masterless Starglitter: `2" + Set_Count(pInfo(peer)->Masterless_Starglitter) + "|size:small;icon:14552;|\nadd_custom_textbox|`oYour Intertwined Fate: `2" + Set_Count(pInfo(peer)->Intertwined_Fate) + "|size:small;icon:9986;|\nadd_custom_textbox|`oYour Acquaint Fate: `2" + Set_Count(pInfo(peer)->Acquaint_Fate) + "|size:small;icon:10382;|\nadd_spacer|small|\nadd_custom_button|Buy_Intertwined|icon:9986;border:white;display:inline_free;width:0.40;|\nadd_custom_button|Buy_Acquaint|icon:10382;border:white;display:inline_free;width:0.40;|\nadd_custom_button|Buy_Starglitter|icon:14552;border:white;display:inline_free;width:0.40;|\nadd_custom_break|\nadd_spacer|small|\nadd_button|BackToDialog|`wBack|noflags|0|0|\nend_dialog|gacha_system|||");
		}
		if (button == "Gacha_Detail") {
			if (pInfo(peer)->gacha_type == "Event") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label|big|`wEvent Wish - Flame Eldritch Rayman's Fist|left|\nadd_spacer|small|\nadd_textbox|`5 - the percentage of acquisition increases - |left|\nadd_spacer|small|\nadd_textbox|`oProbability of getting a 5 Stars percentage: 50,000%|left|\nadd_spacer|small|\nadd_label_with_icon|small|`2Flame Eldritch Rayman's Fist|left|9772|\nadd_spacer|small|\nadd_textbox|`oProbability of getting a 4 Stars percentage: 50,000%|left|\nadd_spacer|small|\nadd_label_with_icon|small|`2Rayman's Fist|left|5480|\nadd_label_with_icon|small|`2Legendary Leonidas Scythe|left|9774|\nadd_label_with_icon|small|`2Zeus' Lightning Crown|left|10364|\nadd_spacer|small|\nadd_label|small|`5 - Detailed Explanation - |left|\nadd_spacer|small|\nadd_smalltext|`o   -  The Wish Event - Flame Eldritch Rayman's Fist has begin. During the wish event, the percentage of obtaining 5-star items `8Exclusive `5\"Flame Eldritch Rayman's Fist\"`o, 4-star items `5\"Rayman's Fist\"``, `5\"Legendary Leonidas Scythe\" `oand `5\"Zeus' Lightning Crown\" `o increases drastically!|left|\nadd_smalltext|`o   -  This Application Event is available for a limited time. All items in the event may return in the future. The above exclusive characters will not be included in the Standard \"Wanderlust Invocation\".|left|\nadd_smalltext|`o   -  Under normal circumstances, requests for goods are calculated based on a basic percentage. For requests with increased acquisition percentages, acquisition guarantees, etc., they will be calculated based on applicable provisions.|left|\nadd_spacer|small|\nadd_label|small|`5 - Stipulations - |left|\nadd_spacer|small|\nadd_smalltext|`o - [Item 5 Stars] - |left|\nadd_smalltext|`o - For Wish Event - Flame Eldritch Rayman's Fist, base percentage to get Items 5: 0.600%; overall percentage (including collateral): 1,600%. Guaranteed to get Items 5 at least once every 90 Applications. When you get Items 5 from the Request, there is a 50,000% chance that Items is the UP Items 5 in this event: \"Flame Eldritch Rayman's Fist\". If the first 5 Stars Items you get from this event is not an UP Items, the next 5 Stars Items you get is guaranteed to be an UP Character.|left|\nadd_spacer|small|\nadd_smalltext|`o - [Item 4 Stars] - |left|\nadd_smalltext|`o - For Wish Event - Flame Eldritch Rayman's Fist, base percentage for getting Item 4 Stars: 5.100%; base percentage to get Item 4 Stars: 2.550%, overall percentage to get a 4 Stars item (including guarantee) : 13,000%. Guaranteed to get a 4 Stars item or above at least once every 10 times you apply; the percentage of obtaining 4 Stars items from the guarantee is 99.400%, percentage item gain 5 Stars of the guarantee is 0.600%. When you get a 4 Stars item from the Wish, there is a 50,000% chance that it will be the 4 Stars UP Item in this event: \"Super's Rayman's Fist\" S.Ray, \"Legendary Leonidas Scythe\" L.Lc and \"Zeus' Lightning Crown\" O.Ray. If the first 4 Stars item you get from this event is not an UP Item, then the next 4 Stars item you get is guaranteed to be a 4 Stars UP Item from this period. When you get a 4 Stars UP item from a Request, the percentage of obtaining each 4 Stars UP Item in this request event is the same flat.|left|\nadd_spacer|small|\nadd_label|small|`5 - List Items - |left|\nadd_spacer|small|\nadd_smalltext|`o- \"5 Stars Item acquistion base percentage: 0,600% (including guarantee: 1,600%)\" -|left|\nadd_spacer|small|\nadd_custom_button||icon:9772;border:yellow;display:inline_free;|\nadd_custom_break|\nadd_spacer|small|\nadd_smalltext|`o(NOTE: When an increase in the probability of earning or a guarantee condition has not been triggered, all items will have the same base percentage)|left|\nadd_spacer|small|\nadd_smalltext|`o- \"4 Stars Item acquistion base percentage: 5,100% (including guarantee: 13,000%)\" -|left|\nadd_spacer|small|\nadd_custom_button||icon:9774;border:purple;display:inline_free;|\nadd_custom_button||icon:10364;border:purple;display:inline_free;|\nadd_custom_button||icon:6006;border:purple;display:inline_free;|\nadd_custom_button||icon:6008;border:purple;display:inline_free;|\nadd_custom_button||icon:9554;border:purple;display:inline_free;|\nadd_custom_button||icon:9998;border:purple;display:inline_free;|\nadd_custom_button||icon:2722;border:purple;display:inline_free;|\nadd_custom_break|\nadd_custom_button||icon:5020;border:purple;display:inline_free;|\nadd_custom_button||icon:9428;border:purple;display:inline_free;|\nadd_custom_button||icon:7412;border:purple;display:inline_free;|\nadd_custom_button||icon:9422;border:purple;display:inline_free;|\nadd_custom_button||icon:4996;border:purple;display:inline_free;|\nadd_custom_button||icon:1738;border:purple;display:inline_free;|\nadd_custom_button||icon:3144;border:purple;display:inline_free;|\nadd_custom_break|\nadd_custom_button||icon:5738;border:purple;display:inline_free;|\nadd_custom_button||icon:9322;border:purple;display:inline_free;|\nadd_custom_button||icon:8194;border:purple;display:inline_free;|\nadd_custom_button||icon:11300;border:purple;display:inline_free;|\nadd_custom_button||icon:13198;border:purple;display:inline_free;|\nadd_custom_button||icon:13432;border:purple;display:inline_free;|\nadd_custom_button||icon:4802;border:purple;display:inline_free;|\nadd_custom_break|\nadd_spacer|small|\nadd_smalltext|`o(NOTE: When an increase in the probability of earning or a guarantee condition has not been triggered, all items will have the same base percentage)|left|\nadd_spacer|small|\nadd_smalltext|`o- \"3 Stars Item acquistion base percentage: 94,300% (including guarantee: 85,400%)\" -|left|\nadd_spacer|small|\nadd_custom_button||icon:818;border:white;display:inline_free;|\nadd_custom_button||icon:1936;border:white;display:inline_free;|\nadd_custom_button||icon:362;border:white;display:inline_free;|\nadd_custom_button||icon:1672;border:white;display:inline_free;|\nadd_custom_button||icon:1574;border:white;display:inline_free;|\nadd_custom_button||icon:1576;border:white;display:inline_free;|\nadd_custom_button||icon:156;border:white;display:inline_free;|\nadd_custom_button||icon:4030;border:white;display:inline_free;|\nadd_custom_break|\nadd_custom_button||icon:2162;border:white;display:inline_free;|\nadd_custom_button||icon:2160;border:white;display:inline_free;|\nadd_custom_button||icon:2158;border:white;display:inline_free;|\nadd_custom_button||icon:2642;border:white;display:inline_free;|\nadd_custom_button||icon:2800;border:white;display:inline_free;|\nadd_custom_button||icon:8830;border:white;display:inline_free;|\nadd_custom_button||icon:1116;border:white;display:inline_free;|\nadd_custom_button||icon:538;border:white;display:inline_free;|\nadd_custom_break|\nadd_custom_button||icon:78;border:white;display:inline_free;|\nadd_custom_button||icon:40;border:white;display:inline_free;|\nadd_custom_button||icon:4534;border:white;display:inline_free;|\nadd_custom_button||icon:5652;border:white;display:inline_free;|\nadd_custom_button||icon:5902;border:white;display:inline_free;|\nadd_custom_button||icon:4682;border:white;display:inline_free;|\nadd_custom_button||icon:4680;border:white;display:inline_free;|\nadd_custom_button||icon:4678;border:white;display:inline_free;|\nadd_custom_break|\nadd_spacer|small|\nadd_smalltext|`o(NOTE: When an increase in the probability of earning or a guarantee condition has not been triggered, all items will have the same base percentage)|left|\nadd_spacer|small|\nadd_button|BackToDialog|Back|noflags|0|0|\nend_dialog|gacha_system|||\nadd_quick_exit|");
			if (pInfo(peer)->gacha_type == "Standar") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label|big|`wStandar Wish - Electrical Evil Lock|left|\nadd_spacer|small|\nadd_textbox|`5 - the percentage of acquisition increases - |left|\nadd_spacer|small|\nadd_textbox|`oProbability of getting a 5 Stars percentage: 50,000%|left|\nadd_spacer|small|\nadd_label_with_icon|small|`2Electrical Evil Lock|left|5980|\nadd_spacer|small|\nadd_textbox|`oProbability of getting a 4 Stars percentage: 50,000%|left|\nadd_spacer|small|\nadd_label_with_icon|small|`2Golden Legendary Wings|left|10684|\nadd_label_with_icon|small|`2Marius Blade Sword|left|10366|\nadd_spacer|small|\nadd_label|small|`5 - Detailed Explanation - |left|\nadd_spacer|small|\nadd_smalltext|`o   -  The Wish Standar - Electrical Evil Lock has begin. During the wish event, the percentage of obtaining 5-star items `8Exclusive `5\"Electrical Evil Lock\"`o, 4-star items `5\"Golden Legendary Wings\"``and `5\"Marius Blade Sword\" `o increases drastically!|left|\nadd_smalltext|`o   -  This Application Event is available for a limited time. All items in the event may return in the future. The above exclusive characters will not be included in the Standard \"Wanderlust Invocation\".|left|\nadd_smalltext|`o   -  Under normal circumstances, requests for goods are calculated based on a basic percentage. For requests with increased acquisition percentages, acquisition guarantees, etc., they will be calculated based on applicable provisions.|left|\nadd_spacer|small|\nadd_label|small|`5 - Stipulations - |left|\nadd_spacer|small|\nadd_smalltext|`o - [Item 5 Stars] - |left|\nadd_smalltext|`o - For Wish Standar - Electrical Evil Lock, base percentage to get Items 5: 0.600%; overall percentage (including collateral): 1,600%. Guaranteed to get Items 5 at least once every 90 Applications. When you get Items 5 from the Request, there is a 50,000% chance that Items is the UP Items 5 in this event: \"Electrical Evil Lock\". If the first 5 Stars Items you get from this event is not an UP Items, the next 5 Stars Items you get is guaranteed to be an UP Character.|left|\nadd_spacer|small|\nadd_smalltext|`o - [Item 4 Stars] - |left|\nadd_smalltext|`o - For Wish Standar - Electrical Evil Lock, base percentage for getting Item 4 Stars: 5.100%; base percentage to get Item 4 Stars: 2.550%, overall percentage to get a 4 Stars item (including guarantee) : 13,000%. Guaranteed to get a 4 Stars item or above at least once every 10 times you apply; the percentage of obtaining 4 Stars items from the guarantee is 99.400%, percentage item gain 5 Stars of the guarantee is 0.600%. When you get a 4 Stars item from the Wish, there is a 50,000% chance that it will be the 4 Stars UP Item in this event: \"Golden Legendary Wings\" L.GoldenW and \"Marius Blade Sword\" M.Sword. If the first 4 Stars item you get from this event is not an UP Item, then the next 4 Stars item you get is guaranteed to be a 4 Stars UP Item from this period. When you get a 4 Stars UP item from a Request, the percentage of obtaining each 4 Stars UP Item in this request event is the same flat.|left|\nadd_spacer|small|\nadd_label|small|`5 - List Items - |left|\nadd_spacer|small|\nadd_smalltext|`o- \"5 Stars Item acquistion base percentage: 0,600% (including guarantee: 1,600%)\" -|left|\nadd_spacer|small|\nadd_custom_button||icon:5980;border:yellow;display:inline_free;|\nadd_custom_break|\nadd_spacer|small|\nadd_smalltext|`o(NOTE: When an increase in the probability of earning or a guarantee condition has not been triggered, all items will have the same base percentage)|left|\nadd_spacer|small|\nadd_smalltext|`o- \"4 Stars Item acquistion base percentage: 5,100% (including guarantee: 13,000%)\" -|left|\nadd_spacer|small|\nadd_custom_button||icon:10684;border:purple;display:inline_free;|\nadd_custom_button||icon:10366;border:purple;display:inline_free;|\nadd_custom_button||icon:6006;border:purple;display:inline_free;|\nadd_custom_button||icon:6008;border:purple;display:inline_free;|\nadd_custom_button||icon:9554;border:purple;display:inline_free;|\nadd_custom_button||icon:9998;border:purple;display:inline_free;|\nadd_custom_button||icon:2722;border:purple;display:inline_free;|\nadd_custom_break|\nadd_custom_button||icon:5020;border:purple;display:inline_free;|\nadd_custom_button||icon:9428;border:purple;display:inline_free;|\nadd_custom_button||icon:7412;border:purple;display:inline_free;|\nadd_custom_button||icon:9422;border:purple;display:inline_free;|\nadd_custom_button||icon:4996;border:purple;display:inline_free;|\nadd_custom_button||icon:1738;border:purple;display:inline_free;|\nadd_custom_button||icon:3144;border:purple;display:inline_free;|\nadd_custom_break|\nadd_custom_button||icon:5738;border:purple;display:inline_free;|\nadd_custom_button||icon:9322;border:purple;display:inline_free;|\nadd_custom_button||icon:8194;border:purple;display:inline_free;|\nadd_custom_button||icon:11300;border:purple;display:inline_free;|\nadd_custom_button||icon:13198;border:purple;display:inline_free;|\nadd_custom_button||icon:13432;border:purple;display:inline_free;|\nadd_custom_button||icon:4802;border:purple;display:inline_free;|\nadd_custom_break|\nadd_spacer|small|\nadd_smalltext|`o(NOTE: When an increase in the probability of earning or a guarantee condition has not been triggered, all items will have the same base percentage)|left|\nadd_spacer|small|\nadd_smalltext|`o- \"3 Stars Item acquistion base percentage: 94,300% (including guarantee: 85,400%)\" -|left|\nadd_spacer|small|\nadd_custom_button||icon:818;border:white;display:inline_free;|\nadd_custom_button||icon:1936;border:white;display:inline_free;|\nadd_custom_button||icon:362;border:white;display:inline_free;|\nadd_custom_button||icon:1672;border:white;display:inline_free;|\nadd_custom_button||icon:1574;border:white;display:inline_free;|\nadd_custom_button||icon:1576;border:white;display:inline_free;|\nadd_custom_button||icon:156;border:white;display:inline_free;|\nadd_custom_button||icon:4030;border:white;display:inline_free;|\nadd_custom_break|\nadd_custom_button||icon:2162;border:white;display:inline_free;|\nadd_custom_button||icon:2160;border:white;display:inline_free;|\nadd_custom_button||icon:2158;border:white;display:inline_free;|\nadd_custom_button||icon:2642;border:white;display:inline_free;|\nadd_custom_button||icon:2800;border:white;display:inline_free;|\nadd_custom_button||icon:8830;border:white;display:inline_free;|\nadd_custom_button||icon:1116;border:white;display:inline_free;|\nadd_custom_button||icon:538;border:white;display:inline_free;|\nadd_custom_break|\nadd_custom_button||icon:78;border:white;display:inline_free;|\nadd_custom_button||icon:40;border:white;display:inline_free;|\nadd_custom_button||icon:4534;border:white;display:inline_free;|\nadd_custom_button||icon:5652;border:white;display:inline_free;|\nadd_custom_button||icon:5902;border:white;display:inline_free;|\nadd_custom_button||icon:4682;border:white;display:inline_free;|\nadd_custom_button||icon:4680;border:white;display:inline_free;|\nadd_custom_break|\nadd_custom_button||icon:4678;border:white;display:inline_free;|\nadd_custom_break|\nadd_spacer|small|\nadd_smalltext|`o(NOTE: When an increase in the probability of earning or a guarantee condition has not been triggered, all items will have the same base percentage)|left|\nadd_spacer|small|\nadd_button|BackToDialog|Back|noflags|0|0|\nend_dialog|gacha_system|||\nadd_quick_exit|");
		}
		if (button == "Clear_Gacha_History") {
			pInfo(peer)->Gacha_History.clear();
			VarList::OnTalkBubble(peer, pInfo(peer)->netID, "History has been cleared!", 0, 1);
		}
		if (button == "Gacha_History") {
			string list = "";
			for (int i = 0; i < pInfo(peer)->Gacha_History.size(); i++) list += "\nadd_smalltext|`o" + to_string(i + 1) + ". " + pInfo(peer)->Gacha_History[i] + "|left|\n";
			if (list.empty()) list = "\nadd_textbox|`oThe Gacha History is empty.|left|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label|big|Gacha History|left|\nadd_smalltext|`oYou can see the Gacha history here, the Gacha history is updated after you make the Gacha, if you don't see it here, please check back in a few moments.|left|\nadd_spacer|small|" + a + (pInfo(peer)->Gacha_History.empty() ? "" : "\nadd_button|Clear_Gacha_History|`4Clear History|noflags|0|0|") + "\nadd_spacer|small|" + list + "|\nadd_spacer|small|\nadd_button|BackToDialog|`wBack|noflags|0|0|\nend_dialog|gacha_system|||");
		}
		if (pInfo(peer)->gacha_type == "Event") {
			if (button == "gacha_1x") {
				if (pInfo(peer)->Intertwined_Fate < 1) {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label|big|Gacha Event Banner|left|\nadd_spacer|small|\nadd_textbox|`oAdd `81 ``Intertwined Fate required, Purchase using 60 Masterless Starglitter?|left|\nadd_spacer|small|\nadd_button|BackToDialog|Cancel|noflags|\nadd_custom_button|Gacha_Shop|textLabel:Yes, Purchase;anchor:_button_BackToDialog;left:1;margin:60,0;|\nend_dialog|gacha_system|||");
					return;
				}
				int itemCount = 1;
				int singleResult = Gacha::Event::Single(peer);
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label|big|`wCongratulations!!|left|\nadd_spacer|small|\nadd_button_with_icon|||" + a + (Gacha::Event::Legendary_Item(singleResult) ? "staticYellowFrame" : Gacha::Event::Rare_Item(singleResult) ? "staticPurpleFrame" : "staticGreyFrame") + "|" + to_string(singleResult) + "|\nadd_button_with_icon||END_LIST|noflags|0|\nend_quick_exit|\nadd_spacer|small|\nadd_button|BackToDialog|`wBack|noflags|0|0|\nend_dialog|gacha_system|||");
				if (Inventory::Modify(peer, singleResult, itemCount) == 0) {
				}
				pInfo(peer)->Intertwined_Fate -= 1;
				time_t currentTime; struct tm* localTime; char buffer[80];
				time(&currentTime); localTime = localtime(&currentTime);
				int Mon = localTime->tm_mon + 1; int Day = localTime->tm_mday; int Hour = localTime->tm_hour; int Min = localTime->tm_min; int Sec = localTime->tm_sec;
				pInfo(peer)->Gacha_History.push_back("" + items[singleResult].name + " `wat " + to_string(Hour) + ":" + to_string(Min) + " on " + to_string(Mon) + "/" + to_string(Day) + "");
			}
			if (button == "gacha_10x") {
				int ttl = pInfo(peer)->Intertwined_Fate, ttl2 = 10, ttl3 = 0;
				ttl3 = ttl2 - ttl;
				if (pInfo(peer)->Intertwined_Fate < 10) {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label|big|Gacha Event Banner|left|\nadd_spacer|small|\nadd_textbox|`oAdd `8" + to_string(10 - pInfo(peer)->Intertwined_Fate) + " ``Intertwined Fate required, Purchase using " + Set_Count(ttl3 * 60) + " Masterless Starglitter?|left|\nadd_spacer|small|\nadd_button|BackToDialog|Cancel|noflags|\nadd_custom_button|Gacha_Shop|textLabel:Yes, Purchase;anchor:_button_BackToDialog;left:1;margin:60,0;|\nend_dialog|gacha_system|||");
					return;
				}
				int itemCount = 1; string list = "";
				std::vector<int> multiResults = Gacha::Event::Multi(peer);
				for (auto result : multiResults) {
					if (Inventory::Modify(peer, result, itemCount) == 0) {
						itemCount = 1;
					}
					time_t currentTime; struct tm* localTime; char buffer[80];
					time(&currentTime); localTime = localtime(&currentTime);
					int Mon = localTime->tm_mon + 1; int Day = localTime->tm_mday; int Hour = localTime->tm_hour; int Min = localTime->tm_min; int Sec = localTime->tm_sec;
					pInfo(peer)->Gacha_History.push_back("" + items[result].name + " `wat " + to_string(Hour) + ":" + to_string(Min) + " on " + to_string(Mon) + "/" + to_string(Day) + "");
					list += "\nadd_button_with_icon|||" + a + (Gacha::Event::Legendary_Item(result) ? "staticYellowFrame" : Gacha::Event::Rare_Item(result) ? "staticPurpleFrame" : "staticGreyFrame") + ",no_padding_x,|" + to_string(result) + "|";
				}
				pInfo(peer)->Intertwined_Fate -= 10;
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label|big|`wCongratulations!!|left|\nadd_spacer|small|" + list + "\nadd_button_with_icon||END_LIST|noflags|0|\nadd_quick_exit|\nadd_spacer|small|\nadd_button|BackToDialog|`wBack|noflags|0|0|\nend_dialog|gacha_system|||");
			}
		}
		if (pInfo(peer)->gacha_type == "Standar") {
			if (button == "gacha_1x") {
				if (pInfo(peer)->Acquaint_Fate < 1) {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label|big|Gacha Standar Banner|left|\nadd_spacer|small|\nadd_textbox|`oAdd `81 ``Acquaint Fate required, Purchase using 60 Masterless Starglitter?|left|\nadd_spacer|small|\nadd_button|BackToDialog|Cancel|noflags|\nadd_custom_button|Gacha_Shop|textLabel:Yes, Purchase;anchor:_button_BackToDialog;left:1;margin:60,0;|\nend_dialog|gacha_system|||");
					return;
				}
				int itemCount = 1;
				int singleResult = Gacha::Standar::Single(peer);
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label|big|`wCongratulations!!|left|\nadd_spacer|small|\nadd_button_with_icon|||" + a + (Gacha::Standar::Legendary_Item(singleResult) ? "staticYellowFrame" : Gacha::Standar::Rare_Item(singleResult) ? "staticPurpleFrame" : "staticGreyFrame") + "|" + to_string(singleResult) + "|\nadd_button_with_icon||END_LIST|noflags|0|\nend_quick_exit|\nadd_spacer|small|\nadd_button|BackToDialog|`wBack|noflags|0|0|\nend_dialog|gacha_system|||");
				if (Inventory::Modify(peer, singleResult, itemCount) == 0) {
				}
				pInfo(peer)->Acquaint_Fate -= 1;
				time_t currentTime; struct tm* localTime; char buffer[80];
				time(&currentTime); localTime = localtime(&currentTime);
				int Mon = localTime->tm_mon + 1; int Day = localTime->tm_mday; int Hour = localTime->tm_hour; int Min = localTime->tm_min; int Sec = localTime->tm_sec;
				pInfo(peer)->Gacha_History.push_back("" + items[singleResult].name + " `wat " + to_string(Hour) + ":" + to_string(Min) + " on " + to_string(Mon) + "/" + to_string(Day) + "");
			}
			if (button == "gacha_10x") {
				int ttl = pInfo(peer)->Acquaint_Fate, ttl2 = 10, ttl3 = 0;
				ttl3 = ttl2 - ttl;
				if (pInfo(peer)->Acquaint_Fate < 10) {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label|big|Gacha Standar Banner|left|\nadd_spacer|small|\nadd_textbox|`oAdd `8" + to_string(10 - pInfo(peer)->Acquaint_Fate) + " ``Acquaint Fate required, Purchase using " + Set_Count(ttl3 * 60) + " Masterless Starglitter?|left|\nadd_spacer|small|\nadd_button|BackToDialog|Cancel|noflags|\nadd_custom_button|Gacha_Shop|textLabel:Yes, Purchase;anchor:_button_BackToDialog;left:1;margin:60,0;|\nend_dialog|gacha_system|||");
					return;
				}
				int itemCount = 1; string list = "";
				std::vector<int> multiResults = Gacha::Standar::Multi(peer);
				for (const int& result : multiResults) {
					if (Inventory::Modify(peer, result, itemCount) == 0) {
						itemCount = 1;
					}
					time_t currentTime; struct tm* localTime; char buffer[80];
					time(&currentTime); localTime = localtime(&currentTime);
					int Mon = localTime->tm_mon + 1; int Day = localTime->tm_mday; int Hour = localTime->tm_hour; int Min = localTime->tm_min; int Sec = localTime->tm_sec;
					pInfo(peer)->Gacha_History.push_back("" + items[result].name + " `wat " + to_string(Hour) + ":" + to_string(Min) + " on " + to_string(Mon) + "/" + to_string(Day) + "");
					list += "\nadd_button_with_icon|||" + a + (Gacha::Standar::Legendary_Item(result) ? "staticYellowFrame" : Gacha::Standar::Rare_Item(result) ? "staticPurpleFrame" : "staticGreyFrame") + ",no_padding_x,|" + to_string(result) + "|";
				}
				pInfo(peer)->Acquaint_Fate -= 10;
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label|big|`wCongratulations!!|left|\nadd_spacer|small|" + list + "\nadd_button_with_icon||END_LIST|noflags|0|\nadd_quick_exit|\nadd_spacer|small|\nadd_button|BackToDialog|`wBack|noflags|0|0|\nend_dialog|gacha_system|||");
			}
		}
	}
	static void xenonite_edit(ENetPeer* peer, std::string cch) {
		std::vector<std::string> t_ = explode("|", cch);
		if (t_.size() < 17) return;
		bool force_double_jump = std::atoi(explode("\n", t_[3])[0].c_str()), block_double_jump = std::atoi(explode("\n", t_[4])[0].c_str()), force_high_jump = std::atoi(explode("\n", t_[5])[0].c_str()), block_high_jump = std::atoi(explode("\n", t_[6])[0].c_str()), force_heat_resist = std::atoi(explode("\n", t_[7])[0].c_str()), block_heat_resist = std::atoi(explode("\n", t_[8])[0].c_str()), force_strong_punch = std::atoi(explode("\n", t_[9])[0].c_str()), block_strong_punch = std::atoi(explode("\n", t_[10])[0].c_str()), force_long_punch = std::atoi(explode("\n", t_[11])[0].c_str()), block_long_punch = std::atoi(explode("\n", t_[12])[0].c_str()), force_speedy = std::atoi(explode("\n", t_[13])[0].c_str()), block_speedy = std::atoi(explode("\n", t_[14])[0].c_str()), force_long_build = std::atoi(explode("\n", t_[15])[0].c_str()), block_long_build = std::atoi(explode("\n", t_[16])[0].c_str());
		if (((force_double_jump != 0 && block_double_jump != 0) && force_double_jump == block_double_jump) || ((force_high_jump != 0 && block_high_jump != 0) && force_high_jump == block_high_jump) || ((force_heat_resist != 0 && block_heat_resist != 0) && force_heat_resist == block_heat_resist) || ((force_strong_punch != 0 && block_strong_punch != 0) && force_strong_punch == block_strong_punch) || ((force_long_punch != 0 && block_long_punch != 0) && force_long_punch == block_long_punch) || ((force_speedy != 0 && block_speedy != 0) && force_speedy == block_speedy) || ((force_long_build != 0 && block_long_build != 0) && force_long_build == block_long_build)) {
			VarList::OnConsoleMessage(peer, "The Xenonite Crystal has shifted...");
		}
		else {
			std::string name_ = pInfo(peer)->world;
			std::vector<World>::iterator paa = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (paa != worlds.end()) {
				World* world_ = &worlds[paa - worlds.begin()];
				world_->fresh_world = true;
				WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
				if (block_->fg == 2072 && Only_Access(peer, world_, &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)])) {
					if (force_double_jump) world_->xenonite |= SETTINGS::XENONITE_FORCE_DOUBLE_JUMP;
					else world_->xenonite &= ~SETTINGS::XENONITE_FORCE_DOUBLE_JUMP;
					if (block_double_jump) world_->xenonite |= SETTINGS::XENONITE_BLOCK_DOUBLE_JUMP;
					else world_->xenonite &= ~SETTINGS::XENONITE_BLOCK_DOUBLE_JUMP;
					if (force_high_jump) world_->xenonite |= SETTINGS::XENONITE_FORCE_HIGH_JUMP;
					else world_->xenonite &= ~SETTINGS::XENONITE_FORCE_HIGH_JUMP;
					if (block_high_jump) world_->xenonite |= SETTINGS::XENONITE_BLOCK_HIGH_JUMP;
					else world_->xenonite &= ~SETTINGS::XENONITE_BLOCK_HIGH_JUMP;
					if (force_heat_resist) world_->xenonite |= SETTINGS::XENONITE_FORCE_HEAT_RESIST;
					else world_->xenonite &= ~SETTINGS::XENONITE_FORCE_HEAT_RESIST;
					if (block_heat_resist) world_->xenonite |= SETTINGS::XENONITE_BLOCK_HEAT_RESIST;
					else world_->xenonite &= ~SETTINGS::XENONITE_BLOCK_HEAT_RESIST;
					if (force_strong_punch) world_->xenonite |= SETTINGS::XENONITE_FORCE_STRONG_PUNCH;
					else world_->xenonite &= ~SETTINGS::XENONITE_FORCE_STRONG_PUNCH;
					if (block_strong_punch) world_->xenonite |= SETTINGS::XENONITE_BLOCK_STRONG_PUNCH;
					else world_->xenonite &= ~SETTINGS::XENONITE_BLOCK_STRONG_PUNCH;
					if (force_long_punch) world_->xenonite |= SETTINGS::XENONITE_FORCE_LONG_PUNCH;
					else world_->xenonite &= ~SETTINGS::XENONITE_FORCE_LONG_PUNCH;
					if (block_long_punch) world_->xenonite |= SETTINGS::XENONITE_BLOCK_LONG_PUNCH;
					else world_->xenonite &= ~SETTINGS::XENONITE_BLOCK_LONG_PUNCH;
					if (force_speedy) world_->xenonite |= SETTINGS::XENONITE_FORCE_SPEEDY;
					else world_->xenonite &= ~SETTINGS::XENONITE_FORCE_SPEEDY;
					if (block_speedy) world_->xenonite |= SETTINGS::XENONITE_BLOCK_SPEEDY;
					else world_->xenonite &= ~SETTINGS::XENONITE_BLOCK_SPEEDY;
					if (force_long_build) world_->xenonite |= SETTINGS::XENONITE_FORCE_LONG_BUILD;
					else world_->xenonite &= ~SETTINGS::XENONITE_FORCE_LONG_BUILD;
					if (block_long_build) world_->xenonite |= SETTINGS::XENONITE_BLOCK_LONG_BUILD;
					else world_->xenonite &= ~SETTINGS::XENONITE_BLOCK_LONG_BUILD;
					string text = xenonite_text(world_->xenonite);
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(cp_)->world != pInfo(peer)->world) continue;
						pInfo(cp_)->xenonite = world_->xenonite;
						Clothing_V2::Update(cp_, false);
						Clothing_V2::Update_Value(cp_, false);
						if (world_->xenonite != 0) {
							VarList::OnConsoleMessage(cp_, text);
							VarList::OnTalkBubble(cp_, pInfo(peer)->netID, text, 0, 1);
						}
					}
				}
			}
		}
	}
	static void statsblock(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [&](const World& a) { return a.name == pInfo(peer)->world; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				world_->fresh_world = true;
				WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
				if (block_->fg != 6016) return;
				if (Only_Access(peer, world_, block_)) {
					if (button == "back_to_gscan") {
						DialogHandle::Growscan_Load(peer, world_, block_);
					}
					if (button.find("search_") != std::string::npos) {
						std::vector<std::string> t_ = explode("|", cch);
						if (t_.size() < 5 || pInfo(peer)->world.empty()) return;
						std::string type = explode("\n", t_[3])[0].c_str(), search = explode("\n", t_[4])[0].c_str();
						replaceAll(type, "search_", "");
						DialogHandle::Growscan_Floating(peer, search, type);
					}
					if (button.substr(0, 11) == "findObject_") {
						uint16_t item_ = std::atoi(button.substr(11).c_str());
						if (item_ <= 0 || item_ > items.size()) return;
						sendArrow(peer, item_, true);
					}
					if (button == "worldBlocks") DialogHandle::Growscan_Blocks(peer, "start", "1");
					if (button == "floatingItems") DialogHandle::Growscan_Floating(peer, "start", "1");
				}
			}
		}
		else {
			string isStatsWorldBlockUsableByPublic = parser.get("isStatsWorldBlockUsableByPublic", 1);
			string isStatsFloatingItemsUsableByPublic = parser.get("isStatsFloatingItemsUsableByPublic", 1);
			if (!isValidCheckboxInput(isStatsWorldBlockUsableByPublic) or !isValidCheckboxInput(isStatsFloatingItemsUsableByPublic)) return;
			std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [&](const World& a) { return a.name == pInfo(peer)->world; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				world_->fresh_world = true;
				WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
				if (block_->fg != 6016) return;
				if (Only_Access(peer, world_, block_)) {
					block_->spin = std::atoi(isStatsWorldBlockUsableByPublic.c_str());
					block_->invert = std::atoi(isStatsFloatingItemsUsableByPublic.c_str());
				}
			}
		}
	}
	static void dynamo(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		int uid = 0, x_ = std::atoi(get_embed(cch, "target_x").c_str()), y_ = std::atoi(get_embed(cch, "target_y").c_str());
		std::string name_ = pInfo(peer)->world;
		std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
			if (block_->fg != 6142) return;
			world_->fresh_world = true;
			if (to_lower(world_->owner_name) != to_lower(pInfo(peer)->tankIDName) and Role::Developer(peer) and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(peer)->tankIDName)) == world_->admins.end())) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Only the owner of this tile has access!", 0, 0);
				return;
			}
			if (parser.try_get("buttonClicked", button)) {
				if (button.substr(0, 14) == "dynamoOnceObj_") {
					for (int i_ = 0; i_ < world_->drop_new.size(); i_++) {
						if (world_->drop_new[i_][4] / 32 == y_ && world_->drop_new[i_][0] != 112 && world_->drop_new[i_][0] != 4490) {
							if (world_->drop_new[i_][3] / 32 == (x_ + (block_->flags & 0x00200000 ? -1 : 1)) or world_->drop_new[i_][3] / 32 == (x_ + (block_->flags & 0x00200000 ? -2 : 2)) or world_->drop_new[i_][3] / 32 == (x_ + (block_->flags & 0x00200000 ? -3 : 3))) {
								uid = std::atoi(button.substr(14).c_str());
								for (int i_ = 0; i_ < world_->drop_new.size(); i_++) {
									if (items[world_->drop_new[i_][0]].untradeable == 0 && world_->drop_new[i_][0] != 0 && world_->drop_new[i_][3] > 0 && world_->drop_new[i_][4] > 0 && world_->drop_new[i_][2] == uid) {
										gamepacket_t p;
										p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
										int c_ = world_->drop_new[i_][1];
										if (Inventory::Modify(peer, world_->drop_new[i_][0], c_) == 0) {
											p.Insert("You have extracted " + to_string(world_->drop_new[i_][1]) + " " + items[world_->drop_new[i_][0]].name + ".");
											int32_t to_netid = pInfo(peer)->netID;
											PlayerMoving data_{}, data2_{};
											data_.packetType = 14, data_.netID = 0, data_.plantingTree = world_->drop_new[i_][2];
											data2_.x = world_->drop_new[i_][3], data2_.y = world_->drop_new[i_][4], data2_.packetType = 19, data2_.plantingTree = 250, data2_.punchX = world_->drop_new[i_][0], data2_.punchY = pInfo(peer)->netID;
											BYTE* raw = packPlayerMoving(&data_);
											BYTE* raw2 = packPlayerMoving(&data2_);
											raw2[3] = 5;
											Memory_Copy(raw2 + 8, &to_netid, 4);
											for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
												if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(cp_)->world != name_) continue;
												send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
												send_raw(cp_, 4, raw2, 56, ENET_PACKET_FLAG_RELIABLE);
											}
											delete[]raw, raw2;
											world_->drop_new.erase(world_->drop_new.begin() + i_);
										}
										else p.Insert("No inventory space.");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(peer);
									}
								}
							}
							else {
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "The target position is too far away!", 0, 0);
								return;
							}
						}
					}
				}
			}
		}
	}
	static void extractor(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		int got = 0, uid = 0;
		int x_ = std::atoi(get_embed(cch, "target_x").c_str()), y_ = std::atoi(get_embed(cch, "target_y").c_str());
		std::string name_ = pInfo(peer)->world;
		std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			world_->fresh_world = true;
			if (to_lower(world_->owner_name) != to_lower(pInfo(peer)->tankIDName) and Role::Developer(peer) and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(peer)->tankIDName)) == world_->admins.end())) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Only the owner of this tile has access!", 0, 0);
				return;
			}
			if (parser.try_get("buttonClicked", button)) {
				if (button.substr(0, 15) == "extractOnceObj_" and pInfo(peer)->lastwrenchb == 6140) {
					int x2 = pInfo(peer)->x / 32, y2 = pInfo(peer)->y / 32;
					if (x2 >= x_ - 3 && x2 <= x_ + 3 && y2 >= y_ - 3 && y2 <= y_ + 3) {
						Inventory::Modify(peer, 6140, got);
						uid = std::atoi(button.substr(15).c_str());
						if (got >= 1) {
							for (int i_ = 0; i_ < world_->drop_new.size(); i_++) {
								if (items[world_->drop_new[i_][0]].untradeable == 0 && world_->drop_new[i_][0] != 0 && world_->drop_new[i_][3] > 0 && world_->drop_new[i_][4] > 0 && world_->drop_new[i_][2] == uid) {
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
									int c_ = world_->drop_new[i_][1];
									if (Inventory::Modify(peer, world_->drop_new[i_][0], c_) == 0) {
										Inventory::Modify(peer, 6140, got = -1);
										p.Insert("You have extracted " + to_string(world_->drop_new[i_][1]) + " " + items[world_->drop_new[i_][0]].name + ".");
										int32_t to_netid = pInfo(peer)->netID;
										PlayerMoving data_{}, data2_{};
										data_.packetType = 14, data_.netID = 0, data_.plantingTree = world_->drop_new[i_][2];
										data2_.x = world_->drop_new[i_][3], data2_.y = world_->drop_new[i_][4], data2_.packetType = 19, data2_.plantingTree = 250, data2_.punchX = world_->drop_new[i_][0], data2_.punchY = pInfo(peer)->netID;
										BYTE* raw = packPlayerMoving(&data_);
										BYTE* raw2 = packPlayerMoving(&data2_);
										raw2[3] = 5;
										Memory_Copy(raw2 + 8, &to_netid, 4);
										for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
											if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(cp_)->world != name_) continue;
											send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											send_raw(cp_, 4, raw2, 56, ENET_PACKET_FLAG_RELIABLE);
										}
										delete[]raw, raw2;
										world_->drop_new.erase(world_->drop_new.begin() + i_);
									}
									else p.Insert("No inventory space.");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(peer);
								}
							}
						}
					}
					else {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "The target position is too far away!", 0, 0);
						return;
					}
				}
			}
		}
	}
	static void ultra_world_spray(ENetPeer* peer, std::string cch) {
		int used_item = pInfo(peer)->lastwrenchb;
		if (used_item == 5926) {
			int total1 = std::atoi(get_embed(cch, "ungrow_tree").c_str()), total2 = std::atoi(get_embed(cch, "ungrow_provider").c_str());
			if (total1 == 0 and total2 == 0) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "I'm not wasting " + items[used_item].name + " on an empty un-grow tree and provider!", 0, 0);
				return;
			}
			string name = pInfo(peer)->world;
			std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name](const World& a) { return a.name == name; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				int ySize = world_->blocks.size() / 100, xSize = world_->blocks.size() / ySize;
				if (to_lower(world_->owner_name) == to_lower(pInfo(peer)->tankIDName) || find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(peer)->tankIDName)) != world_->admins.end()) {
					int c_ = 0;
					Inventory::Modify(peer, 5926, c_ = -1);
					for (int f = 0; f < world_->blocks.size(); f++) {
						int x = f % xSize, y = f / xSize;
						WorldBlock* block_ = &world_->blocks[f];
						if (items[world_->blocks[f].fg].blockType == PROVIDER || items[world_->blocks[f].fg].blockType == SEED) {
							world_->blocks[f].planted = 0;
						}
					}
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (pInfo(cp_)->world == name) {
							pInfo(cp_)->spray_x = pInfo(cp_)->x;
							pInfo(cp_)->spray_y = pInfo(cp_)->y;
							exit_(cp_, true);
							pInfo(cp_)->x = pInfo(cp_)->spray_x;
							pInfo(cp_)->y = pInfo(cp_)->spray_y;
							join_world(cp_, name, pInfo(cp_)->spray_x / 32, pInfo(cp_)->spray_y / 32);
							pInfo(cp_)->x = pInfo(cp_)->spray_x;
							pInfo(cp_)->y = pInfo(cp_)->spray_y;
							pInfo(cp_)->spray_x = 0;
							pInfo(cp_)->spray_y = 0;
						}
					}
				}
				else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You must own the world!", 0, 0);
			}
		}
	}
	static void deluxe_world_spray(ENetPeer* peer, std::string cch) {
		if (Playmods::HasById(pInfo(peer), 144)) {
			VarList::OnConsoleMessage(peer, "`6>> That's sort of hard to do while having a cooldown.``");
		}
		else {
			int used_item = pInfo(peer)->lastwrenchb;
			if (used_item == 13574) {
				int total = std::atoi(get_embed(cch, "ungrow_tree").c_str());
				if (total == 0) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "I'm not wasting " + items[used_item].name + " on an empty un-grow tree!", 0, 0);
					return;
				}
				string name = pInfo(peer)->world;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name](const World& a) { return a.name == name; });
				if (p != worlds.end()) {
					World* world = &worlds[p - worlds.begin()];
					world->fresh_world = true;
					int ySize = world->blocks.size() / 100, xSize = world->blocks.size() / ySize;
					if (to_lower(world->owner_name) == to_lower(pInfo(peer)->tankIDName) || Role::Developer(peer) || find(world->admins.begin(), world->admins.end(), to_lower(pInfo(peer)->tankIDName)) != world->admins.end()) {
						int remove = -1;
						if (Inventory::Modify(peer, used_item, remove) == 0) {
							Playmods::Add(peer, 144);
							for (int f = 0; f < world->blocks.size(); f++) {
								int x = f % xSize, y = f / xSize;
								WorldBlock* block_ = &world->blocks[f];
								if (items[world->blocks[f].fg].blockType == SEED) {
									world->blocks[f].planted -= 86400;
								}
							}
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
								if (pInfo(cp_)->world == name) {
									pInfo(cp_)->spray_x = pInfo(cp_)->x;
									pInfo(cp_)->spray_y = pInfo(cp_)->y;
									exit_(cp_, true);
									pInfo(cp_)->x = pInfo(cp_)->spray_x;
									pInfo(cp_)->y = pInfo(cp_)->spray_y;
									join_world(cp_, name, pInfo(cp_)->spray_x / 32, pInfo(cp_)->spray_y / 32);
									pInfo(cp_)->x = pInfo(cp_)->spray_x;
									pInfo(cp_)->y = pInfo(cp_)->spray_y;
									pInfo(cp_)->spray_x = 0;
									pInfo(cp_)->spray_y = 0;
								}
							}
						}
					}
					else {
						VarList::OnConsoleMessage(peer, "`wYou must own the world!``");
					}
				}
			}
		}
	}
	static void GrowPass(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "", point_ = "";
		int remove_grow_points = 0;
		if (parser.try_get("buttonClicked", button)) {
			if (button == "tab_tasks") DialogHandle::GrowPass(peer, "Tasks");
			if (button == "tab_rewards") DialogHandle::GrowPass(peer, "Rewards");
			if (button == "tab_perks") DialogHandle::GrowPass(peer, "Perks");
			if (button == "next") {
				if (pInfo(peer)->tb_1or2 == "1") DialogHandle::GrowPass(peer, "Rewards", "2");
				else if (pInfo(peer)->tb_1or2 == "2") DialogHandle::GrowPass(peer, "Rewards", "3");
				else if (pInfo(peer)->tb_1or2 == "3") DialogHandle::GrowPass(peer, "Rewards", "4");
			}
			if (button == "previous") {
				if (pInfo(peer)->tb_1or2 == "2") DialogHandle::GrowPass(peer, "Rewards", "1");
				else if (pInfo(peer)->tb_1or2 == "3") DialogHandle::GrowPass(peer, "Rewards", "2");
				else if (pInfo(peer)->tb_1or2 == "4") DialogHandle::GrowPass(peer, "Rewards", "3");
			}
			if (button == "back") {
				if (pInfo(peer)->tb_1or2 == "1") DialogHandle::GrowPass(peer, "Rewards", "1");
				else if (pInfo(peer)->tb_1or2 == "2") DialogHandle::GrowPass(peer, "Rewards", "2");
				else if (pInfo(peer)->tb_1or2 == "3") DialogHandle::GrowPass(peer, "Rewards", "3");
				else if (pInfo(peer)->tb_1or2 == "4") DialogHandle::GrowPass(peer, "Rewards", "4");
			}
			if (button == "Purchase_GrowPass") DialogHandle::Shop_Assets(peer);
			if (button == "life_goals") DialogHandle::Life_Goals(peer);
			if (button == "daily_quests") DialogHandle::Daily_Quest_Info(peer);
			if (button == "role_quests") Role_Quest::Dialog(peer);
			if (button.substr(0, 6) == "claim_") {
				point_ = button.substr(6);
				if (point_ == "p2p_150") remove_grow_points = 150;
				else if (point_ == "p2p_300") remove_grow_points = 300;
				else if (point_ == "p2p_450") remove_grow_points = 450;
				else if (point_ == "p2p_600") remove_grow_points = 600;
				else if (point_ == "p2p_750") remove_grow_points = 750;
				else if (point_ == "p2p_900") remove_grow_points = 900;
				else if (point_ == "f2p_150") remove_grow_points = 150;
				else if (point_ == "f2p_300") remove_grow_points = 300;
				else if (point_ == "f2p_600") remove_grow_points = 600;
				else if (point_ == "f2p_900") remove_grow_points = 900;
				else if (point_ == "p2p_1100") remove_grow_points = 1100;
				else if (point_ == "p2p_1300") remove_grow_points = 1300;
				else if (point_ == "p2p_1500") remove_grow_points = 1500;
				else if (point_ == "p2p_1700") remove_grow_points = 1700;
				else if (point_ == "p2p_1900") remove_grow_points = 1900;
				else if (point_ == "p2p_2100") remove_grow_points = 2100;
				else if (point_ == "f2p_1300") remove_grow_points = 1300;
				else if (point_ == "f2p_1700") remove_grow_points = 1700;
				else if (point_ == "f2p_2100") remove_grow_points = 2100;
				else if (point_ == "p2p_2350") remove_grow_points = 2350;
				else if (point_ == "p2p_2600") remove_grow_points = 2600;
				else if (point_ == "p2p_2850") remove_grow_points = 2850;
				else if (point_ == "p2p_3100") remove_grow_points = 3100;
				else if (point_ == "p2p_3350") remove_grow_points = 3350;
				else if (point_ == "p2p_3600") remove_grow_points = 3600;
				else if (point_ == "f2p_2600") remove_grow_points = 2600;
				else if (point_ == "f2p_3100") remove_grow_points = 3100;
				else if (point_ == "f2p_3600") remove_grow_points = 3600;
				else if (point_ == "p2p_3900") remove_grow_points = 3900;
				else if (point_ == "p2p_4200") remove_grow_points = 4200;
				else if (point_ == "p2p_4500") remove_grow_points = 4500;
				else if (point_ == "p2p_4800") remove_grow_points = 4800;
				else if (point_ == "p2p_5100") remove_grow_points = 5100;
				else if (point_ == "p2p_5400") remove_grow_points = 5400;
				else if (point_ == "f2p_4200") remove_grow_points = 4200;
				else if (point_ == "f2p_4800") remove_grow_points = 4800;
				else if (point_ == "f2p_5400") remove_grow_points = 5400;
			}
			if (remove_grow_points != 0 and pInfo(peer)->gp) {
				if (pInfo(peer)->growpass_points >= remove_grow_points) {
					if (not Has_Claimed::Gpass(peer, button)) {
						if (Gp_Prize[point_].first == 10858) {
							pInfo(peer)->growpass_prizes.push_back(button);
							VarList::OnSetVouchers(peer, Gp_Prize[point_].second);
						}
						else if (Gp_Prize[point_].first == 15014) {
							pInfo(peer)->growpass_prizes.push_back(button);
							pInfo(peer)->Wrench_Style.push_back(15014);
						}
						else {
							int give_now = Gp_Prize[point_].second;
							if (Inventory::Modify(peer, Gp_Prize[point_].first, give_now) == 0) {
								pInfo(peer)->growpass_prizes.push_back(button);
							}
							else VarList::OnConsoleMessage(peer, "No inventory space.");
						}
						string text = "`9Claimed " + to_string(Gp_Prize[point_].second) + " " + items[Gp_Prize[point_].first].ori_name + " from Grow Pass rewards!``";
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, text, 0, 0);
						VarList::OnConsoleMessage(peer, text);
						if (pInfo(peer)->tb_1or2 == "1") DialogHandle::GrowPass(peer, "Rewards", "1");
						else if (pInfo(peer)->tb_1or2 == "2") DialogHandle::GrowPass(peer, "Rewards", "2");
						else if (pInfo(peer)->tb_1or2 == "3") DialogHandle::GrowPass(peer, "Rewards", "3");
						else if (pInfo(peer)->tb_1or2 == "4") DialogHandle::GrowPass(peer, "Rewards", "4");
					}
				}
				else VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wReward Details`|left|9222|\nadd_spacer|small|\nadd_label_with_icon|big| " + to_string(Gp_Prize[point_].second) + " " + items[Gp_Prize[point_].first].ori_name + "|left|" + to_string(Gp_Prize[point_].first) + "|\nadd_textbox|" + items[Gp_Prize[point_].first].description + "|left|\nadd_spacer|small|\nadd_textbox|Earn `2" + to_string(remove_grow_points) + " Grow Pass Points`` and become a `5Royal Grow Pass Member``  to claim this reward.|left|\nadd_spacer|small|\nadd_textbox|`5This reward is only available for players with the `5Royal Grow Pass``.``|left|" + (pInfo(peer)->gp ? "" : "\nadd_button|Purchase_GrowPass|`oPurchase `5Royal Grow Pass|noflags|0|0|") + "\nadd_spacer|small|\nadd_quick_exit|\nadd_button|back|OK|noflags|0|0|\nend_dialog|GrowPass|||");
			}
		}
	}
	static void dnaproc(ENetPeer* peer, std::string cch) {
		std::string name_ = pInfo(peer)->world;
		std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			world_->fresh_world = true;
			WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
			if (not Only_Access(peer, world_, block_) or block_->fg != 4080) return;
			int DNAID;
			int remove = 0 - 1;
			int add = 1;
			if (cch.find("tilex|") != string::npos and cch.find("tiley|") != std::string::npos) {
				int x_ = std::atoi(explode("\n", explode("tilex|", cch)[1])[0].c_str()), y_ = std::atoi(explode("\n", explode("tiley|", cch)[1])[0].c_str());
				std::stringstream ss(cch);
				std::string to;
				try {
					while (std::getline(ss, to, '\n')) {
						std::vector<std::string> infoDat = explode("|", to);
						if (infoDat.at(0) == "choose") {
							DNAID = std::atoi(infoDat.at(1).c_str());
							if (DNAID < 0 or DNAID > items.size()) return;
							if (items[DNAID].name.find("Dino DNA Strand") != string::npos || items[DNAID].name.find("Plant DNA Strand") != string::npos || items[DNAID].name.find("Raptor DNA Strand") != std::string::npos) {
								if (block_->shelf_4 == 0) {
									block_->shelf_1 = DNAID;
									block_->shelf_4 = 1;
									Inventory::Modify(peer, DNAID, remove);
									DialogHandle::DNA_Processor(peer, x_, y_, false, true, false, 0, true, false);
								}
								else if (block_->shelf_4 == 1) {
									block_->shelf_2 = DNAID;
									block_->shelf_4 = 2;
									Inventory::Modify(peer, DNAID, remove);
									DialogHandle::DNA_Processor(peer, x_, y_, false, true, false, 0, true, false);
								}
								else if (block_->shelf_4 == 2) {
									block_->shelf_3 = DNAID;
									block_->shelf_4 = 3;
									Inventory::Modify(peer, DNAID, remove);
									int DnaNumber1 = 0, DnaNumber2 = 0, DnaNumber3 = 0, What = 0;
									ifstream infile("database/text/DnaRecipe.txt");
									for (string line; getline(infile, line);) {
										if (line.length() > 3 && line.at(0) != '/' && line.at(1) != '/') {
											auto ex = explode("|", line);
											int id1 = std::atoi(ex.at(0).c_str());
											int id2 = std::atoi(ex.at(1).c_str());
											int id3 = std::atoi(ex.at(2).c_str());
											if (id1 == block_->shelf_1 && id2 == block_->shelf_2 && id3 == block_->shelf_3) {
												DnaNumber1 = std::atoi(ex.at(0).c_str());
												DnaNumber2 = std::atoi(ex.at(1).c_str());
												DnaNumber3 = std::atoi(ex.at(2).c_str());
												What = std::atoi(ex.at(3).c_str());
												return;
											}
										}
									}
									infile.close();
									if (block_->shelf_1 == DnaNumber1 && block_->shelf_2 == DnaNumber2 && block_->shelf_3 == DnaNumber3 && DnaNumber3 != 0 && DnaNumber2 != 0 && DnaNumber1 != 0 && What != 0) {
										DialogHandle::DNA_Processor(peer, x_, y_, false, true, false, 0, true, false);
									}
									else {
										if (block_->shelf_4 >= 1) {
											DialogHandle::DNA_Processor(peer, x_, y_, false, true, false, 0, true, true);
										}
										else {
											DialogHandle::DNA_Processor(peer, x_, y_, false, false, false, 0, true, true);
										}
									}
								}
							}
							else {
								if (block_->shelf_4 >= 1) {
									DialogHandle::DNA_Processor(peer, x_, y_, true, false, false, 0, true, false);
								}
								else {
									DialogHandle::DNA_Processor(peer, x_, y_, true, false, false, 0, false, false);
								}
							}
						}
					}
				}
				catch (const std::out_of_range& e) {
					Logger::Info("ERROR", "in Dialog 'dnaproc': [" + std::string(e.what()) + "]");
				}
				if (cch.find("buttonClicked|remove0") != std::string::npos) {
					if (block_->shelf_4 == 1) {
						int DNARemoved = block_->shelf_1;
						Inventory::Modify(peer, DNARemoved, add);
						block_->shelf_1 = 0;
						block_->shelf_4 = 0;
						DialogHandle::DNA_Processor(peer, x_, y_, false, false, true, DNARemoved, false, false);
					}
					if (block_->shelf_4 == 2) {
						int DNARemoved = block_->shelf_1;
						Inventory::Modify(peer, DNARemoved, add);
						block_->shelf_1 = block_->shelf_2;
						block_->shelf_2 = 0;
						block_->shelf_4 = 1;
						DialogHandle::DNA_Processor(peer, x_, y_, false, false, true, DNARemoved, true, false);
					}
					if (block_->shelf_4 == 3) {
						int DNARemoved = block_->shelf_1;
						Inventory::Modify(peer, DNARemoved, add);
						block_->shelf_1 = block_->shelf_2;
						block_->shelf_2 = block_->shelf_3;
						block_->shelf_3 = 0;
						block_->shelf_4 = 2;
						DialogHandle::DNA_Processor(peer, x_, y_, false, false, true, DNARemoved, true, false);
					}
				}
				if (cch.find("buttonClicked|remove1") != std::string::npos) {
					if (block_->shelf_4 == 2) {
						int DNARemoved = block_->shelf_2;
						Inventory::Modify(peer, DNARemoved, add);
						block_->shelf_2 = 0;
						block_->shelf_4 = 1;
						DialogHandle::DNA_Processor(peer, x_, y_, false, false, true, DNARemoved, true, false);
					}
					if (block_->shelf_4 == 3) {
						int DNARemoved = block_->shelf_2;
						Inventory::Modify(peer, DNARemoved, add);
						block_->shelf_2 = block_->shelf_3;
						block_->shelf_3 = 0;
						block_->shelf_4 = 2;
						DialogHandle::DNA_Processor(peer, x_, y_, false, false, true, DNARemoved, true, false);
					}
				}
				if (cch.find("buttonClicked|remove2") != std::string::npos) {
					if (block_->shelf_4 == 3) {
						int DNARemoved = block_->shelf_3;
						Inventory::Modify(peer, DNARemoved, add);
						block_->shelf_3 = 0;
						block_->shelf_4 = 2;
						DialogHandle::DNA_Processor(peer, x_, y_, false, false, true, DNARemoved, true, false);
					}
				}
				if (cch.find("buttonClicked|combine") != std::string::npos) {
					if (block_->shelf_4 == 3) {
						int DnaNumber1 = 0, DnaNumber2 = 0, DnaNumber3 = 0, What = 0;
						ifstream infile("database/text/DnaRecipe.txt");
						for (string line; getline(infile, line);) {
							if (line.length() > 3 && line.at(0) != '/' && line.at(1) != '/') {
								auto ex = explode("|", line);
								int id1 = std::atoi(ex.at(0).c_str());
								int id2 = std::atoi(ex.at(1).c_str());
								int id3 = std::atoi(ex.at(2).c_str());
								if (id1 == block_->shelf_1 && id2 == block_->shelf_2 && id3 == block_->shelf_3) {
									DnaNumber1 = std::atoi(ex.at(0).c_str());
									DnaNumber2 = std::atoi(ex.at(1).c_str());
									DnaNumber3 = std::atoi(ex.at(2).c_str());
									What = std::atoi(ex.at(3).c_str());
									return;
								}
							}
						}
						infile.close();
						if (block_->shelf_1 == DnaNumber1 && block_->shelf_2 == DnaNumber2 && block_->shelf_3 == DnaNumber3 && DnaNumber3 != 0 && DnaNumber2 != 0 && DnaNumber1 != 0 && What != 0) {
							int count = 1;
							Inventory::Modify(peer, What, count);
							if (items[What].clothType == ClothTypes::FEET) pInfo(peer)->feet = What;
							else if (items[What].clothType == ClothTypes::HAND) pInfo(peer)->hand = What;
							block_->shelf_1 = 0; block_->shelf_2 = 0; block_->shelf_3 = 0; block_->shelf_4 = 0;
							if (pInfo(peer)->C_QuestActive && pInfo(peer)->C_QuestKind == 15 && pInfo(peer)->C_QuestProgress < pInfo(peer)->C_ProgressNeeded) {
								pInfo(peer)->C_QuestProgress++;
								if (pInfo(peer)->C_QuestProgress >= pInfo(peer)->C_ProgressNeeded) {
									pInfo(peer)->C_QuestProgress = pInfo(peer)->C_ProgressNeeded;
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`9Ring Quest task complete! Go tell the Ringmaster!", 0, 0);
								}
							}
							VarList::OnConsoleMessage(peer, "DNA Processing complete! The DNA combined into a `2" + items[What].name + "``!");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "DNA Processing complete! The DNA combined into a `2" + items[What].name + "``!", 0, 0);
							Clothing_V2::Update(peer);
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL) continue;
								if (pInfo(cp_)->world == pInfo(peer)->world) {
									CAction::Effect(cp_, 44, (float)x_ * 32 + 16, (float)y_ * 32 + 16);
									PlayerMoving data_{};
									data_.packetType = 19, data_.plantingTree = 150, data_.netID = pInfo(peer)->netID;
									data_.punchX = What, data_.punchY = What;
									int32_t to_netid = pInfo(peer)->netID;
									BYTE* raw = packPlayerMoving(&data_);
									raw[3] = 3;
									Memory_Copy(raw + 8, &to_netid, 4);
									send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									delete[]raw;
								}
							}
						}
						else {
							DialogHandle::DNA_Processor(peer, x_, y_, false, false, false, 0, true, true);
						}

					}
				}
			}
		}
	}
	static void dnaget(ENetPeer* peer, std::string cch) {
		if (cch.find("tilex|") != std::string::npos and cch.find("tiley|") != std::string::npos and cch.find("item|") != std::string::npos) {
			int x_ = std::atoi(explode("\n", explode("tilex|", cch)[1])[0].c_str()), y_ = std::atoi(explode("\n", explode("tiley|", cch)[1])[0].c_str());
			int item = std::atoi(explode("\n", explode("item|", cch)[1])[0].c_str());
			vector<int> list_{ 3942,3946,3948,3950 };
			if (find(list_.begin(), list_.end(), item) == list_.end()) return;
			int remove = -1;
			if (Inventory::Modify(peer, item, remove) == 0) {
				int Random = rand() % 100, reward = 0, count = 1;
				vector<int> list{ 4082, 4084, 4086, 4088, 4090, 4092, 4120, 4122, 5488 };
				if (Random >= 4 and Random <= 10) {
					reward = list[rand() % list.size()];
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You ground up a " + items[item].name + ", `9and found " + items[reward].name + " inside!``");
					VarList::OnConsoleMessage(peer, "You ground up a " + items[item].name + ", `9and found " + items[reward].name + " inside!``");
					Inventory::Modify(peer, reward, count);
				}
				else if (Random >= 1 and Random <= 3) {
					VarList::OnConsoleMessage(peer, "Wow! You discovered the missing link between cave-rayman and the modern Growtopian.");
					reward = 5488;
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You ground up a " + items[item].name + ", `9and found " + items[reward].name + " inside!``");
					VarList::OnConsoleMessage(peer, "You ground up a " + items[item].name + ", `9and found " + items[reward].name + " inside!``");
					Inventory::Modify(peer, reward, count);
				}
				else {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You ground up a " + items[item].name + ", `3but any DNA inside was destroyed in the process.``");
					VarList::OnConsoleMessage(peer, "You ground up a " + items[item].name + ", `3but any DNA inside was destroyed in the process.``");
				}
				for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
					if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL) continue;
					if (pInfo(cp_)->world == pInfo(peer)->world) {
						if (reward != 0) {
							CAction::Log(cp_, "action|play_sfx\nfile|audio/bell.wav\ndelayMS|0");
							PlayerMoving data_{};
							data_.packetType = 19, data_.plantingTree = 150, data_.netID = pInfo(peer)->netID;
							data_.punchX = reward, data_.punchY = reward;
							int32_t to_netid = pInfo(peer)->netID;
							BYTE* raw = packPlayerMoving(&data_);
							raw[3] = 3;
							Memory_Copy(raw + 8, &to_netid, 4);
							send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							delete[]raw;
						}
						else {
							CAction::Log(cp_, "action|play_sfx\nfile|audio/ch_start.wav\ndelayMS|0");
						}
					}
				}
			}
		}
	}
	static void inv_rm(ENetPeer* peer, std::string cch) {
		if (pInfo(peer)->tankIDName == "Ocho") {
			TextScanner parser(cch);
			std::string button = "";
			if (parser.try_get("buttonClicked", button)) {
				if (button.substr(0, 25) == "searchableItemListButton_") {
					std::string targetName = get_embed(cch, "target_name");
					int itemid = std::atoi(button.substr(25).c_str());
					if (itemid < 0 or itemid > items.size() or targetName.empty()) return;
					for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) {
						if (pInfo(peer)->inv[i_].first == itemid) {
							if (pInfo(peer)->inv[i_].second > 200) {
								pInfo(peer)->inv[i_].first = 0;
								pInfo(peer)->inv[i_].second = 0;
								Inventory::Visuals(peer);
							}
						}
					}
					if (itemid == 18 || itemid == 32 || itemid == 6336 || itemid == 9384) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Sorry, you can't remove " + items[itemid].name + " from user inventory!");
						VarList::OnConsoleMessage(peer, "Sorry, you can't remove " + items[itemid].name + " from user inventory!");
						DialogHandle::View_Inventory(peer, targetName);
						return;
					}
					bool isOnline = false;
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL) continue;
						if (to_lower(pInfo(cp_)->tankIDName) == to_lower(targetName)) {
							int getTotal = 0;
							Inventory::Modify(cp_, itemid, getTotal);
							if (Inventory::Modify(cp_, itemid, getTotal *= -1) == 0) {
								VarList::OnConsoleMessage(peer, ">> You removed `2" + items[itemid].name + " `ofrom " + pInfo(cp_)->tankIDName + "'s inventory");
								VarList::OnConsoleMessage(cp_, ">> `2" + items[itemid].name + " `oremoved from your inventory ");
								ServerPool::Logs::Add(pInfo(peer)->tankIDName + " took " + to_string(getTotal) + " " + items[itemid].name + " from " + pInfo(cp_)->tankIDName, "Inventory Steal");
							}
							isOnline = true;
							return;
						}
					}
					if (!isOnline) {
						bool isItemFound = 0;
						auto inventory = getOfflineInventory(targetName);
						auto it = std::find_if(inventory.begin(), inventory.end(), [&itemid](const std::pair<int, int>& element) { return element.first == itemid; });
						if (it != inventory.end()) {
							ServerPool::Logs::Add(pInfo(peer)->tankIDName + " took " + to_string(it->second) + " " + items[itemid].name + " from " + targetName, "Inventory Steal");
							it->first = 0;
							it->second = 0;
							if (saveOfflineInventory(targetName, inventory)) {
								VarList::OnConsoleMessage(peer, ">> You removed " + items[itemid].name + " from " + targetName + "'s inventory");
								isItemFound = true;
							}
						}
						if (!isItemFound) {
							VarList::OnConsoleMessage(peer, "`o>> " + items[itemid].name + " not found in user inventory!");
						}
					}
				}
			}
		}
	}
	static void set_newget(ENetPeer* peer, std::string cch) {
		if (not Role::Clist(pInfo(peer)->tankIDName)) return;
		TextScanner parser(cch);
		int id = 0;
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "back") DialogHandle::NewbieGet(peer);
			if (button == "Confirm_Add_Items") {
				string count_items = parser.get("count_items", 1);
				if (not is_number(count_items)) return;
				int i_ = std::atoi(get_embed(cch, "item_id").c_str()), c_ = std::atoi(count_items.c_str());
				if (c_ > 200 or c_ < 1 or i_ < 0 or i_ > items.size() or items[i_].blockType == SEED || items[i_].name.find("Wrench") != string::npos || items[i_].name.find("null_item") != string::npos || items[i_].name.find("null") != string::npos || items[i_].name.find("Guild Flag") != string::npos || items[i_].name.find("Guild Entrance") != string::npos || items[i_].name.find("Guild Banner") != string::npos || items[i_].name.find("Guild Key") != string::npos || items[i_].name.find("World Key") != string::npos || i_ == 5640 || i_ == 5814 || i_ == 18 || i_ == 6336 || i_ == 9384) return;
				pInfo(peer)->n_items.push_back({ i_, c_ });
				DialogHandle::NewbieGet(peer);
				VarList::OnTextOverlay(peer, "`2Succesfully added items!");
			}
			if (button == "remove_newget") {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wSuccessfully removed NewGet.", 0, 1);
				VarList::OnConsoleMessage(peer, "`o>> Successfully removed NewGet");
				for (int i_ = 0; i_ < new_get.list.size();) {
					new_get.list.erase(new_get.list.begin() + i_);
				}
				EventPool::Save::Config();
				DialogHandle::NewbieGet(peer);
			}
			if (button == "back") {
				DialogHandle::NewbieGet(peer);
			}
			if (button.find("a_") != std::string::npos) {
				std::regex number_regex("\\d+");
				std::smatch matches;
				int id = 0, size_ = 0;
				auto search_start = button.cbegin();
				for (int match_index = 0; std::regex_search(search_start, button.cend(), matches, number_regex); ++match_index) {
					int number = std::stoi(matches[0]);
					if (match_index == 0) size_ = number;
					else if (match_index == 1) id = number;
					search_start = matches.suffix().first;
				}
				if (new_get.list.size() < 0) return;
				if (size_ > new_get.list.size()) return;
				for (int c_ = 0; c_ < new_get.list.size(); c_++) {
					if (size_ == c_) {
						if (id == 14590) {
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n"
								"add_label_with_icon|big|`2Modify `2Gems``|left|" + to_string(id) + "|\n"
								"add_smalltext|`oNOTE: Set the Amount to 0 to remove the item from the NewBie Get list|\n"
								"add_text_input|count|Amount:|" + to_string(new_get.list[c_].Gemss) + "|10|\n"
								"embed_data|itemID|" + to_string(id) + "\nembed_data|cnt|" + to_string(c_) + "\n"
								"\nadd_spacer|small|\nadd_custom_button|back|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|Confirm_Change2|textLabel:`wConfirm!;anchor:_button_back;left:1;margin:60,0;|\nend_dialog|set_newget|||\n"
								"add_quick_exit|", 200);
						}
						if (id == 244) {
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n"
								"add_label_with_icon|big|`2Modify `2" + Environment()->server_name + " " + items[id].name + "``|left|" + to_string(id) + "|\n"
								"add_smalltext|`oNOTE: Set the Amount to 0 to remove the item from the NewBie Get list|\n"
								"add_text_input|count|Amount:|" + to_string(new_get.list[c_].Coin) + "|10|\n"
								"embed_data|itemID|" + to_string(id) + "\nembed_data|cnt|" + to_string(c_) + "\n"
								"\nadd_spacer|small|\nadd_custom_button|back|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|Confirm_Change2|textLabel:`wConfirm!;anchor:_button_back;left:1;margin:60,0;|\nend_dialog|set_newget|||\n"
								"add_quick_exit|", 200);
						}
						if (id == guild_event_id) {
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n"
								"add_label_with_icon|big|`2Modify `2" + items[id].name + "``|left|" + to_string(id) + "|\n"
								"add_smalltext|`oNOTE: Set the Amount to 0 to remove the item from the NewBie Get list|\n"
								"add_text_input|count|Amount:|" + to_string(new_get.list[c_].Seasonals_Token) + "|10|\n"
								"embed_data|itemID|" + to_string(id) + "\nembed_data|cnt|" + to_string(c_) + "\n"
								"\nadd_spacer|small|\nadd_custom_button|back|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|Confirm_Change2|textLabel:`wConfirm!;anchor:_button_back;left:1;margin:60,0;|\nend_dialog|set_newget|||\n"
								"add_quick_exit|", 200);
						}
					}
				}
			}
			if (button == "Confirm_Change2") {
				if (new_get.list.size() < 0) return;
				TextScanner parser(cch);
				string count = parser.get("count", 1);
				int targetID = std::atoi(get_embed(cch, "itemID").c_str()), cnt = std::atoi(get_embed(cch, "cnt").c_str()), amount = std::atoi(count.c_str());
				if (amount < 0 || count.size() > 10 || not is_number(count) or cnt > new_get.list.size() or targetID != 14590 and targetID != 244 and targetID != guild_event_id) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input!", 0, 1);
					return;
				}
				if (targetID == 14590) {
					NewbieGet::updateGems(cnt, (amount != 0 ? true : false), amount);
				}
				else if (targetID == 244) {
					NewbieGet::updateCoin(cnt, (amount != 0 ? true : false), amount);
				}
				else if (targetID == guild_event_id) {
					NewbieGet::updateToken(cnt, (amount != 0 ? true : false), amount);
				}
				EventPool::Save::Config();
				DialogHandle::NewbieGet(peer);
			}
			if (button.substr(0, 0) == "") {
				if (new_get.list.size() < 0) return;
				int targetID = std::atoi(button.substr(0).c_str());
				for (int c_ = 0; c_ < new_get.list.size(); c_++) {
					if (targetID > new_get.list[c_].items.size()) return;
					for (int i_ = 0; i_ < new_get.list[c_].items.size(); i_++) {
						if (targetID == i_) {
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n"
								"add_label_with_icon|big|`2Modify `2" + items[new_get.list[c_].items[i_].first].name + "``|left|" + to_string(new_get.list[c_].items[i_].first) + "|\n"
								"add_smalltext|`oNOTE: Set the Amount to 0 to remove the item from the NewBie Get list|\n"
								"add_text_input|count|Amount:|" + to_string(new_get.list[c_].items[i_].second) + "|3|\n"
								"embed_data|itemID|"
								+ to_string(new_get.list[c_].items[i_].first) + "\n"
								"\nadd_spacer|small|\nadd_custom_button|back|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|Confirm_Change|textLabel:`wConfirm!;anchor:_button_back;left:1;margin:60,0;|\nend_dialog|set_newget|||\n"
								"add_quick_exit|", 200);
						}
					}
				}
			}
			if (button == "Confirm_Change") {
				if (new_get.list.size() < 0) return;
				TextScanner parser(cch);
				string count = parser.get("count", 1);
				int targetID = std::atoi(get_embed(cch, "itemID").c_str());
				int amount = std::atoi(count.c_str());
				if (amount < 0 || amount > 200 || not is_number(count)) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input!", 0, 1);
					return;
				}
				bool notfound = true;
				for (int c_ = 0; c_ < new_get.list.size(); c_++) {
					for (auto& item : new_get.list[c_].items) {
						if (targetID == item.first) {
							notfound = false;
							item.second = amount;
							if (amount == 0) {
								new_get.list[c_].items.erase(std::remove_if(new_get.list[c_].items.begin(), new_get.list[c_].items.end(), [targetID](const std::pair<int, int>& element) {return element.first == targetID; }), new_get.list[c_].items.end());
							}
						}
					}
					if (notfound) new_get.list[c_].items.push_back({ targetID, amount });
				}
				EventPool::Save::Config();
				DialogHandle::NewbieGet(peer);
			}
		}
		else if (parser.try_get("itemid", id)) {
			if (id < 0 or id > items.size() or items[id].blockType == SEED || items[id].name.find("Wrench") != string::npos || items[id].name.find("null_item") != string::npos || items[id].name.find("null") != string::npos || items[id].name.find("Guild Flag") != string::npos || items[id].name.find("Guild Entrance") != string::npos || items[id].name.find("Guild Banner") != string::npos || items[id].name.find("Guild Key") != string::npos || items[id].name.find("World Key") != string::npos || id == 5640 || id == 5814 || id == 18 || id == 6336 || id == 9384) return;
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`wAdd Items : " + items[id].name + "|left|982|\nadd_spacer|small|\nadd_textbox|`$Items:|left|\nembed_data|item_id|" + to_string(id) + "\nadd_label_with_icon|small|`2" + items[id].name + "|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`$Count:|left|\nadd_text_input|count_items|||4|\nadd_spacer|small|\nadd_custom_button|back|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|Confirm_Add_Items|textLabel:`wConfirm!;anchor:_button_back;left:1;margin:60,0;|\nend_dialog|set_newget|||");
		}
		else {
			string Amount_Gems = parser.get("Amount_Gems", 1), Amount_Wls = parser.get("Amount_Wls", 1), Amount_Token = parser.get("Amount_Token", 1);
			if (pInfo(peer)->n_items.size() == 0) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou must pick the items", 0, 1);
				return;
			}
			if (not Amount_Gems.empty()) {
				if (Amount_Gems.size() < 1 || atoi(Amount_Gems.c_str()) > 1000000000 || Amount_Gems.find_first_not_of("0123456789") != std::string::npos) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in Amount Gems!", 0, 1);
					return;
				}
			}
			if (not Amount_Wls.empty()) {
				if (Amount_Wls.size() < 1 || atoi(Amount_Wls.c_str()) > 1000000 || Amount_Wls.find_first_not_of("0123456789") != std::string::npos) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in Amount " + Environment()->server_name + " Coin!", 0, 1);
					return;
				}
			}
			if (not Amount_Token.empty()) {
				if (Amount_Token.size() < 1 || atoi(Amount_Token.c_str()) > 1000000 || Amount_Token.find_first_not_of("0123456789") != std::string::npos) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in Amount Token!", 0, 1);
					return;
				}
			}
			Newbie_Get list{};
			list.Gemss = (not Amount_Gems.empty() ? atoi(Amount_Gems.c_str()) : 0), list.Coin = (not Amount_Wls.empty() ? atoi(Amount_Wls.c_str()) : 0), list.Seasonals_Token = (not Amount_Token.empty() ? atoi(Amount_Token.c_str()) : 0);
			for (int i_ = 0; i_ < pInfo(peer)->n_items.size();) {
				int cc_ = pInfo(peer)->n_items.at(i_).second, id_ = pInfo(peer)->n_items.at(i_).first;
				list.items.push_back({ id_, cc_ });
				pInfo(peer)->n_items.erase(pInfo(peer)->n_items.begin() + i_);
			}
			new_get.list.push_back(list);
			DialogHandle::NewbieGet(peer);
			EventPool::Save::Config();
			VarList::OnTextOverlay(peer, "`2Succesfully added newbie get!");
		}
	}
	static void set_redeem(ENetPeer* peer, std::string cch) {
		if (not Role::Clist(pInfo(peer)->tankIDName)) return;
		TextScanner parser(cch);
		int id = 0;
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "back") DialogHandle::RedeemCode(peer);
			if (button == "Confirm_Add_Items") {
				string count_items = parser.get("count_items", 1);
				if (not is_number(count_items)) return;
				int i_ = std::atoi(get_embed(cch, "item_id").c_str()), c_ = std::atoi(count_items.c_str());
				if (c_ > 200 or c_ < 1 or i_ < 0 or i_ > items.size() or items[i_].blockType == SEED || items[i_].name.find("Wrench") != string::npos || items[i_].name.find("null_item") != string::npos || items[i_].name.find("null") != string::npos || items[i_].name.find("Guild Flag") != string::npos || items[i_].name.find("Guild Entrance") != string::npos || items[i_].name.find("Guild Banner") != string::npos || items[i_].name.find("Guild Key") != string::npos || items[i_].name.find("World Key") != string::npos || i_ == 5640 || i_ == 5814 || i_ == 18 || i_ == 6336 || i_ == 9384) return;
				pInfo(peer)->r_items.push_back({ i_, c_ });
				DialogHandle::RedeemCode(peer);
				VarList::OnTextOverlay(peer, "`2Succesfully added items!");
			}
			if (button.substr(0, 12) == "remove_code_") {
				string r_code = button.substr(12);
				transform(r_code.begin(), r_code.end(), r_code.begin(), ::toupper);
				if (RedeemCode::Has_Code(r_code)) {
					RedeemCode::Remove_Code(r_code);
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wSuccessfully removed " + r_code + " from list redeem code.", 0, 1);
					VarList::OnConsoleMessage(peer, "`o>> Successfully removed " + r_code + " from list redeem code.");
					EventPool::Save::RedeemCode();
					DialogHandle::RedeemCode(peer);
				}
			}
			if (button.find("r_") != std::string::npos) {
				std::regex number_regex("\\d+");
				std::smatch matches;
				int targetID = 0, size_ = 0;
				auto search_start = button.cbegin();
				for (int match_index = 0; std::regex_search(search_start, button.cend(), matches, number_regex); ++match_index) {
					int number = std::stoi(matches[0]);
					if (match_index == 0) size_ = number;
					else if (match_index == 1) targetID = number;
					search_start = matches.suffix().first;
				}
				if (redeem_codev2.redeemcode.size() < 0 or size_ > redeem_codev2.redeemcode.size() or targetID > redeem_codev2.redeemcode[size_].items.size()) return;
				for (int i_ = 0; i_ < redeem_codev2.redeemcode[size_].items.size(); i_++) {
					if (targetID == i_) {
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n"
							"add_label_with_icon|big|`2Modify `2" + items[redeem_codev2.redeemcode[size_].items[i_].first].name + "``|left|" + to_string(redeem_codev2.redeemcode[size_].items[i_].first) + "|\n"
							"add_smalltext|`oNOTE: Set the Amount to 0 to remove the item from the NewBie Get list|\n"
							"add_text_input|count|Amount:|" + to_string(redeem_codev2.redeemcode[size_].items[i_].second) + "|3|\n"
							"embed_data|size_|"
							+ to_string(size_) + "\n"
							"embed_data|targetID|"
							+ to_string(targetID) + "\n"
							"embed_data|itemID|"
							+ to_string(redeem_codev2.redeemcode[size_].items[i_].first) + "\n"
							"\nadd_spacer|small|\nadd_custom_button|back|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|Confirm_Change|textLabel:`wConfirm!;anchor:_button_back;left:1;margin:60,0;|\nend_dialog|set_redeem|||\n"
							"add_quick_exit|", 200);
					}
				}
			}
			if (button == "Confirm_Change") {
				TextScanner parser(cch);
				string count = parser.get("count", 1);
				int size_ = std::atoi(get_embed(cch, "size_").c_str()), targetID = std::atoi(get_embed(cch, "targetID").c_str()), itemID = std::atoi(get_embed(cch, "itemID").c_str()), amount = std::atoi(count.c_str());
				if (redeem_codev2.redeemcode.size() < 0 or size_ > redeem_codev2.redeemcode.size() or targetID > redeem_codev2.redeemcode[size_].items.size()) return;
				if (amount < 0 || amount > 200 || not is_number(count)) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input!", 0, 1);
					return;
				}
				bool notfound = true;
				for (auto& item : redeem_codev2.redeemcode[size_].items) {
					if (itemID == item.first) {
						notfound = false;
						item.second = amount;
						if (amount == 0) {
							redeem_codev2.redeemcode[size_].items.erase(std::remove_if(redeem_codev2.redeemcode[size_].items.begin(), redeem_codev2.redeemcode[size_].items.end(), [itemID](const std::pair<int, int>& element) {return element.first == itemID; }), redeem_codev2.redeemcode[size_].items.end());
						}
					}
				}
				if (notfound) redeem_codev2.redeemcode[size_].items.push_back({ itemID, amount });
				EventPool::Save::RedeemCode();
				DialogHandle::RedeemCode(peer);
			}
			if (button.find("redeem_") != std::string::npos) {
				std::regex number_regex("\\d+");
				std::smatch matches;
				int id = 0, size_ = 0;
				auto search_start = button.cbegin();
				for (int match_index = 0; std::regex_search(search_start, button.cend(), matches, number_regex); ++match_index) {
					int number = std::stoi(matches[0]);
					if (match_index == 0) size_ = number;
					else if (match_index == 1) id = number;
					search_start = matches.suffix().first;
				}
				if (redeem_codev2.redeemcode.size() < 0) return;
				if (size_ > redeem_codev2.redeemcode.size()) return;
				for (int c_ = 0; c_ < redeem_codev2.redeemcode.size(); c_++) {
					if (size_ == c_) {
						if (id == 14590) { // GEMS
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n"
								"add_label_with_icon|big|`2Modify `2Gems``|left|" + to_string(id) + "|\n"
								"add_smalltext|`oNOTE: Set the Amount to 0 to remove the item from the Redeem Prize list|\n"
								"add_text_input|count|Amount:|" + to_string(redeem_codev2.redeemcode[c_].Gemss) + "|10|\n"
								"embed_data|itemID|" + to_string(id) + "\nembed_data|cnt|" + to_string(c_) + "\n"
								"\nadd_spacer|small|\nadd_custom_button|back|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|Confirm_Change2|textLabel:`wConfirm!;anchor:_button_back;left:1;margin:60,0;|\nend_dialog|set_redeem|||\n"
								"add_quick_exit|", 200);
						}
						if (id == 244) { // COIN
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n"
								"add_label_with_icon|big|`2Modify `2" + Environment()->server_name + " " + items[id].name + "``|left|" + to_string(id) + "|\n"
								"add_smalltext|`oNOTE: Set the Amount to 0 to remove the item from the Redeem Prize list|\n"
								"add_text_input|count|Amount:|" + to_string(redeem_codev2.redeemcode[c_].Coin) + "|10|\n"
								"embed_data|itemID|" + to_string(id) + "\nembed_data|cnt|" + to_string(c_) + "\n"
								"\nadd_spacer|small|\nadd_custom_button|back|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|Confirm_Change2|textLabel:`wConfirm!;anchor:_button_back;left:1;margin:60,0;|\nend_dialog|set_redeem|||\n"
								"add_quick_exit|", 200);
						}
						if (id == 1488) { // LEVEL
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n"
								"add_label_with_icon|big|`2Modify `2Level``|left|" + to_string(id) + "|\n"
								"add_smalltext|`oNOTE: Set the Amount to 0 to remove the item from the Redeem Prize list|\n"
								"add_text_input|count|Amount:|" + to_string(redeem_codev2.redeemcode[c_].Levell) + "|10|\n"
								"embed_data|itemID|" + to_string(id) + "\nembed_data|cnt|" + to_string(c_) + "\n"
								"\nadd_spacer|small|\nadd_custom_button|back|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|Confirm_Change2|textLabel:`wConfirm!;anchor:_button_back;left:1;margin:60,0;|\nend_dialog|set_redeem|||\n"
								"add_quick_exit|", 200);
						}
						if (id == 11304) { // GROWPASS
							redeem_codev2.redeemcode[c_].GrowPass = false;
							DialogHandle::RedeemCode(peer);
						}
						if (id == 9436) { // ROAD TO GLORY
							redeem_codev2.redeemcode[c_].RoadToGlory = false;
							DialogHandle::RedeemCode(peer);
						}
						if (id == 278) { // ROLE
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n"
								"add_label_with_icon|big|`2Modify `2Role``|left|" + to_string(id) + "|\n"
								"add_smalltext|`oNOTE: Set the Amount to 0 to remove the item from the Redeem Prize list|\n"
								"add_text_input|count|Amount:|" + to_string(redeem_codev2.redeemcode[c_].Player_Role) + "|10|\n"
								"embed_data|itemID|" + to_string(id) + "\nembed_data|cnt|" + to_string(c_) + "\n"
								"\nadd_spacer|small|\nadd_custom_button|back|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|Confirm_Change2|textLabel:`wConfirm!;anchor:_button_back;left:1;margin:60,0;|\nend_dialog|set_redeem|||\n"
								"add_quick_exit|", 200);
						}
						if (id == guild_event_id) { // SEASONAL COIN
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n"
								"add_label_with_icon|big|`2Modify `2" + items[id].name + "``|left|" + to_string(id) + "|\n"
								"add_smalltext|`oNOTE: Set the Amount to 0 to remove the item from the Redeem Prize list|\n"
								"add_text_input|count|Amount:|" + to_string(redeem_codev2.redeemcode[c_].Seasonals_Token) + "|10|\n"
								"embed_data|itemID|" + to_string(id) + "\nembed_data|cnt|" + to_string(c_) + "\n"
								"\nadd_spacer|small|\nadd_custom_button|back|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|Confirm_Change2|textLabel:`wConfirm!;anchor:_button_back;left:1;margin:60,0;|\nend_dialog|set_redeem|||\n"
								"add_quick_exit|", 200);
						}
					}
				}
			}
			if (button == "Confirm_Change2") {
				if (redeem_codev2.redeemcode.size() < 0) return;
				TextScanner parser(cch);
				string count = parser.get("count", 1);
				int targetID = std::atoi(get_embed(cch, "itemID").c_str()), cnt = std::atoi(get_embed(cch, "cnt").c_str()), amount = std::atoi(count.c_str());
				if (targetID == 278 and (amount < 1 or amount > 6)) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in Role! Please input 1-6.", 0, 1);
					return;
				}
				if (amount < 0 || count.size() > 10 || not is_number(count) or cnt > redeem_codev2.redeemcode.size() or targetID != 14590 and targetID != 244 and targetID != 1488 and targetID != 278 and targetID != guild_event_id) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input!", 0, 1);
					return;
				}
				if (targetID == 14590) {
					RedeemCode::updateGems(cnt, (amount != 0 ? true : false), amount);
				}
				else if (targetID == 244) {
					RedeemCode::updateCoin(cnt, (amount != 0 ? true : false), amount);
				}
				else if (targetID == 1488) {
					RedeemCode::updateLevel(cnt, (amount != 0 ? true : false), amount);
				}
				else if (targetID == 278) {
					RedeemCode::updateRole(cnt, (amount != 0 ? true : false), amount);
				}
				else if (targetID == guild_event_id) {
					RedeemCode::updateToken(cnt, (amount != 0 ? true : false), amount);
				}
				EventPool::Save::RedeemCode();
				DialogHandle::RedeemCode(peer);
			}
		}
		else if (parser.try_get("itemid", id)) {
			if (id < 0 or id > items.size() or items[id].blockType == SEED || items[id].name.find("Wrench") != string::npos || items[id].name.find("null_item") != string::npos || items[id].name.find("null") != string::npos || items[id].name.find("Guild Flag") != string::npos || items[id].name.find("Guild Entrance") != string::npos || items[id].name.find("Guild Banner") != string::npos || items[id].name.find("Guild Key") != string::npos || items[id].name.find("World Key") != string::npos || id == 5640 || id == 5814 || id == 18 || id == 6336 || id == 9384) return;
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`wAdd Items : " + items[id].name + "|left|982|\nadd_spacer|small|\nadd_textbox|`$Items:|left|\nembed_data|item_id|" + to_string(id) + "\nadd_label_with_icon|small|`2" + items[id].name + "|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`$Count:|left|\nadd_text_input|count_items|||4|\nadd_spacer|small|\nadd_custom_button|back|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|Confirm_Add_Items|textLabel:`wConfirm!;anchor:_button_back;left:1;margin:60,0;|\nend_dialog|set_redeem|||");
		}
		else {
			string r_code = parser.get("Redeem_CodeV2", 1), t_redeem = parser.get("Time_Redeem", 1), Level_Requi = parser.get("Level_Requi", 1), Maximum_Enter = parser.get("Maximum_Enter", 1), Amount_Gems = parser.get("Amount_Gems", 1), Amount_Level = parser.get("Amount_Level", 1), Amount_Wls = parser.get("Amount_Wls", 1), Amount_Token = parser.get("Amount_Token", 1), Role_Id = parser.get("Role_Id", 1), Gp = parser.get("GrowPass", 1), Glo = parser.get("RoadToGlory", 1);
			if (!isValidCheckboxInput(Gp) or !isValidCheckboxInput(Glo)) return;
			if (r_code != "" and t_redeem == "" and Level_Requi == "" and Maximum_Enter == "") {
				transform(r_code.begin(), r_code.end(), r_code.begin(), ::toupper);
				if (RedeemCode::Has_Code(r_code)) {
					RedeemCode::Remove_Code(r_code);
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wSuccessfully removed " + r_code + " from list redeem code.", 0, 1);
					VarList::OnConsoleMessage(peer, "`o>> Successfully removed " + r_code + " from list redeem code.");
					EventPool::Save::RedeemCode();
					DialogHandle::RedeemCode(peer);
				}
				return;
			}
			if (pInfo(peer)->r_items.size() == 0) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou must pick the items", 0, 1);
				return;
			}
			if (r_code.size() < 10 || r_code.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != std::string::npos) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in code!", 0, 1);
				return;
			}
			if (t_redeem.size() < 1 || atoi(t_redeem.c_str()) > 30 || t_redeem.find_first_not_of("0123456789") != std::string::npos) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in time!", 0, 1);
				return;
			}
			if (Level_Requi.size() < 1 || atoi(Level_Requi.c_str()) > 1000 || t_redeem.find_first_not_of("0123456789") != std::string::npos) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in level requiring!", 0, 1);
				return;
			}
			if (Maximum_Enter.size() < 1 || atoi(Maximum_Enter.c_str()) > 1000 || t_redeem.find_first_not_of("0123456789") != std::string::npos) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in maximum enter!", 0, 1);
				return;
			}
			if (not Amount_Gems.empty()) {
				if (Amount_Gems.size() < 1 || atoi(Amount_Gems.c_str()) > 1000000000 || Amount_Gems.find_first_not_of("0123456789") != std::string::npos) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in Amount Gems!", 0, 1);
					return;
				}
			}
			if (not Amount_Level.empty()) {
				if (Amount_Level.size() < 1 || atoi(Amount_Level.c_str()) > 1000 || Amount_Level.find_first_not_of("0123456789") != std::string::npos) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in Amount Gems!", 0, 1);
					return;
				}
			}
			if (not Amount_Wls.empty()) {
				if (Amount_Wls.size() < 1 || atoi(Amount_Wls.c_str()) > 1000000 || Amount_Wls.find_first_not_of("0123456789") != std::string::npos) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in Amount Premuim Wls!", 0, 1);
					return;
				}
			}
			if (not Amount_Token.empty()) {
				if (Amount_Token.size() < 1 || atoi(Amount_Token.c_str()) > 1000000 || Amount_Token.find_first_not_of("0123456789") != std::string::npos) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in Amount Token!", 0, 1);
					return;
				}
			}
			if (not Role_Id.empty()) {
				if (Role_Id.size() < 1 || atoi(Role_Id.c_str()) > 6 || Role_Id.find_first_not_of("123456") != std::string::npos) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid input in Role ID!", 0, 1);
					return;
				}
			}
			transform(r_code.begin(), r_code.end(), r_code.begin(), ::toupper);
			if (RedeemCode::Has_Code(r_code)) {
				RedeemCode::Remove_Code(r_code);
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wSuccessfully removed " + r_code + " from list redeem code.", 0, 1);
				VarList::OnConsoleMessage(peer, "`o>> Successfully removed " + r_code + " from list redeem code.");
				EventPool::Save::RedeemCode();
				DialogHandle::RedeemCode(peer);
			}
			else {
				RedeemCode::Add_Code(peer, r_code, atoi(t_redeem.c_str()) * 86400, atoi(Level_Requi.c_str()), atoi(Maximum_Enter.c_str()), (not Amount_Gems.empty() ? atoi(Amount_Gems.c_str()) : 0), (not Amount_Wls.empty() ? atoi(Amount_Wls.c_str()) : 0), (not Amount_Token.empty() ? atoi(Amount_Token.c_str()) : 0), (not Role_Id.empty() ? atoi(Role_Id.c_str()) : 0), (not Amount_Level.empty() ? atoi(Amount_Level.c_str()) : 0), (Gp == "1" ? true : false), (Glo == "1" ? true : false));
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wSuccessfully added " + r_code + " to list redeem code.", 0, 1);
				VarList::OnConsoleMessage(peer, "`o>> Successfully added " + r_code + " to list redeem code.");
				EventPool::Save::RedeemCode();
				DialogHandle::RedeemCode(peer);
			}
		}
	}
	static void redeem_code(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "redeem_code_button") {
				string r_code = parser.get("redeemcode", 1);
				if (r_code.empty() || r_code.size() < 10 || r_code.size() > 10 || r_code.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != std::string::npos) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid redemption code!", 0, 1);
					return;
				}
				long long time_ = time(nullptr); bool success = false;
				transform(r_code.begin(), r_code.end(), r_code.begin(), ::toupper);
				if (RedeemCode::Has_Code(r_code)) {
					if (pInfo(peer)->last_redeem + 3000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
						pInfo(peer)->last_redeem = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
					}
					else {
						int kiekDar = (pInfo(peer)->last_redeem + 3000 - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) / 1000;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Redemption in cooldown. Please try again in " + to_string(kiekDar) + " second(s).", 0, 1);
						return;
					}
					vector<Redeem_Code>::iterator p = find_if(redeem_codev2.redeemcode.begin(), redeem_codev2.redeemcode.end(), [&](const Redeem_Code& a) { return a.code == r_code; });
					if (p != redeem_codev2.redeemcode.end()) {
						if (redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].time - time_ >= 1) {
							if (find(redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].UserHasClaim.begin(), redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].UserHasClaim.end(), pInfo(peer)->tankIDName) != redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].UserHasClaim.end()) {
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wThis Redemption Code is already in use!", 0, 1);
								return;
							}
							else if (redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].PoepleEnter >= redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].MaximumEnter) {
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wThis Redemption Code in maximum retrieval!", 0, 1);
								return;
							}
							else {
								if (pInfo(peer)->level >= redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].RequiringLvl) {
									int additem = 0; string list = "";
									if (redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].GrowPass == true) {
										pInfo(peer)->gp = 1;
										list += "\nadd_label_with_icon|small|`wGrowPass (PERMANENT)|left|11304|\nadd_spacer|small|\n";
									}
									if (redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].RoadToGlory == true) {
										pInfo(peer)->glo = 1;
										list += "\nadd_label_with_icon|small|`wRoad To Glory (PERMANENT)|left|9436|\nadd_spacer|small|\n";
									}
									if (redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].Gemss != 0) {
										list += "\nadd_label_with_icon|small|`wGems (x" + Set_Count(redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].Gemss) + ")|left|112|\nadd_spacer|small|\n";
										VarList::OnBuxGems(peer, redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].Gemss);
									}
									if (redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].Levell != 0) {
										list += "\nadd_label_with_icon|small|`wLevel (x" + Set_Count(redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].Levell) + ")|left|1488|\nadd_spacer|small|\n";
										pInfo(peer)->level += redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].Levell;
									}
									if (redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].Coin != 0) {
										list += "\nadd_label_with_icon|small|`w" + Environment()->server_name + " Coin (x" + Set_Count(redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].Coin) + ")|left|244|\nadd_spacer|small|\n";
										pInfo(peer)->gtwl += redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].Coin;
									}
									if (redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].Seasonals_Token != 0) {
										list += "\nadd_label_with_icon|small|`w" + guild_event_type + " Tokens (x" + Set_Count(redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].Seasonals_Token) + ")|left|" + to_string(guild_event_id) + "|\nadd_spacer|small|\n";
										if (guild_event_type == "Spring Clash") pInfo(peer)->spring_token += redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].Seasonals_Token;
										if (guild_event_type == "Summer Clash") pInfo(peer)->summer_token += redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].Seasonals_Token;
										if (guild_event_type == "Winter Clash") pInfo(peer)->winter_token += redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].Seasonals_Token;
									}
									if (redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].Player_Role != 0) {
										int role_id = redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].Player_Role;
										list += "\nadd_label_with_icon|small|`wRole (" + a + (role_id == 1 ? "`w[`1VIP`w]" : role_id == 2 ? "`#@Moderator" : role_id == 3 ? "`e@Administrator" : role_id == 4 ? "`6@Developer" : role_id == 5 ? "`b@Owner Server" : "`7Cheater") + "`w)|left|" + (role_id == 1 ? "9882" : role_id == 2 ? "9852" : role_id == 3 ? "274" : role_id == 4 ? "276" : role_id == 5 ? "278" : "10400") + "|\nadd_spacer|small|\n";
										if (role_id == 1 and not Role::Vip(peer)) pInfo(peer)->Role.Vip = true;
										if (role_id == 2 and not Role::Moderator(peer)) pInfo(peer)->Role.Moderator = true;
										if (role_id == 3 and not Role::Administrator(peer)) pInfo(peer)->Role.Administrator = true;
										if (role_id == 4 and not Role::Developer(peer)) pInfo(peer)->Role.Developer = true;
										if (role_id == 5 and not Role::Owner(peer)) pInfo(peer)->Role.Owner_Server = true;
										if (role_id == 6 and not Role::Cheater(peer)) pInfo(peer)->Role.Cheats = true;
										pInfo(peer)->name_color = Role::Prefix(peer);
										VisualHandle::Nick(peer, NULL);
									}
									for (const auto& items_ : redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].items) {
										int cc_ = items_.second, id_ = items_.first;
										if (Inventory::Modify(peer, id_, cc_) == 0) {
											for (int i_ = 0; i_ < redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].items.size(); i_++) {
												list += "\nadd_label_with_icon|small|`w" + items[redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].items[i_].first].name + " (x" + to_string(redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].items[i_].second) + ")|left|" + to_string(redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].items[i_].first) + "|\nadd_spacer|small|\n";
											}
											VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`wRedeem Your Code!|left|982|\nadd_spacer|small|\nadd_textbox|`1Hurray! You got the following items from the Redeem Code.|left|\nadd_spacer|small|" + list + "|\nadd_button||`oClose|");
											VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`2Redeemed Successfully!", 0, 1);
											success = true;
										}
										else {
											VarList::OnTalkBubble(peer, pInfo(peer)->netID, "I don't have enough room in my backpack!", 0, 0);
										}
									}
									if (success) {
										success = false;
										//redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].Player_Rid.push_back(pInfo(peer)->rid);
										if (pInfo(peer)->redeem_code.size() != 0) pInfo(peer)->redeem_code.clear();
										redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].PoepleEnter++;
										redeem_codev2.redeemcode[p - redeem_codev2.redeemcode.begin()].UserHasClaim.push_back(pInfo(peer)->tankIDName);
										EventPool::Save::RedeemCode();
									}
								}
								else {
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYour level is insufficent to claim this code!", 0, 1);
									return;
								}
							}
						}
						else {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wRedemption code expired!", 0, 1);
							return;
						}
					}
				}
				else {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wInvalid redemption code!", 0, 1);
					return;
				}
			}
		}
	}
	static void checkoutcounter(ENetPeer* peer, std::string cch) {
		std::string name_ = pInfo(peer)->world;
		std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			world_->fresh_world = true;
			WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
			if (not Only_Access(peer, world_, block_) or block_->fg != 9270) return;
			std::vector<std::string> t_ = explode("|", cch);
			if (t_.size() > 4) {
				string button = explode("\n", t_[3])[0].c_str();
				if (button == "filterbytext") DialogHandle::VendHub(peer, world_, block_, explode("\n", t_[4])[0].c_str());
				else if (button == "switchdirection") block_->spin = (block_->spin ? false : true);
				else {
					int i_ = std::atoi(explode("\n", t_[3])[0].c_str()), x_ = i_ % 100, y_ = i_ / 100;
					if (i_ > world_->blocks.size()) return;
					block_ = &world_->blocks[i_];
					if (items[world_->blocks[i_].fg].blockType != BlockTypes::VENDING) return;
					VarList::OnDialogRequest(peer, get_vending(peer, world_, block_, x_, y_));
				}
			}
		}
	}
	static void recycle_machine(ENetPeer* peer, std::string cch) {
		std::vector<std::string> t_ = explode("|", cch);
		if (t_.size() < 3) return;
		string recycled_list = "";
		bool trashed_ = false;
		int total_receive = 0;
		for (int i_ = 2; i_ < t_.size(); i_++) {
			if (t_.size() - i_ <= 1 or !isValidCheckboxInput(explode("\n", t_[i_ + 1])[0])) return;
			if (atoi(explode("\n", t_[i_ + 1])[0].c_str())) {
				int item_id = std::atoi(explode("\n", t_[i_])[1].c_str());
				if (Inventory::Contains(peer, item_id) < 1 or item_id <= 0 or item_id > items.size() or items[item_id].untradeable) return;
				int removal = Inventory::Contains(peer, item_id) * -1;
				if (Inventory::Modify(peer, item_id, removal) == 0) {
					recycled_list += "\n" + to_string(abs(removal)) + " " + items[item_id].ori_name;
					total_receive += abs(removal);
					trashed_ = true;
				}
			}
		}
		if (trashed_) {
			VarList::OnBuxGems(peer, abs(total_receive));
			VarList::OnConsoleMessage(peer, "Received gems: " + Set_Count(total_receive) + ".\nRecycled " + recycled_list + "");
			CAction::Log(peer, "action|play_sfx\nfile|audio/trash.wav\ndelayMS|0");
		}
	}
	static void bannerbandolier(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = ""; int item_ = 0;
		if (pInfo(peer)->necklace != 11748) return;
		if (parser.try_get("banneritem", item_)) {
			if (item_ <= 0 || item_ > items.size()) return;
			if (Inventory::Contains(peer, item_) == 0) return;
			pInfo(peer)->CBanner_Flag = pInfo(peer)->CBanner_Flag;
			pInfo(peer)->CBanner_Item = item_;
			Clothing_V2::Update(peer);
			DialogHandle::Banner_Bandolier2(peer);
		}
		else if (parser.try_get("buttonClicked", button)) {
			if (button == "patternpicker") {
				string dialog = "";
				if (pInfo(peer)->Banner_Flag == 0) dialog += "set_default_color|`o\nadd_label_with_icon|big|`wBanner Bandolier``|left|5838|";
				else if (pInfo(peer)->Banner_Flag == 1) dialog += "set_default_color|`o\nadd_label_with_icon|big|`wBanner Bandolier``|left|5844|";
				else if (pInfo(peer)->Banner_Flag == 2) dialog += "set_default_color|`o\nadd_label_with_icon|big|`wBanner Bandolier``|left|5848|";
				else if (pInfo(peer)->Banner_Flag == 3) dialog += "set_default_color|`o\nadd_label_with_icon|big|`wBanner Bandolier``|left|5846|";
				else if (pInfo(peer)->Banner_Flag == 4) dialog += "set_default_color|`o\nadd_label_with_icon|big|`wBanner Bandolier``|left|5842|";
				dialog += "\nadd_spacer|small|\nadd_textbox|Pick a pattern for your banner.|left|\nadd_spacer|small|";
				dialog += "\nadd_label_with_icon_button|big|Harlequin|left|5838|pattern_1|\nadd_spacer|small|";
				dialog += "\nadd_label_with_icon_button|big|Slant|left|5844|pattern_2|\nadd_spacer|small|";
				dialog += "\nadd_label_with_icon_button|big|Stripe|left|5848|pattern_3|\nadd_spacer|small|";
				dialog += "\nadd_label_with_icon_button|big|Panel|left|5846|pattern_4|\nadd_spacer|small|";
				dialog += "\nadd_label_with_icon_button|big|Cross|left|5842|pattern_5|\nadd_spacer|small|";
				dialog += "\nend_dialog|bannerbandolier|Cancel||\nadd_quick_exit|";
				VarList::OnDialogRequest(peer, SetColor(peer) + dialog);
			}
			if (button.substr(0, 8) == "pattern_") {
				int Pattern = std::atoi(button.substr(8).c_str());
				if (Pattern < 1 || Pattern > 5) return;
				pInfo(peer)->CBanner_Item = pInfo(peer)->Banner_Item;
				pInfo(peer)->CBanner_Flag = Pattern - 1;
				DialogHandle::Banner_Bandolier2(peer);
				Clothing_V2::Update(peer);
			}
			if (button == "reset") {
				pInfo(peer)->CBanner_Item = 0; pInfo(peer)->CBanner_Flag = 0; pInfo(peer)->Banner_Item = 0; pInfo(peer)->Banner_Flag = 0;
				DialogHandle::Banner_Bandolier2(peer);
				Clothing_V2::Update(peer);
			}
		}
		else {
			if (pInfo(peer)->CBanner_Item != 0) pInfo(peer)->Banner_Item = pInfo(peer)->CBanner_Item;
			if (pInfo(peer)->CBanner_Flag != 0) pInfo(peer)->Banner_Flag = pInfo(peer)->CBanner_Flag;
			pInfo(peer)->CBanner_Item = 0; pInfo(peer)->CBanner_Flag = 0;
			Clothing_V2::Update(peer);
		}
	}
	static void magic_compass(ENetPeer* peer, std::string cch) {
		if (cch.find("buttonClicked|clear_item") != std::string::npos) {
			pInfo(peer)->Magnet_Item = 0;
			Clothing_V2::Update(peer);
			gamepacket_t p;
			p.Insert("OnMagicCompassTrackingItemIDChanged");
			p.Insert(pInfo(peer)->Magnet_Item);
			p.CreatePacket(peer);
			return;
		}
		else {
			if (cch.find("magic_compass_item|") != std::string::npos) {
				pInfo(peer)->Magnet_Item = std::atoi(explode("\n", explode("magic_compass_item|", cch)[1])[0].c_str());
				Clothing_V2::Update(peer);
				gamepacket_t p;
				p.Insert("OnMagicCompassTrackingItemIDChanged");
				p.Insert(atoi(explode("\n", explode("magic_compass_item|", cch)[1])[0].c_str()));
				p.CreatePacket(peer);
			}
			return;
		}
	}
	static void dialog_cernuous_mask(ENetPeer* peer, std::string cch) {
		if (cch.find("buttonClicked|restore_default") != std::string::npos) {
			pInfo(peer)->Aura_Season = 2;
			pInfo(peer)->Trail_Season = 2;
			Clothing_V2::Update(peer);
			return;
		}
		else {
			if (cch.find("checkbox_none0|") != string::npos and cch.find("checkbox_spring0|") != string::npos and cch.find("checkbox_summer0|") != string::npos and cch.find("checkbox_autumn0|") != string::npos and cch.find("checkbox_winter0|") != string::npos)
				pInfo(peer)->Aura_Season = (atoi(explode("\n", explode("checkbox_none0|", cch)[1])[0].c_str()) == 1 ? 0 : (atoi(explode("\n", explode("checkbox_spring0|", cch)[1])[0].c_str()) == 1 ? 1 : (atoi(explode("\n", explode("checkbox_summer0|", cch)[1])[0].c_str()) == 1 ? 2 : (atoi(explode("\n", explode("checkbox_autumn0|", cch)[1])[0].c_str()) == 1 ? 3 : (atoi(explode("\n", explode("checkbox_winter0|", cch)[1])[0].c_str()) == 1 ? 4 : 0)))));
			if (cch.find("checkbox_none1|") != string::npos and cch.find("checkbox_spring1|") != string::npos and cch.find("checkbox_summer1|") != string::npos and cch.find("checkbox_autumn1|") != string::npos and cch.find("checkbox_winter1|") != string::npos)
				pInfo(peer)->Trail_Season = (atoi(explode("\n", explode("checkbox_none1|", cch)[1])[0].c_str()) == 1 ? 0 : (atoi(explode("\n", explode("checkbox_spring1|", cch)[1])[0].c_str()) == 1 ? 1 : (atoi(explode("\n", explode("checkbox_summer1|", cch)[1])[0].c_str()) == 1 ? 2 : (atoi(explode("\n", explode("checkbox_autumn1|", cch)[1])[0].c_str()) == 1 ? 3 : (atoi(explode("\n", explode("checkbox_winter1|", cch)[1])[0].c_str()) == 1 ? 4 : 0)))));
			Clothing_V2::Update(peer);
			return;
		}
	}
	static void sessionlength_edit(ENetPeer* peer, std::string cch) {
		try {
			if (cch.find("checkbox_5|") != string::npos and cch.find("checkbox_10|") != string::npos and cch.find("checkbox_20|") != string::npos and cch.find("checkbox_30|") != string::npos and cch.find("checkbox_40|") != string::npos and cch.find("checkbox_50|") != string::npos and cch.find("checkbox_60|") != std::string::npos) {
				std::string name_ = pInfo(peer)->world;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					world_->fresh_world = true;
					if (pInfo(peer)->tankIDName != world_->owner_name) return;
					world_->World_Time = (atoi(explode("\n", explode("checkbox_5|", cch)[1])[0].c_str()) == 1 ? 5 : (atoi(explode("\n", explode("checkbox_10|", cch)[1])[0].c_str()) == 1 ? 10 : (atoi(explode("\n", explode("checkbox_20|", cch)[1])[0].c_str()) == 1 ? 20 : (atoi(explode("\n", explode("checkbox_30|", cch)[1])[0].c_str()) == 1 ? 30 : (atoi(explode("\n", explode("checkbox_40|", cch)[1])[0].c_str()) == 1 ? 40 : (atoi(explode("\n", explode("checkbox_50|", cch)[1])[0].c_str()) == 1 ? 50 : (atoi(explode("\n", explode("checkbox_60|", cch)[1])[0].c_str()) == 1 ? 60 : 0)))))));
					gamepacket_t p;
					p.Insert("OnTalkBubble"); p.Insert(pInfo(peer)->netID);
					p.Insert((world_->World_Time == 0 ? "World Timer limit removed!" : "World Timer limit set to `2" + to_string(world_->World_Time) + " minutes``."));
					p.Insert(0); p.Insert(0); p.CreatePacket(peer);
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (pInfo(cp_)->world == world_->name) {
							if (pInfo(cp_)->tankIDName != world_->owner_name && world_->World_Time != 0) {
								pInfo(cp_)->World_Timed = time(nullptr) + (world_->World_Time * 60);
								pInfo(cp_)->WorldTimed = true;
							}
						}
					}
				}
			}
		}
		catch (out_of_range) {
			Logger::Info("ERROR", "Server error invalid (out of range) on " + cch + "");
			return;
		}
	}
	static void dialog_infinity_crown(ENetPeer* peer, std::string cch) {
		if (cch.find("buttonClicked|button_manual") != std::string::npos) {
			DialogHandle::Infinity_Crown(peer, true);
			return;
		}
		else if (cch.find("buttonClicked|restore_default") != std::string::npos) {
			pInfo(peer)->Crown_Time_Change = true;
			pInfo(peer)->Crown_Cycle_Time = 15;
			pInfo(peer)->Base_R_0 = 255, pInfo(peer)->Base_G_0 = 255, pInfo(peer)->Base_B_0 = 255;
			pInfo(peer)->Gem_R_0 = 255, pInfo(peer)->Gem_G_0 = 0, pInfo(peer)->Gem_B_0 = 255;
			pInfo(peer)->Crystal_R_0 = 0, pInfo(peer)->Crystal_G_0 = 205, pInfo(peer)->Crystal_B_0 = 249;
			pInfo(peer)->Crown_Floating_Effect_0 = false, pInfo(peer)->Crown_Laser_Beam_0 = true, pInfo(peer)->Crown_Crystals_0 = true, pInfo(peer)->Crown_Rays_0 = true;
			pInfo(peer)->Base_R_1 = 255, pInfo(peer)->Base_G_1 = 200, pInfo(peer)->Base_B_1 = 37;
			pInfo(peer)->Gem_R_1 = 255, pInfo(peer)->Gem_G_1 = 0, pInfo(peer)->Gem_B_1 = 64;
			pInfo(peer)->Crystal_R_1 = 26, pInfo(peer)->Crystal_G_1 = 45, pInfo(peer)->Crystal_B_1 = 140;
			pInfo(peer)->Crown_Floating_Effect_1 = false, pInfo(peer)->Crown_Laser_Beam_1 = true, pInfo(peer)->Crown_Crystals_1 = true, pInfo(peer)->Crown_Rays_1 = true;
			pInfo(peer)->Crown_Value = 1768716607;
			pInfo(peer)->Crown_Value_0_0 = 4294967295, pInfo(peer)->Crown_Value_0_1 = 4278255615, pInfo(peer)->Crown_Value_0_2 = 4190961919;
			pInfo(peer)->Crown_Value_1_0 = 633929727, pInfo(peer)->Crown_Value_1_1 = 1073807359, pInfo(peer)->Crown_Value_1_2 = 2351766271;
			Clothing_V2::Update(peer);
			return;
		}
		else {
			try {
				pInfo(peer)->Crown_Time_Change = std::atoi(explode("\n", explode("checkbox_time_cycle|", cch)[1])[0].c_str()) == 1 ? true : false;
				if (!is_number(explode("\n", explode("text_input_time_cycle|", cch)[1])[0])) return;
				pInfo(peer)->Crown_Cycle_Time = std::atoi(explode("\n", explode("text_input_time_cycle|", cch)[1])[0].c_str());
				{ // Crown 1
					pInfo(peer)->Crown_Floating_Effect_0 = std::atoi(explode("\n", explode("checkbox_floating0|", cch)[1])[0].c_str()) == 1 ? true : false;
					{
						auto Crown_Base_0 = explode(",", explode("\n", explode("text_input_base_color0|", cch)[1])[0].c_str());
						std::vector<std::string> t_ = explode(",", explode("\n", explode("text_input_base_color0|", cch)[1])[0].c_str());
						if (Crown_Base_0.size() != 3 || t_.size() < 2 || Crown_Base_0[0] == "" || Crown_Base_0[1] == "" || Crown_Base_0[2] == "" || Crown_Base_0[0].empty() || Crown_Base_0[1].empty() || Crown_Base_0[2].empty()) {
							DialogHandle::Infinity_Crown(peer, false, "you need to enter an RGB (Red, Blue, Green) value");
							return;
						}
						if (!is_number(Crown_Base_0[0]) || !is_number(Crown_Base_0[1]) || !is_number(Crown_Base_0[2]) || atoi(Crown_Base_0[0].c_str()) > 255 || atoi(Crown_Base_0[1].c_str()) > 255 || atoi(Crown_Base_0[2].c_str()) > 255 || atoi(Crown_Base_0[0].c_str()) < 0 || atoi(Crown_Base_0[1].c_str()) < 0 || atoi(Crown_Base_0[2].c_str()) < 0) {
							DialogHandle::Infinity_Crown(peer, false, "you need to enter values betwwen 0 and 255");
							return;
						}
						pInfo(peer)->Base_R_0 = std::atoi(Crown_Base_0[0].c_str());
						pInfo(peer)->Base_G_0 = std::atoi(Crown_Base_0[1].c_str());
						pInfo(peer)->Base_B_0 = std::atoi(Crown_Base_0[2].c_str());
						pInfo(peer)->Crown_Value_0_0 = (long long int)(255 + (256 * pInfo(peer)->Base_R_0) + pInfo(peer)->Base_G_0 * 65536 + (pInfo(peer)->Base_B_0 * (long long int)16777216));
					}
					{
						pInfo(peer)->Crown_Laser_Beam_0 = std::atoi(explode("\n", explode("checkbox_laser_beam0|", cch)[1])[0].c_str()) == 1 ? true : false;
						auto Crown_Gem_0 = explode(",", explode("\n", explode("text_input_gem_color0|", cch)[1])[0].c_str());
						std::vector<std::string> t_ = explode(",", explode("\n", explode("text_input_gem_color0|", cch)[1])[0].c_str());
						if (Crown_Gem_0.size() != 3 || t_.size() < 2 || Crown_Gem_0[0] == "" || Crown_Gem_0[1] == "" || Crown_Gem_0[2] == "" || Crown_Gem_0[0].empty() || Crown_Gem_0[1].empty() || Crown_Gem_0[2].empty()) {
							DialogHandle::Infinity_Crown(peer, false, "you need to enter an RGB (Red, Blue, Green) value");
							return;
						}
						if (!is_number(Crown_Gem_0[0]) || !is_number(Crown_Gem_0[1]) || !is_number(Crown_Gem_0[2]) || atoi(Crown_Gem_0[0].c_str()) > 255 || atoi(Crown_Gem_0[1].c_str()) > 255 || atoi(Crown_Gem_0[2].c_str()) > 255 || atoi(Crown_Gem_0[0].c_str()) < 0 || atoi(Crown_Gem_0[1].c_str()) < 0 || atoi(Crown_Gem_0[2].c_str()) < 0) {
							DialogHandle::Infinity_Crown(peer, false, "you need to enter values betwwen 0 and 255");
							return;
						}
						pInfo(peer)->Gem_R_0 = std::atoi(Crown_Gem_0[0].c_str());
						pInfo(peer)->Gem_G_0 = std::atoi(Crown_Gem_0[1].c_str());
						pInfo(peer)->Gem_B_0 = std::atoi(Crown_Gem_0[2].c_str());
						pInfo(peer)->Crown_Value_0_1 = 255 + (256 * atoi(Crown_Gem_0[0].c_str())) + atoi(Crown_Gem_0[1].c_str()) * 65536 + (atoi(Crown_Gem_0[2].c_str()) * (long long int)16777216);
					}
					{
						auto Crown_Crystal_0 = explode(",", explode("\n", explode("text_input_crystal_color0|", cch)[1])[0].c_str());
						std::vector<std::string> t_ = explode(",", explode("\n", explode("text_input_crystal_color0|", cch)[1])[0].c_str());
						if (Crown_Crystal_0.size() != 3 || t_.size() < 2 || Crown_Crystal_0[0] == "" || Crown_Crystal_0[1] == "" || Crown_Crystal_0[2] == "" || Crown_Crystal_0[0].empty() || Crown_Crystal_0[1].empty() || Crown_Crystal_0[2].empty()) {
							DialogHandle::Infinity_Crown(peer, false, "you need to enter an RGB (Red, Blue, Green) value");
							return;
						};
						if (!is_number(Crown_Crystal_0[0]) || !is_number(Crown_Crystal_0[1]) || !is_number(Crown_Crystal_0[2]) || atoi(Crown_Crystal_0[0].c_str()) > 255 || atoi(Crown_Crystal_0[1].c_str()) > 255 || atoi(Crown_Crystal_0[2].c_str()) > 255 || atoi(Crown_Crystal_0[0].c_str()) < 0 || atoi(Crown_Crystal_0[1].c_str()) < 0 || atoi(Crown_Crystal_0[2].c_str()) < 0) {
							DialogHandle::Infinity_Crown(peer, false, "you need to enter values betwwen 0 and 255");
							return;
						}
						pInfo(peer)->Crystal_R_0 = std::atoi(Crown_Crystal_0[0].c_str());
						pInfo(peer)->Crystal_G_0 = std::atoi(Crown_Crystal_0[1].c_str());
						pInfo(peer)->Crystal_B_0 = std::atoi(Crown_Crystal_0[2].c_str());
						pInfo(peer)->Crown_Value_0_2 = 255 + (256 * atoi(Crown_Crystal_0[0].c_str())) + atoi(Crown_Crystal_0[1].c_str()) * 65536 + (atoi(Crown_Crystal_0[2].c_str()) * (long long int)16777216);
					}
					pInfo(peer)->Crown_Crystals_0 = std::atoi(explode("\n", explode("checkbox_crystals0|", cch)[1])[0].c_str()) == 1 ? true : false;
					pInfo(peer)->Crown_Rays_0 = std::atoi(explode("\n", explode("checkbox_rays0|", cch)[1])[0].c_str()) == 1 ? true : false;
				}
				{ // Crown 2
					pInfo(peer)->Crown_Floating_Effect_1 = std::atoi(explode("\n", explode("checkbox_floating1|", cch)[1])[0].c_str()) == 1 ? true : false;
					{
						auto Crown_Base_1 = explode(",", explode("\n", explode("text_input_base_color1|", cch)[1])[0].c_str());
						std::vector<std::string> t_ = explode(",", explode("\n", explode("text_input_base_color1|", cch)[1])[0].c_str());
						if (Crown_Base_1.size() != 3 || t_.size() < 2 || Crown_Base_1[0] == "" || Crown_Base_1[1] == "" || Crown_Base_1[2] == "" || Crown_Base_1[0].empty() || Crown_Base_1[1].empty() || Crown_Base_1[2].empty()) {
							DialogHandle::Infinity_Crown(peer, false, "you need to enter an RGB (Red, Blue, Green) value");
							return;
						}
						if (!is_number(Crown_Base_1[0]) || !is_number(Crown_Base_1[1]) || !is_number(Crown_Base_1[2]) || atoi(Crown_Base_1[0].c_str()) > 255 || atoi(Crown_Base_1[1].c_str()) > 255 || atoi(Crown_Base_1[2].c_str()) > 255 || atoi(Crown_Base_1[0].c_str()) < 0 || atoi(Crown_Base_1[1].c_str()) < 0 || atoi(Crown_Base_1[2].c_str()) < 0) {
							DialogHandle::Infinity_Crown(peer, false, "you need to enter values betwwen 0 and 255");
							return;
						}
						pInfo(peer)->Base_R_1 = std::atoi(Crown_Base_1[0].c_str());
						pInfo(peer)->Base_G_1 = std::atoi(Crown_Base_1[1].c_str());
						pInfo(peer)->Base_B_1 = std::atoi(Crown_Base_1[2].c_str());
						pInfo(peer)->Crown_Value_1_1 = 255 + (256 * atoi(Crown_Base_1[0].c_str())) + atoi(Crown_Base_1[1].c_str()) * 65536 + (atoi(Crown_Base_1[2].c_str()) * (long long int)16777216);
					}
					{
						pInfo(peer)->Crown_Laser_Beam_1 = std::atoi(explode("\n", explode("checkbox_laser_beam1|", cch)[1])[0].c_str()) == 1 ? true : false;
						auto Crown_Gem_1 = explode(",", explode("\n", explode("text_input_gem_color1|", cch)[1])[0].c_str());
						std::vector<std::string> t_ = explode(",", explode("\n", explode("text_input_gem_color1|", cch)[1])[0].c_str());
						if (Crown_Gem_1.size() != 3 || t_.size() < 2 || Crown_Gem_1[0] == "" || Crown_Gem_1[1] == "" || Crown_Gem_1[2] == "" || Crown_Gem_1[0].empty() || Crown_Gem_1[1].empty() || Crown_Gem_1[2].empty()) {
							DialogHandle::Infinity_Crown(peer, false, "you need to enter an RGB (Red, Blue, Green) value");
							return;
						}
						if (!is_number(Crown_Gem_1[0]) || !is_number(Crown_Gem_1[1]) || !is_number(Crown_Gem_1[2]) || atoi(Crown_Gem_1[0].c_str()) > 255 || atoi(Crown_Gem_1[1].c_str()) > 255 || atoi(Crown_Gem_1[2].c_str()) > 255 || atoi(Crown_Gem_1[0].c_str()) < 0 || atoi(Crown_Gem_1[1].c_str()) < 0 || atoi(Crown_Gem_1[2].c_str()) < 0) {
							DialogHandle::Infinity_Crown(peer, false, "you need to enter values betwwen 0 and 255");
							return;
						}
						pInfo(peer)->Gem_R_1 = std::atoi(Crown_Gem_1[0].c_str());
						pInfo(peer)->Gem_G_1 = std::atoi(Crown_Gem_1[1].c_str());
						pInfo(peer)->Gem_B_1 = std::atoi(Crown_Gem_1[2].c_str());
						pInfo(peer)->Crown_Value_1_1 = 255 + (256 * atoi(Crown_Gem_1[0].c_str())) + atoi(Crown_Gem_1[1].c_str()) * 65536 + (atoi(Crown_Gem_1[2].c_str()) * (long long int)16777216);
					}
					{
						auto Crown_Crystal_1 = explode(",", explode("\n", explode("text_input_crystal_color1|", cch)[1])[0].c_str());
						std::vector<std::string> t_ = explode(",", explode("\n", explode("text_input_crystal_color1|", cch)[1])[0].c_str());
						if (Crown_Crystal_1.size() != 3 || t_.size() < 2 || Crown_Crystal_1[0] == "" || Crown_Crystal_1[1] == "" || Crown_Crystal_1[2] == "" || Crown_Crystal_1[0].empty() || Crown_Crystal_1[1].empty() || Crown_Crystal_1[2].empty()) {
							DialogHandle::Infinity_Crown(peer, false, "you need to enter an RGB (Red, Blue, Green) value");
							return;
						}
						if (!is_number(Crown_Crystal_1[0]) || !is_number(Crown_Crystal_1[1]) || !is_number(Crown_Crystal_1[2]) || atoi(Crown_Crystal_1[0].c_str()) > 255 || atoi(Crown_Crystal_1[1].c_str()) > 255 || atoi(Crown_Crystal_1[2].c_str()) > 255 || atoi(Crown_Crystal_1[0].c_str()) < 0 || atoi(Crown_Crystal_1[1].c_str()) < 0 || atoi(Crown_Crystal_1[2].c_str()) < 0) {
							DialogHandle::Infinity_Crown(peer, false, "you need to enter values betwwen 0 and 255");
							return;
						}
						pInfo(peer)->Crystal_R_1 = std::atoi(Crown_Crystal_1[0].c_str());
						pInfo(peer)->Crystal_G_1 = std::atoi(Crown_Crystal_1[1].c_str());
						pInfo(peer)->Crystal_B_1 = std::atoi(Crown_Crystal_1[2].c_str());
						pInfo(peer)->Crown_Value_1_2 = 255 + (256 * atoi(Crown_Crystal_1[0].c_str())) + atoi(Crown_Crystal_1[1].c_str()) * 65536 + (atoi(Crown_Crystal_1[2].c_str()) * (long long int)16777216);
					}
					pInfo(peer)->Crown_Crystals_1 = std::atoi(explode("\n", explode("checkbox_crystals1|", cch)[1])[0].c_str()) == 1 ? true : false;
					pInfo(peer)->Crown_Rays_1 = std::atoi(explode("\n", explode("checkbox_rays1|", cch)[1])[0].c_str()) == 1 ? true : false;
				}
			}
			catch (...) {
				return;
			}
			int Total_Value = 1768716288;
			if (pInfo(peer)->Crown_Time_Change) Total_Value += 256;
			if (pInfo(peer)->Crown_Floating_Effect_0) Total_Value += 64;
			if (pInfo(peer)->Crown_Laser_Beam_0) Total_Value += 1;
			if (pInfo(peer)->Crown_Crystals_0) Total_Value += 4;
			if (pInfo(peer)->Crown_Rays_0) Total_Value += 16;
			if (pInfo(peer)->Crown_Floating_Effect_1) Total_Value += 128;
			if (pInfo(peer)->Crown_Laser_Beam_1) Total_Value += 2;
			if (pInfo(peer)->Crown_Crystals_1) Total_Value += 8;
			if (pInfo(peer)->Crown_Rays_1) Total_Value += 32;
			pInfo(peer)->Crown_Value = Total_Value;
			Clothing_V2::Update(peer);
		}
	}
	static void dialog_rift_wings(ENetPeer* peer, std::string cch) {
		if (pInfo(peer)->back != 11478) return;
		std::vector<std::string> t_ = explode("|", cch), color;
		if (t_.size() == 29) {
			string color_convert = "";
			if (atoi(explode("\n", t_[3])[0].c_str()) > 0 && atoi(explode("\n", t_[3])[0].c_str()) < 86400) pInfo(peer)->_TimeDilation = std::atoi(explode("\n", t_[3])[0].c_str());
			bool time_dilation = std::atoi(explode("\n", t_[4])[0].c_str());
			if (time_dilation) pInfo(peer)->_flags |= SETTINGS::RIFTWINGS_FLAGS_TIME_DILATION_ON;
			else pInfo(peer)->_flags &= ~SETTINGS::RIFTWINGS_FLAGS_TIME_DILATION_ON;
			color_convert = explode("\n", t_[5])[0].c_str();
			color = explode(",", color_convert);
			if (color.size() == 3) {
				if (atoi(explode(",", color[0])[0].c_str()) >= 0 && atoi(explode(",", color[0])[0].c_str()) <= 255 && atoi(explode(",", color[1])[0].c_str()) >= 0 && atoi(explode(",", color[1])[0].c_str()) <= 255 && atoi(explode(",", color[2])[0].c_str()) >= 0 && atoi(explode(",", color[2])[0].c_str()) <= 255) {
					pInfo(peer)->_CapeStyleColor_1 = color_convert;
					uint8_t* cancer = (uint8_t*)(&(pInfo(peer)->wings_t));
					cancer[1] = std::atoi(explode(",", color[0])[0].c_str());
					cancer[2] = std::atoi(explode(",", color[1])[0].c_str());
					cancer[3] = std::atoi(explode(",", color[2])[0].c_str());
				}
			}
			color_convert = explode("\n", t_[6])[0].c_str();
			color = explode(",", color_convert);
			if (color.size() == 3) {
				if (atoi(explode(",", color[0])[0].c_str()) >= 0 && atoi(explode(",", color[0])[0].c_str()) <= 255 && atoi(explode(",", color[1])[0].c_str()) >= 0 && atoi(explode(",", color[1])[0].c_str()) <= 255 && atoi(explode(",", color[2])[0].c_str()) >= 0 && atoi(explode(",", color[2])[0].c_str()) <= 255) {
					pInfo(peer)->_CapeCollarColor_1 = color_convert;
					uint8_t* cancer = (uint8_t*)(&(pInfo(peer)->wings_c));
					cancer[1] = std::atoi(explode(",", color[0])[0].c_str());
					cancer[2] = std::atoi(explode(",", color[1])[0].c_str());
					cancer[3] = std::atoi(explode(",", color[2])[0].c_str());
				}
			}
			bool open_wings = std::atoi(explode("\n", t_[7])[0].c_str());
			if (open_wings) pInfo(peer)->_flags |= SETTINGS::RIFTWINGS_FLAGS_STYLE_1_OPEN_WINGS;
			else pInfo(peer)->_flags &= ~SETTINGS::RIFTWINGS_FLAGS_STYLE_1_OPEN_WINGS;
			bool closed_wings = std::atoi(explode("\n", t_[8])[0].c_str());
			if (closed_wings) pInfo(peer)->_flags |= SETTINGS::RIFTWINGS_FLAGS_STYLE_1_CLOSE_WINGS;
			else pInfo(peer)->_flags &= ~SETTINGS::RIFTWINGS_FLAGS_STYLE_1_CLOSE_WINGS;
			bool stamp_particle = std::atoi(explode("\n", t_[9])[0].c_str());
			if (stamp_particle) pInfo(peer)->_flags |= SETTINGS::RIFTWINGS_FLAGS_STYLE_1_STAMP_PARTICLE;
			else pInfo(peer)->_flags &= ~SETTINGS::RIFTWINGS_FLAGS_STYLE_1_STAMP_PARTICLE;
			bool trail0 = std::atoi(explode("\n", t_[10])[0].c_str());
			if (trail0) pInfo(peer)->_flags |= SETTINGS::RIFTWINGS_FLAGS_STYLE_1_TRAIL_ON;
			else pInfo(peer)->_flags &= ~SETTINGS::RIFTWINGS_FLAGS_STYLE_1_TRAIL_ON;
			pInfo(peer)->_flags &= ~SETTINGS::RIFTWINGS_FLAGS_STYLE_1_PORTAL_AURA;
			pInfo(peer)->_flags &= ~SETTINGS::RIFTWINGS_FLAGS_STYLE_2_PORTAL_AURA;
			pInfo(peer)->_flags &= ~SETTINGS::RIFTWINGS_FLAGS_STYLE_1_STARFIELD_AURA;
			pInfo(peer)->_flags &= ~SETTINGS::RIFTWINGS_FLAGS_STYLE_2_STARFIELD_AURA;
			bool p_aura = std::atoi(explode("\n", t_[11])[0].c_str()), starfield_Aura = std::atoi(explode("\n", t_[12])[0].c_str()), electrical_aura = std::atoi(explode("\n", t_[13])[0].c_str());
			if (electrical_aura) pInfo(peer)->_flags |= SETTINGS::RIFTWINGS_FLAGS_STYLE_1_ELECTRICAL_AURA;
			else if (p_aura) pInfo(peer)->_flags |= SETTINGS::RIFTWINGS_FLAGS_STYLE_1_PORTAL_AURA;
			else if (starfield_Aura) pInfo(peer)->_flags |= SETTINGS::RIFTWINGS_FLAGS_STYLE_1_STARFIELD_AURA;
			else pInfo(peer)->_flags |= SETTINGS::RIFTWINGS_FLAGS_STYLE_1_PORTAL_AURA;
			pInfo(peer)->_flags &= ~SETTINGS::RIFTWINGS_FLAGS_STYLE_1_MATERIAL_FEATHERS;
			pInfo(peer)->_flags &= ~SETTINGS::RIFTWINGS_FLAGS_STYLE_2_MATERIAL_FEATHERS;
			pInfo(peer)->_flags &= ~SETTINGS::RIFTWINGS_FLAGS_STYLE_1_MATERIAL_BLADES;
			pInfo(peer)->_flags &= ~SETTINGS::RIFTWINGS_FLAGS_STYLE_2_MATERIAL_BLADES;
			bool feathers = std::atoi(explode("\n", t_[14])[0].c_str()), blades = std::atoi(explode("\n", t_[15])[0].c_str()), scales = std::atoi(explode("\n", t_[16])[0].c_str());
			if (scales) pInfo(peer)->_flags |= SETTINGS::RIFTWINGS_FLAGS_STYLE_1_MATERIAL_SCALES;
			else if (feathers) pInfo(peer)->_flags |= SETTINGS::RIFTWINGS_FLAGS_STYLE_1_MATERIAL_FEATHERS;
			else if (blades)pInfo(peer)->_flags |= SETTINGS::RIFTWINGS_FLAGS_STYLE_1_MATERIAL_BLADES;
			else pInfo(peer)->_flags |= SETTINGS::RIFTWINGS_FLAGS_STYLE_1_MATERIAL_FEATHERS;
			color_convert = explode("\n", t_[17])[0].c_str();
			color = explode(",", color_convert);
			if (color.size() == 3) {
				if (atoi(explode(",", color[0])[0].c_str()) >= 0 && atoi(explode(",", color[0])[0].c_str()) <= 255 && atoi(explode(",", color[1])[0].c_str()) >= 0 && atoi(explode(",", color[1])[0].c_str()) <= 255 && atoi(explode(",", color[2])[0].c_str()) >= 0 && atoi(explode(",", color[2])[0].c_str()) <= 255) {
					pInfo(peer)->_CapeStyleColor_2 = color_convert;
					uint8_t* cancer = (uint8_t*)(&(pInfo(peer)->wings_t2));
					cancer[1] = std::atoi(explode(",", color[0])[0].c_str());
					cancer[2] = std::atoi(explode(",", color[1])[0].c_str());
					cancer[3] = std::atoi(explode(",", color[2])[0].c_str());
				}
			}
			color_convert = explode("\n", t_[18])[0].c_str();
			color = explode(",", color_convert);
			if (color.size() == 3) {
				if (atoi(explode(",", color[0])[0].c_str()) >= 0 && atoi(explode(",", color[0])[0].c_str()) <= 255 && atoi(explode(",", color[1])[0].c_str()) >= 0 && atoi(explode(",", color[1])[0].c_str()) <= 255 && atoi(explode(",", color[2])[0].c_str()) >= 0 && atoi(explode(",", color[2])[0].c_str()) <= 255) {
					pInfo(peer)->_CapeCollarColor_2 = color_convert;
					uint8_t* cancer = (uint8_t*)(&(pInfo(peer)->wings_c2));
					cancer[1] = std::atoi(explode(",", color[0])[0].c_str());
					cancer[2] = std::atoi(explode(",", color[1])[0].c_str());
					cancer[3] = std::atoi(explode(",", color[2])[0].c_str());
				}
			}
			bool open_wings2 = std::atoi(explode("\n", t_[19])[0].c_str());
			if (open_wings2) pInfo(peer)->_flags |= SETTINGS::RIFTWINGS_FLAGS_STYLE_2_OPEN_WINGS;
			else pInfo(peer)->_flags &= ~SETTINGS::RIFTWINGS_FLAGS_STYLE_2_OPEN_WINGS;
			bool closed_wings2 = std::atoi(explode("\n", t_[20])[0].c_str());
			if (closed_wings2) pInfo(peer)->_flags |= SETTINGS::RIFTWINGS_FLAGS_STYLE_2_CLOSE_WINGS;
			else pInfo(peer)->_flags &= ~SETTINGS::RIFTWINGS_FLAGS_STYLE_2_CLOSE_WINGS;
			bool stamp_particle2 = std::atoi(explode("\n", t_[21])[0].c_str());
			if (stamp_particle2) pInfo(peer)->_flags |= SETTINGS::RIFTWINGS_FLAGS_STYLE_2_STAMP_PARTICLE;
			else pInfo(peer)->_flags &= ~SETTINGS::RIFTWINGS_FLAGS_STYLE_2_STAMP_PARTICLE;
			bool trail02 = std::atoi(explode("\n", t_[22])[0].c_str());
			if (trail02) pInfo(peer)->_flags |= SETTINGS::RIFTWINGS_FLAGS_STYLE_2_TRAIL_ON;
			else pInfo(peer)->_flags &= ~SETTINGS::RIFTWINGS_FLAGS_STYLE_2_TRAIL_ON;
			bool p_aura2 = std::atoi(explode("\n", t_[23])[0].c_str()), starfield_Aura2 = std::atoi(explode("\n", t_[24])[0].c_str()), electrical_aura2 = std::atoi(explode("\n", t_[25])[0].c_str());
			if (electrical_aura2) pInfo(peer)->_flags |= SETTINGS::RIFTWINGS_FLAGS_STYLE_2_ELECTRICAL_AURA;
			else if (p_aura2) pInfo(peer)->_flags |= SETTINGS::RIFTWINGS_FLAGS_STYLE_2_PORTAL_AURA;
			else if (starfield_Aura2) pInfo(peer)->_flags |= SETTINGS::RIFTWINGS_FLAGS_STYLE_2_STARFIELD_AURA;
			else pInfo(peer)->_flags |= SETTINGS::RIFTWINGS_FLAGS_STYLE_2_PORTAL_AURA;
			bool feathers2 = std::atoi(explode("\n", t_[26])[0].c_str()), blades2 = std::atoi(explode("\n", t_[27])[0].c_str()), scales2 = std::atoi(explode("\n", t_[28])[0].c_str());
			if (scales2) pInfo(peer)->_flags |= SETTINGS::RIFTWINGS_FLAGS_STYLE_2_MATERIAL_SCALES;
			else if (feathers2) pInfo(peer)->_flags |= SETTINGS::RIFTWINGS_FLAGS_STYLE_2_MATERIAL_FEATHERS;
			else if (blades2) pInfo(peer)->_flags |= SETTINGS::RIFTWINGS_FLAGS_STYLE_2_MATERIAL_BLADES;
			else pInfo(peer)->_flags |= SETTINGS::RIFTWINGS_FLAGS_STYLE_2_MATERIAL_FEATHERS;
		}
		else if (t_.size() == 30) {
			string button = explode("\n", t_[3])[0].c_str();
			if (button == "restore_default") {
				pInfo(peer)->wings_t = 3356909055, pInfo(peer)->wings_c = 4282965247, pInfo(peer)->wings_t2 = 723421695, pInfo(peer)->wings_c2 = 1059267327;
				pInfo(peer)->_flags = 104912, pInfo(peer)->_TimeDilation = 30;
				pInfo(peer)->_CapeStyleColor_1 = "93,22,200", pInfo(peer)->_CapeCollarColor_1 = "220,72,255", pInfo(peer)->_CapeStyleColor_2 = "137,30,43", pInfo(peer)->_CapeCollarColor_2 = "34,35,63";
			}
			else if (button == "button_manual") DialogHandle::Rift_Wings(peer, "\nadd_textbox|This Wing has several special functions!|left|\nadd_spacer|small|\nadd_textbox|To set the color for the wings and metal you need to enter an RGB(Red, Green, Blue) value. To separate the individual values, you need to use a comma.|left|\nadd_spacer|small|\nadd_textbox|Set the Time Dilation Cycle Time to define how often the Wings will change between the two Wing Styles. Cycle time is in seconds; maximum number of seconds allowed is: 86400 seconds (24 hours).|left|");
		}
		Clothing_V2::Update(peer);
	}
	static void dialog_rift_cape(ENetPeer* peer, std::string cch) {
		if (pInfo(peer)->back != 10424) return;
		std::vector<std::string> t_ = explode("|", cch), color;
		if (t_.size() == 23) {
			string color_convert = "";
			if (atoi(explode("\n", t_[3])[0].c_str()) > 0 && atoi(explode("\n", t_[3])[0].c_str()) < 86400) pInfo(peer)->TimeDilation = std::atoi(explode("\n", t_[3])[0].c_str());
			bool time_dilation = std::atoi(explode("\n", t_[4])[0].c_str());
			if (time_dilation) pInfo(peer)->flags |= SETTINGS::RIFTCAPE_FLAGS_TIME_DILATION_ON;
			else pInfo(peer)->flags &= ~SETTINGS::RIFTCAPE_FLAGS_TIME_DILATION_ON;
			color_convert = explode("\n", t_[5])[0].c_str();
			color = explode(",", color_convert);
			if (color.size() == 3) {
				if (atoi(explode(",", color[0])[0].c_str()) >= 0 && atoi(explode(",", color[0])[0].c_str()) <= 255 && atoi(explode(",", color[1])[0].c_str()) >= 0 && atoi(explode(",", color[1])[0].c_str()) <= 255 && atoi(explode(",", color[2])[0].c_str()) >= 0 && atoi(explode(",", color[2])[0].c_str()) <= 255) {
					pInfo(peer)->CapeStyleColor_1 = color_convert;
					uint8_t* cancer = (uint8_t*)(&(pInfo(peer)->cape_t));
					cancer[1] = std::atoi(explode(",", color[0])[0].c_str());
					cancer[2] = std::atoi(explode(",", color[1])[0].c_str());
					cancer[3] = std::atoi(explode(",", color[2])[0].c_str());
				}
			}
			bool cape_collar = std::atoi(explode("\n", t_[6])[0].c_str());
			if (cape_collar) pInfo(peer)->flags |= SETTINGS::RIFTCAPE_FLAGS_STYLE_1_COLLAR_ON;
			else pInfo(peer)->flags &= ~SETTINGS::RIFTCAPE_FLAGS_STYLE_1_COLLAR_ON;
			color_convert = explode("\n", t_[7])[0].c_str();
			color = explode(",", color_convert);
			if (color.size() == 3) {
				if (atoi(explode(",", color[0])[0].c_str()) >= 0 && atoi(explode(",", color[0])[0].c_str()) <= 255 && atoi(explode(",", color[1])[0].c_str()) >= 0 && atoi(explode(",", color[1])[0].c_str()) <= 255 && atoi(explode(",", color[2])[0].c_str()) >= 0 && atoi(explode(",", color[2])[0].c_str()) <= 255) {
					pInfo(peer)->CapeCollarColor_1 = color_convert;
					uint8_t* cancer = (uint8_t*)(&(pInfo(peer)->cape_c));
					cancer[1] = std::atoi(explode(",", color[0])[0].c_str());
					cancer[2] = std::atoi(explode(",", color[1])[0].c_str());
					cancer[3] = std::atoi(explode(",", color[2])[0].c_str());
				}
			}
			bool closed_cape = std::atoi(explode("\n", t_[8])[0].c_str());
			if (closed_cape) pInfo(peer)->flags |= SETTINGS::RIFTCAPE_FLAGS_STYLE_1_CLOSED_CAPE;
			else pInfo(peer)->flags &= ~SETTINGS::RIFTCAPE_FLAGS_STYLE_1_CLOSED_CAPE;
			bool open_cape = std::atoi(explode("\n", t_[9])[0].c_str());
			if (open_cape) pInfo(peer)->flags |= SETTINGS::RIFTCAPE_FLAGS_STYLE_1_OPEN_CAPE_ON_MOVEMENT;
			else pInfo(peer)->flags &= ~SETTINGS::RIFTCAPE_FLAGS_STYLE_1_OPEN_CAPE_ON_MOVEMENT;
			bool aura_on = std::atoi(explode("\n", t_[10])[0].c_str());
			if (aura_on) pInfo(peer)->flags |= SETTINGS::RIFTCAPE_FLAGS_STYLE_1_AURA_ON;
			else pInfo(peer)->flags &= ~SETTINGS::RIFTCAPE_FLAGS_STYLE_1_AURA_ON;
			bool p_aura = std::atoi(explode("\n", t_[11])[0].c_str()), starfield_Aura = std::atoi(explode("\n", t_[12])[0].c_str()), electrical_aura = std::atoi(explode("\n", t_[13])[0].c_str());
			pInfo(peer)->flags &= ~SETTINGS::RIFTCAPE_FLAGS_STYLE_1_PORTAL_AURA;
			pInfo(peer)->flags &= ~SETTINGS::RIFTCAPE_FLAGS_STYLE_2_PORTAL_AURA;
			pInfo(peer)->flags &= ~SETTINGS::RIFTCAPE_FLAGS_STYLE_1_STARFIELD_AURA;
			pInfo(peer)->flags &= ~SETTINGS::RIFTCAPE_FLAGS_STYLE_2_STARFIELD_AURA;
			if (electrical_aura) pInfo(peer)->flags |= SETTINGS::RIFTCAPE_FLAGS_STYLE_1_ELECTRICAL_AURA;
			else if (p_aura) pInfo(peer)->flags |= SETTINGS::RIFTCAPE_FLAGS_STYLE_1_PORTAL_AURA;
			else if (starfield_Aura) pInfo(peer)->flags |= SETTINGS::RIFTCAPE_FLAGS_STYLE_1_STARFIELD_AURA;
			else pInfo(peer)->flags |= SETTINGS::RIFTCAPE_FLAGS_STYLE_1_PORTAL_AURA;
			color_convert = explode("\n", t_[14])[0].c_str();
			color = explode(",", color_convert);
			if (color.size() == 3) {
				if (atoi(explode(",", color[0])[0].c_str()) >= 0 && atoi(explode(",", color[0])[0].c_str()) <= 255 && atoi(explode(",", color[1])[0].c_str()) >= 0 && atoi(explode(",", color[1])[0].c_str()) <= 255 && atoi(explode(",", color[2])[0].c_str()) >= 0 && atoi(explode(",", color[2])[0].c_str()) <= 255) {
					pInfo(peer)->CapeStyleColor_2 = color_convert;
					uint8_t* cancer = (uint8_t*)(&(pInfo(peer)->cape_t2));
					cancer[1] = std::atoi(explode(",", color[0])[0].c_str());
					cancer[2] = std::atoi(explode(",", color[1])[0].c_str());
					cancer[3] = std::atoi(explode(",", color[2])[0].c_str());
				}
			}
			bool collar_aura = std::atoi(explode("\n", t_[15])[0].c_str());
			if (collar_aura) pInfo(peer)->flags |= SETTINGS::RIFTCAPE_FLAGS_STYLE_2_COLLAR_ON;
			else pInfo(peer)->flags &= ~SETTINGS::RIFTCAPE_FLAGS_STYLE_2_COLLAR_ON;
			color_convert = explode("\n", t_[16])[0].c_str();
			color = explode(",", color_convert);
			if (color.size() == 3) {
				if (atoi(explode(",", color[0])[0].c_str()) >= 0 && atoi(explode(",", color[0])[0].c_str()) <= 255 && atoi(explode(",", color[1])[0].c_str()) >= 0 && atoi(explode(",", color[1])[0].c_str()) <= 255 && atoi(explode(",", color[2])[0].c_str()) >= 0 && atoi(explode(",", color[2])[0].c_str()) <= 255) {
					pInfo(peer)->CapeCollarColor_2 = color_convert;
					uint8_t* cancer = (uint8_t*)(&(pInfo(peer)->cape_c2));
					cancer[1] = std::atoi(explode(",", color[0])[0].c_str());
					cancer[2] = std::atoi(explode(",", color[1])[0].c_str());
					cancer[3] = std::atoi(explode(",", color[2])[0].c_str());
				}
			}
			bool closed_cape2 = std::atoi(explode("\n", t_[17])[0].c_str());
			if (closed_cape2) pInfo(peer)->flags |= SETTINGS::RIFTCAPE_FLAGS_STYLE_2_CLOSED_CAPE;
			else pInfo(peer)->flags &= ~SETTINGS::RIFTCAPE_FLAGS_STYLE_2_CLOSED_CAPE;
			bool cape_movement2 = std::atoi(explode("\n", t_[18])[0].c_str());
			if (cape_movement2) pInfo(peer)->flags |= SETTINGS::RIFTCAPE_FLAGS_STYLE_2_OPEN_CAPE_ON_MOVEMENT;
			else pInfo(peer)->flags &= ~SETTINGS::RIFTCAPE_FLAGS_STYLE_2_OPEN_CAPE_ON_MOVEMENT;
			bool aura_on_2 = std::atoi(explode("\n", t_[19])[0].c_str());
			if (aura_on_2) pInfo(peer)->flags |= SETTINGS::RIFTCAPE_FLAGS_STYLE_2_AURA_ON;
			else pInfo(peer)->flags &= ~SETTINGS::RIFTCAPE_FLAGS_STYLE_2_AURA_ON;
			bool p_aura_2 = std::atoi(explode("\n", t_[20])[0].c_str()), starfield_aura_2 = std::atoi(explode("\n", t_[21])[0].c_str()), electrical_2 = std::atoi(explode("\n", t_[22])[0].c_str());
			if (electrical_2) pInfo(peer)->flags |= SETTINGS::RIFTCAPE_FLAGS_STYLE_2_ELECTRICAL_AURA;
			else if (p_aura_2) pInfo(peer)->flags |= SETTINGS::RIFTCAPE_FLAGS_STYLE_2_PORTAL_AURA;
			else if (starfield_aura_2) pInfo(peer)->flags |= SETTINGS::RIFTCAPE_FLAGS_STYLE_2_STARFIELD_AURA;
			else pInfo(peer)->flags |= SETTINGS::RIFTCAPE_FLAGS_STYLE_2_PORTAL_AURA;
		}
		else if (t_.size() == 24) {
			string button = explode("\n", t_[3])[0].c_str();
			if (button == "restore_default") {
				pInfo(peer)->cape_t = 2402849791, pInfo(peer)->cape_c = 2402849791, pInfo(peer)->cape_t2 = 723421695, pInfo(peer)->cape_c2 = 1059267327;
				pInfo(peer)->flags = 19451, pInfo(peer)->TimeDilation = 30;
				pInfo(peer)->CapeStyleColor_1 = "147,56,143", pInfo(peer)->CapeCollarColor_1 = "147,56,143", pInfo(peer)->CapeStyleColor_2 = "137,30,43", pInfo(peer)->CapeCollarColor_2 = "34,35,36";
				Clothing_V2::Update(peer);
			}
			else if (button == "button_manual") DialogHandle::Rift_Cape(peer, "\nadd_textbox|This cape has several special functions!|left|\nadd_spacer|small|\nadd_textbox|To set the color for the cape and collar you need to enter an RGB (Red, Blue, Green) value. To separate the individual values, you need to use a comma.|left|\nadd_spacer|small|\nadd_textbox|Set the Time Dilation Cycle Time to define how often the cape will change between the two Cape Styles. Cycle time is in seconds; maximum number of seconds allowed is: 86400 seconds (24 hours).|left|");
		}
		Clothing_V2::Update(peer);
	}
	static void skin_color(ENetPeer* peer, std::string cch) {
		std::vector<std::string> t_ = explode("|", cch), color;
		if (t_.size() < 4) return;
		string color_convert = explode("\n", t_[3])[0].c_str();
		if (color_convert == "restore_default") {
			pInfo(peer)->skin_c = "0,0,0";
			pInfo(peer)->skin = 0x8295C3FF;
		}
		else {
			color = explode(",", color_convert);
			if (color.size() == 3) {
				if (atoi(explode(",", color[0])[0].c_str()) >= 0 && atoi(explode(",", color[0])[0].c_str()) <= 255 && atoi(explode(",", color[1])[0].c_str()) >= 0 && atoi(explode(",", color[1])[0].c_str()) <= 255 && atoi(explode(",", color[2])[0].c_str()) >= 0 && atoi(explode(",", color[2])[0].c_str()) <= 255) {
					pInfo(peer)->skin_c = color_convert;
					uint8_t* cancer = (uint8_t*)(&(pInfo(peer)->skin));
					cancer[1] = std::atoi(explode(",", color[0])[0].c_str());
					cancer[2] = std::atoi(explode(",", color[1])[0].c_str());
					cancer[3] = std::atoi(explode(",", color[2])[0].c_str());
				}
			}
		}
		Clothing_V2::Update(peer);
	}
	static void News(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "featured_server") {
				std::ifstream txt("database/text/featured.txt");
				std::stringstream buffer;
				buffer << txt.rdbuf();
				std::string dialog(buffer.str());
				VarList::OnDialogRequest(peer, SetColor(peer) + dialog);
			}
			if (button.substr(0, 8) == "warp_to_") {
				string world_name = button.substr(8);
				Enter_World(peer, world_name);
			}
			if (button == "back") DialogHandle::News(peer);
			if (button == "cc_program") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_image_button||interface/large/gui_social_banner1.rttex|bannerlayout|||\nadd_spacer|small|\nadd_smalltext|`$We are looking streamer to stream " + Environment()->server_name + ", if you asking what's the benefits for streaming " + Environment()->server_name + ", this list is the benefits:|left|\nadd_smalltext|`7   - Role `#@Moderator`` (PERMANENT)|left|\nadd_smalltext|`7   - Tiktok Badge (for Tiktok Creator) / Verifed Badge (for Youtuber Creator)|left|\nadd_smalltext|`7   - Your videos about this server and your TikTok account or YouTube channel will be displayed on the Community Hub board and also on our official website|left|\nadd_smalltext|`7   - You will get items needed for live needs from the Owner such as Custom Items and other rare items.|left|\nadd_smalltext|`7   - Custom Block & Awesome Item-O-Matic|left|\nadd_button_with_icon|||noflags,no_padding_x,|8148||\nadd_button_with_icon|||noflags,no_padding_x,|8150||\nadd_button_with_icon|||noflags,no_padding_x,|8152||\nadd_button_with_icon|||noflags,no_padding_x,|8154||\nadd_button_with_icon|||noflags,no_padding_x,|8156||\nadd_button_with_icon|||noflags,no_padding_x,|8158||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|\nadd_smalltext|`$The benefits will increase along with your performance|left|\nadd_smalltext|`5Requierements:|left|\nadd_smalltext|`7   - Your followers / Subscriber must up to 250 (Real Followers / Subscriber)|left|\nadd_smalltext|`7   - Your view must up to 100+ (Real View)|left|\nadd_smalltext|`7   - Daily stream for once every 1 day|left|\nadd_smalltext|`7   - The content is about " + Environment()->server_name + "|left|\nadd_spacer|small|\nadd_smalltext|`$Contact Helper or Owner to send your live stats and profile.|left|\nadd_spacer|small|\nadd_button|back|`wBack|\nend_dialog|News|||\nadd_quick_exit|");
		}
	}
	static void handleHalloweenShopVerification(ENetPeer* peer, std::string cch) {
		if (!Event()->Halloween) return;
		TextScanner parser(cch);
		std::string button = "";
		if (!parser.try_get("buttonClicked", button)) return;
		if (button == "back" or button == "no") {
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wShady Salesman``|left|12826|\nadd_spacer|small|\nadd_smalltext|Welcome Stranger! Complete your Trick or Treat Tasks to earn some sweet candy. You can get your tasks by scaring my good old pal Crazy Jim while wearing `5" + items[7112].name + "`` item today and doing his tasks. In case you forgot, dial 12345 on a phone to call him. In return for candy I can trade you these spooky boxes!|left|\nadd_spacer|small|\ntext_scaling_string|10,000BZ|\nadd_button_with_icon|halloween_store_item_open_purchase_0|20|noflags|12830||\nadd_button_with_icon|halloween_store_item_open_purchase_1|100|noflags|12832||\nadd_button_with_icon||END_LIST|noflags|0||\nend_dialog|handleHalloweenShopPopup|OK|\nadd_quick_exit|");
		}
		if (button == "yesbuy") {
			int id = std::atoi(explode("\n", explode("itemIndex|", cch)[1])[0].c_str());
			int Candy = 0, item = id == 0 ? 12830 : 12832;
			Inventory::Modify(peer, 12766, Candy);
			if (Candy >= (id == 0 ? 20 : 100)) {
				int c_ = 1, remove = id == 0 ? -20 : -100;
				if (Inventory::Modify(peer, item, c_) == 0) {
					Inventory::Modify(peer, 12766, remove);
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You have got 1 " + items[item].name + "!", 0, 0);
				}
				else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough inventory!", 0, 0);
			}
		}
	}
	static void halloween_tasks_popup_handle(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "purchase_halloween_pack") {
				if (pInfo(peer)->gtwl < 600) {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`w\nadd_label|big|Purchase Unsuccessful.|left|\nadd_smalltext|You can't afford `oHalloween Starter Pack``! You're `$600`` " + Environment()->server_name + " Coin short. (Purchase " + Environment()->server_name + " Coin? Type `2/deposit``)|left|\nend_dialog||Continue||");
				}
				else {
					pInfo(peer)->gtwl -= 600;
					VarList::OnBuxGems(peer, 540000);
					std::vector<std::pair<int, int>> list; int add = 0;
					list.push_back(std::make_pair(25, 10328)), list.push_back(std::make_pair(5, 9018)), list.push_back(std::make_pair(75, 10386)), list.push_back(std::make_pair(1, 12744)), list.push_back(std::make_pair(1, 12766));
					for (const auto& item : list) {
						if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
							CAction::Positioned(peer, pInfo(peer)->netID, "audio/cash_register.wav", 0);
							WorldDrop drop_block_{};
							drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
							std::string name_ = pInfo(peer)->world;
							std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								world_->fresh_world = true;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
					}
				}
			}
			if (button == "warp_player_into_halloween_world") {
				string world = "GROWGANOTH";
				Enter_World(peer, world);
			}
			if (button == "open_store") {
				shop_tab(peer, "tab1_dark_ticket");
			}
			if (button.substr(0, 35) == "halloween_store_item_open_purchase_") {
				int item = std::atoi(button.substr(35).c_str()), Candy = Inventory::Contains(peer, 12766);
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wShady Salesman``|left|12826|\nadd_spacer|small|\nadd_textbox|Halloween " + (string(item == 0 ? "" : "Special ")) + "Gift Box costs `5" + to_string((item == 0 ? 20 : 100)) + " candies``. " + (Candy < (item == 0 ? 20 : 100) ? "You have `4" + to_string(Candy) + " candies`` so you can't afford it. Sorry!|left|\nadd_spacer|small|\nadd_button|back|Back|noflags|0|0|" : "Are you sure you want to buy it? You have `2" + Set_Count(Candy) + " candies``.|left|\nadd_spacer|small|\nadd_button|yesbuy|Yes, please|noflags|0|0|\nadd_button|no|No, thanks|noflags|0|0|\nembed_data|itemIndex|" + to_string(item)) + "\nend_dialog|handleHalloweenShopVerification||\nadd_quick_exit|");
			}
			if (button == "Claim_Reward") {
				if (pInfo(peer)->DarkKing_Sacrifices >= 15) {
					pInfo(peer)->DarkKing_Sacrifices -= 15;
					VarList::OnProgressUIUpdateValue(peer, 10328, pInfo(peer)->DarkKing_Sacrifices);
					VarList::OnProgressUISet(peer, 10328, pInfo(peer)->DarkKing_Sacrifices, 15);
					int itemid = items[10328].consume_prize[rand() % items[10328].consume_prize.size()], give_ = 1;
					if (Inventory::Modify(peer, itemid, give_) != 0) {
						WorldDrop drop_block_{};
						drop_block_.id = itemid, drop_block_.count = 1, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
						std::string name_ = pInfo(peer)->world;
						std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
						if (p != worlds.end()) {
							World* world_ = &worlds[p - worlds.begin()];
							world_->fresh_world = true;
							VisualHandle::Drop(world_, drop_block_);
						}
					}
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "A `2" + items[itemid].ori_name + "`` was bestowed upon you!", 0, 0);
					VarList::OnConsoleMessage(peer, "A `2" + items[itemid].ori_name + "`` was bestowed upon you!");
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wBonus Reward - Dark King's Offering``|left|10328|\nadd_spacer|small|\nadd_textbox|During the Halloween season, sacrificing 15 of the Dark King's Offering at the Maw of Growganoth will please him. As a token of thanks, he will grant you an extra reward.|left|\nadd_spacer|small|\nadd_textbox|Current Sacrifices: " + to_string(pInfo(peer)->DarkKing_Sacrifices) + "/15|left|\nadd_spacer|small|" + (pInfo(peer)->DarkKing_Sacrifices >= 15 ? "\nadd_button|Claim_Reward|`oClaim Reward|noflags|0|0|\nadd_spacer|small|" : "") + "\nadd_quick_exit|\nend_dialog|halloween_tasks_popup_handle|Close||", 500);
				}
			}
			if (button == "halloween_claim_task_reward_1") {
				if (pInfo(peer)->halloween_q1 >= 1) {
					int itemid = 12766, give_ = 5;
					if (Inventory::Modify(peer, itemid, give_) == 0) {
						pInfo(peer)->halloween_q1 -= 1;
						VarList::OnConsoleMessage(peer, "You received `25 Halloween Candy ``from Sacrifice Dark King's Offering!");
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You received `25 Halloween Candy ``from Sacrifice Dark King's Offering!", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!");
					DialogHandle::Halloween_Task(peer);
				}
			}
			if (button == "halloween_claim_task_reward_2") {
				if (pInfo(peer)->halloween_q2 >= 1) {
					int itemid = 12766, give_ = 1;
					if (Inventory::Modify(peer, itemid, give_) == 0) {
						pInfo(peer)->halloween_q2 -= 1;
						VarList::OnConsoleMessage(peer, "You received `21 Halloween Candy ``from Sacrifice Dark King's Offering!");
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You received `21 Halloween Candy ``from Sacrifice Dark King's Offering!", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!");
					DialogHandle::Halloween_Task(peer);
				}
			}
			if (button == "halloween_claim_task_reward_3") {
				if (pInfo(peer)->halloween_q3 >= 1) {
					int itemid = 12766, give_ = 2;
					if (Inventory::Modify(peer, itemid, give_) == 0) {
						pInfo(peer)->halloween_q3 -= 1;
						VarList::OnConsoleMessage(peer, "You received `22 Halloween Candy ``from Sacrifice Dark King's Offering!");
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You received `22 Halloween Candy ``from Sacrifice Dark King's Offering!", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!");
					DialogHandle::Halloween_Task(peer);
				}
			}
			if (button == "halloween_claim_task_reward_4") {
				if (pInfo(peer)->halloween_q4 >= 1) {
					int itemid = 12766, give_ = 10;
					if (Inventory::Modify(peer, itemid, give_) == 0) {
						pInfo(peer)->halloween_q4 -= 1;
						VarList::OnConsoleMessage(peer, "You received `25 Halloween Candy ``from Sacrifice Dark King's Offering!");
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You received `25 Halloween Candy ``from Sacrifice Dark King's Offering!", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!");
					DialogHandle::Halloween_Task(peer);
				}
			}
			if (button == "halloween_claim_task_reward_5") {
				if (pInfo(peer)->halloween_q5 >= 200 and not Has_Claimed::HalloweenT(peer, "task5")) {
					int itemid = 12766, give_ = 50;
					if (Inventory::Modify(peer, itemid, give_) == 0) {
						pInfo(peer)->HalloweenTask_Prize.push_back("task5");
						VarList::OnConsoleMessage(peer, "You received `250 Halloween Candy ``from Sacrifice Dark King's Offering!");
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You received `250 Halloween Candy ``from Sacrifice Dark King's Offering!", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!");
					DialogHandle::Halloween_Task(peer);
				}
			}
			if (button == "halloween_claim_task_reward_6") {
				if (pInfo(peer)->halloween_q6 >= 2 and not Has_Claimed::HalloweenT(peer, "task6")) {
					int itemid = 12766, give_ = 40;
					if (Inventory::Modify(peer, itemid, give_) == 0) {
						pInfo(peer)->HalloweenTask_Prize.push_back("task6");
						VarList::OnConsoleMessage(peer, "You received `240 Halloween Candy ``from Sacrifice Dark King's Offering!");
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You received `240 Halloween Candy ``from Sacrifice Dark King's Offering!", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!");
					DialogHandle::Halloween_Task(peer);
				}
			}
			if (button == "halloween_claim_task_reward_7") {
				if (pInfo(peer)->halloween_q7 >= 100 and not Has_Claimed::HalloweenT(peer, "task7")) {
					int itemid = 12766, give_ = 25;
					if (Inventory::Modify(peer, itemid, give_) == 0) {
						pInfo(peer)->HalloweenTask_Prize.push_back("task7");
						VarList::OnConsoleMessage(peer, "You received `225 Halloween Candy ``from Sacrifice Dark King's Offering!");
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You received `225 Halloween Candy ``from Sacrifice Dark King's Offering!", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!");
					DialogHandle::Halloween_Task(peer);
				}
			}
			if (button == "halloween_claim_task_reward_8") {
				if (pInfo(peer)->halloween_q8 >= 1 and not Has_Claimed::HalloweenT(peer, "task8")) {
					int itemid = 12766, give_ = 100;
					if (Inventory::Modify(peer, itemid, give_) == 0) {
						pInfo(peer)->HalloweenTask_Prize.push_back("task8");
						VarList::OnConsoleMessage(peer, "You received `2100 Halloween Candy ``from Sacrifice Dark King's Offering!");
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You received `2100 Halloween Candy ``from Sacrifice Dark King's Offering!", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!");
					DialogHandle::Halloween_Task(peer);
				}
			}
			if (button == "halloween_claim_task_reward_9") {
				if (pInfo(peer)->halloween_q9 >= 200 and not Has_Claimed::HalloweenT(peer, "task9")) {
					int itemid = 12766, give_ = 50;
					if (Inventory::Modify(peer, itemid, give_) == 0) {
						pInfo(peer)->HalloweenTask_Prize.push_back("task9");
						VarList::OnConsoleMessage(peer, "You received `2200 Halloween Candy ``from Sacrifice Dark King's Offering!");
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You received `2200 Halloween Candy ``from Sacrifice Dark King's Offering!", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!");
					DialogHandle::Halloween_Task(peer);
				}
			}
		}
	}
	static void WinterFest_Shop(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "purchase") {
				if (pInfo(peer)->gtwl < 700) {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`w\nadd_label|big|Purchase Unsuccessful.|left|\nadd_smalltext|You can't afford `oWinterfest Event Pack``! You're `$700`` " + Environment()->server_name + " Coin short. (Purchase " + Environment()->server_name + " Coin? Type `2/deposit``)|left|\nend_dialog||Continue||");
				}
				else {
					pInfo(peer)->gtwl -= 700;
					pInfo(peer)->winter_seal += 1200;
					VarList::OnBuxGems(peer, 130000);
					std::vector<std::pair<int, int>> list; int add = 0;
					list.push_back(std::make_pair(10, 1368)), list.push_back(std::make_pair(15, 5402)), list.push_back(std::make_pair(1, 5404)), list.push_back(std::make_pair(1, 10536));
					for (const auto& item : list) {
						if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
							CAction::Positioned(peer, pInfo(peer)->netID, "audio/cash_register.wav", 0);
							WorldDrop drop_block_{};
							drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
							std::string name_ = pInfo(peer)->world;
							std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								world_->fresh_world = true;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
					}
				}
			}
		}
	}
	static void Valentine_Shop(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "purchase_value") {
				if (pInfo(peer)->gtwl < 250) {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`w\nadd_label|big|Purchase Unsuccessful.|left|\nadd_smalltext|You can't afford `oValentine Value Pack``! You're `$250`` " + Environment()->server_name + " Coin short. (Purchase " + Environment()->server_name + " Coin? Type `2/deposit``)|left|\nend_dialog||Continue||");
				}
				else {
					pInfo(peer)->gtwl -= 250;
					VarList::OnBuxGems(peer, 105000);
					std::vector<std::pair<int, int>> list; int add = 0;
					list.push_back(std::make_pair(2, 14248)), list.push_back(std::make_pair(20, 3402)), list.push_back(std::make_pair(1, 10656));
					for (const auto& item : list) {
						if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
							CAction::Positioned(peer, pInfo(peer)->netID, "audio/cash_register.wav", 0);
							WorldDrop drop_block_{};
							drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
							std::string name_ = pInfo(peer)->world;
							std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								world_->fresh_world = true;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
					}
				}
			}
			if (button == "purchase_starter") {
				if (pInfo(peer)->gtwl < 900) {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`w\nadd_label|big|Purchase Unsuccessful.|left|\nadd_smalltext|You can't afford `oValentine Starter Pack``! You're `$900`` " + Environment()->server_name + " Coin short. (Purchase " + Environment()->server_name + " Coin? Type `2/deposit``)|left|\nend_dialog||Continue||");
				}
				else {
					pInfo(peer)->gtwl -= 900;
					VarList::OnBuxGems(peer, 540000);
					std::vector<std::pair<int, int>> list; int add = 0;
					list.push_back(std::make_pair(50, 3402)), list.push_back(std::make_pair(3, 9350)), list.push_back(std::make_pair(1, 10656)), list.push_back(std::make_pair(1, 13154)), list.push_back(std::make_pair(1, 13142));
					for (const auto& item : list) {
						if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
							CAction::Positioned(peer, pInfo(peer)->netID, "audio/cash_register.wav", 0);
							WorldDrop drop_block_{};
							drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
							std::string name_ = pInfo(peer)->world;
							std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								world_->fresh_world = true;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
					}
				}
			}
		}
	}
	static void Goblin_Disguise(ENetPeer* peer, std::string cch) {
		if (not pInfo(peer)->Silver_Donatur) return;
		pInfo(peer)->Already_Tried_Gob = true;
		pInfo(peer)->Present_Goblin = time(nullptr) + 30;
		pInfo(peer)->face = 4260;
		Clothing_V2::Update_Value(peer);
		Clothing_V2::Update(peer);
	}
	static void mooncake_choose_dialog(ENetPeer* peer, std::string cch) {
		if (pInfo(peer)->lastwrenchb != 12598) return;
		std::vector<std::string> t_ = explode("|", cch);
		if (t_.size() < 4) return;
		string button = explode("\n", t_[5])[0].c_str();
		if (button == "goto_maindialog") offering_table(peer);
		else {
			int slot = std::atoi(explode("\n", t_[3])[0].c_str());
			if (button.find("item_btn_") != std::string::npos) {
				int item = std::atoi(button.substr(9, button.length() - 9).c_str()), have = 0;
				if (item < 0 or item >= items.size()) return;
				if (items[item].mooncake) {
					Inventory::Modify(peer, item, have);
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`w" + items[item].name + "``|left|" + to_string(item) + "|\nadd_textbox|`2How many do you want to offer?``|left|\nadd_text_input|count||" + to_string(have) + "|5|\nembed_data|itemID|" + to_string(item) + "\nembed_data|slot|" + to_string(slot) + "\nadd_spacer|small|\nadd_button|goto_choosedoalog|Cancel|0|0|\nadd_button|ok|OK|0|0|\nadd_spacer|small|\nend_dialog|mooncake_count_dialog|||");
				}
			}
			else if (button == "clear_slot") {
				std::string name_ = pInfo(peer)->world;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					world_->fresh_world = true;
					WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
					if (Only_Access(peer, world_, block_)) {
						for (int i_ = 0; i_ < block_->donates.size(); i_++) {
							if (i_ == slot) {
								if (Inventory::Modify(peer, block_->donates[i_].item, block_->donates[i_].count) == 0) {
									block_->donates.erase(block_->donates.begin() + i_);
								}
								else {
									VarList::OnConsoleMessage(peer, "No inventory space.");
								}
							}
						}
					}
				}
			}
		}
	}
	static void mooncake_count_dialog(ENetPeer* peer, std::string cch) {
		if (pInfo(peer)->lastwrenchb != 12598) return;
		std::vector<std::string> t_ = explode("|", cch);
		if (t_.size() < 4) return;
		string button = explode("\n", t_[7])[0].c_str();
		if (button == "goto_choosedoalog") offering_table(peer);
		else if (button == "ok") {
			int item = std::atoi(explode("\n", t_[3])[0].c_str()), slot = std::atoi(explode("\n", t_[5])[0].c_str()), count = std::atoi(explode("\n", t_[8])[0].c_str()), have = 0;
			if (item < 0 or item >= items.size()) return;
			if (items[item].mooncake) {
				Inventory::Modify(peer, item, have);
				if (have >= count && count > 0) offering_table(peer, 0, "", item, count, slot);
			}
		}
	}
	static void guide_book(ENetPeer* peer, std::string cch) {
		std::vector<std::string> t_ = explode("|", cch);
		if (t_.size() < 4) return;
		string button = explode("\n", t_[3])[0].c_str();
		if (button == "news") DialogHandle::News(peer);
		else if (button == "rules") DialogHandle::Rules(peer);
		else {
			pInfo(peer)->page_number = 26;
			pInfo(peer)->page_item = "";
			DialogHandle::Splicing_Recipe(peer, (button == "splicing" ? Environment()->splicing : button == "combining" ? Environment()->combining : button == "combusting" ? Environment()->combusting : Environment()->crystals));
		}
	}
	static void guide_book_(ENetPeer* peer, std::string cch) {
		std::vector<std::string> t_ = explode("|", cch);
		if (t_.size() < 4) return;
		string button = explode("\n", t_[3])[0].c_str();
		if (button == "search") {
			pInfo(peer)->page_number = 26;
			pInfo(peer)->page_item = explode("\n", t_[4])[0].c_str();
		}
		else if (button == "next_pg") pInfo(peer)->page_number += 26;
		else if (button == "last_pg") {
			pInfo(peer)->page_number -= 26;
			if (pInfo(peer)->page_number < 0) pInfo(peer)->page_number = 26;
		}
		if (t_.size() > 4) {
			if (cch.find("guide_book_s\n") != string::npos) DialogHandle::Splicing_Recipe(peer, Environment()->splicing);
			else if (cch.find("guide_book_c\n") != string::npos) DialogHandle::Splicing_Recipe(peer, Environment()->combining);
			else if (cch.find("guide_book_f\n") != string::npos) DialogHandle::Splicing_Recipe(peer, Environment()->combusting);
			else if (cch.find("guide_book_r\n") != string::npos) DialogHandle::Splicing_Recipe(peer, Environment()->crystals);
		}
		else DialogHandle::GuideBook(peer);
	}
	static void dialog_minokawa(ENetPeer* peer, std::string cch) {
		if (pInfo(peer)->back == 12640) {
			std::vector<std::string> t_ = explode("|", cch);
			if (t_.size() < 5) return;
			bool minokawa_wings = std::atoi(explode("\n", t_[3])[0].c_str()), minokawa_pet = std::atoi(explode("\n", t_[4])[0].c_str());
			if (minokawa_wings && minokawa_pet) pInfo(peer)->minokawa_wings = 2;
			else if (minokawa_wings == false && minokawa_pet == false) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You must choose one or two of the options!", 0, 0);
			}
			else {
				if (minokawa_wings) pInfo(peer)->minokawa_wings = 0;
				if (minokawa_pet) pInfo(peer)->minokawa_wings = 1;
			}
			Clothing_V2::Update(peer);
		}
	}
	static void top(ENetPeer* peer, std::string cch) {
		std::string button = "";
		TextScanner parser(cch);
		if (parser.try_get("buttonClicked", button)) {
			if (button == "wotdlistback") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n\nadd_label_with_icon|big|`oWorld Rankings``|left|394|\nadd_spacer|\nadd_textbox|World Rankings are based on unique daily visitors. Where do your worlds stack up?|\nadd_button|toprated|`8Top Rated Worlds``|noflags|0|0|\nadd_button|toplist|`8Top worlds today``|noflags|0|0|\nadd_button|yesterdaylist|`5Top worlds yesterday``|noflags|0|0|\nadd_button|overalllist|`0Top worlds overall``|noflags|0|0|\nadd_button|wotd|`$World of the Day winners``|noflags|0|0|\nend_dialog|top|Close||\n");
			if (button == "toplist") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n\nadd_label_with_icon|big|`8Top Worlds Of Today``|left|394|\nadd_spacer|" + top_list + "\nadd_button|wotwlistback|`oBack`|NOFLAGS|0|0|\nend_dialog|top|Close||\n");
			if (button == "yesterdaylist") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n\nadd_label_with_icon|big|`5Top Worlds Of Yesterday``|left|394|\nadd_spacer|" + top_yesterday_list + "\nadd_button|wotwlistback|`oBack`|NOFLAGS|0|0|\nend_dialog|top|Close||\n");
			if (button == "overalllist") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n\nadd_label_with_icon|big|`0Top Worlds Of All Time``|left|394|\nadd_spacer|" + top_overall_list + "\nadd_button|wotwlistback|`oBack`|NOFLAGS|0|0|\nend_dialog|top|Close||\n");
			if (button == "toprated") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wTop Rated Worlds``|left|3802|\nadd_textbox|Select a category to view.|left|\nadd_button|cat_1|Adventure|noflags|0|0|\nadd_button|cat_2|Art|noflags|0|0|\nadd_button|cat_3|Farm|noflags|0|0|\nadd_button|cat_4|Game|noflags|0|0|\nadd_button|cat_5|Information|noflags|0|0|\nadd_button|cat_6|Parkour|noflags|0|0|\nadd_button|cat_7|Roleplay|noflags|0|0|\nadd_button|cat_8|Shop|noflags|0|0|\nadd_button|cat_9|Social|noflags|0|0|\nadd_button|cat_10|Storage|noflags|0|0|\nadd_button|cat_11|Story|noflags|0|0|\nadd_button|cat_12|Trade|noflags|0|0|\nadd_button|cat_13|Guild|noflags|0|0|\nadd_button|cat_14|Puzzle|noflags|0|0|\nadd_button|cat_15|Music|noflags|0|0|\nend_dialog|top|Nevermind||");
			if (button.substr(0, 8) == "warp_to_") {
				string world_name = button.substr(8);
				Enter_World(peer, world_name);
			}
			if (button == "wotd") {
				string wotd_text = "";
				if (Environment()->WOTD.size() == 0) wotd_text = "\nadd_smalltext|The list should update in few minutes.|\nadd_spacer|small|";
				else {
					for (const auto& wlist : Environment()->WOTD) {
						wotd_text += "\nadd_button|warp_to_" + wlist.first + "|`w" + wlist.first + "`` by `#" + wlist.second + "``|noflags|0|0|";
					}
				}
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n\nadd_label_with_icon|big|`$World Of The Day Winners``|left|394|\nadd_spacer|" + wotd_text + "\nadd_button|wotdlistback|`oBack`|NOFLAGS|0|0|\nend_dialog|top|Close||\n");
			}
			if (button.substr(0, 4) == "cat_") {
				int world_rateds = std::atoi(button.substr(4).c_str());
				if (world_rateds > Environment()->world_rate_types.size()) return;
				string worlds = "";
				for (int i = 0; i < Environment()->world_rate_types[world_rateds].size(); i++) {
					string world = Environment()->world_rate_types[world_rateds][i].substr(0, Environment()->world_rate_types[world_rateds][i].find("|")), rate = Environment()->world_rate_types[world_rateds][i].substr(Environment()->world_rate_types[world_rateds][i].find("|") + 1);
					worlds += "\nadd_button|warp_to_" + world + "|#" + to_string(i + 1) + "``. `8" + world + "`` (" + rate + ")|noflags|0|0|";
				}
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wTop 100 " + (world_category(world_rateds)) + " Worlds``|left|3802|" + worlds + "\nend_dialog|top|Nevermind|Back|\n");
			}
		}
	}
	static void Shop_Assets(ENetPeer* peer, std::string cch) {
		std::string button = "";
		TextScanner parser(cch);
		if (parser.try_get("buttonClicked", button)) {
			if (button == "backtoshopdialog") DialogHandle::Shop_Assets(peer);
			if (button == "deposit") DialogHandle::Deposit(peer);
			if (button == "Buy_PiggyBank") {
				if (pInfo(peer)->pg_bank == 0) {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`5Piggy Bank|left|14588|\nadd_smalltext|You're viewing the Piggy Bank benefits & privilieges, every role has it's own features, also if you own a higher role than another you also get the previous role features!|left|\nadd_spacer|small|\nadd_label_with_icon|small|`5Piggy Bank ``Benefits:|left|2398|\nadd_spacer|small|\nadd_custom_textbox|`2Extra Gems `o- Complete the Daily Quest, Life goals and Daily Bonus to fill the piggy bank with gems and take the gems once the bank is full.|size:small;color:255,255,255,255;icon:4490;|\nadd_custom_textbox|`1Permanent`o - ............|size:small;color:255,255,255,255;icon:3804;|\nadd_spacer|small|\nadd_label_with_icon|small|`2Price ``: 400 " + Environment()->server_name + " Coin|left|244|\nadd_spacer|small|\nadd_smalltext|`4NOTE``: Make sure to read this information clearly!``|left|\nadd_spacer|small|\nadd_custom_button|backtoshopdialog|textLabel:Cancel;middle_colour:3434645503;border_colour:3434645503;display:block;|\nadd_custom_button|YesBuy_PiggyBank|textLabel:Return;middle_colour:431888895;border_colour:431888895;anchor:backtoshopdialog;left:1;margin:40,0;|\nreset_placement_x|\nadd_spacer|small|\nend_dialog|Shop_Assets|||");
				}
			}
			if (button == "Buy_BoostRole") {
				if (not pInfo(peer)->Role.BOOST) {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`5[BOOST] `wRole|left|9228|\nadd_smalltext|You're viewing the Boost Role benefits & privilieges, every role has it's own features, also if you own a higher role than another you also get the previous role features!|left|\nadd_spacer|small|\nadd_label_with_icon|small|`5[BOOST] ``Benefits:|left|2398|\nadd_spacer|small|\nadd_custom_textbox|`22x Gems `o- Applies to all farmable blocks and this can be overridden with other x gems effects.|size:small;color:255,255,255,255;icon:4490;|\nadd_custom_textbox|`11 Weeks / 7 Day`o - This role is not permanent, you are only given 7 days to use it, after 7 days this role will automatically disappear from your account.|size:small;color:255,255,255,255;icon:3804;|\nadd_spacer|small|\nadd_label_with_icon|small|`2Price Role``: 400 " + Environment()->server_name + " Coin|left|244|\nadd_spacer|small|\nadd_smalltext|`4NOTE``: Make sure to read this information clearly!``|left|\nadd_spacer|small|\nadd_custom_button|backtoshopdialog|textLabel:Cancel;middle_colour:3434645503;border_colour:3434645503;display:block;|\nadd_custom_button|YesBuy_Boost|textLabel:Return;middle_colour:431888895;border_colour:431888895;anchor:backtoshopdialog;left:1;margin:40,0;|\nreset_placement_x|\nadd_spacer|small|\nend_dialog|Shop_Assets|||");
				}
			}
			if (button == "Buy_SupBoostRole") {
				if (not pInfo(peer)->Role.SUPER_BOOST) {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`8[SUPER-BOOST] `wRole|left|9228|\nadd_smalltext|You're viewing the Super-Boost Role benefits & privilieges, every role has it's own features, also if you own a higher role than another you also get the previous role features!|left|\nadd_spacer|small|\nadd_label_with_icon|small|`8[SUPER-BOOST] ``Benefits:|left|2398|\nadd_spacer|small|\nadd_custom_textbox|`24x Gems `o- Applies to all farmable blocks and this can be overridden with other x gems effects.|size:small;color:255,255,255,255;icon:4490;|\nadd_custom_textbox|`110 Day`o - This role is not permanent, you are only given 10 days to use it, after 10 days this role will automatically disappear from your account.|size:small;color:255,255,255,255;icon:3804;|\nadd_spacer|small|\nadd_label_with_icon|small|`2Price Role``: 800 " + Environment()->server_name + " Coin|left|244|\nadd_spacer|small|\nadd_smalltext|`4NOTE``: Make sure to read this information clearly!``|left|\nadd_spacer|small|\nadd_custom_button|backtoshopdialog|textLabel:Cancel;middle_colour:3434645503;border_colour:3434645503;display:block;|\nadd_custom_button|YesBuy_SupBoost|textLabel:Return;middle_colour:431888895;border_colour:431888895;anchor:backtoshopdialog;left:1;margin:40,0;|\nreset_placement_x|\nadd_spacer|small|\nend_dialog|Shop_Assets|||");
				}
			}
			if (button == "YesBuy_PiggyBank") {
				if (pInfo(peer)->pg_bank != 0) return;
				if (pInfo(peer)->gtwl >= 400) {
					pInfo(peer)->gtwl -= 400;
					pInfo(peer)->pg_bank = 0;
					VarList::OnAddNotification(peer, "You has been received Piggy Bank!", "interface/atomic_button.rttex", "audio/hub_open.wav");
					CAction::Log(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; cp_++) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(peer)->world != pInfo(cp_)->world) continue;
						CAction::Effect_V2(cp_, 199, (float)pInfo(peer)->x + 16, (float)pInfo(peer)->y + 16);
					}
				}
				else VarList::OnConsoleMessage(peer, "`o>> You don't have enough Coin! Type /deposit.``");
			}
			if (button == "YesBuy_Boost") {
				if (pInfo(peer)->Role.BOOST) return;
				if (pInfo(peer)->gtwl >= 400) {
					pInfo(peer)->gtwl -= 400;
					pInfo(peer)->Role.BOOST = true;
					pInfo(peer)->Role.BOOST_TIME = time(nullptr) + 604800;
					VarList::OnAddNotification(peer, "You has been received [BOOST] Role!", "interface/atomic_button.rttex", "audio/hub_open.wav");
					pInfo(peer)->name_color = Role::Prefix(peer);
					VisualHandle::Nick(peer, NULL);
					CAction::Log(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; cp_++) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(peer)->world != pInfo(cp_)->world) continue;
						CAction::Effect_V2(cp_, 199, (float)pInfo(peer)->x + 16, (float)pInfo(peer)->y + 16);
					}
				}
				else VarList::OnConsoleMessage(peer, "`o>> You don't have enough Coin! Type /deposit.``");
			}
			if (button == "YesBuy_SupBoost") {
				if (pInfo(peer)->Role.SUPER_BOOST) return;
				if (pInfo(peer)->gtwl >= 800) {
					pInfo(peer)->gtwl -= 800;
					pInfo(peer)->Role.SUPER_BOOST = true;
					pInfo(peer)->Role.SUPER_BOOST_TIME = time(nullptr) + 864000;
					VarList::OnAddNotification(peer, "You has been received [SUPER-BOOST] Role!", "interface/atomic_button.rttex", "audio/hub_open.wav");
					pInfo(peer)->name_color = Role::Prefix(peer);
					VisualHandle::Nick(peer, NULL);
					CAction::Log(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; cp_++) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(peer)->world != pInfo(cp_)->world) continue;
						CAction::Effect_V2(cp_, 199, (float)pInfo(peer)->x + 16, (float)pInfo(peer)->y + 16);
					}
				}
				else VarList::OnConsoleMessage(peer, "`o>> You don't have enough Coin! Type /deposit.``");
			}
		}
	}
	static void surge_(ENetPeer* peer, std::string cch) {
		if (pInfo(peer)->lastwrenchb == 4296 || pInfo(peer)->lastwrenchb == 8558) {
			setstats(peer, rand() % 30 + 1, "", items[pInfo(peer)->lastwrenchb].name);
		}
	}
	static void ss_storage(ENetPeer* peer, std::string cch) {
		std::string name_ = pInfo(peer)->world;
		std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			world_->fresh_world = true;
			WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
			if (block_->fg == 8878) {
				if (to_lower(world_->owner_name) == to_lower(pInfo(peer)->tankIDName) || Role::Administrator(peer)) {
					std::vector<std::string> t_ = explode("|", cch);
					if (t_.size() < 4) return;
					string button = explode("\n", t_[3])[0].c_str();
					if (button == "s_password") {
						string text = explode("\n", t_[4])[0].c_str(), text2 = explode("\n", t_[5])[0].c_str();
						if (not check_password(text) || not check_password(text2)) VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`4Your input contains special characters. It should only contain alphanumeric characters!``", 0, 1);
						else if (text.empty()) VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`4You did not enter a new password!``", 0, 1);
						else if (text2.empty()) VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`4You did not enter a recovery answer!``", 0, 1);
						else if (text.length() > 12 || text2.length() > 12) VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`4The password is too long! You can only use a maximum of 12 characters!``", 0, 1);
						else {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`2Your password has been updated!``", 0, 1);
							block_->door_destination = text;
							block_->door_id = text2;
						}
					}
					else if (button == "check_password") {
						string password = explode("\n", t_[4])[0].c_str();
						if (to_lower(password) == to_lower(block_->door_destination)) {
							pInfo(peer)->temporary_vault = password;
							DialogHandle::Storage_Box(peer, world_, block_);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`4The password you entered did not match!``", 0, 1);
					}
					else if (button == "show_recoveryanswer") {
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSafe Vault``|left|8878|\nadd_textbox|Please enter recovery answer.|left|\nadd_text_input|storage_recovery_answer|||12|\nadd_button|check_recovery|Enter Recovery Answer|noflags|0|0|\nend_dialog|ss_storage|Exit||\nadd_quick_exit|");
					}
					else if (button == "check_recovery") {
						string password = explode("\n", t_[4])[0].c_str();
						if (to_lower(password) == to_lower(block_->door_id)) {
							block_->door_destination = "", block_->door_id = "";
							DialogHandle::Storage_Box(peer, world_, block_);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`4The recovery answer you entered does not match!``", 0, 1);
					}
				}
			}
		}
	}
	static void lvl_rewards(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (!parser.try_get("buttonClicked", button)) return;
		if (button == "info") send_wrench_self(peer, "");
		else if (button == "road_to_glory") send_wrench_self(peer, "road_to_glory");
		else if (button == "kit_pass") send_wrench_self(peer, "kit_pass");
		else if (button == "level_rwds") send_wrench_self(peer, "level_rwds");
		else if (button == "skill_and_assets") send_wrench_self(peer, "skill_and_assets");
		else if (button == "previous_page1") DialogHandle::Level_Rewards(peer, "1");
		else if (button == "next_page2" or button == "previous_page2") DialogHandle::Level_Rewards(peer, "2");
		else if (button == "next_page3" or button == "previous_page3") DialogHandle::Level_Rewards(peer, "3");
		else if (button == "next_page4" or button == "previous_page4") DialogHandle::Level_Rewards(peer, "4");
		else if (button == "next_page5" or button == "previous_page5") DialogHandle::Level_Rewards(peer, "5");
		else if (button.substr(0, 6) == "claim_") {
			std::string type = button.substr(6); int add = 0; bool has_ = false;
			std::string name_ = pInfo(peer)->world;
			std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				world_->fresh_world = true;
				if (type == "lvl5") {
					if (pInfo(peer)->level >= 5) {
						if (Has_Claimed::Lvl(peer, 5)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(50, 3839)), list.push_back(std::make_pair(5, 242)), list.push_back(std::make_pair(10, 1778)), list.push_back(std::make_pair(5, 1008));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(5);
						DialogHandle::Level_Rewards(peer, "1");
						has_ = true;
					}
				}
				if (type == "lvl10") {
					if (pInfo(peer)->level >= 10) {
						if (Has_Claimed::Lvl(peer, 10)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(50, 3839)), list.push_back(std::make_pair(5, 242)), list.push_back(std::make_pair(10, 1778)), list.push_back(std::make_pair(5, 1008));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(10);
						DialogHandle::Level_Rewards(peer, "1");
						has_ = true;
					}
				}
				if (type == "lvl15") {
					if (pInfo(peer)->level >= 15) {
						if (Has_Claimed::Lvl(peer, 15)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(50, 3839)), list.push_back(std::make_pair(5, 242)), list.push_back(std::make_pair(10, 1778)), list.push_back(std::make_pair(1, 1796));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->Intertwined_Fate = pInfo(peer)->Intertwined_Fate + 5;
						pInfo(peer)->lvl_rewards.push_back(15);
						DialogHandle::Level_Rewards(peer, "1");
						has_ = true;
					}
				}
				if (type == "lvl20") {
					if (pInfo(peer)->level >= 20) {
						if (Has_Claimed::Lvl(peer, 20)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(50, 3839)), list.push_back(std::make_pair(5, 242)), list.push_back(std::make_pair(10, 1778)), list.push_back(std::make_pair(5, 1008));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(20);
						DialogHandle::Level_Rewards(peer, "1");
						has_ = true;
					}
				}
				if (type == "lvl25") {
					if (pInfo(peer)->level >= 25) {
						if (Has_Claimed::Lvl(peer, 25)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(50, 341)), list.push_back(std::make_pair(5, 242)), list.push_back(std::make_pair(10, 1778)), list.push_back(std::make_pair(3, 1796)), list.push_back(std::make_pair(5, 1008));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(25);
						DialogHandle::Level_Rewards(peer, "1");
						has_ = true;
					}
				}
				if (type == "lvl30") {
					if (pInfo(peer)->level >= 30) {
						if (Has_Claimed::Lvl(peer, 30)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(50, 341)), list.push_back(std::make_pair(10, 242)), list.push_back(std::make_pair(10, 1778)), list.push_back(std::make_pair(10, 14084)), list.push_back(std::make_pair(5, 1008));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(30);
						DialogHandle::Level_Rewards(peer, "1");
						has_ = true;
					}
				}
				if (type == "lvl35") {
					if (pInfo(peer)->level >= 35) {
						if (Has_Claimed::Lvl(peer, 35)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(50, 341)), list.push_back(std::make_pair(10, 242)), list.push_back(std::make_pair(10, 1778)), list.push_back(std::make_pair(5, 1008));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(35);
						DialogHandle::Level_Rewards(peer, "1");
						has_ = true;
					}
				}
				if (type == "lvl40") {
					if (pInfo(peer)->level >= 40) {
						if (Has_Claimed::Lvl(peer, 40)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(50, 9929)), list.push_back(std::make_pair(5, 242)), list.push_back(std::make_pair(10, 1778)), list.push_back(std::make_pair(1, 6856));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(40);
						DialogHandle::Level_Rewards(peer, "1");
						has_ = true;
					}
				}
				if (type == "lvl45") {
					if (pInfo(peer)->level >= 45) {
						if (Has_Claimed::Lvl(peer, 45)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(50, 9929)), list.push_back(std::make_pair(5, 242)), list.push_back(std::make_pair(10, 1778)), list.push_back(std::make_pair(5, 1008)), list.push_back(std::make_pair(5, 1796));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(45);
						DialogHandle::Level_Rewards(peer, "1");
						has_ = true;
					}
				}
				if (type == "lvl50") {
					if (pInfo(peer)->level >= 50) {
						if (Has_Claimed::Lvl(peer, 50)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(50, 9929)), list.push_back(std::make_pair(5, 242)), list.push_back(std::make_pair(10, 1778)), list.push_back(std::make_pair(1, 528)), list.push_back(std::make_pair(10, 14084)), list.push_back(std::make_pair(5, 1008));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(50);
						DialogHandle::Level_Rewards(peer, "1");
						has_ = true;
					}
				}
				if (type == "lvl55") {
					if (pInfo(peer)->level >= 55) {
						if (Has_Claimed::Lvl(peer, 55)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(200, 3838)), list.push_back(std::make_pair(10, 242)), list.push_back(std::make_pair(10, 1778)), list.push_back(std::make_pair(5, 3044));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(55);
						DialogHandle::Level_Rewards(peer, "2");
						has_ = true;
					}
				}
				if (type == "lvl60") {
					if (pInfo(peer)->level >= 60) {
						if (Has_Claimed::Lvl(peer, 60)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(200, 3838)), list.push_back(std::make_pair(10, 242)), list.push_back(std::make_pair(10, 1778)), list.push_back(std::make_pair(5, 3044));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(60);
						DialogHandle::Level_Rewards(peer, "2");
						has_ = true;
					}
				}
				if (type == "lvl65") {
					if (pInfo(peer)->level >= 65) {
						if (Has_Claimed::Lvl(peer, 65)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(200, 3838)), list.push_back(std::make_pair(10, 242)), list.push_back(std::make_pair(10, 1778)), list.push_back(std::make_pair(1, 1778)), list.push_back(std::make_pair(5, 3044));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Acquaint_Fate = pInfo(peer)->Acquaint_Fate = 5;
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(65);
						DialogHandle::Level_Rewards(peer, "2");
						has_ = true;
					}
				}
				if (type == "lvl70") {
					if (pInfo(peer)->level >= 70) {
						if (Has_Claimed::Lvl(peer, 70)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(200, 3838)), list.push_back(std::make_pair(10, 242)), list.push_back(std::make_pair(10, 1778)), list.push_back(std::make_pair(5, 3044));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(70);
						DialogHandle::Level_Rewards(peer, "2");
						has_ = true;
					}
				}
				if (type == "lvl75") {
					if (pInfo(peer)->level >= 75) {
						if (Has_Claimed::Lvl(peer, 75)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(200, 340)), list.push_back(std::make_pair(10, 242)), list.push_back(std::make_pair(2, 1062)), list.push_back(std::make_pair(3, 1796)), list.push_back(std::make_pair(5, 3044));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(75);
						DialogHandle::Level_Rewards(peer, "2");
						has_ = true;
					}
				}
				if (type == "lvl80") {
					if (pInfo(peer)->level >= 80) {
						if (Has_Claimed::Lvl(peer, 80)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(200, 340)), list.push_back(std::make_pair(15, 242)), list.push_back(std::make_pair(2, 1062)), list.push_back(std::make_pair(10, 7960)), list.push_back(std::make_pair(5, 3044));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(80);
						DialogHandle::Level_Rewards(peer, "2");
						has_ = true;
					}
				}
				if (type == "lvl85") {
					if (pInfo(peer)->level >= 85) {
						if (Has_Claimed::Lvl(peer, 85)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(200, 340)), list.push_back(std::make_pair(15, 242)), list.push_back(std::make_pair(2, 1062)), list.push_back(std::make_pair(5, 3044));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(85);
						DialogHandle::Level_Rewards(peer, "2");
						has_ = true;
					}
				}
				if (type == "lvl90") {
					if (pInfo(peer)->level >= 90) {
						if (Has_Claimed::Lvl(peer, 90)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(200, 9928)), list.push_back(std::make_pair(15, 242)), list.push_back(std::make_pair(2, 1062)), list.push_back(std::make_pair(1, 5178));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(90);
						DialogHandle::Level_Rewards(peer, "2");
						has_ = true;
					}
				}
				if (type == "lvl95") {
					if (pInfo(peer)->level >= 95) {
						if (Has_Claimed::Lvl(peer, 95)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(200, 9928)), list.push_back(std::make_pair(15, 242)), list.push_back(std::make_pair(2, 1062)), list.push_back(std::make_pair(5, 1796)), list.push_back(std::make_pair(5, 3044));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(95);
						DialogHandle::Level_Rewards(peer, "2");
						has_ = true;
					}
				}
				if (type == "lvl100") {
					if (pInfo(peer)->level >= 100) {
						if (Has_Claimed::Lvl(peer, 100)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(200, 9928)), list.push_back(std::make_pair(15, 242)), list.push_back(std::make_pair(1, 13574)), list.push_back(std::make_pair(10, 7960)), list.push_back(std::make_pair(1, 9602)), list.push_back(std::make_pair(5, 1008));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(100);
						DialogHandle::Level_Rewards(peer, "2");
						has_ = true;
					}
				}
				if (type == "lvl105") {
					if (pInfo(peer)->level >= 105) {
						if (Has_Claimed::Lvl(peer, 105)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(10, 4490)), list.push_back(std::make_pair(15, 242)), list.push_back(std::make_pair(5, 7962)), list.push_back(std::make_pair(1, 9844));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(105);
						DialogHandle::Level_Rewards(peer, "3");
						has_ = true;
					}
				}
				if (type == "lvl110") {
					if (pInfo(peer)->level >= 110) {
						if (Has_Claimed::Lvl(peer, 110)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(10, 4490)), list.push_back(std::make_pair(15, 242)), list.push_back(std::make_pair(5, 7962)), list.push_back(std::make_pair(5, 10716));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(110);
						DialogHandle::Level_Rewards(peer, "3");
						has_ = true;
					}
				}
				if (type == "lvl115") {
					if (pInfo(peer)->level >= 115) {
						if (Has_Claimed::Lvl(peer, 115)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(10, 4490)), list.push_back(std::make_pair(15, 242)), list.push_back(std::make_pair(5, 7962)), list.push_back(std::make_pair(5, 1796));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Intertwined_Fate = pInfo(peer)->Intertwined_Fate = 5;
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(115);
						DialogHandle::Level_Rewards(peer, "3");
						has_ = true;
					}
				}
				if (type == "lvl120") {
					if (pInfo(peer)->level >= 120) {
						if (Has_Claimed::Lvl(peer, 120)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(10, 4490)), list.push_back(std::make_pair(15, 242)), list.push_back(std::make_pair(5, 7962)), list.push_back(std::make_pair(5, 10716));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(120);
						DialogHandle::Level_Rewards(peer, "3");
						has_ = true;
					}
				}
				if (type == "lvl125") {
					if (pInfo(peer)->level >= 125) {
						if (Has_Claimed::Lvl(peer, 125)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(10, 4490)), list.push_back(std::make_pair(15, 242)), list.push_back(std::make_pair(5, 7962)), list.push_back(std::make_pair(5, 1796)), list.push_back(std::make_pair(5, 10716));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(125);
						DialogHandle::Level_Rewards(peer, "3");
						has_ = true;
					}
				}
				if (type == "lvl130") {
					if (pInfo(peer)->level >= 130) {
						if (Has_Claimed::Lvl(peer, 130)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(10, 4490)), list.push_back(std::make_pair(15, 242)), list.push_back(std::make_pair(5, 7962)), list.push_back(std::make_pair(5, 10716)), list.push_back(std::make_pair(1, 528));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(130);
						DialogHandle::Level_Rewards(peer, "3");
						has_ = true;
					}
				}
				if (type == "lvl135") {
					if (pInfo(peer)->level >= 135) {
						if (Has_Claimed::Lvl(peer, 135)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(10, 4490)), list.push_back(std::make_pair(15, 242)), list.push_back(std::make_pair(5, 7962)), list.push_back(std::make_pair(5, 10716));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(135);
						DialogHandle::Level_Rewards(peer, "3");
						has_ = true;
					}
				}
				if (type == "lvl140") {
					if (pInfo(peer)->level >= 140) {
						if (Has_Claimed::Lvl(peer, 140)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(10, 4490)), list.push_back(std::make_pair(15, 242)), list.push_back(std::make_pair(5, 7962)), list.push_back(std::make_pair(5, 10716));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(140);
						DialogHandle::Level_Rewards(peer, "3");
						has_ = true;
					}
				}
				if (type == "lvl145") {
					if (pInfo(peer)->level >= 145) {
						if (Has_Claimed::Lvl(peer, 145)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(10, 4490)), list.push_back(std::make_pair(15, 242)), list.push_back(std::make_pair(5, 7962)), list.push_back(std::make_pair(5, 1796)), list.push_back(std::make_pair(1, 528));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(145);
						DialogHandle::Level_Rewards(peer, "3");
						has_ = true;
					}
				}
				if (type == "lvl150") {
					if (pInfo(peer)->level >= 150) {
						if (Has_Claimed::Lvl(peer, 150)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(10, 4490)), list.push_back(std::make_pair(15, 242)), list.push_back(std::make_pair(5, 7962)), list.push_back(std::make_pair(5, 10716)), list.push_back(std::make_pair(1, 528));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Acquaint_Fate = pInfo(peer)->Acquaint_Fate = 5;
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(150);
						DialogHandle::Level_Rewards(peer, "3");
						has_ = true;
					}
				}
				if (type == "lvl155") {
					if (pInfo(peer)->level >= 155) {
						if (Has_Claimed::Lvl(peer, 155)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(15, 4490)), list.push_back(std::make_pair(20, 242)), list.push_back(std::make_pair(3, 1062)), list.push_back(std::make_pair(25, 5706)), list.push_back(std::make_pair(1, 1966));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(155);
						DialogHandle::Level_Rewards(peer, "4");
						has_ = true;
					}
				}
				if (type == "lvl160") {
					if (pInfo(peer)->level >= 160) {
						if (Has_Claimed::Lvl(peer, 160)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(15, 4490)), list.push_back(std::make_pair(20, 242)), list.push_back(std::make_pair(3, 1062)), list.push_back(std::make_pair(25, 5706)), list.push_back(std::make_pair(200, 1746));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(160);
						DialogHandle::Level_Rewards(peer, "4");
						has_ = true;
					}
				}
				if (type == "lvl165") {
					if (pInfo(peer)->level >= 165) {
						if (Has_Claimed::Lvl(peer, 165)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(15, 4490)), list.push_back(std::make_pair(20, 242)), list.push_back(std::make_pair(3, 1062)), list.push_back(std::make_pair(25, 5706)), list.push_back(std::make_pair(5, 1796));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Intertwined_Fate = pInfo(peer)->Intertwined_Fate = 5;
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(165);
						DialogHandle::Level_Rewards(peer, "4");
						has_ = true;
					}
				}
				if (type == "lvl170") {
					if (pInfo(peer)->level >= 170) {
						if (Has_Claimed::Lvl(peer, 170)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(15, 4490)), list.push_back(std::make_pair(20, 242)), list.push_back(std::make_pair(3, 1062)), list.push_back(std::make_pair(25, 5706)), list.push_back(std::make_pair(1, 5488));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(170);
						DialogHandle::Level_Rewards(peer, "4");
						has_ = true;
					}
				}
				if (type == "lvl175") {
					if (pInfo(peer)->level >= 175) {
						if (Has_Claimed::Lvl(peer, 175)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(15, 4490)), list.push_back(std::make_pair(20, 242)), list.push_back(std::make_pair(3, 1062)), list.push_back(std::make_pair(25, 5706)), list.push_back(std::make_pair(6, 1796)), list.push_back(std::make_pair(1, 5486));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(175);
						DialogHandle::Level_Rewards(peer, "4");
						has_ = true;
					}
				}
				if (type == "lvl180") {
					if (pInfo(peer)->level >= 180) {
						if (Has_Claimed::Lvl(peer, 180)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(15, 4490)), list.push_back(std::make_pair(20, 242)), list.push_back(std::make_pair(3, 1062)), list.push_back(std::make_pair(25, 5706)), list.push_back(std::make_pair(1, 5484)), list.push_back(std::make_pair(2, 528));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(180);
						DialogHandle::Level_Rewards(peer, "4");
						has_ = true;
					}
				}
				if (type == "lvl185") {
					if (pInfo(peer)->level >= 185) {
						if (Has_Claimed::Lvl(peer, 185)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(15, 4490)), list.push_back(std::make_pair(20, 242)), list.push_back(std::make_pair(3, 1062)), list.push_back(std::make_pair(25, 5706)), list.push_back(std::make_pair(1, 5482));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(185);
						DialogHandle::Level_Rewards(peer, "4");
						has_ = true;
					}
				}
				if (type == "lvl190") {
					if (pInfo(peer)->level >= 190) {
						if (Has_Claimed::Lvl(peer, 190)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(15, 4490)), list.push_back(std::make_pair(20, 242)), list.push_back(std::make_pair(3, 1062)), list.push_back(std::make_pair(25, 5706)), list.push_back(std::make_pair(1, 5480));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(190);
						DialogHandle::Level_Rewards(peer, "4");
						has_ = true;
					}
				}
				if (type == "lvl195") {
					if (pInfo(peer)->level >= 195) {
						if (Has_Claimed::Lvl(peer, 195)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(15, 4490)), list.push_back(std::make_pair(20, 242)), list.push_back(std::make_pair(3, 1062)), list.push_back(std::make_pair(25, 5706)), list.push_back(std::make_pair(7, 1796)), list.push_back(std::make_pair(1, 9602));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(195);
						DialogHandle::Level_Rewards(peer, "4");
						has_ = true;
					}
				}
				if (type == "lvl200") {
					if (pInfo(peer)->level >= 200) {
						if (Has_Claimed::Lvl(peer, 200)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(15, 4490)), list.push_back(std::make_pair(25, 242)), list.push_back(std::make_pair(2, 13574)), list.push_back(std::make_pair(25, 5706)), list.push_back(std::make_pair(1, 6840)), list.push_back(std::make_pair(2, 5178));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(200);
						DialogHandle::Level_Rewards(peer, "4");
						has_ = true;
					}
				}
				if (type == "lvl205") {
					if (pInfo(peer)->level >= 205) {
						if (Has_Claimed::Lvl(peer, 205)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(20, 4490)), list.push_back(std::make_pair(25, 242)), list.push_back(std::make_pair(5, 1062)), list.push_back(std::make_pair(25, 5706)), list.push_back(std::make_pair(1, 98));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(205);
						DialogHandle::Level_Rewards(peer, "5");
						has_ = true;
					}
				}
				if (type == "lvl210") {
					if (pInfo(peer)->level >= 210) {
						if (Has_Claimed::Lvl(peer, 210)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(20, 4490)), list.push_back(std::make_pair(25, 242)), list.push_back(std::make_pair(5, 1062)), list.push_back(std::make_pair(25, 5706)), list.push_back(std::make_pair(50, 9526));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(210);
						DialogHandle::Level_Rewards(peer, "5");
						has_ = true;
					}
				}
				if (type == "lvl215") {
					if (pInfo(peer)->level >= 215) {
						if (Has_Claimed::Lvl(peer, 215)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(20, 4490)), list.push_back(std::make_pair(25, 242)), list.push_back(std::make_pair(5, 1062)), list.push_back(std::make_pair(25, 5706)), list.push_back(std::make_pair(10, 1796));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Intertwined_Fate = pInfo(peer)->Intertwined_Fate = 5;
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(215);
						DialogHandle::Level_Rewards(peer, "5");
						has_ = true;
					}
				}
				if (type == "lvl220") {
					if (pInfo(peer)->level >= 220) {
						if (Has_Claimed::Lvl(peer, 220)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(20, 4490)), list.push_back(std::make_pair(25, 242)), list.push_back(std::make_pair(5, 1062)), list.push_back(std::make_pair(25, 5706)), list.push_back(std::make_pair(50, 9526));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(220);
						DialogHandle::Level_Rewards(peer, "5");
						has_ = true;
					}
				}
				if (type == "lvl225") {
					if (pInfo(peer)->level >= 225) {
						if (Has_Claimed::Lvl(peer, 225)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(20, 4490)), list.push_back(std::make_pair(25, 242)), list.push_back(std::make_pair(5, 1062)), list.push_back(std::make_pair(25, 5706)), list.push_back(std::make_pair(10, 1796)), list.push_back(std::make_pair(1, 5078));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(225);
						DialogHandle::Level_Rewards(peer, "5");
						has_ = true;
					}
				}
				if (type == "lvl230") {
					if (pInfo(peer)->level >= 230) {
						if (Has_Claimed::Lvl(peer, 230)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(20, 4490)), list.push_back(std::make_pair(25, 242)), list.push_back(std::make_pair(5, 1062)), list.push_back(std::make_pair(25, 5706)), list.push_back(std::make_pair(50, 9526)), list.push_back(std::make_pair(2, 528));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(230);
						DialogHandle::Level_Rewards(peer, "5");
						has_ = true;
					}
				}
				if (type == "lvl235") {
					if (pInfo(peer)->level >= 235) {
						if (Has_Claimed::Lvl(peer, 235)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(20, 4490)), list.push_back(std::make_pair(25, 242)), list.push_back(std::make_pair(5, 1062)), list.push_back(std::make_pair(25, 5706)), list.push_back(std::make_pair(50, 9526));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(235);
						DialogHandle::Level_Rewards(peer, "5");
						has_ = true;
					}
				}
				if (type == "lvl240") {
					if (pInfo(peer)->level >= 240) {
						if (Has_Claimed::Lvl(peer, 240)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(20, 4490)), list.push_back(std::make_pair(25, 242)), list.push_back(std::make_pair(5, 1062)), list.push_back(std::make_pair(25, 5706)), list.push_back(std::make_pair(1, 5638));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(240);
						DialogHandle::Level_Rewards(peer, "5");
						has_ = true;
					}
				}
				if (type == "lvl245") {
					if (pInfo(peer)->level >= 245) {
						if (Has_Claimed::Lvl(peer, 245)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(20, 4490)), list.push_back(std::make_pair(25, 242)), list.push_back(std::make_pair(5, 1062)), list.push_back(std::make_pair(25, 5706)), list.push_back(std::make_pair(10, 1796)), list.push_back(std::make_pair(1, 9602));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(245);
						DialogHandle::Level_Rewards(peer, "5");
						has_ = true;
					}
				}
				if (type == "lvl250") {
					if (pInfo(peer)->level >= 250) {
						if (Has_Claimed::Lvl(peer, 250)) return;
						std::vector<std::pair<int, int>> list;
						list.push_back(std::make_pair(20, 4490)), list.push_back(std::make_pair(25, 242)), list.push_back(std::make_pair(2, 13574)), list.push_back(std::make_pair(25, 5706)), list.push_back(std::make_pair(1, 6946)), list.push_back(std::make_pair(5, 5178));
						for (const auto& item : list) {
							if (Inventory::Modify(peer, item.second, add = item.first) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item.second, drop_block_.count = item.first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						pInfo(peer)->Masterless_Starglitter += 10;
						pInfo(peer)->lvl_rewards.push_back(250);
						DialogHandle::Level_Rewards(peer, "5");
						has_ = true;
					}
				}
				if (has_) {
					VarList::OnAddNotification(peer, "You claimed your Level Rewards Prize!", "interface/guide_arrow.rttex", "audio/piano_nice.wav.wav");
					PlayerMoving data_{};
					data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
					BYTE* raw = packPlayerMoving(&data_);
					send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					delete[] raw;
				}
			}
		}
	}
	static void roadtoglory(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (!parser.try_get("buttonClicked", button)) return;
		if (button == "info") send_wrench_self(peer, "");
		else if (button == "road_to_glory") send_wrench_self(peer, "road_to_glory");
		else if (button == "kit_pass") send_wrench_self(peer, "kit_pass");
		else if (button == "level_rwds") send_wrench_self(peer, "level_rwds");
		else if (button == "skill_and_assets") send_wrench_self(peer, "skill_and_assets");
		else if (button.substr(0, 11) == "claimreward") {
			int count = std::atoi(button.substr(11).c_str());
			if (count < 1 || count > 10) return;
			if (std::find(pInfo(peer)->glo_p.begin(), pInfo(peer)->glo_p.end(), count) == pInfo(peer)->glo_p.end()) {
				if (pInfo(peer)->level >= count * 10) {
					pInfo(peer)->glo_p.push_back(count);
					CAction::Log(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
					VarList::OnBuxGems(peer, count * 10000);
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations! You have received your Road to Glory Reward!", 0, 0);
					PlayerMoving data_{};
					data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
					BYTE* raw = packPlayerMoving(&data_);
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (pInfo(peer)->world != pInfo(cp_)->world) continue;
						send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw;
					send_wrench_self(peer, "road_to_glory");
				}
			}
		}
	}
	static void worldgen_return(ENetPeer* peer, std::string cch) {
		if (!Role::Clist(pInfo(peer)->tankIDName)) return;

		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "generate_world") {
				int width = std::stoi(parser.get("width_input"));
				int height = std::stoi(parser.get("height_input"));

				if (width < 30 || width > 255 || height < 30 || height > 255) {
					VarList::OnConsoleMessage(peer, "`4Ukuran world tidak valid! Minimal 30x30 dan maksimal 255x255.");
					return;
				}

				Player* player = pInfo(peer);
				std::string world_name = player->world;

				auto it = std::find_if(worlds.begin(), worlds.end(), [world_name](const World& w) {
					return w.name == world_name;
					});
				if (it == worlds.end()) return;

				World* world = &(*it);

				// Update ukuran world
				world->max_x = width;
				world->max_y = height;

				// Reset block
				world->blocks.clear();
				world->blocks.resize(width * height);

				// Generate blok terrain
				for (int x = 0; x < width; ++x) {
					for (int y = 0; y < height; ++y) {
						int index = x + y * width; // indexing aman
						auto& block = world->blocks[index];

						if (y == height - 1)
							block.fg = 8; // Bedrock
						else if (y >= height - 5)
							block.fg = 2; // Dirt
						else
							block.fg = 0; // Kosong
					}
				}

				// Force refresh semua player di world
				for (ENetPeer* cp = server->peers; cp < &server->peers[server->peerCount]; ++cp) {
					if (!cp || cp->state != ENET_PEER_STATE_CONNECTED) continue;

					Player* other = (Player*)cp->data;
					if (!other || other->world != world_name) continue;

					other->last_world = world_name;
					Exit_World(cp, true);
					Enter_World(cp, world_name);
				}

				VarList::OnConsoleMessage(peer, "`2World berhasil di-generate ulang dengan ukuran " + std::to_string(width) + "x" + std::to_string(height) + ".");
			}
		}
	}
	static void giveaway_role(ENetPeer* peer, std::string cch) {
		if (!Role::Clist(pInfo(peer)->tankIDName)) return;
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "apply_giveaway") {
				std::vector<ENetPeer*> players;
				for (int i = 0; i < server->peerCount; i++) {
					ENetPeer* p = &server->peers[i];
					if (p->state == ENET_PEER_STATE_CONNECTED && p->data != nullptr) {
						players.push_back(p);
					}
				}

				if (players.empty()) {
					VarList::OnConsoleMessage(peer, "`4[ERROR] `oTidak ada player online untuk giveaway.");
					return;
				}

				ENetPeer* winner = players[rand() % players.size()];
				std::string winnerName = pInfo(winner)->tankIDName;
				std::string role_given = "";

				if (parser.get("give_vip") == "1") {
					pInfo(winner)->Role.Vip = true;
					role_given += "\n- VIP";
				}
				if (parser.get("give_mod") == "1") {
					pInfo(winner)->Role.Moderator = true;
					role_given += "\n- Moderator";
				}
				if (parser.get("give_admin") == "1") {
					pInfo(winner)->Role.Administrator = true;
					role_given += "\n- Administrator";
				}
				if (parser.get("give_dev") == "1") {
					pInfo(winner)->Role.Developer = true;
					role_given += "\n- Developer";
				}
				if (parser.get("give_god") == "1") {
					pInfo(winner)->Role.God = true;
					role_given += "\n- God";
				}
				if (parser.get("give_unli") == "1") {
					pInfo(winner)->Role.Unlimited = true;
					role_given += "\n- Unlimited";
				}
				if (parser.get("give_boost") == "1") {
					pInfo(winner)->Role.BOOST = true;
					pInfo(winner)->Role.BOOST_TIME = time(nullptr) + 604800;
					role_given += "\n- BOOST (1 minggu)";
				}
				if (parser.get("give_sboost") == "1") {
					pInfo(winner)->Role.SUPER_BOOST = true;
					pInfo(winner)->Role.SUPER_BOOST_TIME = time(nullptr) + 864000;
					role_given += "\n- SUPER BOOST (10 hari)";
				}

				if (role_given.empty()) {
					VarList::OnConsoleMessage(peer, "`4[ERROR] `oKamu belum memilih role manapun.");
					return;
				}

				pInfo(winner)->Role.Role_Level = Role::GetLevel(winner);
				pInfo(winner)->name_color = Role::Prefix(winner);
				VisualHandle::Nick(winner, nullptr);

				VarList::OnConsoleMessage(winner, "`2SELAMAT! `oKamu mendapatkan role dari giveaway:" + role_given);
				VarList::OnAddNotification(winner, "", "interface/large/special_event.rttex", "audio/pinata_lasso.wav");

				VarList::OnConsoleMessage(peer, "`oKamu telah memberikan role ke player `5" + winnerName);
				ServerPool::Logs::Add(pInfo(peer)->tankIDName + " gave giveaway role to " + winnerName + ":" + role_given, "Giveaway Role");

				for (int i = 0; i < server->peerCount; i++) {
					ENetPeer* p = &server->peers[i];
					if (p->state == ENET_PEER_STATE_CONNECTED && p->data != nullptr) {
						VarList::OnConsoleMessage(p, "`2[GIVEAWAY ROLE] `w" + winnerName + " `omemenangkan:" + role_given);
					}
				}

				enet_peer_disconnect_later(winner, 0);
			}
		}
	}
	static void autoharvest(ENetPeer* peer, std::string cch) {
		std::string name_ = pInfo(peer)->world;
		auto it = std::find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (it != worlds.end()) {
			World* world_ = &(*it);
			for (int y = 0; y < 60; ++y) {
				for (int x = 0; x < 100; ++x) {
					int index = x + (y * 100);
					WorldBlock* block_ = &world_->blocks[index];

					if (block_->fg == 0 || block_->fg >= items.size()) continue;
					if (items[block_->fg].blockType != BlockTypes::SEED) continue;
					if (block_->fg - 1 >= items.size()) continue;


					uint32_t grow_time = items[block_->fg].growTime;
					if (grow_time != 0 && block_->planted != 0) {
						uint32_t elapsed = std::time(nullptr) - block_->planted;
						if (elapsed >= grow_time) {
							int drop_count = items[block_->fg - 1].rarity == 1
								? (rand() % 6) + 5
								: (rand() % block_->fruit) + 1;

							harvest_seed(world_, block_, x, y, drop_count, pInfo(peer)->netID, peer);
						}
					}
				}
			}
			// VALLEN AUTO HAR
			VarList::OnConsoleMessage(peer, "Auto Harvest Complete!");
		}
	}
	static void confirm_createworld(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "", width_str = "", height_str = "";
		parser.try_get("buttonClicked", button);
		width_str = parser.get("world_width", 1);
		height_str = parser.get("world_height", 1);

		if (button != "confirm_createworld") return;

		std::string worldName = pInfo(peer)->world;
		auto it = std::find_if(worlds.begin(), worlds.end(), [&](const World& a) {
			return a.name == worldName;
			});

		if (it == worlds.end()) {
			VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`4Dunia tidak ditemukan.");
			return;
		}

		try {
			int world_x = std::stoi(width_str);
			int world_y = std::stoi(height_str);

			if (world_x < 30 || world_y < 30 || world_x > 255 || world_y > 255) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`4Ukuran dunia harus antara 30x30 sampai 255x255!");
				return;
			}

			World* world_ = &(*it);

			// Reset blok dan properti
			for (int i = 0; i < world_->blocks.size(); i++) {
				int x = i % world_->max_x;
				int y = i / world_->max_x;
				reset_(&world_->blocks[i], x, y, world_);
			}

			// Reset properti lainnya
			world_->cycle_ke = 0;
			world_->b = 64;
			world_->kickall = 0;
			world_->r = 255;
			world_->g = 128;
			world_->last_lock = 0;
			world_->special_event_item = 0;
			world_->special_event_item_taken = 0;
			world_->total_drop_uid = 0;
			world_->npc_uid = 0;
			world_->guild_id = 0;
			world_->xenonite = 0;
			world_->world_settings = 0;
			world_->fire_try = 0;
			world_->total_fires = 0;
			world_->music_bpm = 100;
			world_->entry_level = 1;
			world_->World_Time = 0;
			world_->gems = 1;
			world_->gems_lvl = 0;

			world_->infinity.clear();
			world_->npc.clear();
			world_->special_event_name.clear();
			world_->whitelist.clear();
			world_->Game_Score.clear();
			world_->joinedPlayers.clear();
			world_->drop_new.clear();
			world_->cctv_settings.clear();
			world_->active_jammers.clear();
			world_->world_event_items.clear();
			world_->bannedPlayers.clear();

			world_->special_event = false;
			world_->nuked_by.clear();
			world_->text.clear();
			world_->honors.clear();
			world_->owner_name.clear();
			world_->owner_named.clear();
			world_->category.clear();

			world_->last_special_event = 0;
			world_->last_comet_spawn = 0;
			world_->s4tb = { 0, 0 };

			create_world(world_, world_x, world_y);

			// Kick semua player dari world
			for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
				if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL) continue;
				if (pInfo(cp_)->world == pInfo(peer)->world) {
					Exit_World(cp_);
				}
			}

			VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`2Berhasil mengatur ulang dunia ke ukuran " + std::to_string(world_x) + " x " + std::to_string(world_y));
		}
		catch (...) {
			VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`4Terjadi kesalahan saat mengatur ulang dunia.");
		}
	}
	static void HandleBlockDTDialog(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button, id_str;
		parser.try_get("buttonClicked", button);
		id_str = parser.get("item_id_input", 1);

		if (id_str.empty()) return;

		int id = std::stoi(id_str);
		std::ifstream in("blockdroptrash.json");
		nlohmann::json data = nlohmann::json::array();
		if (in.good()) in >> data;
		in.close();

		if (button == "block_item") {
			if (std::find(data.begin(), data.end(), id) == data.end()) {
				data.push_back(id);
			}
		}
		else if (button == "unblock_item") {
			data.erase(std::remove(data.begin(), data.end(), id), data.end());
		}

		std::ofstream out("blockdroptrash.json");
		out << data.dump(4);
		out.close();

		VarList::OnConsoleMessage(peer, "Berhasil");
	}
	static void TRASHALL_DIALOG(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::vector<std::pair<uint32_t, uint32_t>> items_selected;

		for (auto& item : pInfo(peer)->inv) {
			if (item.first <= 0 || item.second <= 0) continue;
			std::string checkicon_name = "trash_item_" + std::to_string(item.first);
			std::string value;
			if (parser.try_get(checkicon_name, value) && value == "1") {
				items_selected.push_back(std::make_pair(item.first, item.second));
			}
		}

		std::string button;
		if (!parser.try_get("buttonClicked", button) || items_selected.empty()) return;

		if (button == "trash_confirm") {
			std::string deleted_items = "";
			int total_items = 0;
			for (auto& item : items_selected) {
				int remove_count = item.second * -1;
				if (Inventory::Modify(peer, item.first, remove_count) == 0) {
					deleted_items += "\nadd_textbox|`w" + items[item.first].ori_name + " `ox" + std::to_string(item.second) + "``|left|";
					total_items += item.second;
				}
			}

			std::string confirm = SetColor(peer);
			confirm += "add_label_with_icon|big|`4Items Deleted``|left|2480|\n";
			confirm += "add_spacer|small|\n";
			confirm += "add_textbox|`4You have deleted the following items:``|left|\n";
			confirm += deleted_items;
			confirm += "\nadd_spacer|small|\n";
			confirm += "add_textbox|Total items deleted: `4" + std::to_string(total_items) + "``|left|\n";
			confirm += "end_dialog|trash_confirm|Close||\n";
			confirm += "add_quick_exit|\n";
			VarList::OnDialogRequest(peer, confirm);
		}
		else if (button == "drop_confirm") {
			std::string name_ = pInfo(peer)->world;
			auto paa = std::find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (paa == worlds.end()) return;
			World* world_ = &worlds[paa - worlds.begin()];

			std::string dropped_items = "";
			int total_items = 0;

			for (auto& item : items_selected) {
				if (items[item.first].untradeable != 0) continue;

				int remove = item.second * -1;
				WorldDrop drop_block{};
				drop_block.x = (pInfo(peer)->state == 16 ? pInfo(peer)->x - ((rand() % 12) + 18) : pInfo(peer)->x + ((rand() % 12) + 22));
				drop_block.y = pInfo(peer)->y + rand() % 16;
				drop_block.id = item.first;
				drop_block.count = item.second;
				drop_block.uid = uint16_t(world_->drop_new.size()) + 1;

				VisualHandle::Drop(world_, drop_block);
				Inventory::Modify(peer, item.first, remove);

				dropped_items += "\nadd_textbox|`w" + items[item.first].ori_name + " `ox" + std::to_string(item.second) + "``|left|";
				total_items += item.second;
			}

			std::string confirm = SetColor(peer);
			confirm += "add_label_with_icon|big|`2Items Dropped``|left|1020|\n";
			confirm += "add_spacer|small|\n";
			confirm += "add_textbox|`2You have dropped the following items:``|left|\n";
			confirm += dropped_items;
			confirm += "\nadd_spacer|small|\n";
			confirm += "add_textbox|Total items dropped: `2" + std::to_string(total_items) + "``|left|\n";
			confirm += "end_dialog|drop_confirm|Close||\n";
			confirm += "add_quick_exit|\n";
			VarList::OnDialogRequest(peer, confirm);
		}
	}
	static void remove_bulletin(ENetPeer* peer, std::string cch) {
		std::string name_ = pInfo(peer)->world;
		std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
			for (int i_ = 0; i_ < world_->bulletin.size(); i_++) {
				if (i_ == pInfo(peer)->lastchoosennr) {
					if (Only_Access(peer, world_, block_) == false && !guild_access(peer, world_->guild_id)) return;
					world_->fresh_world = true;
					if (world_->bulletin.size() != 0 && pInfo(peer)->lastchoosennr <= world_->bulletin.size() && world_->bulletin[pInfo(peer)->lastchoosennr].x == pInfo(peer)->lastwrenchx and world_->bulletin[pInfo(peer)->lastchoosennr].y == pInfo(peer)->lastwrenchy) {
						world_->bulletin.erase(world_->bulletin.begin() + pInfo(peer)->lastchoosennr);
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`2Bulletin removed.``", 0, 0);
					}
				}
			}
		}
	}
	static void adventure(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		string text = parser.get("name", 1), time = parser.get("time", 1), live = parser.get("live", 1);
		if (text.size() > 32 or time.size() < 1 or live.size() < 1) return;
		std::string name_ = pInfo(peer)->world;
		std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			world_->fresh_world = true;
			WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
			if (block_->fg == 4722) {
				if (Only_Access(peer, world_, block_)) {
					if (text != "") block_->heart_monitor = text;
					if (time != "" and is_number(time)) block_->times = std::atoi(time.c_str());
					if (live != "" and is_number(live)) block_->lives = std::atoi(live.c_str());
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Updated adventure!", 0, 0);
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(peer)->world != pInfo(cp_)->world or pInfo(cp_)->adventure_begins == false) continue;
						pInfo(cp_)->adventure_begins = false;
					}
				}
			}
		}
	}
	static void ban_player(ENetPeer* peer, std::string cch) {
		if (Role::Moderator(peer) or Role::Administrator(peer)) {
			if (Playmods::HasById(pInfo(peer), 120)) {
				int time_ = 0;
				for (PlayMods peer_playmod : pInfo(peer)->playmods) {
					if (peer_playmod.id == 120) {
						time_ = peer_playmod.time - time(nullptr);
						return;
					}
				}
				CAction::Log(peer, "action|log\nmsg|>> (" + Time::Playmod(time_) + " before you can ban again)", "");
				return;
			}
			else {
				TextScanner parser(cch);
				string reason = parser.get("reason", 1);
				if (reason.empty()) reason = "Nothing!";
				pInfo(peer)->ban_reason = reason;
				Playmods::Add(peer, 120);
				for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
					if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
					if (to_lower(pInfo(cp_)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						long long int seconds = pInfo(peer)->ban_seconds;
						Punishment::Banned(cp_, pInfo(peer)->ban_seconds, pInfo(peer)->ban_reason, pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``", 76);
						ServerPool::ModLogs::Add(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, "BANNED (" + pInfo(peer)->ban_reason + "): " + pInfo(cp_)->name_color + pInfo(cp_)->tankIDName + "``", "`#" + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds"));
					}
				}
			}
		}
	}
	static void phonecall(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "chc0") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wBeverly Hills``|left|2354|\nadd_textbox|No! Why does everyone ask that? Beverly is a name, you know. I am Beverly. Of the Hills family. Please stop calling us!|left|\nend_dialog|phonecall|Hang Up||");
			if (button == "operdial") {
				string opr = parser.get("operator", 1);
				if (opr.find("Crazy Jim") != std::string::npos) VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wCrazy Jim's Quest Emporium``|left|3902|\nadd_textbox|HEEEEYYY there Growtopian! I'm Crazy Jim, and my quests are so crazy they're KERRRRAAAAZZY!! And that is clearly very crazy, so please, be cautious around them. What can I do ya for, partner?|left|\nadd_button|chc1_1|Daily Quest|noflags|0|0|1|\nadd_button|life_goals|`oGoals|noflags|0|0|1|\nadd_button|epic_quest|`oEpic Quests|noflags|0|0|\nadd_button|biweekly_quest|`oBiweekly Quests|noflags|0|0|1|\nend_dialog|3898|Hang Up||\n");
				else if (opr.find("Growtopizza") != std::string::npos) VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wGrowtopizza``|left|964|\nadd_textbox|Hello, this is Growtopizza, we cook 'em when you book 'em. What would you like to order, sir or ma'am?|left|\nadd_button|buy_pizza|1 Slice of Supreme With Cheese<CR>(costs 1 Big Lock)|noflags|0|0|\nend_dialog|phonecall|Hang Up||");
				else if (opr.find("Beverly Hills") != std::string::npos) VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wBeverly Hills``|left|3802|\nadd_textbox|Hello, this is Beverly Hills. How may I help you?|left|\nadd_button|chc0|Um, the city?|noflags|0|0|\nadd_button|chc1|Nothing, thanks|noflags|0|0|\nend_dialog|phonecall|Hang Up||");
				else if (opr.find("Locke") != std::string::npos) VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSales-Man``|left|4358|\nadd_textbox|It is I, Sales-Man, savior of the wealthy! Let me rescue you from your riches. What would you like to buy today?|left|\nadd_button|chc4_1|Surgery Items|noflags|0|0|\nadd_button|chc5_1|Wolfworld Items|noflags|0|0|\nadd_button|chc3_1|Zombie Defense Items|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
				else VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wDisconnected``|left|774|\nadd_textbox|The number you have tried to reach is disconnected. Please check yourself before you wreck yourself.|left|\nend_dialog|3898|Hang Up||\n");
			}
			if (button == "buy_pizza") {
				if (Inventory::Contains(peer, 204) < 1) {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wGrowtopizza``|left|964|\nadd_textbox|Your total comes to 1 Big Lock. Will that be all tonight?|left|\nadd_smalltext|`6You have " + to_string(Inventory::Contains(peer, 204)) + " Big Lock.``|left|\nadd_button||Nevermind|noflags|0|0|\nend_dialog|phonecall|Hang Up||");
				}
				else {
					int rem = 0;
					if (Inventory::Modify(peer, 964, rem = +1) == 0) {
						Inventory::Modify(peer, 204, rem = -1);
						PlayerMoving data_{}; PlayerMoving data{};
						data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = 204, data_.punchY = pInfo(peer)->netID;
						int32_t to_netid = pInfo(peer)->netID;
						BYTE* raw = packPlayerMoving(&data_);
						raw[3] = 5;
						Memory_Copy(raw + 8, &to_netid, 4);
						data.packetType = 19, data.netID = -1, data.plantingTree = 0;
						data.x = pInfo(peer)->lastwrenchx * 32 + 16, data.y = pInfo(peer)->lastwrenchy * 32 + 16;
						data.XSpeed = pInfo(peer)->x + 16, data.YSpeed = pInfo(peer)->y + 16;
						data.punchX = 964;
						BYTE* raw_ = packPlayerMoving(&data);
						raw_[3] = 6;
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; cp_++) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL) return;
							if (pInfo(peer)->world == pInfo(cp_)->world) {
								send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								send_raw(cp_, 4, raw_, 56, ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, raw_;
					}
				}
			}
		}
	}
	static void added_seal_branch_1(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (!parser.try_get("buttonClicked", button) or not WinterFest.Active) return;
		if (button == "back") {
			DialogHandle::Winter_Branch(peer, "1");
		}
		if (button == "add_seal") {
			string number = parser.get("add_seals", 1);
			if ((number.find_first_not_of("0123456789") != std::string::npos) or std::atoi(number.c_str()) < 1) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You do not have enough Royal Winter Seal's.", 0, 0);
				return;
			}
			if (std::atoi(number.c_str()) > pInfo(peer)->winter_seal) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You do not have enough Royal Winter Seal's.", 0, 0);
			}
			else {
				pInfo(peer)->winter_seal -= std::atoi(number.c_str());
				pInfo(peer)->winter_seal_branch_1 += std::atoi(number.c_str());
				DialogHandle::Winter_Branch(peer, "1");
			}
		}
	}
	static void added_seal_branch_2(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (!parser.try_get("buttonClicked", button) or not WinterFest.Active) return;
		if (button == "back") {
			DialogHandle::Winter_Branch(peer, "2");
		}
		if (button == "add_seal") {
			string number = parser.get("add_seals", 1);
			if ((number.find_first_not_of("0123456789") != std::string::npos) or std::atoi(number.c_str()) < 1) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You do not have enough Royal Winter Seal's.", 0, 0);
				return;
			}
			if (std::atoi(number.c_str()) > pInfo(peer)->winter_seal) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You do not have enough Royal Winter Seal's.", 0, 0);
			}
			else {
				pInfo(peer)->winter_seal -= std::atoi(number.c_str());
				pInfo(peer)->winter_seal_branch_2 += std::atoi(number.c_str());
				DialogHandle::Winter_Branch(peer, "2");
			}
		}
	}
	static void added_seal_branch_3(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (!parser.try_get("buttonClicked", button) or not WinterFest.Active) return;
		if (button == "back") {
			DialogHandle::Winter_Branch(peer, "3");
		}
		if (button == "add_seal") {
			string number = parser.get("add_seals", 1);
			if ((number.find_first_not_of("0123456789") != std::string::npos) or std::atoi(number.c_str()) < 1) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You do not have enough Royal Winter Seal's.", 0, 0);
				return;
			}
			if (std::atoi(number.c_str()) > pInfo(peer)->winter_seal) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You do not have enough Royal Winter Seal's.", 0, 0);
			}
			else {
				pInfo(peer)->winter_seal -= std::atoi(number.c_str());
				pInfo(peer)->winter_seal_branch_3 += std::atoi(number.c_str());
				DialogHandle::Winter_Branch(peer, "3");
			}
		}
	}
	static void added_seal_branch_4(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (!parser.try_get("buttonClicked", button) or not WinterFest.Active) return;
		if (button == "back") {
			DialogHandle::Winter_Branch(peer, "4");
		}
		if (button == "add_seal") {
			string number = parser.get("add_seals", 1);
			if ((number.find_first_not_of("0123456789") != std::string::npos) or std::atoi(number.c_str()) < 1) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You do not have enough Royal Winter Seal's.", 0, 0);
				return;
			}
			if (std::atoi(number.c_str()) > pInfo(peer)->winter_seal) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You do not have enough Royal Winter Seal's.", 0, 0);
			}
			else {
				pInfo(peer)->winter_seal -= std::atoi(number.c_str());
				pInfo(peer)->winter_seal_branch_4 += std::atoi(number.c_str());
				DialogHandle::Winter_Branch(peer, "4");
			}
		}
	}
	static void winter_seal_rewards(ENetPeer* peer, std::string cch) {
		if (not WinterFest.Active) return;
		TextScanner parser(cch); std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button.substr(0, 14) == "reward_branch_") {
				std::string type = button.substr(14);
				if (type == "1") {
					DialogHandle::Winter_Branch(peer, "1");
				}
				if (type == "2") {
					DialogHandle::Winter_Branch(peer, "2");
				}
				if (type == "3") {
					DialogHandle::Winter_Branch(peer, "3");
				}
				if (type == "4") {
					DialogHandle::Winter_Branch(peer, "4");
				}
			}
		}
	}
	static void royal_winter_wonder(ENetPeer* peer, std::string cch) {
		if (not WinterFest.Active) return;
		TextScanner parser(cch); std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button.substr(0, 13) == "addws_branch_") {
				std::string type = button.substr(13);
				if (type == "1") {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`wRoyal Winter Wonders|left|9186|\nadd_textbox|`oYou have " + Set_Count(pInfo(peer)->winter_seal) + " Royal Winter Seals.|left|\nadd_textbox|`oHow many would you like to use?|left|\nadd_text_input|add_seals||0|6|\nadd_button|add_seal|`wAdd|noflags|0|0|\nadd_button|back|`wCancel|noflags|0|0|\nend_dialog|added_seal_branch_1|||");
				}
				if (type == "2") {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`wRoyal Winter Wonders|left|9186|\nadd_textbox|`oYou have " + Set_Count(pInfo(peer)->winter_seal) + " Royal Winter Seals.|left|\nadd_textbox|`oHow many would you like to use?|left|\nadd_text_input|add_seals||0|6|\nadd_button|add_seal|`wAdd|noflags|0|0|\nadd_button|back|`wCancel|noflags|0|0|\nend_dialog|added_seal_branch_2|||");
				}
				if (type == "3") {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`wRoyal Winter Wonders|left|9186|\nadd_textbox|`oYou have " + Set_Count(pInfo(peer)->winter_seal) + " Royal Winter Seals.|left|\nadd_textbox|`oHow many would you like to use?|left|\nadd_text_input|add_seals||0|6|\nadd_button|add_seal|`wAdd|noflags|0|0|\nadd_button|back|`wCancel|noflags|0|0|\nend_dialog|added_seal_branch_3|||");
				}
				if (type == "4") {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`wRoyal Winter Wonders|left|9186|\nadd_textbox|`oYou have " + Set_Count(pInfo(peer)->winter_seal) + " Royal Winter Seals.|left|\nadd_textbox|`oHow many would you like to use?|left|\nadd_text_input|add_seals||0|6|\nadd_button|add_seal|`wAdd|noflags|0|0|\nadd_button|back|`wCancel|noflags|0|0|\nend_dialog|added_seal_branch_4|||");
				}
			}
			if (button.substr(0, 14) == "claim_branch1_") {
				std::string type = button.substr(14);
				if (type == "1") {
					if (pInfo(peer)->winter_seal_branch_1 >= 240 and not Has_Claimed::WinterBranch(peer, "branch1_1")) {
						int itemid = 9206, got = 1;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							VisualHandle::Trade(peer, itemid, 500);
							pInfo(peer)->Winter_Branch_Rewards.push_back("branch1_1");
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "1");
					}
				}
				if (type == "2") {
					if (pInfo(peer)->winter_seal_branch_1 >= 600 and not Has_Claimed::WinterBranch(peer, "branch1_2")) {
						int itemid = 1486, got = 5;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							VisualHandle::Trade(peer, itemid, 500);
							pInfo(peer)->Winter_Branch_Rewards.push_back("branch1_2");
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "1");
					}
				}
				if (type == "3") {
					if (pInfo(peer)->winter_seal_branch_1 >= 1200 and not Has_Claimed::WinterBranch(peer, "branch1_3")) {
						int itemid = 9224, got = 1;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							VisualHandle::Trade(peer, itemid, 500);
							pInfo(peer)->Winter_Branch_Rewards.push_back("branch1_3");
							pInfo(peer)->winter_power = true;
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "1");
					}
				}
				if (type == "4") {
					if (pInfo(peer)->winter_seal_branch_1 >= 3000 and not Has_Claimed::WinterBranch(peer, "branch1_4")) {
						int itemid = 2480, itemid_2 = 9178, got = 2, got_2 = 1;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							if (Inventory::Modify(peer, itemid_2, got) == 0) {
								VisualHandle::Trade(peer, itemid, 500);
								VisualHandle::Trade(peer, itemid_2, 1000);
								pInfo(peer)->Winter_Branch_Rewards.push_back("branch1_4");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "1");
					}
				}
				if (type == "5") {
					if (pInfo(peer)->winter_seal_branch_1 >= 6000 and not Has_Claimed::WinterBranch(peer, "branch1_5")) {
						int itemid = 5404, got = 5;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							VisualHandle::Trade(peer, itemid, 500);
							pInfo(peer)->Winter_Branch_Rewards.push_back("branch1_5");
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "1");
					}
				}
				if (type == "6") {
					if (pInfo(peer)->winter_seal_branch_1 >= 9000 and not Has_Claimed::WinterBranch(peer, "branch1_6")) {
						int itemid = 9208, got = 1;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							VisualHandle::Trade(peer, itemid, 500);
							pInfo(peer)->Winter_Branch_Rewards.push_back("branch1_6");
							pInfo(peer)->ability_upgrade_ances = true;
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "1");
					}
				}
				if (type == "7") {
					if (pInfo(peer)->winter_seal_branch_1 >= 12000 and not Has_Claimed::WinterBranch(peer, "branch1_7")) {
						int itemid = 9210, got = 1;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							VisualHandle::Trade(peer, itemid, 500);
							pInfo(peer)->Winter_Branch_Rewards.push_back("branch1_7");
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "1");
					}
				}
			}
			if (button.substr(0, 14) == "claim_branch2_") {
				std::string type = button.substr(14);
				if (type == "1") {
					if (pInfo(peer)->winter_seal_branch_2 >= 240 and not Has_Claimed::WinterBranch(peer, "branch2_1")) {
						int itemid = 10416, got = 1;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							VisualHandle::Trade(peer, itemid, 500);
							pInfo(peer)->Winter_Branch_Rewards.push_back("branch2_1");
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "2");
					}
				}
				if (type == "2") {
					if (pInfo(peer)->winter_seal_branch_2 >= 600 and not Has_Claimed::WinterBranch(peer, "branch2_2")) {
						int itemid = 1486, got = 5;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							VisualHandle::Trade(peer, itemid, 500);
							pInfo(peer)->Winter_Branch_Rewards.push_back("branch2_2");
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "2");
					}
				}
				if (type == "3") {
					if (pInfo(peer)->winter_seal_branch_2 >= 1200 and not Has_Claimed::WinterBranch(peer, "branch2_3")) {
						int itemid = 10446, got = 1;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							VisualHandle::Trade(peer, itemid, 500);
							pInfo(peer)->Winter_Branch_Rewards.push_back("branch2_3");
							pInfo(peer)->winter_power = true;
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "2");
					}
				}
				if (type == "4") {
					if (pInfo(peer)->winter_seal_branch_2 >= 3000 and not Has_Claimed::WinterBranch(peer, "branch2_4")) {
						int itemid = 2480, itemid_2 = 10450, got = 2, got_2 = 1;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							if (Inventory::Modify(peer, itemid_2, got) == 0) {
								VisualHandle::Trade(peer, itemid, 500);
								VisualHandle::Trade(peer, itemid_2, 1000);
								pInfo(peer)->Winter_Branch_Rewards.push_back("branch2_4");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "2");
					}
				}
				if (type == "5") {
					if (pInfo(peer)->winter_seal_branch_2 >= 6000 and not Has_Claimed::WinterBranch(peer, "branch2_5")) {
						int itemid = 5404, itemid_2 = 10536, got = 5, got_2 = 1;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							if (Inventory::Modify(peer, itemid_2, got) == 0) {
								VisualHandle::Trade(peer, itemid, 500);
								VisualHandle::Trade(peer, itemid_2, 1000);
								pInfo(peer)->Winter_Branch_Rewards.push_back("branch2_5");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "2");
					}
				}
				if (type == "6") {
					if (pInfo(peer)->winter_seal_branch_2 >= 9000 and not Has_Claimed::WinterBranch(peer, "branch2_6")) {
						int itemid = 10506, got = 1;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							VisualHandle::Trade(peer, itemid, 500);
							pInfo(peer)->Winter_Branch_Rewards.push_back("branch2_6");
							pInfo(peer)->ability_upgrade_ances = true;
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "2");
					}
				}
				if (type == "7") {
					if (pInfo(peer)->winter_seal_branch_2 >= 12000 and not Has_Claimed::WinterBranch(peer, "branch2_7")) {
						int itemid = 10502, got = 1;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							VisualHandle::Trade(peer, itemid, 500);
							pInfo(peer)->Winter_Branch_Rewards.push_back("branch2_7");
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "2");
					}
				}
			}
			if (button.substr(0, 14) == "claim_branch3_") {
				std::string type = button.substr(14);
				if (type == "1") {
					if (pInfo(peer)->winter_seal_branch_3 >= 240 and not Has_Claimed::WinterBranch(peer, "branch3_1")) {
						int itemid = 11486, got = 1;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							VisualHandle::Trade(peer, itemid, 500);
							pInfo(peer)->Winter_Branch_Rewards.push_back("branch3_1");
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "3");
					}
				}
				if (type == "2") {
					if (pInfo(peer)->winter_seal_branch_3 >= 600 and not Has_Claimed::WinterBranch(peer, "branch3_2")) {
						int itemid = 1486, got = 5;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							VisualHandle::Trade(peer, itemid, 500);
							pInfo(peer)->Winter_Branch_Rewards.push_back("branch3_2");
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "4");
					}
				}
				if (type == "3") {
					if (pInfo(peer)->winter_seal_branch_3 >= 1200 and not Has_Claimed::WinterBranch(peer, "branch3_3")) {
						int itemid = 11472, got = 1;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							VisualHandle::Trade(peer, itemid, 500);
							pInfo(peer)->Winter_Branch_Rewards.push_back("branch3_3");
							pInfo(peer)->winter_power = true;
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "3");
					}
				}
				if (type == "4") {
					if (pInfo(peer)->winter_seal_branch_3 >= 3000 and not Has_Claimed::WinterBranch(peer, "branch3_4")) {
						int itemid = 2480, itemid_2 = 10858, got = 2, got_2 = 1;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							if (Inventory::Modify(peer, itemid_2, got) == 0) {
								VisualHandle::Trade(peer, itemid, 500);
								VisualHandle::Trade(peer, itemid_2, 1000);
								pInfo(peer)->Winter_Branch_Rewards.push_back("branch3_4");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "3");
					}
				}
				if (type == "5") {
					if (pInfo(peer)->winter_seal_branch_3 >= 6000 and not Has_Claimed::WinterBranch(peer, "branch3_5")) {
						int itemid = 5404, itemid_2 = 10536, got = 5, got_2 = 1;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							if (Inventory::Modify(peer, itemid_2, got) == 0) {
								VisualHandle::Trade(peer, itemid, 500);
								VisualHandle::Trade(peer, itemid_2, 1000);
								pInfo(peer)->Winter_Branch_Rewards.push_back("branch3_5");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "3");
					}
				}
				if (type == "6") {
					if (pInfo(peer)->winter_seal_branch_3 >= 9000 and not Has_Claimed::WinterBranch(peer, "branch3_6")) {
						int itemid = 11460, got = 1;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							VisualHandle::Trade(peer, itemid, 500);
							pInfo(peer)->Winter_Branch_Rewards.push_back("branch3_6");
							pInfo(peer)->ability_upgrade_ances = true;
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "3");
					}
				}
				if (type == "7") {
					if (pInfo(peer)->winter_seal_branch_3 >= 12000 and not Has_Claimed::WinterBranch(peer, "branch3_7")) {
						int itemid = 11458, got = 1;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							VisualHandle::Trade(peer, itemid, 500);
							pInfo(peer)->Winter_Branch_Rewards.push_back("branch3_7");
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "3");
					}
				}
				if (type == "8") {
					if (pInfo(peer)->winter_seal_branch_3 >= 18000 and not Has_Claimed::WinterBranch(peer, "branch3_8")) {
						int itemid = 7412, got = 1;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							VisualHandle::Trade(peer, itemid, 500);
							pInfo(peer)->Winter_Branch_Rewards.push_back("branch3_8");
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "3");
					}
				}
			}
			if (button.substr(0, 14) == "claim_branch4_") {
				std::string type = button.substr(14);
				if (type == "1") {
					if (pInfo(peer)->winter_seal_branch_4 >= 240 and not Has_Claimed::WinterBranch(peer, "branch4_1")) {
						int itemid = 12920, got = 1;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							VisualHandle::Trade(peer, itemid, 500);
							pInfo(peer)->Winter_Branch_Rewards.push_back("branch4_1");
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "4");
					}
				}
				if (type == "2") {
					if (pInfo(peer)->winter_seal_branch_4 >= 600 and not Has_Claimed::WinterBranch(peer, "branch4_2")) {
						int itemid = 1486, got = 5;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							VisualHandle::Trade(peer, itemid, 500);
							pInfo(peer)->Winter_Branch_Rewards.push_back("branch4_2");
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "4");
					}
				}
				if (type == "3") {
					if (pInfo(peer)->winter_seal_branch_4 >= 1200 and not Has_Claimed::WinterBranch(peer, "branch4_3")) {
						int itemid = 12986, got = 1;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							VisualHandle::Trade(peer, itemid, 500);
							pInfo(peer)->Winter_Branch_Rewards.push_back("branch4_3");
							pInfo(peer)->winter_power = true;
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "4");
					}
				}
				if (type == "4") {
					if (pInfo(peer)->winter_seal_branch_4 >= 3000 and not Has_Claimed::WinterBranch(peer, "branch4_4")) {
						int itemid = 10858, itemid_2 = 12876, got = 1, got_2 = 1;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							if (Inventory::Modify(peer, itemid_2, got) == 0) {
								VisualHandle::Trade(peer, itemid, 500);
								VisualHandle::Trade(peer, itemid_2, 1000);
								pInfo(peer)->Winter_Branch_Rewards.push_back("branch4_4");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "4");
					}
				}
				if (type == "5") {
					if (pInfo(peer)->winter_seal_branch_4 >= 6000 and not Has_Claimed::WinterBranch(peer, "branch4_5")) {
						int itemid = 5404, itemid_2 = 10536, got = 5, got_2 = 1;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							if (Inventory::Modify(peer, itemid_2, got) == 0) {
								VisualHandle::Trade(peer, itemid, 500);
								VisualHandle::Trade(peer, itemid_2, 1000);
								pInfo(peer)->Winter_Branch_Rewards.push_back("branch4_5");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "4");
					}
				}
				if (type == "6") {
					if (pInfo(peer)->winter_seal_branch_4 >= 9000 and not Has_Claimed::WinterBranch(peer, "branch4_6")) {
						int itemid = 12890, got = 1;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							VisualHandle::Trade(peer, itemid, 500);
							pInfo(peer)->Winter_Branch_Rewards.push_back("branch4_6");
							pInfo(peer)->ability_upgrade_ances = true;
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "4");
					}
				}
				if (type == "7") {
					if (pInfo(peer)->winter_seal_branch_4 >= 12000 and not Has_Claimed::WinterBranch(peer, "branch4_7")) {
						int itemid = 12880, got = 1;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							VisualHandle::Trade(peer, itemid, 500);
							pInfo(peer)->Winter_Branch_Rewards.push_back("branch4_7");
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "4");
					}
				}
				if (type == "8") {
					if (pInfo(peer)->winter_seal_branch_4 >= 18000 and not Has_Claimed::WinterBranch(peer, "branch4_8")) {
						int itemid = 12540, got = 1;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							VisualHandle::Trade(peer, itemid, 500);
							pInfo(peer)->Winter_Branch_Rewards.push_back("branch4_8");
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your inventory is full!", 0, 0);
						DialogHandle::Winter_Branch(peer, "4");
					}
				}
			}
		}
		else {
			if (cch.find("claim_branch1_") != string::npos or cch.find("claim_branch2_") != string::npos or cch.find("claim_branch3_") != string::npos or cch.find("claim_branch4_") != string::npos or cch.find("addws_branch_") != string::npos) return;
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`wRoyal Winter Wonders|left|9186|\nadd_textbox|`oYou unspent Royal Winter Seals: `2" + Set_Count(pInfo(peer)->winter_seal) + "|left|\nadd_spacer|small|\nadd_textbox|`oYou can choose to add seals to any of the branches.|left|\nadd_spacer|small|\nadd_textbox|`oYou can choose how many you'd like to add in each branch.|left|\nadd_spacer|small|\nadd_button|reward_branch_1|`wReward Branch 1 - `2" + Set_Count(pInfo(peer)->winter_seal_branch_1) + "|noflags|0|0|\nadd_button|reward_branch_2|`wReward Branch 2 - `2" + Set_Count(pInfo(peer)->winter_seal_branch_2) + "|noflags|0|0|\nadd_button|reward_branch_3|`wReward Branch 3 - `2" + Set_Count(pInfo(peer)->winter_seal_branch_3) + "|noflags|0|0|\nadd_button|reward_branch_4|`wReward Branch 4 - `2" + Set_Count(pInfo(peer)->winter_seal_branch_4) + "|noflags|0|0|\nend_dialog|winter_seal_rewards|Back||\nadd_quick_exit|");
		}
	}
	static void iotm_purchase(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (!parser.try_get("buttonClicked", button)) return;
		if (button == "BackToIotmShop") DialogHandle::Iotm_Shop(peer);
		/*2017*/
		if (button == "Golden Razor Wings") {
			int id = 4534, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Zraei's Dragoscarf") {
			int id = 4590, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Kudo's Carriage") {
			int id = 4628, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Diamond Horn") {
			int id = 4746, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Speed Medallion") {
			int id = 4988, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Prismatic Aura") {
			int id = 5020, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Ghastly Robe") {
			int id = 5088, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Cloak of Falling Waters") {
			int id = 5206, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Zephyr Helm") {
			int id = 5322, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		/*2018*/
		if (button == "Will of the Wild") {
			int id = 5712, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Raptor Legs") {
			int id = 6294, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Mighty Tiger") {
			int id = 6338, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Cloak of Hoveration") {
			int id = 6758, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Sorcerer's Tunic of Mystery") {
			int id = 6892, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Shadow Spirit of the Underworld") {
			int id = 7192, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Monarch Butterfly Wings") {
			int id = 7196, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Go-Go-Growformer!") {
			int id = 7384, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		/*2019*/
		if (button == "Hovernator Drone") {
			int id = 7568, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Dragon Warrior's Shield") {
			int id = 7676, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Morty the Elephant") {
			int id = 7836, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Hellfire Horns") {
			int id = 8006, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Genie's Lamp") {
			int id = 8288, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Galactic Destructor") {
			int id = 8432, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Nightking's Cape") {
			int id = 8576, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Astro Shades") {
			int id = 8816, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Riding World Lock") {
			int id = 8898, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Cursed Spirit Pendant") {
			int id = 9008, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Laser Scimitar") {
			int id = 9116, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Dueling Star Fighter") {
			int id = 9136, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		/*2020*/
		if (button == "Ancient Shards") {
			int id = 9236, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Medusa's Crown") {
			int id = 9348, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Galaxy Aura") {
			int id = 9408, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Boastful Brawler Hair") {
			int id = 9462, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Doomsday Warhammer") {
			int id = 9606, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Go Anywhere Surfboard") {
			int id = 9648, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Pegasus Wings") {
			int id = 9760, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Golem's Gift") {
			int id = 10044, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Mechanical Butler") {
			int id = 10128, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Haunted Jack O' Lantern") {
			int id = 10166, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Celestial Dragon Charm") {
			int id = 10246, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Mystic Snow Fox") {
			int id = 10426, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		/*2021*/
		if (button == "Crown of the Cosmos") {
			int id = 10496, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Perilous Pirate Ship") {
			int id = 10618, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Grow Air Balloon") {
			int id = 10666, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Grow X Rocket Wings") {
			int id = 10718, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Plasma Heart") {
			int id = 10810, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Pure Being of Light and Shadow") {
			int id = 10914, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Soul Scythe") {
			int id = 11006, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Crystal Crown") {
			int id = 11116, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "Ouroboros Charm") {
			int id = 11232, price = 200;
			string wk = "";
			int wl = get_wls(peer, true);
			if (wl < price) wk = "\nadd_spacer|small|\nadd_textbox|`oYou can't afford this!|left|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|BackToIotmShop|`oSee other items|0|0|";
			else wk = "\nadd_spacer|small|\nadd_textbox|`oHow many " + items[id].name + " do you want to buy, for " + to_string(price) + " World Locks each?|left|\nadd_text_input|buy_amount||1|5|\nadd_smalltext|`oYou have " + Set_Count(wl) + " World Locks.|left|\nadd_button|yes_purchase_iotm|`9Purchase|0|0|\nadd_button|BackToIotmShop|No Thanks|0|0|";
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Buy " + items[id].name + "?|left|" + to_string(id) + "|\nadd_smalltext|`3ITEM DATA: `o" + items[id].description + "|left|" + wk + "\nadd_quick_exit|\nend_dialog|iotm_purchase|||");
			pInfo(peer)->last_id_item = id; pInfo(peer)->last_price_item = price;
		}
		if (button == "yes_purchase_iotm") {
			TextScanner parser(cch);
			string buycountstr = parser.get("buy_amount", 1);
			if (buycountstr.size() > 3 || buycountstr.size() <= 0 || not is_number(buycountstr) or pInfo(peer)->last_price_item == 0 or pInfo(peer)->last_id_item == 0) return;
			int buyprice = std::atoi(buycountstr.c_str());
			if (buyprice <= 0 || buyprice > 200) return;
			pInfo(peer)->buyp = buyprice;
			auto realprice = pInfo(peer)->last_price_item, id = pInfo(peer)->last_id_item;
			auto kiekmoketi = buyprice * realprice;
			int my_wls = get_wls(peer, true);
			if (kiekmoketi > my_wls) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You can't afford that many!", 0, true);
				return;
			}
			else VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Really Buy " + to_string(buyprice) + " " + items[pInfo(peer)->last_id_item].name + "?|left|" + to_string(pInfo(peer)->last_id_item) + "|\nadd_textbox|`oAre you sure you want to buy `w" + to_string(buyprice) + " " + items[pInfo(peer)->last_id_item].name + " `ofor a total cost of `2" + (realprice > 99 ? to_string(kiekmoketi / 100) + " Diamond Locks" : to_string(kiekmoketi) + " World Locks") + "`o?|left|\nadd_smalltext|`oYou have " + (realprice > 99 ? Set_Count(my_wls / 100) + " Diamond Locks" : Set_Count(my_wls) + " World Locks") + ".|left|\nadd_button|yes_confirm_iotm|`9YES! GIMME!!!|0|0|\nadd_button|notys|`oNo thanks|0|0|\nend_dialog|iotm_purchase|||\nadd_quick_exit|");
			pInfo(peer)->last_price_item = realprice;
		}
		if (button == "yes_confirm_iotm") {
			if (pInfo(peer)->buyp == 0 or pInfo(peer)->last_price_item == 0 or pInfo(peer)->last_id_item == 0) return;
			int buyprice = pInfo(peer)->buyp, my_wls = get_wls(peer, true);
			auto realprice = pInfo(peer)->last_price_item, kiekmoketi = buyprice * realprice;
			if (kiekmoketi > my_wls) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You can't afford that many!", 0, true);
				return;
			}
			else {
				if (Inventory::Check_Max(peer, pInfo(peer)->last_id_item, buyprice)) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That wouldnt fit into my inventory!", 0, true);
					return;
				}
				int free_slots = Inventory::Get_Slots(pInfo(peer));
				if (free_slots == 0) {
					VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
					return;
				}
				if (Inventory::Modify(peer, pInfo(peer)->last_id_item, buyprice) == 0) {
					get_wls(peer, true, true, kiekmoketi);
					VisualHandle::Trade(peer, pInfo(peer)->last_id_item, 550);
					VarList::OnConsoleMessage(peer, "You've purchased `o " + to_string(buyprice) + " " + items[pInfo(peer)->last_id_item].name + "`` for `$" + Set_Count(kiekmoketi) + "`` World Locks ā.\n`5Received: ``" + to_string(buyprice) + " " + items[pInfo(peer)->last_id_item].name);
				}
			}
		}
	}
	static void remove_transmutated_dialog(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "ConfirmRemoveTransmutation") {
				int item_removal = pInfo(peer)->remove_transmute;
				std::vector<std::pair<int, int>>::iterator p = find_if(pInfo(peer)->transmute.begin(), pInfo(peer)->transmute.end(), [&](const pair < int, int>& element) { return element.first == item_removal; });
				if (p != pInfo(peer)->transmute.end()) {
					int got1 = 1, give_back = pInfo(peer)->transmute[p - pInfo(peer)->transmute.begin()].second;
					if (Inventory::Modify(peer, give_back, got1) == 0) {
						int i = p - pInfo(peer)->transmute.begin();
						pInfo(peer)->transmute.erase(pInfo(peer)->transmute.begin() + i);
						pInfo(peer)->temp_transmute = true;
						Clothing_V2::Update_Value(peer);
						Clothing_V2::Update(peer);
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You have removed the transmutation!", 0, 0);
					}
					else VarList::OnConsoleMessage(peer, "No inventory space.");
				}
			}
		}
		else VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wTransmutabooth``|left|9170|\nadd_spacer|small|\nadd_smalltext|This booth will let you transfer the visuals of one clothing item onto another (of the same slot)!|left|\nadd_smalltext|The transmuted item will keep its properties (and mods!), so have fun and experiment with crazy combos!|left|" + (pInfo(peer)->transmute.size() == 0 ? "" : "\nadd_spacer|small|\nadd_smalltext|You have transmuted `2" + to_string(pInfo(peer)->transmute.size()) + "/12`` clothing items.|left|\nadd_button|permanentlist|`wYour Permanent Transmutes``|noflags|0|0|\n") + "\nadd_spacer|small|\nadd_smalltext|Here's where you can permanently change the visuals of clothing!|left|\nadd_button|permanttransmutation|`wTransmutate!``|noflags|0|0|\nadd_spacer|small|\nadd_button|transmutationhelp|`wHelp``|noflags|0|0|\nadd_spacer|small|\nend_dialog|transmutated_device_edit|Close||\nadd_quick_exit|");
	}
	static void transmutated_device_edit(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		int itemnr = 0;
		if (parser.try_get("mainitemid", itemnr)) {
			int got = Inventory::Contains(peer, itemnr);
			if (itemnr <= 0 || itemnr > items.size() || got == 0) return;
			if (items[itemnr].blockType != BlockTypes::CLOTHING) {
				pInfo(peer)->transmute_item1 = 0, pInfo(peer)->transmute_item2 = 0;
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`4" + items[itemnr].ori_name + "`` does not fit in the Transmutabooth.", 0, 0);
				return;
			}
			std::vector<std::pair<int, int>>::iterator pf = find_if(pInfo(peer)->transmute.begin(), pInfo(peer)->transmute.end(), [&](const pair < int, int>& element) { return element.first == itemnr; });
			if (pf != pInfo(peer)->transmute.end()) {
				pInfo(peer)->transmute_item1 = 0, pInfo(peer)->transmute_item2 = 0;
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`4You can't transmute the same item... that would be silly!``", 0, 0);
				return;
			}
			pInfo(peer)->transmute_item1 = itemnr;
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wTransmutabooth``|left|9170|\nadd_spacer|small|\nadd_textbox|Okay, this is the item that will get NEW visuals - remember, you'll keep its mods, but it'll look different!|left|\nadd_label_with_icon|small|`w" + items[itemnr].ori_name + "``|left|" + to_string(itemnr) + "|\nadd_spacer|small|\nadd_textbox|Now you'll pick the NEW look for this item. Same slot only!|left|\nadd_item_picker|linkitemid|`wPick Transmute Target!``|Choose the item for your NEW look!|\nadd_spacer|small|\nend_dialog|transmutated_linkitem_edit|Close||\nadd_quick_exit|");
		}
		else if (parser.try_get("buttonClicked", button)) {
			if (button == "permanttransmutation") {
				if (pInfo(peer)->transmute.size() >= 12) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You have reached the limit of Transmutabooth.", 0, 0);
					return;
				}
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wTransmutabooth``|left|9170|\nadd_spacer|small|\nadd_textbox|Tired of how an item looks but want to keep its abilities? Here is where you can overwrite its appearance with that of another item from the SAME slot!|left|\nadd_textbox|Cost: `210,000`` Gems.|left|\nadd_spacer|small|\nadd_textbox|To begin, you'll need to pick the item you want to change (its mods will remain)...|left|\nadd_spacer|small|\nadd_item_picker|mainitemid|`wStart Transmuting!``|Choose the item you want to change!|\nadd_spacer|small|\nadd_button|beforeMainBackToModes|Back|noflags|0|0|\nend_dialog|transmutated_device_edit|Close||\nadd_quick_exit|");
			}
			if (button == "beforeMainBackToModes" or button == "fromHelpBackToModes" or button == "fromListBackToModes") {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wTransmutabooth``|left|9170|\nadd_spacer|small|\nadd_smalltext|This booth will let you transfer the visuals of one clothing item onto another (of the same slot)!|left|\nadd_smalltext|The transmuted item will keep its properties (and mods!), so have fun and experiment with crazy combos!|left|" + (pInfo(peer)->transmute.size() == 0 ? "" : "\nadd_spacer|small|\nadd_smalltext|You have transmuted `2" + to_string(pInfo(peer)->transmute.size()) + "/12`` clothing items.|left|\nadd_button|permanentlist|`wYour Permanent Transmutes``|noflags|0|0|\n") + "\nadd_spacer|small|\nadd_smalltext|Here's where you can permanently change the visuals of clothing!|left|\nadd_button|permanttransmutation|`wTransmutate!``|noflags|0|0|\nadd_spacer|small|\nadd_button|transmutationhelp|`wHelp``|noflags|0|0|\nadd_spacer|small|\nend_dialog|transmutated_device_edit|Close||\nadd_quick_exit|");
			}
			if (button == "transmutationhelp") {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wHELP! Transmutabooth``|left|9170|\nadd_spacer|small|\nadd_textbox|Here you will find all the necessary details about the Transmutabooth.|left|\nadd_spacer|small|\nadd_smalltext|#1 The Transmutabooth lets you transfer the visuals of one clothing item onto another (of the same slot)! The transmuted item will keep its properties (and mods!).|left|\nadd_spacer|small|\nadd_smalltext|#2 You can transmute clothing items in two ways:|left|\nadd_label_with_icon|small|`5Permanent Transmutes``|left|9230|\nadd_smalltext|     - Lets you permanently change the visuals of clothing!|left|\nadd_smalltext|     - Cost is `210,000 Gems.``|left|\nadd_smalltext|     - The item will get NEW visuals - remember, it will keep its mods, but it'll look different!|left|\nadd_smalltext|     - You first pick the item you want to change, you then pick a Transmute Target to give the item a NEW look!|left|\nadd_smalltext|     - If you attempt to overwrite a permanently-transmuted item, example: Fairy Wings transmuted to look like the Backpack, but you then decide to transmute the Fairy Wings to Ripper Wings!|left|\nadd_smalltext|          - `4Alert!`` This item already has a permanent transmutation! Are you SURE you want to overwrite it?|left|\nadd_smalltext|     - Permanent Transmutes are designated with a 'purple circle' icon in the inventory.|left|\nadd_spacer|small|\nadd_button|fromHelpBackToModes|Back|noflags|0|0|\nend_dialog|transmutated_device_edit|Close||\nadd_quick_exit|");
			}
			if (button == "permanentlist") {
				string stuff = pInfo(peer)->transmuted;
				replaceAll(stuff, ":", ",");
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wTransmutabooth``|left|9170|\nadd_spacer|small|\nadd_textbox|You have transmuted `2" + to_string(pInfo(peer)->transmute.size()) + "/12`` clothing items.|left|\nadd_label_with_icon_button_list|small|`w%s: Transmuted %s to %s|left|removetransmutation_|itemID_transID|" + stuff + "\nadd_spacer|small|\nadd_button|fromListBackToModes|Back|noflags|0|0|\nend_dialog|transmutated_device_edit|Close||\nadd_quick_exit|");
			}
			if (button.substr(0, 20) == "removetransmutation_") {
				int item_removal = std::atoi(button.substr(20).c_str());
				std::vector<std::pair<int, int>>::iterator p = find_if(pInfo(peer)->transmute.begin(), pInfo(peer)->transmute.end(), [&](const pair < int, int>& element) { return element.first == item_removal; });
				if (p != pInfo(peer)->transmute.end()) {
					int item1 = pInfo(peer)->transmute[p - pInfo(peer)->transmute.begin()].first, item2 = pInfo(peer)->transmute[p - pInfo(peer)->transmute.begin()].second;
					pInfo(peer)->remove_transmute = item_removal;
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wTransmutabooth``|left|9170|\nadd_spacer|small|\nadd_textbox|Done with this transmutation? Want your item back? Here's where you can break them apart!|left|\nadd_textbox|You have transmuted `2" + to_string(pInfo(peer)->transmute.size()) + "/12`` clothing items.|left|\nadd_spacer|small|\nadd_textbox|Here's the old item that got a new look:|left|\nadd_label_with_icon|small|" + items[item1].ori_name + "``|left|" + to_string(item1) + "|\nadd_spacer|small|\nadd_textbox|Here's the item that gave its look (and is held here):|left|\nadd_label_with_icon|small|" + items[item2].ori_name + "``|left|" + to_string(item2) + "|\nadd_spacer|small|\nadd_textbox|`4Warning:`` Are you sure you want to end this transmutation? Your `2" + items[item1].ori_name + "`` will go back to normal, and your `2" + items[item2].ori_name + "`` will be returned to your backpack!``|left|\nadd_spacer|small|\nadd_button|ConfirmRemoveTransmutation|END TRANSMUTATION!|noflags|0|0|\nend_dialog|remove_transmutated_dialog|Close|Back|\nadd_quick_exit|");
				}
			}
		}
	}
	static void PayDialog(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		string gemcount = parser.get("CountGems", 1);
		if (gemcount == "") return;
		if (atoi(gemcount.c_str()) > pInfo(peer)->gems) {
			VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou don't have enough gems to pay", 0, 0);
			return;
		}
		else if (atoi(gemcount.c_str()) < 1 || gemcount.find_first_not_of("0123456789") != string::npos) return;
		else if (atoi(gemcount.c_str()) > 2000000000) {
			VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wMaximum money amount is 2.000.000.000", 0, 0);
			return;
		}
		for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
			if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
			if (pInfo(cp_)->tankIDName == pInfo(peer)->last_wrenched) {
				if (pInfo(cp_)->gems >= MAX_GEMS) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Warning! " + pInfo(cp_)->tankIDName + " gems have reached the maximum limit", 0, 0);
					return;
				}
				VarList::OnMinGems(peer, atoi(gemcount.c_str()));
				VarList::OnBuxGems(cp_, atoi(gemcount.c_str()));
				VarList::OnAddNotification(cp_, "`wYou received `2" + gemcount + " `wGems from " + pInfo(peer)->name_color + pInfo(peer)->tankIDName, "interface/cash_icon_overlay.rttex", "audio/hub_open.wav");
				VarList::OnConsoleMessage(cp_, "You received `2" + gemcount + "`o Gems from " + pInfo(peer)->name_color + pInfo(peer)->tankIDName);
				VarList::OnConsoleMessage(peer, "`oSuccesfully send " + gemcount + " Gems to " + pInfo(cp_)->tankIDName + ".");
				PlayerMoving data_{};
				data_.packetType = 19, data_.plantingTree = 500, data_.netID = pInfo(cp_)->netID;
				data_.punchX = 112, data_.punchY = 112;
				int32_t to_netid = pInfo(peer)->netID;
				BYTE* raw = packPlayerMoving(&data_);
				raw[3] = 3;
				Memory_Copy(raw + 8, &to_netid, 4);
				for (ENetPeer* cp_2 = server->peers; cp_2 < &server->peers[server->peerCount]; ++cp_2) {
					if (cp_2->state != ENET_PEER_STATE_CONNECTED or cp_2->data == NULL) continue;
					if (pInfo(cp_2)->world == pInfo(peer)->world) {
						send_raw(cp_2, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					}
				}
				delete[]raw;
			}
		}
	}
	static void spotify_dialog(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "next") {
				DialogHandle::Spotify_Menu(peer, "eng", "2");
			}
			if (button == "previous") {
				DialogHandle::Spotify_Menu(peer, "eng", "1");
			}
			if (button == "spotify_indo") {
				DialogHandle::Spotify_Menu(peer, "indo", "1");
			}
			if (button == "spotify_english") {
				DialogHandle::Spotify_Menu(peer, "eng", "1");
			}
			if (button == "play1") {
				pInfo(peer)->spotify = 1;
				CAction::Log(peer, "action|play_music\nfile|audio/be_alright.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "play2") {
				pInfo(peer)->spotify = 2;
				CAction::Log(peer, "action|play_music\nfile|audio/darniere_danse.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "play3") {
				pInfo(peer)->spotify = 3;
				CAction::Log(peer, "action|play_music\nfile|audio/love_is_gone.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "play4") {
				pInfo(peer)->spotify = 4;
				CAction::Log(peer, "action|play_music\nfile|audio/lonely.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "play5") {
				pInfo(peer)->spotify = 5;
				CAction::Log(peer, "action|play_music\nfile|audio/hurts_so_good.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "play6") {
				pInfo(peer)->spotify = 6;
				CAction::Log(peer, "action|play_music\nfile|audio/animals.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "play7") {
				pInfo(peer)->spotify = 7;
				CAction::Log(peer, "action|play_music\nfile|audio/tattoo.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "play8") {
				pInfo(peer)->spotify = 8;
				CAction::Log(peer, "action|play_music\nfile|audio/arcade.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "play9") {
				pInfo(peer)->spotify = 9;
				CAction::Log(peer, "action|play_music\nfile|audio/bring_metl.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "play10") {
				pInfo(peer)->spotify = 10;
				CAction::Log(peer, "action|play_music\nfile|audio/impossible.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "play11") {
				pInfo(peer)->spotify = 11;
				CAction::Log(peer, "action|play_music\nfile|audio/monster.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "play12") {
				pInfo(peer)->spotify = 12;
				CAction::Log(peer, "action|play_music\nfile|audio/somebody_pleasure.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "play13") {
				pInfo(peer)->spotify = 13;
				CAction::Log(peer, "action|play_music\nfile|audio/saturn.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "play14") {
				pInfo(peer)->spotify = 14;
				CAction::Log(peer, "action|play_music\nfile|audio/la_vaguelette_2.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "play15") {
				pInfo(peer)->spotify = 15;
				CAction::Log(peer, "action|play_music\nfile|audio/heart_attack.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "play16") {
				pInfo(peer)->spotify = 16;
				CAction::Log(peer, "action|play_music\nfile|audio/danse_le_vide.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "play17") {
				pInfo(peer)->spotify = 17;
				CAction::Log(peer, "action|play_music\nfile|audio/diamonds.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "play18") {
				pInfo(peer)->spotify = 18;
				CAction::Log(peer, "action|play_music\nfile|audio/the_drum.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "play19") {
				pInfo(peer)->spotify = 19;
				CAction::Log(peer, "action|play_music\nfile|audio/heat_waves.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "play20") {
				pInfo(peer)->spotify = 20;
				CAction::Log(peer, "action|play_music\nfile|audio/Zombie.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "play21") {
				pInfo(peer)->spotify = 21;
				CAction::Log(peer, "action|play_music\nfile|audio/Bad_Boys.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "play22") {
				pInfo(peer)->spotify = 22;
				CAction::Log(peer, "action|play_music\nfile|audio/Dear_God.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "play23") {
				pInfo(peer)->spotify = 23;
				CAction::Log(peer, "action|play_music\nfile|audio/Happy_Nation.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "play24") {
				pInfo(peer)->spotify = 24;
				CAction::Log(peer, "action|play_music\nfile|audio/Mary_On_A_Cross.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			//INDO
			if (button == "indo_play25") {
				pInfo(peer)->spotify = 25;
				CAction::Log(peer, "action|play_music\nfile|audio/tanpa_pesan_terakhir.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "indo_play26") {
				pInfo(peer)->spotify = 26;
				CAction::Log(peer, "action|play_music\nfile|audio/menunggumu.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "indo_play27") {
				pInfo(peer)->spotify = 27;
				CAction::Log(peer, "action|play_music\nfile|audio/aku_yang_tersakiti.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "indo_play28") {
				pInfo(peer)->spotify = 28;
				CAction::Log(peer, "action|play_music\nfile|audio/hakikat_sebuah_cinta.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "indo_play29") {
				pInfo(peer)->spotify = 29;
				CAction::Log(peer, "action|play_music\nfile|audio/feast.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "indo_play30") {
				pInfo(peer)->spotify = 30;
				CAction::Log(peer, "action|play_music\nfile|audio/sempurna.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "indo_play31") {
				pInfo(peer)->spotify = 31;
				CAction::Log(peer, "action|play_music\nfile|audio/sembilu.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "indo_play32") {
				pInfo(peer)->spotify = 32;
				CAction::Log(peer, "action|play_music\nfile|audio/bunga_maaf.ogg\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
			if (button == "stop_music") {
				pInfo(peer)->spotify = 0;
				CAction::Log(peer, "action|play_music\nfile|\ndelayMS|0");
				DialogHandle::Spotify_Menu(peer, pInfo(peer)->page_type, pInfo(peer)->page_music);
			}
		}
	}
	static void kit_dialog(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "info") send_wrench_self(peer, "");
			if (button == "road_to_glory") send_wrench_self(peer, "road_to_glory");
			if (button == "kit_pass") send_wrench_self(peer, "kit_pass");
			if (button == "kit_pass") send_wrench_self(peer, "kit_pass");
			if (button == "level_rwds") send_wrench_self(peer, "level_rwds");
			if (button == "skill_and_assets") send_wrench_self(peer, "skill_and_assets");
			if (button == "info_kit1") DialogHandle::Kit_Pass_Info(peer, 1);
			if (button == "info_kit2") DialogHandle::Kit_Pass_Info(peer, 2);
			if (button == "info_kit3") DialogHandle::Kit_Pass_Info(peer, 3);
			if (button == "info_kit4") DialogHandle::Kit_Pass_Info(peer, 4);
			if (button == "info_kit5") DialogHandle::Kit_Pass_Info(peer, 5);
			if (button == "info_kit6") DialogHandle::Kit_Pass_Info(peer, 6);
			if (button == "info_kit7") DialogHandle::Kit_Pass_Info(peer, 7);
			if (button == "info_kit8") DialogHandle::Kit_Pass_Info(peer, 8);
			if (button == "info_kit9") DialogHandle::Kit_Pass_Info(peer, 9);
			if (button == "info_kit10") DialogHandle::Kit_Pass_Info(peer, 10);
			if (button == "info_kit11") DialogHandle::Kit_Pass_Info(peer, 11);
			if (button == "info_kit12") DialogHandle::Kit_Pass_Info(peer, 12);
			if (button == "info_kit13") DialogHandle::Kit_Pass_Info(peer, 13);
			if (button == "info_kit14") DialogHandle::Kit_Pass_Info(peer, 14);
			if (button == "info_kit15") DialogHandle::Kit_Pass_Info(peer, 15);
			if (button == "info_kit16") DialogHandle::Kit_Pass_Info(peer, 16);
			if (button == "info_kit17") DialogHandle::Kit_Pass_Info(peer, 17);
			if (button == "info_kit18") DialogHandle::Kit_Pass_Info(peer, 18);
			if (button == "back_to_dialog") DialogHandle::Kit_Pass(peer);
			if (button == "claim_kit1") {
				if (pInfo(peer)->lvlKit >= 5 and not Has_Claimed::Kit(peer, "kit_1")) {
					int free = Inventory::Get_Slots(pInfo(peer)), slot = 1, addItem = 0, id = 14896;
					if (free >= slot) {
						if (Inventory::Modify(peer, id, addItem = 1) == 0) {
							pInfo(peer)->KitPass_Prize.push_back("kit_1");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations! You have received " + items[id].name + ".", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "There is no empty slot in your inventory", 0, 0);
				}
				return;
			}
			if (button == "claim_kit2") {
				if (pInfo(peer)->lvlKit >= 10 and not Has_Claimed::Kit(peer, "kit_2")) {
					int free = Inventory::Get_Slots(pInfo(peer)), slot = 1, addItem = 0, id = 5196;
					if (free >= slot) {
						if (Inventory::Modify(peer, id, addItem = 10) == 0) {
							pInfo(peer)->KitPass_Prize.push_back("kit_2");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations! You have received " + items[id].name + ".", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "There is no empty slot in your inventory", 0, 0);
				}
				return;
			}
			if (button == "claim_kit3") {
				if (pInfo(peer)->lvlKit >= 15 and not Has_Claimed::Kit(peer, "kit_3")) {
					int free = Inventory::Get_Slots(pInfo(peer)), slot = 1, addItem = 0, id = 14360;
					if (free >= slot) {
						if (Inventory::Modify(peer, id, addItem = 1) == 0) {
							pInfo(peer)->KitPass_Prize.push_back("kit_3");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations! You have received " + items[id].name + ".", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "There is no empty slot in your inventory", 0, 0);
				}
				return;
			}
			if (button == "claim_kit4") {
				if (pInfo(peer)->lvlKit >= 20 and not Has_Claimed::Kit(peer, "kit_4")) {
					int free = Inventory::Get_Slots(pInfo(peer)), slot = 1, addItem = 0, id = 9266;
					if (free >= slot) {
						if (Inventory::Modify(peer, id, addItem = 15) == 0) {
							pInfo(peer)->KitPass_Prize.push_back("kit_4");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Claimed 15 " + items[id].name + ".", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "There is no empty slot in your inventory", 0, 0);
				}
				return;
			}
			if (button == "claim_kit5") {
				if (pInfo(peer)->lvlKit >= 25 and not Has_Claimed::Kit(peer, "kit_5")) {
					int free = Inventory::Get_Slots(pInfo(peer)), slot = 1, addItem = 0, id = 6282;
					if (free >= slot) {
						if (Inventory::Modify(peer, id, addItem = 1) == 0) {
							pInfo(peer)->KitPass_Prize.push_back("kit_5");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations! You have received " + items[id].name + ".", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "There is no empty slot in your inventory", 0, 0);
				}
				return;
			}
			if (button == "claim_kit6") {
				if (pInfo(peer)->lvlKit >= 30 and not Has_Claimed::Kit(peer, "kit_6")) {
					int free = Inventory::Get_Slots(pInfo(peer)), slot = 1, addItem = 0, id = 14990;
					if (free >= slot) {
						if (Inventory::Modify(peer, id, addItem = 1) == 0) {
							pInfo(peer)->KitPass_Prize.push_back("kit_6");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations! You have received " + items[id].name + ".", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "There is no empty slot in your inventory", 0, 0);
				}
				return;
			}
			if (button == "claim_kit7") {
				if (pInfo(peer)->lvlKit >= 35 and not Has_Claimed::Kit(peer, "kit_7")) {
					int free = Inventory::Get_Slots(pInfo(peer)), slot = 1, addItem = 0, id = 14500;
					if (free >= slot) {
						if (Inventory::Modify(peer, id, addItem = 1) == 0) {
							pInfo(peer)->KitPass_Prize.push_back("kit_7");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations! You have received " + items[id].name + ".", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "There is no empty slot in your inventory", 0, 0);
				}
				return;
			}
			if (button == "claim_kit8") {
				if (pInfo(peer)->lvlKit >= 40 and not Has_Claimed::Kit(peer, "kit_8")) {
					int free = Inventory::Get_Slots(pInfo(peer)), slot = 1, addItem = 0, id = 11050;
					if (free >= slot) {
						if (Inventory::Modify(peer, id, addItem = 1) == 0) {
							pInfo(peer)->KitPass_Prize.push_back("kit_8");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations! You have received " + items[id].name + ".", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "There is no empty slot in your inventory", 0, 0);
				}
				return;
			}
			if (button == "claim_kit9") {
				if (pInfo(peer)->lvlKit >= 45 and not Has_Claimed::Kit(peer, "kit_9")) {
					int free = Inventory::Get_Slots(pInfo(peer)), slot = 1, addItem = 0, id = 3134;
					if (free >= slot) {
						if (Inventory::Modify(peer, id, addItem = 1) == 0) {
							pInfo(peer)->KitPass_Prize.push_back("kit_9");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations! You have received " + items[id].name + ".", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "There is no empty slot in your inventory", 0, 0);
				}
				return;
			}
			if (button == "claim_kit10") {
				if (pInfo(peer)->lvlKit >= 50 and not Has_Claimed::Kit(peer, "kit_10")) {
					int free = Inventory::Get_Slots(pInfo(peer)), slot = 1, addItem = 0, id = 14552;
					if (free >= slot) {
						if (Inventory::Modify(peer, id, addItem = 50) == 0) {
							pInfo(peer)->KitPass_Prize.push_back("kit_10");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations! You have received " + items[id].name + ".", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "There is no empty slot in your inventory", 0, 0);
				}
				return;
			}
			if (button == "claim_kit11") {
				if (pInfo(peer)->lvlKit >= 55 and not Has_Claimed::Kit(peer, "kit_11")) {
					int free = Inventory::Get_Slots(pInfo(peer)), slot = 1, addItem = 0, id = 14358;
					if (free >= slot) {
						if (Inventory::Modify(peer, id, addItem = 25) == 0) {
							pInfo(peer)->KitPass_Prize.push_back("kit_11");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Claimed 25 " + items[id].name + ".", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "There is no empty slot in your inventory", 0, 0);
				}
				return;
			}
			if (button == "claim_kit12") {
				if (pInfo(peer)->lvlKit >= 60 and not Has_Claimed::Kit(peer, "kit_12")) {
					int free = Inventory::Get_Slots(pInfo(peer)), slot = 1, addItem = 0, id = 13198;
					if (free >= slot) {
						if (Inventory::Modify(peer, id, addItem = 1) == 0) {
							pInfo(peer)->KitPass_Prize.push_back("kit_12");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations! You have received " + items[id].name + ".", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "There is no empty slot in your inventory", 0, 0);
				}
				return;
			}
			if (button == "claim_kit13") {
				if (pInfo(peer)->lvlKit >= 65 and not Has_Claimed::Kit(peer, "kit_13")) {
					int free = Inventory::Get_Slots(pInfo(peer)), slot = 1, addItem = 0, id = 14084;
					if (free >= slot) {
						if (Inventory::Modify(peer, id, addItem = 15) == 0) {
							pInfo(peer)->KitPass_Prize.push_back("kit_13");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations! You have received " + items[id].name + ".", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "There is no empty slot in your inventory", 0, 0);
				}
				return;
			}
			if (button == "claim_kit14") {
				if (pInfo(peer)->lvlKit >= 70 and not Has_Claimed::Kit(peer, "kit_14")) {
					int free = Inventory::Get_Slots(pInfo(peer)), slot = 1, addItem = 0, id = 14498;
					if (free >= slot) {
						if (Inventory::Modify(peer, id, addItem = 1) == 0) {
							pInfo(peer)->KitPass_Prize.push_back("kit_14");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations! You have received " + items[id].name + ".", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "There is no empty slot in your inventory", 0, 0);
				}
				return;
			}
			if (button == "claim_kit15") {
				if (pInfo(peer)->lvlKit >= 75 and not Has_Claimed::Kit(peer, "kit_15")) {
					int free = Inventory::Get_Slots(pInfo(peer)), slot = 1, addItem = 0, id = 10944;
					if (free >= slot) {
						if (Inventory::Modify(peer, id, addItem = 15) == 0) {
							pInfo(peer)->KitPass_Prize.push_back("kit_15");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Claimed 15 " + items[id].name + ".", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "There is no empty slot in your inventory", 0, 0);
				}
				return;
			}
			if (button == "claim_kit16") {
				if (pInfo(peer)->lvlKit >= 80 and not Has_Claimed::Kit(peer, "kit_16")) {
					int free = Inventory::Get_Slots(pInfo(peer)), slot = 1, addItem = 0, id = 7960;
					if (free >= slot) {
						if (Inventory::Modify(peer, id, addItem = 15) == 0) {
							pInfo(peer)->KitPass_Prize.push_back("kit_16");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Claimed 40 " + items[id].name + ".", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "There is no empty slot in your inventory", 0, 0);
				}
				return;
			}
			if (button == "claim_kit17") {
				if (pInfo(peer)->lvlKit >= 90 and not Has_Claimed::Kit(peer, "kit_17")) {
					int free = Inventory::Get_Slots(pInfo(peer)), slot = 1, addItem = 0, id = 10382;
					if (free >= slot) {
						if (Inventory::Modify(peer, id, addItem = 10) == 0) {
							pInfo(peer)->KitPass_Prize.push_back("kit_17");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations! You have received " + items[id].name + ".", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "There is no empty slot in your inventory", 0, 0);
				}
				return;
			}
			if (button == "claim_kit18") {
				if (pInfo(peer)->lvlKit >= 100 and not Has_Claimed::Kit(peer, "kit_18")) {
					int free = Inventory::Get_Slots(pInfo(peer)), slot = 1, addItem = 0, id = 5930;
					if (free >= slot) {
						if (Inventory::Modify(peer, id, addItem = 1) == 0) {
							pInfo(peer)->KitPass_Prize.push_back("kit_18");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Congratulations! You have received " + items[id].name + ".", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "There is no empty slot in your inventory", 0, 0);
				}
				return;
			}
		}
	}
	static void World_Default(ENetPeer* peer, std::string cch) {
		if (Role::Clist(pInfo(peer)->tankIDName)) {
			TextScanner parser(cch);
			string fg = parser.get("fg", 1), bg = parser.get("bg", 1), rock = parser.get("rock", 1), lava = parser.get("lava", 1), weather = parser.get("weather", 1);
			if (not is_number(fg) or not is_number(bg) or not is_number(rock) or not is_number(lava) or not is_number(weather) or fg.size() < 1 or bg.size() < 1 or rock.size() < 1 or lava.size() < 1 or weather.size() < 1) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid input.", 0, true);
				return;
			}
			if (items[std::atoi(fg.c_str())].blockType != BlockTypes::FOREGROUND || items[std::atoi(fg.c_str())].untradeable || items[std::atoi(fg.c_str())].rarity < 0 || items[std::atoi(fg.c_str())].rarity == 999 || items[std::atoi(fg.c_str())].block_possible_put == false) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "input fg: That's not a foreground!", 0, 1);
				return;
			}
			if (items[std::atoi(bg.c_str())].blockType != BlockTypes::BACKGROUND || items[std::atoi(bg.c_str())].untradeable || items[std::atoi(bg.c_str())].rarity < 0 || items[std::atoi(bg.c_str())].rarity == 999 || items[std::atoi(bg.c_str())].block_possible_put == false) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "input bg: That's not a background!", 0, 1);
				return;
			}
			if (items[std::atoi(rock.c_str())].blockType != BlockTypes::FOREGROUND || items[std::atoi(rock.c_str())].untradeable || items[std::atoi(rock.c_str())].rarity < 0 and std::atoi(rock.c_str()) != 7006 || items[std::atoi(rock.c_str())].rarity == 999 and std::atoi(rock.c_str()) != 7006 || items[std::atoi(rock.c_str())].block_possible_put == false) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "input rock: Invalid!", 0, 1);
				return;
			}
			if (std::atoi(lava.c_str()) != 4 and std::atoi(lava.c_str()) != 380 and std::atoi(lava.c_str()) != 1000 and std::atoi(lava.c_str()) != 1630 and std::atoi(lava.c_str()) != 7376 and std::atoi(lava.c_str()) != 8212 and std::atoi(lava.c_str()) != 9892) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "input lava: Invalid!", 0, 1);
				return;
			}
			if (std::atoi(weather.c_str()) > 78) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "input weather: between 0-78!", 0, 1);
				return;
			}
			WorldDefault.fg = std::atoi(fg.c_str());
			WorldDefault.bg = std::atoi(bg.c_str());
			WorldDefault.rock = std::atoi(rock.c_str());
			WorldDefault.lava = std::atoi(lava.c_str());
			WorldDefault.weather = std::atoi(weather.c_str());
			EventPool::Save::Config();
			VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Succesfully changed!", 0, 1);
		}
	}
	static void carnival(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "c_quest") {
				int removeTicket = -10;
				if (Inventory::Modify(peer, 1898, removeTicket) == 0) {
					pInfo(peer)->C_QuestActive = true;
					pInfo(peer)->CQ = true;
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Quest For The Ring``|left|1900|\nadd_textbox|`oYou are about to embark on a VallenSasuke journey! it won't be easy, but the reward is one of the fine rings from my vast collection. You don't get to pick which one, mind you.<CR>I've got a lot of rings sitting in my bag, with a lot of VallenSasuke properties. If you want one, picked randomly at my discretion, you'll need to complete 10 little tasks for me.<CR>Doesn't sound so bad does it?<CR>Remember that i travel with the carnival, so if you don't get your quest done this time but don't worry because in GTPS i won't be travel somewhere and i will be here everyday!<CR>There's one last thing you should know before you begin. You can quit your quest at any time, but be aware that if you do, you'll lose all your progress, and you'll have to pay another 10 Golden Tickets to start again!``|\nadd_spacer|small|\nadd_label|small|`oSo... now that you've received the official disclaimer, are you truly prepared to hand over 10 Golden Tickets and embark on the Quest For The Ring?``|\nend_dialog|carnival|No!|Yes!|");
					p.CreatePacket(peer);
				}
			}
			if (button == "deliver") {
				if (pInfo(peer)->C_QuestKind == 1 or pInfo(peer)->C_QuestKind == 8) {
					if (pInfo(peer)->C_QuestStep != 10) {
						int adaBrp = 0;
						Inventory::Modify(peer, pInfo(peer)->C_DeliverID, adaBrp);
						if (adaBrp != 0) {
							if (pInfo(peer)->C_QuestProgress + adaBrp > pInfo(peer)->C_ProgressNeeded) adaBrp = pInfo(peer)->C_ProgressNeeded - pInfo(peer)->C_QuestProgress;
							int removeItem = 0 - adaBrp;
							Inventory::Modify(peer, pInfo(peer)->C_DeliverID, removeItem);
							pInfo(peer)->C_QuestProgress += adaBrp;
							if (pInfo(peer)->C_QuestProgress >= pInfo(peer)->C_ProgressNeeded) {
								pInfo(peer)->C_QuestProgress = 0;
								pInfo(peer)->C_QuestKind = 0;
								pInfo(peer)->C_QuestStep++;
								gamepacket_t p, p2;
								p.Insert("OnTextOverlay");
								p.Insert("`9Quest step complete!!");
								p2.Insert("OnParticleEffect");
								p2.Insert(48);
								p2.Insert((float)pInfo(peer)->x + 10, (float)pInfo(peer)->y + 16);
								p.CreatePacket(peer);
								for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
									if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
									if (pInfo(cp_)->world == pInfo(peer)->world) {
										p2.CreatePacket(peer);
									}
								}
								RandomizeCQuest(peer);
								SendCarnivalQuest(peer, 500);
								return;
							}
							else {
								gamepacket_t p;
								p.Insert("OnTextOverlay");
								p.Insert("`9Thanks! Keep it coming!");
								p.CreatePacket(peer);
								return;
							}
						}
						else {
							goto GoodLuck;
						}
					}
					else {
						int adaBrp = 0;
						Inventory::Modify(peer, pInfo(peer)->C_DeliverID, adaBrp);
						if (adaBrp != 0) {
							if (pInfo(peer)->C_QuestProgress + adaBrp > pInfo(peer)->C_ProgressNeeded) adaBrp = pInfo(peer)->C_ProgressNeeded - pInfo(peer)->C_QuestProgress;
							int removeItem = 0 - adaBrp;
							Inventory::Modify(peer, pInfo(peer)->C_DeliverID, removeItem);
							pInfo(peer)->C_QuestProgress += adaBrp;
							if (pInfo(peer)->C_QuestProgress >= pInfo(peer)->C_ProgressNeeded) {
								int amount = 1;
								vector<int> listRing{ 1874, 1876, 1996, 2970, 1932, 3140, 1904, 1986, 3174, 6028, 6846, 8962, 11094 };
								int randomRing = listRing[rand() % listRing.size()];
								Inventory::Modify(peer, randomRing, amount);
								gamepacket_t p;
								p.Insert("OnTextOverlay");
								p.Insert("`9Quest completed!!");
								p.CreatePacket(peer);
								VarList::OnAction(peer, pInfo(peer)->netID, "/cheer", 0);
								Clothing::Equip(peer, randomRing);
								for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
									if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
									if (pInfo(cp_)->world == pInfo(peer)->world) {
										CAction::Log(cp_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
										gamepacket_t p3, p4;
										p3.Insert("OnParticleEffect");
										p3.Insert(73);
										p3.Insert((float)pInfo(peer)->x + 10, (float)pInfo(peer)->y + 16);
										p4.Insert("OnConsoleMessage");
										p4.Insert("`9>> " + get_player_nick(peer) + " `9has completed the Quest For The Ring and earned the " + items[randomRing].ori_name + "!");
										p3.CreatePacket(cp_), p4.CreatePacket(cp_);
									}
								}
								pInfo(peer)->C_QuestProgress = 0;
								pInfo(peer)->C_ProgressNeeded = 0;
								pInfo(peer)->C_QuestStep = 1;
								pInfo(peer)->C_QuestActive = false;
								pInfo(peer)->C_QuestKind = 0;
								pInfo(peer)->C_DeliverID = 0;
								return;
							}
						}
						else {
							goto GoodLuck;
						}
					}
				}
				else if (pInfo(peer)->C_QuestKind == 7) {
					if (pInfo(peer)->C_QuestStep != 10) {
						int cost = pInfo(peer)->C_ProgressNeeded;
						if (pInfo(peer)->gems >= cost) {
							VarList::OnBuxGems(peer, cost * -1);
							pInfo(peer)->C_QuestProgress = 0;
							pInfo(peer)->C_QuestKind = 0;
							pInfo(peer)->C_QuestStep++;
							gamepacket_t p, p2;
							p.Insert("OnTextOverlay");
							p.Insert("`9Quest step complete!!");
							p2.Insert("OnParticleEffect");
							p2.Insert(48);
							p2.Insert((float)pInfo(peer)->x + 10, (float)pInfo(peer)->y + 16);
							p.CreatePacket(peer);
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
								if (pInfo(cp_)->world == pInfo(peer)->world) {
									p2.CreatePacket(peer);
								}
							}
							RandomizeCQuest(peer);
							SendCarnivalQuest(peer, 500);
							return;
						}
						else {
							goto GoodLuck;
						}
					}
					else {
						int cost = pInfo(peer)->C_ProgressNeeded;
						if (pInfo(peer)->gems >= cost) {
							VarList::OnBuxGems(peer, cost * -1);
							int amount = 1;
							vector<int> listRing{ 1874, 1876, 1996, 2970, 1932, 3140, 1904, 1986, 3174, 6028, 6846, 8962, 11094 };
							int randomRing = listRing[rand() % listRing.size()];
							Inventory::Modify(peer, randomRing, amount);
							gamepacket_t p;
							p.Insert("OnTextOverlay");
							p.Insert("`9Quest completed!!");
							p.CreatePacket(peer);
							VarList::OnAction(peer, pInfo(peer)->netID, "/cheer", 0);
							Clothing::Equip(peer, randomRing);
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
								if (pInfo(cp_)->world == pInfo(peer)->world) {
									CAction::Log(cp_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p3, p4;
									p3.Insert("OnParticleEffect");
									p3.Insert(73);
									p3.Insert((float)pInfo(peer)->x + 10, (float)pInfo(peer)->y + 16);
									p4.Insert("OnConsoleMessage");
									p4.Insert("`9>> " + get_player_nick(peer) + " `9has completed the Quest For The Ring and earned the " + items[randomRing].ori_name + "!");
									p3.CreatePacket(cp_), p4.CreatePacket(cp_);
								}
							}
							pInfo(peer)->C_QuestProgress = 0;
							pInfo(peer)->C_ProgressNeeded = 0;
							pInfo(peer)->C_QuestStep = 1;
							pInfo(peer)->C_QuestActive = false;
							pInfo(peer)->C_QuestKind = 0;
							pInfo(peer)->C_DeliverID = 0;
							return;
						}
						else {
							goto GoodLuck;
						}
					}
				}
				else {
					if (pInfo(peer)->C_QuestStep != 10) {
						if (pInfo(peer)->C_QuestProgress >= pInfo(peer)->C_ProgressNeeded) {
							pInfo(peer)->C_QuestProgress = 0;
							pInfo(peer)->C_QuestKind = 0;
							pInfo(peer)->C_QuestStep++;
							gamepacket_t p, p2;
							p.Insert("OnTextOverlay");
							p.Insert("`9Quest step complete!!");
							p2.Insert("OnParticleEffect");
							p2.Insert(48);
							p2.Insert((float)pInfo(peer)->x + 10, (float)pInfo(peer)->y + 16);
							p.CreatePacket(peer);
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
								if (pInfo(cp_)->world == pInfo(peer)->world) {
									p2.CreatePacket(peer);
								}
							}
							RandomizeCQuest(peer);
							SendCarnivalQuest(peer, 500);
							return;
						}
						else {
							goto GoodLuck;
						}
					}
					else {
						if (pInfo(peer)->C_QuestProgress >= pInfo(peer)->C_ProgressNeeded) {
							int amount = 1;
							vector<int> listRing{ 1874, 1876, 1996, 2970, 1932, 3140, 1904, 1986, 3174, 6028, 6846, 8962, 11094 };
							int randomRing = listRing[rand() % listRing.size()];
							Inventory::Modify(peer, randomRing, amount);
							gamepacket_t p;
							p.Insert("OnTextOverlay");
							p.Insert("`9Quest completed!!");
							p.CreatePacket(peer);
							VarList::OnAction(peer, pInfo(peer)->netID, "/cheer", 0);
							Clothing::Equip(peer, randomRing);
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
								if (pInfo(cp_)->world == pInfo(peer)->world) {
									CAction::Log(cp_, "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0");
									gamepacket_t p3, p4;
									p3.Insert("OnParticleEffect");
									p3.Insert(73);
									p3.Insert((float)pInfo(peer)->x + 10, (float)pInfo(peer)->y + 16);
									p4.Insert("OnConsoleMessage");
									p4.Insert("`9>> " + get_player_nick(peer) + " `9has completed the Quest For The Ring and earned the " + items[randomRing].ori_name + "!");
									p3.CreatePacket(cp_), p4.CreatePacket(cp_);
								}
							}
							pInfo(peer)->C_QuestProgress = 0;
							pInfo(peer)->C_ProgressNeeded = 0;
							pInfo(peer)->C_QuestStep = 1;
							pInfo(peer)->C_QuestActive = false;
							pInfo(peer)->C_QuestKind = 0;
							pInfo(peer)->C_DeliverID = 0;
							return;
						}
						else {
							goto GoodLuck;
						}
					}
				}
			GoodLuck:
				gamepacket_t p;
				p.Insert("OnTextOverlay");
				p.Insert("`9Good luck! You can do it!");
				p.CreatePacket(peer);
			}
			if (button == "give_up") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("\nadd_label_with_icon|big|`9Quest For The Ring|left|1900|\nadd_textbox|`oIf you quit, any progress you've made will be lost forever.<CR>There is no benefit to quitting the Ring Quest, except that you can start over and hope for easier tasks (not likely!). You'll also have to pay 10 more Golden Tickets when you start again.``|\nadd_spacer|small|\nadd_label|small|`4Are you absolutely sure you want to quit this quest?``|\nadd_spacer|small|\nend_dialog|carnival_give_up|`wNo!|`wYes!|\nadd_quick_exit|\n");
				p.CreatePacket(peer);
			}
		}
		else {
			if (pInfo(peer)->CQ) {
				RandomizeCQuest(peer);
				SendCarnivalQuest(peer, 500);
			}
		}
	}
	static void carnival_give_up(ENetPeer* peer, std::string cch) {
		pInfo(peer)->C_QuestActive = false;
		pInfo(peer)->C_QuestKind = 0;
		pInfo(peer)->C_DeliverID = 0;
		pInfo(peer)->C_QuestStep = 1;
		pInfo(peer)->C_ProgressNeeded = 0;
		pInfo(peer)->C_QuestProgress = 0;
		gamepacket_t p;
		p.Insert("OnTextOverlay");
		p.Insert("`9Okay! You are no longer on the Ring Quest! Good luck!");
		p.CreatePacket(peer);
	}
	static void giveaway_setting(ENetPeer* peer, std::string cch) {
		if (not Role::Clist(pInfo(peer)->tankIDName)) return;
		TextScanner parser(cch);
		std::string button = ""; int targetID = 0;
		if (parser.try_get("ItemID", targetID)) {
			if ((targetID < 0 && targetID > items.size())) return;
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n"
				"add_label_with_icon|big|`wInsert `2" + items[targetID].ori_name + "``|left|" + to_string(targetID) + "|\n"
				"add_text_input|count|Amount:|0|3|\n"
				"embed_data|itemID|"
				+ to_string(targetID) + "\n"
				"end_dialog|giveaway_insert|Nevermind.|`2Apply|\n"
				"add_quick_exit|", 200);
		}
		else if (parser.try_get("buttonClicked", button)) {
			if (button.substr(0, 0) == "") {
				int targetID = std::atoi(button.substr(0).c_str());
				if (targetID > giveaway.Items.size()) return;
				targetID = giveaway.Items[targetID].first;
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n"
					"add_label_with_icon|big|`2Modify `2" + items[targetID].ori_name + "``|left|" + to_string(targetID) + "|\n"
					"add_smalltext|Set the Amount to 0 to remove the item from the giveaway list|\n"
					"add_text_input|count|Amount:|0|3|\n"
					"embed_data|itemID|"
					+ to_string(targetID) + "\n"
					"end_dialog|giveaway_insert|Nevermind.|`2Apply|\n"
					"add_quick_exit|", 200);
			}
		}
		else {
			string randomItem_ = parser.get("randomItem", 1), randomCount = parser.get("randomCount", 1);
			if (not is_number(randomCount)) return;
			if (randomItem_ == "1" and atoi(randomCount.c_str()) != 0) {
				int targetID = std::atoi(randomCount.c_str());
				if (targetID > 99 || targetID < 1) return;
				for (int i = 0; i < targetID; i++) {
					bool exist = false;
					int randomItem;
					while (!exist) {
						exist = true;
						randomItem = rand() % items.size(); if (randomItem % 2 != 0 && randomItem != items.size()) randomItem++;
						if (randomItem == 2950 || items[randomItem].untradeable || items[randomItem].blockType == BlockTypes::LOCK || items[randomItem].blockType == SEED || items[randomItem].name.find("Data Bedrock") != string::npos || items[randomItem].name.find("Phoenix") != string::npos || items[randomItem].name.find("Golden") != string::npos || items[randomItem].name.find("Legend") != string::npos || items[randomItem].name.find("Legendary") != string::npos || items[randomItem].name.find("Ancestral") != string::npos || items[randomItem].name.find("Wrench") != string::npos || items[randomItem].name.find("null_item") != string::npos || items[randomItem].name.find("null") != string::npos || items[randomItem].name.find("Guild Flag") != string::npos || items[randomItem].name.find("Guild Entrance") != string::npos || items[randomItem].name.find("Guild Banner") != string::npos || items[randomItem].name.find("Guild Key") != string::npos || items[randomItem].name.find("World Key") != string::npos || randomItem == 5640 || randomItem == 5814 || randomItem == 1486 || randomItem == 6802 || randomItem == 5070 || randomItem == 5072 || randomItem == 5074 || randomItem == 5076 || randomItem == 9158) return;
						for (auto& item : giveaway.Items)
							if (randomItem == item.second) exist = false;
					}
					if (exist) giveaway.Items.push_back({ randomItem, 10 });
				}
			}
			for (auto& item : giveaway.Items) {
				int give_count = 0;
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					gamepacket_t p;
					p.Insert("OnAddNotification"), p.Insert("interface/large/tianvan/partystart_banner.rttex");
					p.Insert(""), p.Insert("audio/cumbia_horns.wav"), p.Insert(1);
					p.CreatePacket(currentPeer);
					{
						gamepacket_t p(5000);
						p.Insert("OnAddNotification"), p.Insert("interface/large/tianvan/partyend_banner.rttex");
						p.Insert(""), p.Insert("audio/cumbia_horns.wav"), p.Insert(1);
						p.CreatePacket(currentPeer);
					}
					if (Inventory::Modify(currentPeer, item.first, give_count = +item.second) == 0) VarList::OnConsoleMessage(currentPeer, pInfo(peer)->tankIDName + " `2Give you some gift:`` `w" + to_string(item.second) + " " + items[item.first].ori_name + "``." + (items.at(item.first).rarity > 363 ? "" : " Rarity: `w" + to_string(items.at(item.first).rarity) + "``") + "");
					else VarList::OnConsoleMessage(currentPeer, pInfo(peer)->tankIDName + " `2Give you some gift:`` `w" + to_string(item.second) + " " + items[item.first].ori_name + "``." + (items.at(item.first).rarity > 363 ? "" : " Rarity: `w" + to_string(items.at(item.first).rarity) + "``") + ", buy you didn't have inventory/max item\n`6>> Sorry, you can wait until the next giveaway!``");
				}
			}
			giveaway.Items = {};
		}
	}
	static void giveaway_insert(ENetPeer* peer, std::string cch) {
		if (not Role::Clist(pInfo(peer)->tankIDName)) return;
		TextScanner parser(cch);
		string count = parser.get("count", 1);
		int targetID = std::atoi(get_embed(cch, "itemID").c_str());
		int amount = std::atoi(count.c_str());
		if (amount < 0 || amount > 200 || not is_number(count)) return;
		if (items[targetID].blockType == BlockTypes::FISH) amount = 1;
		insertGiveaway(peer, targetID, amount);
	}
	static void s4tb(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		if (not WinterFest.Active and pInfo(peer)->world != "GROWCH") return;
		string donate_rarity = parser.get("donate_rarity", 1);
		int count = std::atoi(donate_rarity.c_str());
		int got = 0;
		int item = pInfo(peer)->lastchoosenitem;
		Inventory::Modify(peer, pInfo(peer)->lastchoosenitem, got);
		if (got <= 0 || count <= 0 || item > items.size()) return;
		if (items[item].untradeable == 1 || item == 1424 || items[item].rarity >= 999 || items[item].rarity == 0 || items[item].rarity < 1 || count > got) {
			if (count > got) VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have that to give!");
			else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "I'm sorry, we can't accept items without rarity!");
		}
		else {
			std::string name_ = pInfo(peer)->world;
			std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				if (pInfo(peer)->staged < WinterFest.Growch_Prize.size()) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Thank you for your generosity!");
					PlayerMoving data{};
					data.packetType = 19, data.netID = -1, data.plantingTree = 0;
					data.x = pInfo(peer)->lastwrenchx * 32 + 16, data.y = pInfo(peer)->lastwrenchy * 32 + 16;
					data.XSpeed = pInfo(peer)->x + 16, data.YSpeed = pInfo(peer)->y + 16;
					data.punchX = item;
					BYTE* raw_ = packPlayerMoving(&data);
					raw_[3] = 6;
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL) return;
						if (pInfo(peer)->world == pInfo(cp_)->world) {
							send_raw(cp_, 4, raw_, 56, ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[] raw_;
					world_->s4tb = { world_->s4tb.first + count, world_->s4tb.second + (count * items[item].rarity) };
					Inventory::Modify(peer, pInfo(peer)->lastchoosenitem, got = -count);
					pInfo(peer)->s4tb += (count * items[item].rarity);
					if (WinterFest.Active) DailyEvent_Task::WinterFest(peer, "8", count * items[item].rarity);
					if (pInfo(peer)->s4tb >= WinterFest.Growch_Prize[pInfo(peer)->staged].second) {
						int got = 0;
						PlayerMoving data_{};
						data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = WinterFest.Growch_Prize[pInfo(peer)->staged].first, data_.punchY = pInfo(peer)->netID;
						int32_t to_netid = pInfo(peer)->netID;
						BYTE* raw = packPlayerMoving(&data_);
						raw[3] = 5;
						Memory_Copy(raw + 8, &to_netid, 4);
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL) return;
							if (pInfo(peer)->world == pInfo(cp_)->world) {
								send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw;
						Inventory::Modify(peer, WinterFest.Growch_Prize[pInfo(peer)->staged].first, got = +1);
						if (WinterFest.Growch_Prize[pInfo(peer)->staged].first == 10500) {
							pInfo(peer)->Diamond_Donatur = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "We declare you a Diamond Level Donatur, and award you the amazing `2" + items[WinterFest.Growch_Prize[pInfo(peer)->staged].first].name + "!``", 0, 0);
						}
						if (WinterFest.Growch_Prize[pInfo(peer)->staged].first == 4288) {
							pInfo(peer)->Gold_Donatur = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "We declare you a `9Gold Level Donatur``, and award you the amazing `2" + items[WinterFest.Growch_Prize[pInfo(peer)->staged].first].name + "!``", 0, 0);
						}
						if (WinterFest.Growch_Prize[pInfo(peer)->staged].first == 4286) {
							pInfo(peer)->Silver_Donatur = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "We declare you a Silver Level Donatur, and award you the amazing `2" + items[WinterFest.Growch_Prize[pInfo(peer)->staged].first].name + "!``", 0, 0);
						}
						if (WinterFest.Growch_Prize[pInfo(peer)->staged].first == 4292) {
							pInfo(peer)->Bronze_Donatur = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "We declare you a `8Bronze Level Donatur``, and award you the amazing `2" + items[WinterFest.Growch_Prize[pInfo(peer)->staged].first].name + "!``", 0, 0);
						}
						if (pInfo(peer)->staged < WinterFest.Growch_Prize.size()) pInfo(peer)->staged++;
						else if (pInfo(peer)->staged == WinterFest.Growch_Prize.size()) pInfo(peer)->staged = 0;
					}
				}
			}
		}
	}
	static void adventure_join(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button.substr(0, 6) == "button") {
				if (not is_number(std::string(get_embed(cch, "tilex"))) or not is_number(std::string(get_embed(cch, "tiley")))) return;
				int number = std::atoi(button.substr(6).c_str()), spawn_x = 0, spawn_y = 0, x = std::atoi(get_embed(cch, "tilex").c_str()), y = std::atoi(get_embed(cch, "tiley").c_str());
				std::string name_ = pInfo(peer)->world;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					World target_world = worlds[p - worlds.begin()];
					WorldBlock* block_ = &world_->blocks[x + (y * 100)];
					string door_target = block_->gate_dest[number], door_id = "";
					string btn = block_->gate_options[number].second;
					bool locked = true;
					if (number > 4) return;
					if (block_->fg != 1682) return;
					if (locked) {
						if (door_target.empty()) return;
						if (door_target.find(":") != string::npos) {
							std::vector<std::string> detales = explode(":", door_target);
							door_target = detales[0], door_id = detales[1];
						}
						if (not door_target.empty() and door_target != world_->name) {
							if (not check_name(door_target)) {
								VarList::OnSetFreezeState(peer, pInfo(peer)->netID, 250, 1);
								VarList::OnConsoleMessage(peer, door_target);
								VarList::OnZoomCamera(peer, 250);
								VarList::OnSetFreezeState(peer, pInfo(peer)->netID, 250, 0);
								return;
							}
							target_world = get_world(door_target);
						}
						if (door_target == world_->name or door_target.empty()) {
							auto has_adventure = [&](const int& id) {
								for (auto item : pInfo(peer)->adventure_item) {
									if (item.id == id) return true;
								}
								return false;
								};
							auto del_adventure = [&](const int& id) {
								bool done = false;
								for (int i = 0; i < pInfo(peer)->adventure_item.size(); i++) {
									if (!done) {
										if (pInfo(peer)->adventure_item[i].id == id) {
											pInfo(peer)->adventure_item[i].id = 0;
											pInfo(peer)->adventure_item[i].pos = -1;
											PlayerMoving data_;
											data_.packetType = 35;
											data_.netID = i;
											data_.plantingTree = 0;
											BYTE* raw = packPlayerMoving(&data_);
											send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											done = true;
										}
									}
								}
								};
							if (btn.starts_with("#")) {
								if (btn.substr(1, btn.length() - (btn.length() - 1)) == "I") {
									if (has_adventure(1698)) {
										del_adventure(1698);
									}
								}
								else if (btn.substr(1, btn.length() - (btn.length() - 1)) == "R") {
									if (has_adventure(1694)) {
										del_adventure(1694);
									}
								}
								else if (btn.substr(1, btn.length() - (btn.length() - 1)) == "T") {
									if (has_adventure(1702)) {
										del_adventure(1702);
									}
								}
								else if (btn.substr(1, btn.length() - (btn.length() - 1)) == "B") {
									if (has_adventure(1700)) {
										del_adventure(1700);
									}
								}
								else if (btn.substr(1, btn.length() - (btn.length() - 1)) == "K") {
									if (has_adventure(1696)) {
										del_adventure(1696);
									}
								}
								else if (btn.substr(1, btn.length() - (btn.length() - 1)) == "G") {
									if (has_adventure(4738)) {
										del_adventure(4738);
									}
								}
								else if (btn.substr(1, btn.length() - (btn.length() - 1)) == "P") {
									if (has_adventure(4716)) {
										del_adventure(4716);
									}
								}
							}
						}
						int ySize = (int)target_world.blocks.size() / 100, xSize = (int)target_world.blocks.size() / ySize, square = (int)target_world.blocks.size();
						if (not door_id.empty()) {
							for (int i_ = 0; i_ < target_world.blocks.size(); i_++) {
								WorldBlock block_data = target_world.blocks[i_];
								if (block_data.fg == 1684 or block_data.fg == 4482 or items[block_data.fg].blockType == BlockTypes::DOOR or items[block_data.fg].blockType == BlockTypes::PORTAL) {
									if (block_data.door_id == door_id && block_data.fg != 762) {
										spawn_x = i_ % xSize, spawn_y = i_ / xSize;
										return;
									}
								}
							}
						}
					}
					Enter_World(peer, target_world.name, spawn_x, spawn_y, 250, false, true);
					return;
				}
			}
		}
	}
	static void adventure_edit(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		string button = "", number = ""; bool has_ = false;
		if (parser.try_get("buttonClicked", button)) {
			if (button == "clear") {
				if (not is_number(std::string(get_embed(cch, "tilex"))) or not is_number(std::string(get_embed(cch, "tiley")))) return;
				int x = std::atoi(get_embed(cch, "tilex").c_str()), y = std::atoi(get_embed(cch, "tiley").c_str());
				bool updated = false;
				std::string name_ = pInfo(peer)->world;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					WorldBlock* block_ = &world_->blocks[x + (y * 100)];
					if (block_->fg != 1682) return;
					for (int i = 0; i <= 4; i++) {
						block_->gate_options[i].first = "";
						block_->gate_options[i].second = "";
						block_->gate_dest[i] = "";
					}
					has_ = true;
				}
			}
			if (has_) VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`2Adventure Update!", 0, true);
		}
		else {
			if (not is_number(std::string(get_embed(cch, "tilex"))) or not is_number(std::string(get_embed(cch, "tiley")))) return;
			int x = std::atoi(get_embed(cch, "tilex").c_str()), y = std::atoi(get_embed(cch, "tiley").c_str());
			string story0 = parser.get("story0", 1), story1 = parser.get("story1", 1), story2 = parser.get("story2", 1), story3 = parser.get("story3", 1), story4 = parser.get("story4", 1), button0 = parser.get("button0", 1), button1 = parser.get("button1", 1), button2 = parser.get("button2", 1), button3 = parser.get("button3", 1), button4 = parser.get("button4", 1), doorid0 = parser.get("doorid0", 1), doorid1 = parser.get("doorid1", 1), doorid2 = parser.get("doorid2", 1), doorid3 = parser.get("doorid3", 1), doorid4 = parser.get("doorid4", 1);
			std::string name_ = pInfo(peer)->world;
			std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				WorldBlock* block_ = &world_->blocks[x + (y * 100)];
				if (block_->fg != 1682) return;
				if (block_->gate_options[0].first != story0) {
					block_->gate_options[0].first = story0;
					has_ = true;
				}
				if (block_->gate_options[1].first != story1) {
					block_->gate_options[1].first = story1;
					has_ = true;
				}
				if (block_->gate_options[2].first != story2) {
					block_->gate_options[2].first = story2;
					has_ = true;
				}
				if (block_->gate_options[3].first != story3) {
					block_->gate_options[3].first = story3;
					has_ = true;
				}
				if (block_->gate_options[4].first != story4) {
					block_->gate_options[4].first = story4;
					has_ = true;
				}
				if (block_->gate_options[0].second != button0) {
					block_->gate_options[0].second = button0;
					has_ = true;
				}
				if (block_->gate_options[1].second != button1) {
					block_->gate_options[1].second = button1;
					has_ = true;
				}
				if (block_->gate_options[2].second != button2) {
					block_->gate_options[2].second = button2;
					has_ = true;
				}
				if (block_->gate_options[3].second != button3) {
					block_->gate_options[3].second = button3;
					has_ = true;
				}
				if (block_->gate_options[4].second != button4) {
					block_->gate_options[4].second = button4;
					has_ = true;
				}
				if (block_->gate_dest[0] != doorid0) {
					if (block_->gate_options[0].second == "") return;
					block_->gate_dest[0] = doorid0;
					transform(block_->gate_dest[0].begin(), block_->gate_dest[0].end(), block_->gate_dest[0].begin(), ::toupper);
					has_ = true;
				}
				if (block_->gate_dest[1] != doorid1) {
					if (block_->gate_options[1].second == "") return;
					block_->gate_dest[1] = doorid1;
					transform(block_->gate_dest[1].begin(), block_->gate_dest[1].end(), block_->gate_dest[1].begin(), ::toupper);
					has_ = true;
				}
				if (block_->gate_dest[2] != doorid2) {
					if (block_->gate_options[2].second == "") return;
					block_->gate_dest[2] = doorid2;
					transform(block_->gate_dest[2].begin(), block_->gate_dest[2].end(), block_->gate_dest[2].begin(), ::toupper);
					has_ = true;
				}
				if (block_->gate_dest[3] != doorid3) {
					if (block_->gate_options[3].second == "") return;
					block_->gate_dest[3] = doorid3;
					transform(block_->gate_dest[3].begin(), block_->gate_dest[3].end(), block_->gate_dest[3].begin(), ::toupper);
					has_ = true;
				}
				if (block_->gate_dest[4] != doorid4) {
					if (block_->gate_options[4].second == "") return;
					block_->gate_dest[4] = doorid4;
					transform(block_->gate_dest[4].begin(), block_->gate_dest[4].end(), block_->gate_dest[4].begin(), ::toupper);
					has_ = true;
				}
			}
			if (has_) VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`2Adventure Update!", 0, true);
		}
	}
	static void epoch_dialog(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		string iceage = parser.get("iceage", 1), volcano = parser.get("volcano", 1), islands = parser.get("islands", 1), cycleTime = parser.get("cycleTime", 1);
		if (!isValidCheckboxInput(iceage) or !isValidCheckboxInput(volcano) or !isValidCheckboxInput(islands)) return;
		if (not is_number(std::string(get_embed(cch, "tilex"))) or not is_number(std::string(get_embed(cch, "tiley")))) return;
		int x = std::atoi(get_embed(cch, "tilex").c_str()), y = std::atoi(get_embed(cch, "tiley").c_str());
		std::string name_ = pInfo(peer)->world;
		std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			WorldBlock* block_ = &world_->blocks[x + (y * 100)];
			if (block_->epoch_state.first[1] != std::atoi(volcano.c_str())) {
				block_->epoch_state.first[1] = (atoi(volcano.c_str()));
			}
			if (block_->epoch_state.first[2] != std::atoi(islands.c_str())) {
				block_->epoch_state.first[2] = (atoi(islands.c_str()));
			}
			if (block_->epoch_state.first[0] != std::atoi(iceage.c_str())) {
				block_->epoch_state.first[0] = (atoi(iceage.c_str()));
			}
			if (block_->epoch_state.second != std::atoi(cycleTime.c_str()) and is_number(cycleTime)) {
				block_->epoch_state.second = (atoi(cycleTime.c_str()));
			}
			if (block_->flags & 0x00400000) {
				world_->weather = get_epoch_weather(*block_);
				block_->epoch_cycle = time(nullptr) + (block_->epoch_state.second * 60);
				gamepacket_t t;
				t.Insert("OnSetCurrentWeather");
				t.Insert(world_->weather == 0 ? 4 : world_->weather);
				for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
					if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
					if (pInfo(cp_)->world == name_) {
						t.CreatePacket(cp_);
					}
				}
			}
		}
	}
	static void infinity_machine(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (not is_number(std::string(get_embed(cch, "tilex"))) or not is_number(std::string(get_embed(cch, "tiley")))) return;
		int id = 0, x_ = std::atoi(get_embed(cch, "tilex").c_str()), y_ = std::atoi(get_embed(cch, "tiley").c_str());
		if (parser.try_get("add_weather", id)) {
			if (id >= items.size() || id < 1) return;
			if (items[id].blockType == BlockTypes::WEATHER and not (id == 6280 or id == 3832 or id == 5654 or id == 10058 or id == 5000 or id == 3694)) {
				int count_ = -1; bool already_ = false;
				std::string name_ = pInfo(peer)->world;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					WorldBlock* block_ = &world_->blocks.at(x_ + (y_ * 100));
					if (world_->infinity.size() >= 10) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "The Weather Machine is maximum limit", 0, 0);
						already_ = true;
						return;
					}
					for (int i_ = 0; i_ < world_->infinity.size(); i_++) {
						if (world_->infinity[i_] == id) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "This Weather Machine it's already inside!", 0, 0);
							already_ = true;
							return;
						}
					}
					if (not already_) {
						world_->infinity.push_back(id);
						Inventory::Modify(peer, id, count_);
						string weather_list = "";
						for (int i_ = 0; i_ < world_->infinity.size(); i_++) weather_list += "\nadd_label_with_icon|small|`w" + items[world_->infinity[i_]].name + "|left|" + to_string(world_->infinity[i_]) + "|\n";
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`w" + items[10058].name + "``|left|10058|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "|\nadd_smalltext|`oAdd weather machines from your inventory to be able to cycle through then automatically.|left|\nadd_smalltext|`oNever have the same weather every day again|left|\nadd_spacer|small|" + weather_list + "|\nadd_spacer|small|\nadd_text_input|cycle_time|`oCycle time (minutes):|" + to_string(block_->infinity_cycle) + "|5|\nadd_spacer|small|\nadd_item_picker|add_weather|`wAdd Weather Machine|Choose the Weather Machine you want to add!|\nadd_button|remove_weather|`wRemove Weather Machine|0|0|\nend_dialog|infinity_machine|Close|Save|");
						if (block_->enabled) {
							world_->weather = items[id].base_weather;
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
								if (pInfo(cp_)->world == world_->name) {
									VarList::OnSetCurrentWeather(cp_, (Event()->Comet_Dust ? 16 : world_->weather == 0 ? 80 : world_->weather));
								}
							}
						}
					}
				}
			}
			else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "The Weather Machine does not accept this item!", 0, 1);
		}
		else if (parser.try_get("buttonClicked", button)) {
			if (button == "remove_weather") {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`oAre you sure want to remove all Weather Machines?|left|\nadd_spacer|small|\nadd_button|confirm_remove_weather|Yes|0|0|\nadd_button||No|0|0|\nend_dialog|infinity_machine|||\nadd_quick_exit|");
			}
			if (button == "confirm_remove_weather") {
				std::string name_ = pInfo(peer)->world;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					world_->fresh_world = true;
					WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
					if (not Only_Access(peer, world_, block_)) return;
					for (int i_ = 0; i_ < world_->infinity.size();) {
						int receive = 1, id = world_->infinity.at(i_);
						if (Inventory::Modify(peer, id, receive) == 0) {
							receive = 1;
							world_->infinity.erase(world_->infinity.begin() + i_);
							string weather_list = "";
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`w" + items[10058].name + "``|left|10058|\nadd_spacer|small|\nembed_data|tilex|" + to_string(pInfo(peer)->lastwrenchx) + "\nembed_data|tiley|" + to_string(pInfo(peer)->lastwrenchy) + "|\nadd_smalltext|`oAdd weather machines from your inventory to be able to cycle through then automatically.|left|\nadd_smalltext|`oNever have the same weather every day again|left|\nadd_spacer|small|" + weather_list + "|\nadd_spacer|small|\nadd_text_input|cycle_time|`oCycle time (minutes):|" + to_string(block_->infinity_cycle) + "|5|\nadd_spacer|small|\nadd_item_picker|add_weather|`wAdd Weather Machine|Choose the Weather Machine you want to add!|\nadd_button|remove_weather|`wRemove Weather Machine|0|0|\nend_dialog|infinity_machine|Close|Save|");
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
								if (pInfo(cp_)->world == name_) {
									world_->weather = 0;
									VarList::OnSetCurrentWeather(cp_, (Event()->Comet_Dust ? 16 : 0));
								}
							}
							world_->cycle_ke = 0;
							world_->blocks[i_].flags ^= 0x00400000;
							int ySize = world_->blocks.size() / 100, xSize = world_->blocks.size() / ySize;
							int x = i_ % xSize, y = i_ / xSize;
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = x, data_.punchY = y, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
							BYTE* blc = raw + 56;
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
								if (pInfo(cp_)->world == world_->name) {
									form_visual(blc, *block_, *world_, peer, false);
									send_raw(cp_, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw, blc;
						}
						else {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "I don't have enough room in my backpack!", 0, 0);
							i_++;
						}
					}
				}
			}
		}
		else {
			string cycle_time = parser.get("cycle_time", 1);
			if (not is_number(std::string(get_embed(cch, "tilex"))) or not is_number(std::string(get_embed(cch, "tiley")))) return;
			int x = std::atoi(get_embed(cch, "tilex").c_str()), y = std::atoi(get_embed(cch, "tiley").c_str());
			std::string name_ = pInfo(peer)->world;
			std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				WorldBlock* block_ = &world_->blocks[x + (y * 100)];
				if (block_->infinity_cycle != std::atoi(cycle_time.c_str()) and is_number(cycle_time)) {
					block_->infinity_cycle = (atoi(cycle_time.c_str()));
					block_->epoch_cycle = time(nullptr) + (block_->infinity_cycle * 60);
				}
			}
		}
	}
	static void guild_machine(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		string spin = parser.get("spin", 1), invert = parser.get("invert", 1), gravity = parser.get("gravity", 1);
		if (!isValidCheckboxInput(spin) or !isValidCheckboxInput(invert) or not is_number(gravity)) return;
		if (not is_number(std::string(get_embed(cch, "tilex"))) or not is_number(std::string(get_embed(cch, "tiley")))) return;
		int spin_ = std::atoi(spin.c_str()), invert_ = std::atoi(invert.c_str()), x_ = std::atoi(get_embed(cch, "tilex").c_str()), y_ = std::atoi(get_embed(cch, "tiley").c_str());
		std::string name_ = pInfo(peer)->world;
		std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			WorldBlock* block_ = &world_->blocks.at(x_ + (y_ * 100));
			if (not Only_Access(peer, world_, block_)) return;
			if (world_->guild_id == 0) return;
			uint32_t new_id = 0; bool update_ = false;
			int gravity_ = std::atoi(gravity.c_str());
			uint32_t guild_id = world_->guild_id;
			vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
			if (p != guilds.end()) {
				Guild* guild_information = &guilds[p - guilds.begin()];
				for (GuildMember member_search : guild_information->guild_members) {
					if (to_lower(member_search.member_name) == to_lower(pInfo(peer)->tankIDName)) {
						new_id = (guild_information->guild_mascot[0] == 0 ? 5814 : guild_information->guild_mascot[0]);
					}
					if (block_->id != new_id) {
						block_->id = new_id;
						update_ = true;
					}
					if (gravity_ > 500)  gravity_ = 500;
					if (gravity_ < -500)  gravity_ = -500;
					if (block_->gravity != gravity_) {
						block_->gravity = gravity_;
						update_ = true;
					}
					if (spin == "1" or spin == "0") {
						if (block_->spin != spin_) block_->spin = spin_, update_ = true;
					}
					if (invert == "1" or invert == "0") {
						if (block_->invert != invert_) block_->invert = invert_, update_ = true;
					}
					tile_update(peer, world_, block_, x_, y_);
					PlayerMoving data_{};
					data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
					BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
					BYTE* blc = raw + 56;
					form_visual(blc, *block_, *world_, peer, false);
					if (block_->enabled and update_) {
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
							if (pInfo(cp_)->world == name_) {
								VarList::OnSetCurrentWeather(cp_, world_->weather);
								send_raw(cp_, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
							}
							delete[] raw, blc;
						}
					}
				}
			}
		}
	}
	static void battlecage_edit(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		int item = 0, x = std::atoi(explode("|", explode("tilex|", cch)[1])[0].c_str()), y = std::atoi(explode("|", explode("tiley|", cch)[1])[0].c_str());
		if (parser.try_get("critter", item)) {
			std::string name_ = pInfo(peer)->world;
			std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				if (items[item].petAbility == "") {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "A " + items[item].name + " would not make a very good Battle Pet.", 0, 0);
					return;
				}
				if (item < 0 or item > items.size()) return;
				World* world_ = &worlds[p - worlds.begin()];
				WorldBlock* block_ = &world_->blocks[x + (y * 100)];
				if (block_->fg != 3548) return;
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wBattle Pet Cage``|left|3548|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x) + "\nembed_data|tiley|" + to_string(y) + "\nadd_textbox|Are you absolutely sure you want to `4permanently destroy`` your `2" + items[item].name + "`` to make a Battle Pet? Once caged, a Battle Pet can never be removed because it becomes too dangerous. Destroying the Battle Pet Cage will also destroy the pet inside.|left|\nembed_data|critters|" + to_string(item) + "\nadd_button|docage|Yes, I am sure!|\nend_dialog|battlecage_edit|Nevermind||");
			}
		}
		else if (parser.try_get("replace1", item)) {
			std::string name_ = pInfo(peer)->world;
			std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				if (items[item].petAbility == "") return;
				if (item < 0 or item > items.size()) return;
				World* world_ = &worlds[p - worlds.begin()];
				WorldBlock* block_ = &world_->blocks[x + (y * 100)];
				if (block_->fg != 3548) return;
				int got = 0;
				Inventory::Modify(peer, 242, got);
				if (got < 10) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have 10 World Locks.", 0, 0);
					return;
				}
				if (items[item].petAbility == "") {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "A " + items[item].name + " would not make a very good Battle Pet.", 0, 0);
					return;
				}
				if (items[item].petElement != items[block_->battle_pet.first[0]].petElement) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "A pet needs same Elements to gene-splice.", 0, 0);
					return;
				}
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wBattle Pet Cage``|left|3548|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x) + "\nembed_data|tiley|" + to_string(y) + "\nadd_textbox|Are you absolutely sure you want to `4permanently destroy`` your `2" + items[item].name + "`` to gene-splice its ability into " + block_->battle_pet.second + "? This will cost you `410 World Locks`` and the item you are gene-splicing.|left|\nembed_data|critters|" + to_string(item) + "\nadd_button|docage|Yes, I am sure!|\nend_dialog|battlecage_edit|Nevermind||");
			}
		}
		else if (parser.try_get("buttonClicked", button)) {
			if (button == "docage0") {
				std::string name_ = pInfo(peer)->world;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					WorldBlock* block_ = &world_->blocks[x + (y * 100)];
					if (block_->fg != 3548) return;
					string suffix1 = items[pInfo(peer)->battle_pet.first[0]].petSuffix;
					suffix1[0] = toupper(suffix1[0]);
					string mixed = suffix1 + items[pInfo(peer)->battle_pet.first[1]].petPrefix + items[pInfo(peer)->battle_pet.first[2]].petSuffix;
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "I have caged " + mixed + ".", 0, 0);
					gamepacket_t p2;
					p2.Insert("OnParticleEffect");
					p2.Insert(44);
					p2.Insert((float)x * 32 + 7, (float)y * 32 + 7);
					p2.CreatePacket(peer);
					block_->battle_pet.first[0] = pInfo(peer)->battle_pet.first[0];
					block_->battle_pet.first[1] = pInfo(peer)->battle_pet.first[1];
					block_->battle_pet.first[2] = pInfo(peer)->battle_pet.first[2];
					pInfo(peer)->battle_pet.first[0] = 0;
					pInfo(peer)->battle_pet.first[1] = 0;
					pInfo(peer)->battle_pet.first[2] = 0;
					if (pInfo(peer)->hand == 3552) {
						PlayerMoving data2;
						data2.netID = pInfo(peer)->netID;
						data2.packetType = 33;
						data2.punchY = (pInfo(peer)->battle_pet.first[3] == 1 ? pInfo(peer)->battle_pet.first[0] : pInfo(peer)->battle_pet.second[0] == 0 ? pInfo(peer)->battle_pet.first[0] : pInfo(peer)->battle_pet.second[0]);
						(pInfo(peer)->battle_pet.first[3] == 1 ? pInfo(peer)->battle_pet.first[3] = 0 : pInfo(peer)->battle_pet.first[3] = 1);
						BYTE* raw2 = packPlayerMoving(&data2);
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
							if (pInfo(cp_)->world == pInfo(peer)->world) {
								{
									send_raw(cp_, 4, raw2, 56, ENET_PACKET_FLAG_RELIABLE);
								}
							}
						}
					}
					PlayerMoving data_{};
					data_.packetType = 5, data_.punchX = x, data_.punchY = y, data_.characterState = 0x8;
					BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
					BYTE* blc = raw + 56;
					form_visual(blc, *block_, *world_, peer, false);
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (pInfo(cp_)->world == pInfo(peer)->world) {
							send_raw(cp_, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[] raw, blc;
					if (block_->locked) {
						upd_lock(*block_, *world_, peer);
					}
				}
			}
			if (button == "docage1") {
				std::string name_ = pInfo(peer)->world;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					WorldBlock* block_ = &world_->blocks[x + (y * 100)];
					if (block_->fg != 3548) return;
					string suffix1 = items[pInfo(peer)->battle_pet.second[0]].petSuffix;
					suffix1[0] = toupper(suffix1[0]);
					string mixed = suffix1 + items[pInfo(peer)->battle_pet.second[1]].petPrefix + items[pInfo(peer)->battle_pet.second[2]].petSuffix;
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "I have caged " + mixed + ".", 0, 0);
					gamepacket_t p2;
					p2.Insert("OnParticleEffect");
					p2.Insert(44);
					p2.Insert((float)x * 32 + 7, (float)y * 32 + 7);
					p2.CreatePacket(peer);
					block_->battle_pet.first[0] = pInfo(peer)->battle_pet.second[0];
					block_->battle_pet.first[1] = pInfo(peer)->battle_pet.second[1];
					block_->battle_pet.first[2] = pInfo(peer)->battle_pet.second[2];
					pInfo(peer)->battle_pet.second[0] = 0;
					pInfo(peer)->battle_pet.second[1] = 0;
					pInfo(peer)->battle_pet.second[2] = 0;
					if (pInfo(peer)->hand == 3552) {
						PlayerMoving data2;
						data2.netID = pInfo(peer)->netID;
						data2.packetType = 33;
						data2.punchY = (pInfo(peer)->battle_pet.first[3] == 1 ? pInfo(peer)->battle_pet.first[0] : pInfo(peer)->battle_pet.second[0] == 0 ? pInfo(peer)->battle_pet.first[0] : pInfo(peer)->battle_pet.second[0]);
						(pInfo(peer)->battle_pet.first[3] == 1 ? pInfo(peer)->battle_pet.first[3] = 0 : pInfo(peer)->battle_pet.first[3] = 1);
						BYTE* raw2 = packPlayerMoving(&data2);
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
							if (pInfo(cp_)->world == pInfo(peer)->world) {
								{
									send_raw(cp_, 4, raw2, 56, ENET_PACKET_FLAG_RELIABLE);
								}
							}
						}
					}
					PlayerMoving data_{};
					data_.packetType = 5, data_.punchX = x, data_.punchY = y, data_.characterState = 0x8;
					BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
					BYTE* blc = raw + 56;
					form_visual(blc, *block_, *world_, peer, false);
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (pInfo(cp_)->world == pInfo(peer)->world) {
							send_raw(cp_, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[] raw, blc;
					if (block_->locked) {
						upd_lock(*block_, *world_, peer);
					}
				}
			}
			if (button == "docage") {
				std::string name_ = pInfo(peer)->world;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					int item = std::atoi(explode("|", explode("critters|", cch)[1])[0].c_str());
					if (item < 0 or item > items.size()) return;
					World* world_ = &worlds[p - worlds.begin()];
					WorldBlock* block_ = &world_->blocks[x + (y * 100)];
					if (block_->fg != 3548) return;
					if (block_->battle_pet.first[0] == 0) {
						if (items[item].petAbility == "") return;
						int got = 0;
						Inventory::Modify(peer, item, got);
						if (got == 0) return;
						Inventory::Modify(peer, item, got = -1);
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "I have caged " + items[item].name + ".", 0, 0);
						std::vector<std::string> list{ "You", "Duck", "Smile", "Squish", "Tor", "Rat", "Zero", "Lite", "Joy", "Smell", "Sickle", "Pie", "Bill", "Head", "Snake", "Wave", "Death", "Brave", "Watch", "Banana", "Fire", "Grow", "Dawn", "Fairy", "Burp", "Mouse", "Bucks", "Bad", "Einst", "Len", "Grip", "Tickle", "Pickle", "Cry", "Fun", "Luck", "Gar", "Cake", "Shiny", "Board", "Wiggle", "Bob", "Tiny", "Dar", "Good", "Krazy", "Punch", "Azure", "Solid", "Laugh", "Flash" };
						gamepacket_t p2;
						p2.Insert("OnParticleEffect");
						p2.Insert(44);
						p2.Insert((float)x * 32 + 7, (float)y * 32 + 7);
						p2.CreatePacket(peer);
						block_->battle_pet.first[0] = item;
						if (block_->battle_pet.second == "") block_->battle_pet.second = list[rand() % list.size()] + list[rand() % list.size()];
						PlayerMoving data_{};
						data_.packetType = 5, data_.punchX = x, data_.punchY = y, data_.characterState = 0x8;
						BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
						BYTE* blc = raw + 56;
						form_visual(blc, *block_, *world_, peer, false);
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
							if (pInfo(cp_)->world == pInfo(peer)->world) {
								send_raw(cp_, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, blc;
						if (block_->locked) {
							upd_lock(*block_, *world_, peer);
						}
					}
					else if (block_->battle_pet.first[0] != 0 && block_->battle_pet.first[1] == 0) {
						if (items[item].petAbility == "") return;
						int got = 0;
						Inventory::Modify(peer, item, got);
						if (got == 0) return;
						int got2 = 0;
						Inventory::Modify(peer, 242, got2);
						if (got2 < 10) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have 10 World Locks.", 0, 0);
							return;
						}
						if (item == block_->battle_pet.first[0]) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your Battle Pet already has this ability!", 0, 0);
							return;
						}
						Inventory::Modify(peer, 242, got2 = -10);
						Inventory::Modify(peer, item, got = -1);
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You spent 10 World Locks and 1 " + items[item].name + " to gene-splice the ability \'" + items[item].petAbility + "\' into your Battle Pet " + block_->battle_pet.second + ".", 0, 0);
						gamepacket_t p2;
						p2.Insert("OnParticleEffect");
						p2.Insert(44);
						p2.Insert((float)x * 32 + 7, (float)y * 32 + 7);
						p2.CreatePacket(peer);
						block_->battle_pet.first[1] = item;
						PlayerMoving data_{};
						data_.packetType = 5, data_.punchX = x, data_.punchY = y, data_.characterState = 0x8;
						BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
						BYTE* blc = raw + 56;
						form_visual(blc, *block_, *world_, peer, false);
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
							if (pInfo(cp_)->world == pInfo(peer)->world) {
								send_raw(cp_, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, blc;
						if (block_->locked) {
							upd_lock(*block_, *world_, peer);
						}
					}
					else if (block_->battle_pet.first[0] != 0 && block_->battle_pet.first[1] != 0 && block_->battle_pet.first[2] == 0) {
						if (items[item].petAbility == "") return;
						int got = 0;
						Inventory::Modify(peer, item, got);
						if (got == 0) return;
						int got2 = 0;
						Inventory::Modify(peer, 242, got2);
						if (got2 < 10) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have 10 World Locks.", 0, 0);
							return;
						}
						if (item == block_->battle_pet.first[0] or item == block_->battle_pet.first[1]) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your Battle Pet already has this ability!", 0, 0);
							return;
						}
						Inventory::Modify(peer, 242, got2 = -10);
						Inventory::Modify(peer, item, got = -1);
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You spent 10 World Locks and 1 " + items[item].name + " to gene-splice the ability \'" + items[item].petAbility + "\' into your Battle Pet " + block_->battle_pet.second + ".", 0, 0);
						gamepacket_t p2;
						p2.Insert("OnParticleEffect");
						p2.Insert(44);
						p2.Insert((float)x * 32 + 7, (float)y * 32 + 7);
						p2.CreatePacket(peer);
						block_->battle_pet.first[2] = item;
						PlayerMoving data_{};
						data_.packetType = 5, data_.punchX = x, data_.punchY = y, data_.characterState = 0x8;
						BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
						BYTE* blc = raw + 56;
						form_visual(blc, *block_, *world_, peer, false);
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
							if (pInfo(cp_)->world == pInfo(peer)->world) {
								send_raw(cp_, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, blc;
						if (block_->locked) {
							upd_lock(*block_, *world_, peer);
						}
					}
				}
			}
			if (button == "pickitup") {
				std::string name_ = pInfo(peer)->world;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					WorldBlock* block_ = &world_->blocks[x + (y * 100)];
					if (block_->fg != 3548) return;
					if (block_->battle_pet.first[0] == 0) return;
					if (block_->battle_pet.first[2] == 0) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "A pet needs 3 powers to be put in a Battle Leash.", 0, 0);
						return;
					}
					if (pInfo(peer)->battle_pet.first[0] == 0) {
						pInfo(peer)->battle_pet.first[0] = block_->battle_pet.first[0];
						pInfo(peer)->battle_pet.first[1] = block_->battle_pet.first[1];
						pInfo(peer)->battle_pet.first[2] = block_->battle_pet.first[2];
					}
					else if (pInfo(peer)->battle_pet.second[0] == 0) {
						pInfo(peer)->battle_pet.second[0] = block_->battle_pet.first[0];
						pInfo(peer)->battle_pet.second[1] = block_->battle_pet.first[1];
						pInfo(peer)->battle_pet.second[2] = block_->battle_pet.first[2];
					}
					else if (pInfo(peer)->battle_pet.first[0] != 0 && pInfo(peer)->battle_pet.second[0] != 0) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Your Battle Leash is full, take somebody out of it!", 0, 0);
						return;
					}
					gamepacket_t p2;
					p2.Insert("OnParticleEffect");
					p2.Insert(44);
					p2.Insert((float)x * 32 + 7, (float)y * 32 + 7);
					p2.CreatePacket(peer);
					block_->battle_pet.first[0] = 0;
					block_->battle_pet.first[1] = 0;
					block_->battle_pet.first[2] = 0;
					PlayerMoving data_{};
					data_.packetType = 5, data_.punchX = x, data_.punchY = y, data_.characterState = 0x8;
					BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
					BYTE* blc = raw + 56;
					form_visual(blc, *block_, *world_, peer, false);
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (pInfo(cp_)->world == pInfo(peer)->world) {
							send_raw(cp_, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[] raw, blc;
					if (block_->locked) {
						upd_lock(*block_, *world_, peer);
					}
					Clothing_V2::Update(peer);
				}
			}
		}
		else {
			string setname = parser.get("setname", 1);
			std::string name_ = pInfo(peer)->world;
			std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				WorldBlock* block_ = &world_->blocks[x + (y * 100)];
				if (block_->fg != 3548) return;
				if (block_->battle_pet.second != setname and not special_char(setname)) {
					block_->battle_pet.second = setname;
					PlayerMoving data_{};
					data_.packetType = 5, data_.punchX = x, data_.punchY = y, data_.characterState = 0x8;
					BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
					BYTE* blc = raw + 56;
					form_visual(blc, *block_, *world_, peer, false);
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (pInfo(cp_)->world == pInfo(peer)->world) {
							send_raw(cp_, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[] raw, blc;
					if (block_->locked) {
						upd_lock(*block_, *world_, peer);
					}
				}
			}
		}
	}
	static void popup(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			uint64_t Btn_Hash = quick_hash(button.c_str());
			switch (Btn_Hash) {
			case "backto_wrench"_qh: case "info"_qh: {
				send_wrench_self(peer, "");
				return;
			}
			case "road_to_glory"_qh: {
				send_wrench_self(peer, "road_to_glory");
				return;
			}
			case "kit_pass"_qh: {
				send_wrench_self(peer, "kit_pass");
				return;
			}
			case "level_rwds"_qh: {
				send_wrench_self(peer, "level_rwds");
				return;
			}
			case "skill_and_assets"_qh: {
				send_wrench_self(peer, "skill_and_assets");
				return;
			}
			case "creatortools"_qh: {
				if (not Role::Clist(pInfo(peer)->tankIDName)) return;
				int TotalPlayer = TotalJson("database/players/"), TotalWorld = TotalJson("database/worlds/"), TotalGuild = TotalJson("database/guilds/"), add_amount = 0, total_online = 0, total_pc = 0, total_ios = 0, total_android = 0;
				for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
					if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
					add_amount = 1;
					total_online += add_amount;
					if (pInfo(cp_)->player_device == "0,1,1") total_pc += add_amount;
					if (pInfo(cp_)->player_device == "1") total_ios += add_amount;
					else total_android += add_amount;
				}
				string clist = "";
				for (int w_ = 0; w_ < C_List.clist.size(); w_++) clist += "\nadd_smalltext|`o#" + to_string(w_ + 1) + ". " + C_List.clist[w_] + "|left|\n";
				if (clist.empty()) clist = "None!";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wCreator Tools|left|5956|\nadd_spacer|small|\nadd_label|small|- Information Server -|left|\nadd_smalltext|Uptime: " + Time::Playmod(time(nullptr) - Environment()->UpTime) + " - `$" + Set_Count(ServerPool::PlayerCountServer()) + "`` players on.  Stats for this node: `$" + Set_Count(ServerPool::PlayerCountServer()) + "`` players. (" + to_string(total_pc) + " PC, " + to_string(total_android) + " Android, " + to_string(total_ios) + " iOS) and `$" + to_string(worlds.size()) + "`` Worlds active.|left|\nadd_smalltext|- Total Players : " + Set_Count(TotalPlayer) + "<CR>- Total Worlds : " + Set_Count(TotalWorld) + "<CR>- Total Guilds : " + Set_Count(TotalGuild) + "|left|\nadd_spacer|small|\nadd_label|small|- Creator List -|left|" + clist + "|\nadd_spacer|small|\nadd_label|small|- Event Server -|left|\nadd_smalltext|Gems Event: [" + to_string(Event()->X_Gems) + "x] Active: [" + (Event()->Gems_Event ? "`2YES" : "`4NO") + "``] " + (Event()->Gems_Event != 0 ? "Time: [" + Time::Gacha(Event()->x_gems_time - time(nullptr)) + "]" : "") + "|left|\nadd_smalltext|Xp Event: [" + to_string(Event()->X_Xp) + "x] Active: [" + (Event()->Xp_Event ? "`2YES" : "`4NO") + "``] " + (Event()->Xp_Event ? "Time: [" + Time::Gacha(Event()->x_xp_time - time(nullptr)) + "]" : "") + "|left|\nadd_smalltext|Exchange Event: [" + to_string(Event()->X_Exchange) + "x] Active: [" + (Event()->Exchange_Event ? "`2YES" : "`4NO") + "``] " + (Event()->Exchange_Event != 0 ? "Time: [" + Time::Gacha(Event()->x_exchange_time - time(nullptr)) + "]" : "") + "|left|\nadd_spacer|small|"
					"\nadd_textbox|`o- Server Panel -|left|\nadd_spacer|small|"
					"\nadd_inner_image_label_button|RESETPASS90| `oSetting Pass|game/tiles_page14.rttex|1.6|28|23|32|""\nadd_inner_image_label_button|RESETPASS90| `oSetting Pass|game/tiles_page14.rttex|1.6|30|23|32|"
					+ (Environment()->Anti_Proxy ? "\nadd_inner_image_label_button|Anti_Proxy| `oAnti Proxy|game/tiles_page14.rttex|1.6|28|23|32|" : "\nadd_inner_image_label_button|Anti_Proxy| `oAnti Proxy|game/tiles_page14.rttex|1.6|30|23|32|") +
					+(Environment()->Anti_GL ? "\nadd_inner_image_label_button|Anti_GL| `oAnti Growlauncher/Powerkuy|game/tiles_page14.rttex|1.6|28|23|32|" : "\nadd_inner_image_label_button|Anti_GL| `oAnti Growlauncher/Powerkuy|game/tiles_page14.rttex|1.6|30|23|32|") +
					+(Environment()->Enable_Joystick ? "\nadd_inner_image_label_button|Enable_Joystick| `oEnable Joysticky|game/tiles_page14.rttex|1.6|28|23|32|" : "\nadd_inner_image_label_button|Enable_Joystick| `oEnable Joystick|game/tiles_page14.rttex|1.6|30|23|32|") +
					"\nadd_spacer|small|"
					"\nadd_custom_button|add_rcode|image:interface/large/tianvan/gui_button.rttex;image_size:400,260;frame:6,1;width:0.19;|"
					"\nadd_custom_button|set_event|image:interface/large/tianvan/gui_button.rttex;image_size:400,260;frame:7,1;width:0.19;|"
					"\nadd_custom_button|set_newget|image:interface/large/tianvan/gui_button.rttex;image_size:400,260;frame:5,1;width:0.19;|"
					"\nadd_custom_break|\nadd_spacer|small|\nadd_quick_exit|\nadd_button|back|`wBack|0|0|\nend_dialog|creator_tools|||");
				return;
			}
			case "Logout_MyAcc"_qh: {
				pInfo(peer)->tankIDName = "", pInfo(peer)->tankIDPass = "";
				VarList::SetHasGrowID(peer, 1, "", "");
				Peer_Disconnect(peer, 0);
				return;
			}
			case "game_menu"_qh: {
				GameMenu::Dialog(peer);
				return;
			}
			case "royal_winter_wonder"_qh: {
				if (not WinterFest.Active) return;
				DialogHandle::Royal_Winter(peer);
				return;
			}
			case "get_card_battle"_qh: {
				if (pInfo(peer)->gems > 1499) VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`oCard Battle License|left|112|\nadd_spacer|small|\nadd_label_with_icon|small|`oYou currently have: " + Set_Count(pInfo(peer)->gems) + " Gems|left|112|\nadd_button|Get_License_Confirm|`oGet License for 1.500 Gems|0|0|\nadd_spacer|small|\nadd_button|backto_wrench|`wBack|0|0|\nend_dialog|popup|||\nand_quick_exit|");
				else VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`oCard Battle License|left|112|\nadd_spacer|small|\nadd_textbox|`oOops! Looks like you can't afford a new Card Battle License of the moment! Try again later.|left|\nadd_textbox|`oA new license Will cost you 1,500 Gems.|left|\nadd_label_with_icom|small|`oYou currently have: " + Set_Count(pInfo(peer)->gems) + " Gems|left|112|\nadd_spacer|small|\nadd_button|backto_wrench|`wBack|0|0|\nend_dialog|popup|||\nadd_quick_exit|");
				return;
			}
			case "Get_License_Confirm"_qh: {
				if (pInfo(peer)->gems > 1499) {
					pInfo(peer)->unlock_card_license = true;
					VarList::OnMinGems(peer, 1500);
				}
				else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Don't have enough gems!", 0, 1);
				return;
			}
			case "fav_items"_qh: {
				string item_list = "";
				if (pInfo(peer)->Fav_Items.size() == 0) {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`wFavorite Items|left|13814|\nadd_spacer|small|\nadd_textbox|`oYou have not favorited any item yet.|left|\nadd_spacer|small|\nadd_button|backto_wrench|`wBack|0|0|\nend_dialog|popup|||");
					return;
				}
				for (int i = 0; i < pInfo(peer)->Fav_Items.size(); i++) item_list += "\nadd_label_with_icon|small|`w" + items[pInfo(peer)->Fav_Items[i]].name + "|left|" + to_string(pInfo(peer)->Fav_Items[i]) + "|";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`wFavorite Items|left|13814|\nadd_spacer|small|\nadd_textbox|`oAll favorited items are currently in your inventory. They can be unfavorited by tapping on the UNFAV button while having the item selected in your inventory.|left|\nadd_spacer|small|" + item_list + "|\nadd_spacer|small|\nadd_button|backto_wrench|`wBack|0|0|\nend_dialog|popup|||");
				return;
			}
			case "online_status"_qh: {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n\nadd_label_with_icon|big|`wOnline Status``|left|1366|\nadd_spacer|small|\nmax_checks|1|\nadd_checkbox|checkbox_status_online|`wOnline``|" + a + (pInfo(peer)->p_status == 0 ? "1" : "0") + "\nadd_checkbox|checkbox_status_busy|`wBusy``|" + (pInfo(peer)->p_status == 1 ? "1" : "0") + "\nadd_checkbox|checkbox_status_away|`wAway``|" + (pInfo(peer)->p_status == 2 ? "1" : "0") + "\nadd_button|online_status|Ok|noflags|0|0|\nend_dialog|online_status|||\nadd_quick_exit|\n");
				return;
			}
			case "playing_music"_qh: {
				DialogHandle::Spotify_Menu(peer);
				return;
			}
			case "Bank_Central"_qh: {
				DialogHandle::BankCentral(peer);
				return;
			}
			case "my_worlds"_qh: {
				string worlds_owned_ = "";
				for (int w_ = 0; w_ < pInfo(peer)->worlds_owned.size(); w_++) worlds_owned_ += "\nadd_button|" + pInfo(peer)->worlds_owned[w_] + "|" + pInfo(peer)->worlds_owned[w_] + "|noflags|0|0|";
				if (worlds_owned_.empty()) worlds_owned_ = "\nadd_textbox|You do not have any World-Locked worlds.``|left|";
				string dialog = SetColor(peer) + "set_default_color|`o\nstart_custom_tabs|\nadd_custom_button|My_World|image:interface/large/btn_tabs2.rttex;image_size:228,92;frame:1,0;width:0.15;|\nadd_custom_button|Home_World|image:interface/large/btn_tabs2.rttex;image_size:228,92;frame:0,1;width:0.15;|\nadd_custom_button|Fav_World|image:interface/large/btn_tabs2.rttex;image_size:228,92;frame:0,2;width:0.15;|\nend_custom_tabs|";
				VarList::OnDialogRequest(peer, dialog + "\nadd_label|big|Locked Worlds|lefr|\nadd_spacer|small|\nadd_textbox|You must be a Supporter or Super Supporter to warp to these worlds.|left|\nadd_textbox|Place a World Lock in a World to lock. Break your World Lock to unlock a world.|\nadd_spacer|small|" + worlds_owned_ + "|\nadd_quick_exit|\nadd_spacer|small|\nend_dialog|worlds_list||Back|", 500);
				return;
			}
			case "trade_scan"_qh: {
				DialogHandle::Trade_Scan(peer);
				return;
			}
			case "wrench_edit"_qh: {
				DialogHandle::Wrench_Customs(peer);
				return;
			}
			case "guild_notebook_edit"_qh: {
				VarList::OnDialogRequest(peer, SetColor(peer) + get_guild_notebook_edit(peer));
				return;
			}
			case "bonus"_qh: {
				DialogHandle::GrowPass(peer, "Tasks");
				return;
			}
			case "account_security"_qh: {
				DialogHandle::Acc_Security(peer);
				return;
			}
			case "cheats_menu"_qh: {
				DialogHandle::Cheats(peer);
				return;
			}
			case "marvelous_missions"_qh: {
				DialogHandle::Marvelous_Mission(peer, "1");
				return;
			}
			case "growmoji"_qh: {
				string emoji = "", first_emoji = "\nadd_spacer|small|", chest_title = "", chest_have = "", chest_dont_have = "";
				if (pInfo(peer)->level >= 5) first_emoji += "\nadd_smalltext_forced| (sigh) |left|\nadd_smalltext_forced| (mad) |left|\nadd_smalltext_forced| (smile) |left|\nadd_smalltext_forced| (tongue) |left|\nadd_smalltext_forced| (wow) |left|";
				if (pInfo(peer)->supp >= 1) first_emoji += "\nadd_smalltext_forced| (no) |left|\nadd_smalltext_forced| (shy) |left|\nadd_smalltext_forced| (wink) |left|\nadd_smalltext_forced| (music) |left|\nadd_smalltext_forced| (lol) |left|";
				if (pInfo(peer)->supp == 2) first_emoji += "\nadd_smalltext_forced| (yes) |left|\nadd_smalltext_forced| (love) |left|\nadd_smalltext_forced| (megaphone) |left|\nadd_smalltext_forced| (heart) |left|\nadd_smalltext_forced| (cool) |left|";
				if (pInfo(peer)->friends.size() >= 10)  first_emoji += "\nadd_smalltext_forced| (kiss) |left|";
				if (pInfo(peer)->friends.size() >= 20)  first_emoji += "\nadd_smalltext_forced| (agree) |left|";
				if (pInfo(peer)->friends.size() >= 30)  first_emoji += "\nadd_smalltext_forced| (see-no-evil) |left|";
				if (pInfo(peer)->friends.size() >= 40)  first_emoji += "\nadd_smalltext_forced| (dance) |left|";
				if (pInfo(peer)->friends.size() >= 50)  first_emoji += "\nadd_smalltext_forced| (build) |left|";
				string cch = pInfo(peer)->growmoji;
				std::vector<std::string> a_ = explode("(", replace_str(cch, ")", "|"));
				for (int i_ = 0; i_ < a_.size(); i_++) {
					string str = a_[i_];
					size_t i = 0;
					for (; i < str.length(); i++) { if (isdigit(str[i])) break; }
					str = str.substr(i, str.length() - i);
					int id = std::atoi(str.c_str());
					if (not a_[i_].empty()) {
						string emojied = fixchar3(a_[i_]);
						if (emojied == "oops" || emojied == "sleep" || emojied == "punch" || emojied == "bheart" || emojied == "cry" || emojied == "bunny" || emojied == "cactus" || emojied == "pine" || emojied == "peace" || emojied == "terror" || emojied == "troll" || emojied == "fireworks" || emojied == "party" || emojied == "song" || emojied == "ghost" || emojied == "nuke" || emojied == "halo" || emojied == "lucky" || emojied == "weary" || emojied == "moyai" || emojied == "plead" || emojied == "wl" || emojied == "grow" || emojied == "gems" || emojied == "gtoken" || emojied == "vend" || emojied == "football") {
							if (id) first_emoji += "\nadd_smalltext_forced| (" + emojied + ") |left|";
							else emoji += "\nadd_smalltext|`9This Growmoji can be found in a secret event.``|left|\nadd_smalltext_forced_alpha| (" + emojied + ") |0.5|left|\nadd_spacer|small|";
						}
						if (emojied == "trophy") {
							if (id) first_emoji += "\nadd_smalltext_forced| (" + emojied + ") |left|";
							else emoji += "\nadd_smalltext|`9This Growmoji can be obtained from a guild thats level 6.``|left|\nadd_smalltext_forced_alpha| (" + emojied + ") |0.5|left|\nadd_spacer|small|";
						}
						else {
							if (id) {
								chest_have += "\nadd_smalltext_forced| (" + emojied + ") |left|";
							}
							else {
								chest_title = "\nadd_spacer|small|\nadd_smalltext|`9These Growmojis can be found in the Growmoji Chest sold by Locke the Traveling Salesman.``|left|";
								chest_dont_have += "\nadd_smalltext_forced_alpha| (" + emojied + ") |0.5|left|";
							}
						}
					}
				}
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|Growmojis|left|1366|" + a + first_emoji + chest_have + (pInfo(peer)->level >= 5 ? "" : "\nadd_spacer|small|\nadd_smalltext|`9You need to be Level 5 to get these Growmojis.``|left|\nadd_smalltext_forced_alpha| (sigh) |0.5|left|\nadd_smalltext_forced_alpha| (mad) |0.5|left|\nadd_smalltext_forced_alpha| (smile) |0.5|left|\nadd_smalltext_forced_alpha| (tongue) |0.5|left|\nadd_smalltext_forced_alpha| (wow) |0.5|left|") + "" + (pInfo(peer)->supp >= 1 ? "" : "\nadd_spacer|small|\nadd_smalltext|`9You need to be a Supporter to get these Growmojis.``|left|\nadd_smalltext_forced_alpha| (no) |0.5|left|\nadd_smalltext_forced_alpha| (shy) |0.5|left|\nadd_smalltext_forced_alpha| (wink) |0.5|left|\nadd_smalltext_forced_alpha| (music) |0.5|left|\nadd_smalltext_forced_alpha| (lol) |0.5|left|") + "" + (pInfo(peer)->supp == 2 ? "" : "\nadd_spacer|small|\nadd_smalltext|`9You need to be a Super Supporter to get these Growmojis.``|left|\nadd_smalltext_forced_alpha| (yes) |0.5|left|\nadd_smalltext_forced_alpha| (love) |0.5|left|\nadd_smalltext_forced_alpha| (megaphone) |0.5|left|\nadd_smalltext_forced_alpha| (heart) |0.5|left|\nadd_smalltext_forced_alpha| (cool) |0.5|left|") + "" + (pInfo(peer)->friends.size() >= 10 ? "" : "\nadd_spacer|small|\nadd_smalltext|`9You need 10 friends to get this Growmoji.``|left|\nadd_smalltext_forced_alpha| (kiss) |0.5|left|") + "" + (pInfo(peer)->friends.size() >= 20 ? "" : "\nadd_spacer|small|\nadd_smalltext|`9You need 20 friends to get this Growmoji.``|left|\nadd_smalltext_forced_alpha| (agree) |0.5|left|") + "" + (pInfo(peer)->friends.size() >= 30 ? "" : "\nadd_spacer|small|\nadd_smalltext|`9You need 30 friends to get this Growmoji.``|left|\nadd_smalltext_forced_alpha| (see-no-evil) |0.5|left|") + "" + (pInfo(peer)->friends.size() >= 40 ? "" : "\nadd_spacer|small|\nadd_smalltext|`9You need 40 friends to get this Growmoji.``|left|\nadd_smalltext_forced_alpha| (dance) |0.5|left|") + "" + (pInfo(peer)->friends.size() >= 50 ? "" : "\nadd_spacer|small|\nadd_smalltext|`9You need 50 friends to get this Growmoji.``|left|\nadd_smalltext_forced_alpha| (build) |0.5|left|") + emoji + chest_title + chest_dont_have + "\nadd_spacer|small|\nend_dialog|worlds_list||Back|\nadd_quick_exit|\n", 500);
				return;
			}
			case "title_edit"_qh: {
				string titles = "";
				if (pInfo(peer)->Title.Doctor) titles += "\nadd_checkbox|1|'Dr.'|" + to_string(pInfo(peer)->drt) + "|";
				if (pInfo(peer)->level >= 125) titles += "\nadd_checkbox|2|'Level 125'|" + to_string(pInfo(peer)->lvl125) + "|";
				if (pInfo(peer)->level >= 250) titles += "\nadd_checkbox|3|'Black Name'|" + to_string(pInfo(peer)->black_color) + "|";
				if (pInfo(peer)->Title.Grow4Good) titles += "\nadd_checkbox|4|'Grow4Good Title'|" + to_string(pInfo(peer)->donor) + "|";
				if (pInfo(peer)->Title.Mentor) titles += "\nadd_checkbox|5|'Mentor Title'|" + to_string(pInfo(peer)->master) + "|";
				if (pInfo(peer)->Title.OfLegend) titles += "\nadd_checkbox|6|'of Legend'|" + to_string(pInfo(peer)->is_legend) + "|";
				if (pInfo(peer)->Title.TiktokBadge) titles += "\nadd_checkbox|7|'TikTok Creator Badge'|" + to_string(pInfo(peer)->ttBadge) + "|";
				if (pInfo(peer)->Title.ContentCBadge) titles += "\nadd_checkbox|8|'Content Creator Badge'|" + to_string(pInfo(peer)->ccBadge) + "|";
				if (pInfo(peer)->Title.ThanksGiving) titles += "\nadd_checkbox|9|'Thanksgiving'|" + to_string(pInfo(peer)->tgiv) + "|";
				if (pInfo(peer)->Title.OldTimer) titles += "\nadd_checkbox|10|'Old Timer'|" + to_string(pInfo(peer)->anni_old) + "|";
				if (pInfo(peer)->Title.WinterSanta) titles += "\nadd_checkbox|11|'Winter Santa Claus'|" + to_string(pInfo(peer)->santa) + "|";
				if (pInfo(peer)->Title.PartyAnimal) titles += "\nadd_checkbox|12|'Party Animal'|" + to_string(pInfo(peer)->party_animal) + "|";
				if (pInfo(peer)->Title.GrowPass_Gold) titles += "\nadd_checkbox|13|'Gold Grow Royal'|" + to_string(pInfo(peer)->gp_gold) + "|";
				if (pInfo(peer)->Title.GrowPass_Silver) titles += "\nadd_checkbox|14|'Silver Grow Royal'|" + to_string(pInfo(peer)->gp_silver) + "|";
				if (pInfo(peer)->Title.GrowPass_Bronze) titles += "\nadd_checkbox|15|'Bronze Grow Royal'|" + to_string(pInfo(peer)->gp_bronze) + "|";
				if (pInfo(peer)->Title.Award_Winning) titles += "\nadd_checkbox|16|'Award Winning'|" + to_string(pInfo(peer)->aw_winning) + "|";
				VarList::OnDialogRequest(peer, SetColor(peer) + a + "set_default_color|`o\nadd_label|big|" + (titles.empty() ? "No Titles Obtained" : "Select Title:") + "|right|" + titles + "\nadd_spacer|small|\nadd_button||OK|noflags|0|0|\nend_dialog|title_edit||\n");
				return;
			}
			case "neck"_qh: case "feet"_qh: case "hand"_qh: {
				int item = (button == "neck" ? pInfo(peer)->necklace : button == "feet" ? pInfo(peer)->feet : pInfo(peer)->hand);
				if (item <= 0 || item >= items.size()) return;
				if (Inventory::Contains(peer, item) == 0 && item != 256) return;
				pInfo(peer)->flagmay = (pInfo(peer)->flagmay == 1 ? 0 : 1);
				gamepacket_t p(0, pInfo(peer)->netID);
				p.Insert("OnFlagMay2019"), p.Insert(VisualHandle::Flagmay(pInfo(peer)));
				for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
					if (cp_->state != ENET_PEER_STATE_CONNECTED || pInfo(peer)->world != pInfo(cp_)->world) continue;
					p.CreatePacket(cp_);
				}
				return;
			}
			case "Rift_Cape"_qh: {
				DialogHandle::Rift_Cape(peer);
				return;
			}
			case "Rift_Wings"_qh: {
				DialogHandle::Rift_Wings(peer);
				return;
			}
			case "notebook_edit"_qh: {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label|big|Notebook|left|0|\nadd_text_box_input|personal_note||" + pInfo(peer)->note + "|128|5|\nadd_spacer|small|\nadd_button|save|Save|noflags|0|0|\nadd_button|clear|Clear|noflags|0|0|\nadd_button|cancel|Cancel|noflags|0|0|\nend_dialog|notebook_edit||\nadd_quick_exit|\n");
				return;
			}
			case "piano_wings_edit"_qh: {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wMusical Wings``|left|10182|\nadd_spacer|small|\nadd_button|manual|Instructions|noflags|0|0|\nadd_spacer|small|\nadd_text_input|volume|Volume|" + to_string(pInfo(peer)->musical_volume) + "|3|\nadd_text_input|text|Notes|" + pInfo(peer)->musical_note + "|50|\nadd_spacer|small|\nadd_button|resoterdefault|Restore to Default|noflags|0|0|\nend_dialog|pianowings|Cancel|Update|");
				return;
			}
			case "billboard_edit"_qh: {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wTrade Billboard``|left|8282|\nadd_spacer|small|" + (pInfo(peer)->b_i != 0 ? "\nadd_label_with_icon|small|`w" + items[pInfo(peer)->b_i].name + "``|left|" + to_string(pInfo(peer)->b_i) + "|" : "") + "\nadd_item_picker|billboard_item|`wSelect Billboard Item``|Choose an item to put on your billboard!|\nadd_spacer|small|\nadd_checkbox|billboard_toggle|`$Show Billboard``|" + (pInfo(peer)->b_bill.substr(0, 1)) + "\nadd_checkbox|billboard_buying_toggle|`$Is Buying``|" + (pInfo(peer)->b_bill.substr(2, 3)) + "\nadd_text_input|setprice|Price of item:|" + to_string(pInfo(peer)->b_p) + "|5|\nadd_checkbox|chk_peritem|World Locks per Item|" + (pInfo(peer)->b_w == 0 ? "0" : "1") + "\nadd_checkbox|chk_perlock|Items per World Lock|" + (pInfo(peer)->b_w == 0 ? "1" : "0") + "\nadd_spacer|small|\nend_dialog|billboard_edit|Close|Update|\n");
				return;
			}
			case "scarf_of_seasons_edit"_qh: {
				VarList::OnDialogRequest(peer, SetColor(peer) + a + "set_default_color|`o\nadd_label_with_icon|big|`wEquinox Scarf``|left|11818|\nadd_spacer|small|\nadd_textbox|Scarf Design|left|\nadd_spacer|small|\nadd_checkbox|checkbox_color_0|      Spring |" + (pInfo(peer)->i_11818_1 == 0 ? "1" : "0") + "\nadd_checkbox|checkbox_color_1|      Summer |" + (pInfo(peer)->i_11818_1 == 1 ? "1" : "0") + "\nadd_checkbox|checkbox_color_2|      Autumn |" + (pInfo(peer)->i_11818_1 == 2 ? "2" : "0") + "\nadd_checkbox|checkbox_color_3|      Winter |" + (pInfo(peer)->i_11818_1 == 3 ? "1" : "0") + "\nadd_textbox|Scarf Attack|left|\nadd_spacer|small|\nadd_checkbox|checkbox_punch_0|      Spring |" + (pInfo(peer)->i_11818_2 == 0 ? "1" : "0") + "\nadd_checkbox|checkbox_punch_1|      Summer |" + (pInfo(peer)->i_11818_2 == 1 ? "1" : "0") + "\nadd_checkbox|checkbox_punch_2|      Autumn |" + (pInfo(peer)->i_11818_2 == 2 ? "1" : "0") + "\nadd_checkbox|checkbox_punch_3|      Winter |" + (pInfo(peer)->i_11818_2 == 3 ? "1" : "0") + "\nadd_spacer|small|\nadd_button|restore_default|Restore to Default|noflags|0|0|\nend_dialog|dialog_scarf_of_seasons|Cancel|Update|\nadd_quick_exit|");
				return;
			}
			case "eq_aura"_qh: {
				VarList::OnDialogRequest(peer, SetColor(peer) + a + "set_default_color|`o\nadd_label_with_icon|big|`wEQ Aura``|left|12634|\nadd_spacer|small|\nadd_textbox|Play music wherever you are with the EQ Aura! Choose a musical block from your inventory to play the song.|left|\nadd_spacer|small|\nadd_label_with_icon|small|" + (pInfo(peer)->eq_aura == 0 ? "None" : items[pInfo(peer)->eq_aura].ori_name) + "|left|" + to_string((pInfo(peer)->eq_aura == 0 ? 2946 : pInfo(peer)->eq_aura)) + "|\nadd_spacer|small|\nadd_item_picker|change_item|`wChange Block Item``|Choose an item to put on your EQ Aura!|" + (pInfo(peer)->eq_aura == 0 ? "" : "\nadd_button|remove_item|`wRemove Block Item``|noflags|0|0|") + "\nend_dialog|dialog_eqaura|Cancel|Update|\nadd_quick_exit|");
				return;
			}
			case "minokawa_wings"_qh: {
				VarList::OnDialogRequest(peer, SetColor(peer) + a + "set_default_color|`o\nadd_label_with_icon|big|`wMinokawa Wings``|left|12640|\nadd_spacer|small|\nadd_textbox|Choose which items you would like to appear. You can choose one item or two!|left|\nadd_spacer|small|\nadd_checkbox|c1|Minokawa Wings|" + (pInfo(peer)->minokawa_wings == 0 || pInfo(peer)->minokawa_wings == 2 ? "1" : "0") + "\nadd_checkbox|c2|Minokawa Pet|" + (pInfo(peer)->minokawa_wings == 1 || pInfo(peer)->minokawa_wings == 2 ? "1" : "0") + "\nend_dialog|dialog_minokawa|Cancel|Update|\nadd_quick_exit|");
				return;
			}
			case "panda_spirit"_qh: {
				if (pInfo(peer)->hair == 12872 || pInfo(peer)->hair == 12874) {
					pInfo(peer)->panda_spirit = (pInfo(peer)->panda_spirit == 1 ? 0 : 1);
					Clothing_V2::Update_Value(peer);
					Clothing_V2::Update(peer);
				}
				return;
			}
			case "infinity_crown_edit"_qh: {
				DialogHandle::Infinity_Crown(peer);
				return;
			}
			case "cernuous_mask_edit"_qh: {
				DialogHandle::Cernuous(peer);
				return;
			}
			case "bannerbandolier"_qh: {
				DialogHandle::Banner_Bandolier(peer);
				return;
			}
			case "goals"_qh: {
				DialogHandle::Daily_Quest_Info(peer);
				return;
			}
			case "acceptguild"_qh: {
				if (pInfo(peer)->pending_guild == 0 or pInfo(peer)->guild_id != 0) return;
				std::string name_ = pInfo(peer)->world;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					uint32_t guild_id = pInfo(peer)->pending_guild;
					vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
					if (p != guilds.end()) {
						Guild* guild_information = &guilds[p - guilds.begin()];
						if (guild_information->guild_members.size() >= guild_information->guild_level * 5) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Guild is at maximum capacity of " + to_string(guild_information->guild_level * 5) + " peoples!", 0, 0);
							VarList::OnConsoleMessage(peer, "Guild is at maximum capacity of " + to_string(guild_information->guild_level * 5) + " peoples!");
							return;
						}
						GuildMember new_member{};
						new_member.member_name = pInfo(peer)->tankIDName;
						new_member.role_id = 0;
						new_member.last_online = time(NULL);
						guild_information->guild_members.push_back(new_member);
						pInfo(peer)->pending_guild = 0;
						pInfo(peer)->guild_id = guild_information->guild_id;
						guild_information->guild_settings &= ~SETTINGS::SETTINGS_0;
						guild_information->guild_settings |= SETTINGS::SETTINGS_0;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You Succesfully joined " + guild_information->guild_name, 0, 0);
						Clothing_V2::Update_Value(peer, true);
						Clothing_V2::Update(peer);
						if (pInfo(peer)->world == guild_information->guild_world and guild_access(peer, guild_id)) {
							int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
							{
								std::vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return a.fg == 5814; });
								if (p != world_->blocks.end()) {
									int i_ = p - world_->blocks.begin();
									int x_ = i_ % xSize;
									int y_ = i_ / xSize;
									WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
									PlayerMoving data_2{};
									data_2.packetType = 5, data_2.punchX = x_, data_2.punchY = y_, data_2.characterState = 0x8;
									BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc_(world_, block_));
									BYTE* blc = raw2 + 56;
									form_visual(blc, *block_, *world_, peer, false);
									VisualHandle::Nick(peer, NULL);
									for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
										if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
										if (pInfo(cp_)->world == pInfo(peer)->world) {
											VarList::OnConsoleMessage(cp_, "`5[GUILD ALERT]`` " + get_player_nick(peer) + " joined the guild!");
											send_raw(cp_, 4, raw2, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[] raw2, blc;
								}
							}
						}
						else {
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
								if (pInfo(cp_)->guild_id == pInfo(peer)->guild_id) {
									VarList::OnConsoleMessage(cp_, "`5[GUILD ALERT]`` " + get_player_nick(peer) + " joined the guild!");
								}
							}
						}
						create_guild_log(guild_information, "`$" + pInfo(peer)->tankIDName + "`` `wjoined the guild", 5948);
					}
				}
				return;
			}
			case "acceptlock"_qh: {
				if (pInfo(peer)->access_offers.size() == 0) return;
				for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
					if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
					if (pInfo(cp_)->world == pInfo(peer)->world) {
						if (pInfo(peer)->access_offers.find(pInfo(cp_)->netID) != pInfo(peer)->access_offers.end()) {
							std::string name_ = pInfo(peer)->world;
							std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								string owner_name = to_lower(world_->owner_name), user_name = to_lower(pInfo(cp_)->tankIDName);
								int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
								int x_ = (pInfo(peer)->access_offers[pInfo(cp_)->netID]) % xSize, y_ = (pInfo(peer)->access_offers[pInfo(cp_)->netID]) / xSize;
								WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
								if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) owner_name = to_lower(block_->owner_name);
								if (owner_name != user_name and not Role::Administrator(peer)) return;
								if (x_ < 0 or x_ >= world_->max_x or y_ < 0 or y_ >= world_->max_y) return;
								if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) {
									if (to_lower(block_->owner_name) != user_name) return;
								}
								else {
									if (owner_name != user_name) return;
								}
								VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|small|Accept Access To World|left|242|\nadd_smalltext|When you have access to a world, you are responsible for anything the world's owners or other admins do.|left|\nadd_smalltext|Don't accept access to a world unless it is from people you trust.|left|\nadd_smalltext|You can remove your access later by either wrenching the lock, or typing `2/unaccess`` to remove yourself from all locks in the world.|left|\nadd_spacer|small|\nadd_textbox|Are you sure you want to be added to this " + items[block_->fg].name + "?|left|\nend_dialog|acceptaccess|No|Yes|");
							}
							return;
						}
					}
				}
				return;
			}
			default:
				return;
			}
		}
	}
	static void title_edit(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		string a = "", b = "", c = "", d = "", e = "", f = "", g = "", h = "", i = "", j = "", k = "", l = "", m = "", n = "", o = "", p = "";
		if (pInfo(peer)->Title.Doctor) {
			a = parser.get("1", 1);
			if (!isValidCheckboxInput(a)) return;
		}
		if (pInfo(peer)->level >= 125) {
			b = parser.get("2", 1);
			if (!isValidCheckboxInput(b)) return;
		}
		if (pInfo(peer)->level >= 250) {
			c = parser.get("3", 1);
			if (!isValidCheckboxInput(c)) return;
		}
		if (pInfo(peer)->Title.Grow4Good) {
			d = parser.get("4", 1);
			if (!isValidCheckboxInput(d)) return;
		}
		if (pInfo(peer)->Title.Mentor) {
			e = parser.get("5", 1);
			if (!isValidCheckboxInput(e)) return;
		}
		if (pInfo(peer)->Title.OfLegend) {
			f = parser.get("6", 1);
			if (!isValidCheckboxInput(f)) return;
		}
		if (pInfo(peer)->Title.TiktokBadge) {
			g = parser.get("7", 1);
			if (!isValidCheckboxInput(g)) return;
		}
		if (pInfo(peer)->Title.ContentCBadge) {
			h = parser.get("8", 1);
			if (!isValidCheckboxInput(h)) return;
		}
		if (pInfo(peer)->Title.ThanksGiving) {
			i = parser.get("9", 1);
			if (!isValidCheckboxInput(i)) return;
		}
		if (pInfo(peer)->Title.OldTimer) {
			j = parser.get("10", 1);
			if (!isValidCheckboxInput(j)) return;
		}
		if (pInfo(peer)->Title.WinterSanta) {
			k = parser.get("11", 1);
			if (!isValidCheckboxInput(k)) return;
		}
		if (pInfo(peer)->Title.PartyAnimal) {
			l = parser.get("12", 1);
			if (!isValidCheckboxInput(l)) return;
		}
		if (pInfo(peer)->Title.GrowPass_Gold) {
			m = parser.get("13", 1);
			if (!isValidCheckboxInput(m)) return;
		}
		if (pInfo(peer)->Title.GrowPass_Silver) {
			n = parser.get("14", 1);
			if (!isValidCheckboxInput(n)) return;
		}
		if (pInfo(peer)->Title.GrowPass_Bronze) {
			o = parser.get("15", 1);
			if (!isValidCheckboxInput(o)) return;
		}
		if (pInfo(peer)->Title.Award_Winning) {
			p = parser.get("16", 1);
			if (!isValidCheckboxInput(p)) return;
		}
		if (pInfo(peer)->Title.Doctor and pInfo(peer)->drt != std::atoi(a.c_str())) {
			pInfo(peer)->drt = std::atoi(a.c_str());
		}
		if (pInfo(peer)->level >= 125 and pInfo(peer)->lvl125 != std::atoi(b.c_str())) {
			pInfo(peer)->lvl125 = std::atoi(b.c_str());
		}
		if (pInfo(peer)->level >= 250 and pInfo(peer)->black_color != std::atoi(c.c_str())) {
			pInfo(peer)->black_color = std::atoi(c.c_str());
		}
		if (pInfo(peer)->Title.Grow4Good and pInfo(peer)->donor != std::atoi(d.c_str())) {
			pInfo(peer)->donor = std::atoi(d.c_str());
		}
		if (pInfo(peer)->Title.Mentor and pInfo(peer)->master != std::atoi(e.c_str())) {
			pInfo(peer)->master = std::atoi(e.c_str());
		}
		if (pInfo(peer)->Title.OfLegend and pInfo(peer)->is_legend != std::atoi(f.c_str())) {
			pInfo(peer)->is_legend = std::atoi(f.c_str());
		}
		if (pInfo(peer)->Title.TiktokBadge and pInfo(peer)->ttBadge != std::atoi(g.c_str())) {
			pInfo(peer)->ttBadge = std::atoi(g.c_str());
		}
		if (pInfo(peer)->Title.ContentCBadge and pInfo(peer)->ccBadge != std::atoi(h.c_str())) {
			pInfo(peer)->ccBadge = std::atoi(h.c_str());
		}
		if (pInfo(peer)->Title.PartyAnimal and pInfo(peer)->party_animal != std::atoi(l.c_str())) {
			pInfo(peer)->party_animal = std::atoi(l.c_str());
		}
		if (pInfo(peer)->Title.ThanksGiving and pInfo(peer)->tgiv != std::atoi(i.c_str())) {
			pInfo(peer)->tgiv = std::atoi(i.c_str());
			if (pInfo(peer)->tgiv == 1) pInfo(peer)->TitleTexture = "game/tiles_page15.rttex", pInfo(peer)->TitleCoordinate = "12,1";
			else pInfo(peer)->TitleTexture = "", pInfo(peer)->TitleCoordinate = "";
		}
		if (pInfo(peer)->Title.OldTimer and pInfo(peer)->anni_old != std::atoi(j.c_str())) {
			pInfo(peer)->anni_old = std::atoi(j.c_str());
			if (pInfo(peer)->anni_old == 1) pInfo(peer)->TitleTexture = "game/tiles_page7.rttex", pInfo(peer)->TitleCoordinate = "8,6";
			else pInfo(peer)->TitleTexture = "", pInfo(peer)->TitleCoordinate = "";
		}
		if (pInfo(peer)->Title.WinterSanta and pInfo(peer)->santa != std::atoi(k.c_str())) {
			pInfo(peer)->santa = std::atoi(k.c_str());
			if (pInfo(peer)->santa == 1) pInfo(peer)->TitleTexture = "game/tiles_page2.rttex", pInfo(peer)->TitleCoordinate = "28,8";
			else pInfo(peer)->TitleTexture = "", pInfo(peer)->TitleCoordinate = "";
		}
		if (pInfo(peer)->Title.GrowPass_Gold and pInfo(peer)->gp_gold != std::atoi(m.c_str())) {
			pInfo(peer)->gp_gold = std::atoi(m.c_str());
			if (pInfo(peer)->gp_gold == 1) pInfo(peer)->TitleTexture = "game/tiles_page16.rttex", pInfo(peer)->TitleCoordinate = "0,25";
			else pInfo(peer)->TitleTexture = "", pInfo(peer)->TitleCoordinate = "";
		}
		if (pInfo(peer)->Title.GrowPass_Silver and pInfo(peer)->gp_silver != std::atoi(n.c_str())) {
			pInfo(peer)->gp_silver = std::atoi(n.c_str());
			if (pInfo(peer)->gp_silver == 1) pInfo(peer)->TitleTexture = "game/tiles_page16.rttex", pInfo(peer)->TitleCoordinate = "1,25";
			else pInfo(peer)->TitleTexture = "", pInfo(peer)->TitleCoordinate = "";
		}
		if (pInfo(peer)->Title.GrowPass_Bronze and pInfo(peer)->gp_bronze != std::atoi(o.c_str())) {
			pInfo(peer)->gp_bronze = std::atoi(o.c_str());
			if (pInfo(peer)->gp_bronze == 1) pInfo(peer)->TitleTexture = "game/tiles_page16.rttex", pInfo(peer)->TitleCoordinate = "2,25";
			else pInfo(peer)->TitleTexture = "", pInfo(peer)->TitleCoordinate = "";
		}
		if (pInfo(peer)->Title.Award_Winning and pInfo(peer)->aw_winning != std::atoi(p.c_str())) {
			pInfo(peer)->aw_winning = std::atoi(p.c_str());
			if (pInfo(peer)->aw_winning == 1) pInfo(peer)->TitleTexture = "game/tiles_page16.rttex", pInfo(peer)->TitleCoordinate = "27,11";
			else pInfo(peer)->TitleTexture = "", pInfo(peer)->TitleCoordinate = "";
		}
		VisualHandle::Nick(peer, NULL);
		Clothing_V2::Update_Value(peer);
		Clothing_V2::Update(peer);
	}
	static void changeguildname(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string new_name = parser.get("name", 1);
		if (Inventory::Contains(peer, 7190) == 0) return;
		uint32_t guild_id = pInfo(peer)->guild_id;
		if (guild_id == 0) {
			gamepacket_t p2;
			p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert("You must own a guild to change name!"), p2.Insert(1), p2.Insert(1), p2.CreatePacket(peer);
			return;
		}
		vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
		if (p != guilds.end()) {
			Guild* guild_information = &guilds[p - guilds.begin()];
			guild_information->guild_settings &= ~SETTINGS::SETTINGS_0;
			guild_information->guild_settings |= SETTINGS::SETTINGS_0;
			for (GuildMember member_search : guild_information->guild_members) {
				if (to_lower(member_search.member_name) == to_lower(pInfo(peer)->tankIDName)) {
					if (member_search.role_id == 3) {
						replaceAll(new_name, "\n", "");
						string check_name = to_lower(new_name);
						bool error_dialog = false;
						for (int i = 0; i < Environment()->swear_words.size(); i++) {
							if (check_name.find(to_lower(Environment()->swear_words[i])) != string::npos) {
								error_dialog = true;
								new_name = "`4OOPS:`` `0The name includes bad words.``";
								return;
							}
						}
						for (Guild check_guild_name : guilds) {
							if (to_lower(check_guild_name.guild_name) == check_name) {
								error_dialog = true;
								new_name = "`4OOPS:`` `0The guild with this name already exists.``";
								return;
							}
						}
						if (check_name.size() < 3) {
							error_dialog = true;
							new_name = "`4OOPS:`` `0The guild name is too short.``";
						}
						if (check_name.size() > 15) {
							error_dialog = true;
							new_name = "`4OOPS:`` `0The guild name is too long.``";
						}
						if (special_char(check_name)) {
							error_dialog = true;
							new_name = "`4OOPS:`` `0Guild name can not have special characters.``";
						}
						change_guild_name(peer, new_name, error_dialog);
					}
				}
			}
		}
	}
	static void world_swap(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		string world = parser.get("name_box", 1), name_ = pInfo(peer)->world;
		std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			if (to_lower(world_->owner_name) == to_lower(pInfo(peer)->tankIDName)) {
				transform(world.begin(), world.end(), world.begin(), ::toupper);
				if (not check_blast(world) || pInfo(peer)->world == world) {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSwap World Names``|left|2580|\nadd_textbox|`4World swap failed - you don't own both worlds!``|left|\nadd_smalltext|This will swap the name of the world you are standing in with another world `4permanently``.  You must own both worlds, with a World Lock in place.<CR>Your `wChange of Address`` will be consumed if you press `5Swap 'Em``.|left|\nadd_textbox|Enter the other world's name:|left|\nadd_text_input|name_box|||32|\nadd_spacer|small|\nend_dialog|world_swap|Cancel|Swap 'Em!|");
				}
				else {
					create_address_world(peer, world, pInfo(peer)->world);
				}
			}
		}
	}
	static void surgery(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button.substr(0, 4) == "tool") {
				int count = std::atoi(button.substr(4).c_str());
				if (count == 999) end_surgery(peer);
				else load_surgery(peer, count);
			}
		}
	}
	static void statsblockworld(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			std::string name_ = pInfo(peer)->world;
			std::vector<World>::iterator pd = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (pd != worlds.end()) {
				World* world_ = &worlds[pd - worlds.begin()];
				world_->fresh_world = true;
				WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
				if (!Only_Access(peer, world_, block_)) return;
				if (button == "back_to_gscan") {
					DialogHandle::Growscan_Load(peer, world_, block_);
				}
				if (button.find("search_") != std::string::npos) {
					std::vector<std::string> t_ = explode("|", cch);
					if (t_.size() < 5 || pInfo(peer)->world.empty()) return;
					std::string type = explode("\n", t_[3])[0].c_str(), search = explode("\n", t_[4])[0].c_str();
					replaceAll(type, "search_", "");
					DialogHandle::Growscan_Blocks(peer, search, type);
				}
				if (button.substr(0, 9) == "findTile_") {
					int item_ = std::atoi(button.substr(9).c_str());
					if (item_ <= 0 || item_ > items.size()) return;
					PlayerMoving data_{};
					data_.packetType = 37, data_.netID = item_;
					BYTE* raw = packPlayerMoving(&data_);
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(cp_)->world != pInfo(peer)->world) continue;
						send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw;
				}
			}
		}
	}
	static void autoclave(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button.substr(0, 4) == "tool") {
				int itemtool = std::atoi(button.substr(4).c_str());
				if (itemtool == 1258 || itemtool == 1260 || itemtool == 1262 || itemtool == 1264 || itemtool == 1266 || itemtool == 1268 || itemtool == 1270 || itemtool == 4308 || itemtool == 4310 || itemtool == 4312 || itemtool == 4314 || itemtool == 4316 || itemtool == 4318) {
					int got = 0;
					Inventory::Modify(peer, itemtool, got);
					if (got >= 20) {
						pInfo(peer)->lastchoosenitem = itemtool;
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`9Autoclave``|left|4322|\nadd_spacer|small|\nadd_textbox|Are you sure you want to destroy 20 " + items[itemtool].ori_name + " in exchange for one of each of the other 12 surgical tools?|left|\nadd_button|verify|Yes!|noflags|0|0|\nend_dialog|autoclave|Cancel||");
					}
				}
			}
			if (button == "verify") {
				int removeitem = pInfo(peer)->lastchoosenitem, inventory_space = 12, slots = Inventory::Get_Slots(pInfo(peer)), got = 0;
				vector<int> noobitems{ 1262, 1266,1260, 1264, 4314, 4312, 4318, 4308, 1268, 1258, 1270, 4310, 4316 };
				if (find(noobitems.begin(), noobitems.end(), removeitem) == noobitems.end()) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, items[removeitem].name + " cannot be used in the Autoclave!");
					return;
				}
				Inventory::Modify(peer, removeitem, got);
				if (got >= 20) {
					bool toobig = false;
					for (int i_ = 0, remove = 0; i_ < pInfo(peer)->inv.size(); i_++) for (int i = 0; i < noobitems.size(); i++) {
						if (pInfo(peer)->inv[i_].first == noobitems[i]) {
							if (pInfo(peer)->inv[i_].second == 200) toobig = true;
							else inventory_space -= 1;
						}
					}
					if (toobig == false && slots >= inventory_space) {
						Inventory::Modify(peer, removeitem, got = -20);
						for (int i = 0; i < noobitems.size(); i++) {
							if (noobitems[i] == removeitem) return;
							Inventory::Modify(peer, noobitems[i], got = 1);
						}
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "[`3I swapped 20 " + items[removeitem].ori_name + " for 1 of every other instrument!``]");
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "No inventory space!");
				}
			}
		}
	}
	static void camera_edit(ENetPeer* peer, std::string cch) {
		if (cch.find("checkbox_showpick|") != string::npos) {
			std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [&](const World& a) { return a.name == pInfo(peer)->world; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				world_->fresh_world = true;
				std::vector<std::string> t_ = explode("|", cch);
				if (t_.size() < 11) return;
				bool show_item_taking = std::atoi(explode("\n", t_[3])[0].c_str()), show_item_dropping = std::atoi(explode("\n", t_[4])[0].c_str()), show_people_entering = std::atoi(explode("\n", t_[5])[0].c_str()), show_people_exiting = std::atoi(explode("\n", t_[6])[0].c_str()), dont_show_owner = std::atoi(explode("\n", t_[7])[0].c_str()), dont_show_admins = std::atoi(explode("\n", t_[8])[0].c_str()), dont_show_noaccess = std::atoi(explode("\n", t_[9])[0].c_str()), show_vend_logs = std::atoi(explode("\n", t_[10])[0].c_str()), changed = false;
				for (int i_ = 0; i_ < world_->cctv_settings.size(); i_++) {
					if (world_->cctv_settings[i_][0] == pInfo(peer)->lastwrenchx and world_->cctv_settings[i_][1] == pInfo(peer)->lastwrenchy) {
						changed = true;
						world_->cctv_settings[i_][2] = show_item_taking;
						world_->cctv_settings[i_][3] = show_item_dropping;
						world_->cctv_settings[i_][4] = show_people_entering;
						world_->cctv_settings[i_][5] = show_people_exiting;
						world_->cctv_settings[i_][6] = dont_show_owner;
						world_->cctv_settings[i_][7] = dont_show_admins;
						world_->cctv_settings[i_][8] = dont_show_noaccess;
						world_->cctv_settings[i_][9] = show_vend_logs;
					}
				}
				if (changed == false) world_->cctv_settings.push_back({ {pInfo(peer)->lastwrenchx}, {pInfo(peer)->lastwrenchy}, {show_item_taking}, {show_item_dropping}, {show_people_entering}, {show_people_exiting}, {dont_show_owner}, {dont_show_admins}, {dont_show_noaccess}, {show_vend_logs} });
			}
		}
		if (cch.find("buttonClicked|clear") != string::npos) {
			std::string name_ = pInfo(peer)->world;
			std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
				if (not Only_Access(peer, world_, block_)) {
					Punishment::Banned(peer, 6.307e+7, "Stupid Hacker", "SYSTEM", 76);
					ServerPool::ModLogs::Add(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, " `4Stupid Hacker", "");
					return;
				}
				world_->fresh_world = true;
				for (int i_ = 0; i_ < world_->cctv.size(); i_++) {
					if (world_->cctv[i_].x == pInfo(peer)->lastwrenchx and world_->cctv[i_].y == pInfo(peer)->lastwrenchy) {
						if (i_ != 0) {
							world_->cctv.erase(world_->cctv.begin() + i_);
							i_--;
						}
					}
				}
				ServerPool::Logs::Add(pInfo(peer)->tankIDName + " cleared cctv in World: [" + pInfo(peer)->world + "]", "CCTV Clear Logs");
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`2Camera log cleared.``", 0, 0);
			}
		}
	}
	static void dialog_scarf_of_seasons(ENetPeer* peer, std::string cch) {
		if (cch.find("buttonClicked") != string::npos) {
			if (pInfo(peer)->necklace == 11818) pInfo(peer)->i_11818_1 = 0, pInfo(peer)->i_11818_2 = 0;
			Clothing_V2::Update(peer);
		}
		if (cch.find("checkbox") != string::npos) {
			if (pInfo(peer)->necklace == 11818) {
				std::vector<std::string> t_ = explode("|", cch);
				if (t_.size() < 11) return;
				for (int i = 3; i <= 10; i++) {
					if (i <= 6 && atoi(explode("\n", t_[i])[0].c_str()) == 1) pInfo(peer)->i_11818_1 = i - 3;
					else if (atoi(explode("\n", t_[i])[0].c_str()) == 1) pInfo(peer)->i_11818_2 = i - 7;
				}
				Clothing_V2::Update(peer);
			}
		}
	}
	static void blast(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		string world = parser.get("name", 1);
		if (pInfo(peer)->lastchoosenitem == 14896 || pInfo(peer)->lastchoosenitem == 6420 || pInfo(peer)->lastchoosenitem == 830 || pInfo(peer)->lastchoosenitem == 9164 || pInfo(peer)->lastchoosenitem == 8738 || pInfo(peer)->lastchoosenitem == 9602 || pInfo(peer)->lastchoosenitem == 942 || pInfo(peer)->lastchoosenitem == 1060 || pInfo(peer)->lastchoosenitem == 1136 || pInfo(peer)->lastchoosenitem == 1402 || pInfo(peer)->lastchoosenitem == 9582 || pInfo(peer)->lastchoosenitem == 1532 || pInfo(peer)->lastchoosenitem == 3562 || pInfo(peer)->lastchoosenitem == 4774 || pInfo(peer)->lastchoosenitem == 7380 || pInfo(peer)->lastchoosenitem == 7588 || pInfo(peer)->lastchoosenitem == 8556) {
			int blast = pInfo(peer)->lastchoosenitem;
			replace_str(world, "\n", "");
			transform(world.begin(), world.end(), world.begin(), ::toupper);
			if (find_if(worlds.begin(), worlds.end(), [world](const World& a) { return a.name == world; }) != worlds.end() || not check_blast(world) || _access_s(("database/worlds/" + world + "_.json").c_str(), 0) == 0) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That world name already exists. You'll have to be more original. Maybe add some numbers after it?", 0, 0);
			}
			else {
				int got = -1;
				if (Inventory::Modify(peer, blast, got) == 0) {
					create_world_blast(peer, world, blast);
					if (blast == 830) Inventory::Modify(peer, 834, got = -100);
					Enter_World(peer, world);
					VarList::OnConsoleMessage(peer, "** `5" + pInfo(peer)->tankIDName + " activates a " + items[blast].name + "! ``**", 0, 750);
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "** `5" + pInfo(peer)->tankIDName + " activates a " + items[blast].name + "! ``**", 0, 1, 750);
					ServerPool::Logs::Add(pInfo(peer)->tankIDName + " activates a " + items[blast].name + " in " + world + ".", "Blast");
				}
			}
		}
	}
	static void megaphone(ENetPeer* peer, std::string cch) {
		if (cch.find("itemID|2480|\nwords|") != string::npos) {
			string text = cch.substr(62, cch.length() - 63).c_str();
			bool cansb = true;
			int c_ = Inventory::Contains(peer, 2480);
			if (c_ == 0) return;
			if (Playmods::HasById(pInfo(peer), 11)) {
				VarList::OnConsoleMessage(peer, "`6>> That's sort of hard to do while duct-taped.``");
				cansb = false;
				return;
			}
			if (Playmods::HasById(pInfo(peer), 13)) {
				int time_ = 0;
				for (PlayMods peer_playmod : pInfo(peer)->playmods) {
					if (peer_playmod.id == 13) {
						time_ = peer_playmod.time - time(nullptr);
						return;
					}
				}
				CAction::Log(peer, "action|log\nmsg|>> (" + Time::Playmod(time_) + " before you can broadcast again)", "");
				return;
			}
			if (cansb) {
				pInfo(peer)->usedmegaphone = 1;
				SendBoardcast(peer, text);
			}
		}
	}
	static void notebook_edit(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "cancel") send_wrench_self(peer);
			if (button == "clear") {
				pInfo(peer)->note = "";
				send_wrench_self(peer);
			}
			if (button == "save") {
				string personal_note = parser.get("personal_note", 1);
				if (personal_note.length() > 128) return;
				pInfo(peer)->note = personal_note;
				send_wrench_self(peer);
			}
		}
	}
	static void dailyc(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "back_to_dailyc") {
				EventPool::Load::DailyC_Leaderboard();
				string top = "", claimed = "", banner = ""; int id = 0, ranks = 0;
				if (Event()->dailyc_name == "Fish Frenzy") {
					id = 7072;
					banner = "\nadd_image_button||interface/large/gui_event_fishing.rttex|bannerlayout|||";
				}
				if (Event()->dailyc_name == "Surgeon") {
					id = 7068;
					banner = "\nadd_image_button||interface/large/gui_event_surgery_info.rttex|bannerlayout|||";
				}
				if (Event()->dailyc_name == "Geiger") {
					id = 2204;
					banner = "\nadd_image_button||interface/large/gui_event_geigar.rttex|bannerlayout|||";
				}
				if (Event()->dailyc_name == "Crimewave") {
					id = 2302;
					banner = "\nadd_image_button||interface/large/gui_event_crimewave.rttex|bannerlayout|||";
				}
				if (Event()->dailyc_name == "Wolf World") {
					id = 2992;
					banner = "\nadd_image_button||interface/large/gui_event_wolfworld.rttex|bannerlayout|||";
				}
				if (Event()->dailyc_name == "Mining") {
					id = 14526;
					banner = "\nadd_image_button||interface/large/gui_mining_banner1.rttex|bannerlayout|||";
				}
				std::vector<std::pair<long long int, string>>::iterator pa = find_if(Event()->top_dailyc.begin(), Event()->top_dailyc.end(), [&](const pair < long long int, string>& element) { return element.second == pInfo(peer)->tankIDName; });
				if (pa != Event()->top_dailyc.end()) {
					ranks = distance(Event()->top_dailyc.begin(), pa) + 1;
					if (Event()->DailyChallenge == false) claimed = "\nadd_button|claim_dailyc_rewards|Claim Rewards|0|0|\nadd_custom_textbox|`3Reward`o: " + a + (ranks == 1 ? "1 Challenge Crown, 5 Diamond Locks and 50 World Locks" : ranks == 2 ? "1 Flaming Aura, 4 Diamond Locks and 50 World Locks" : ranks == 3 ? "1 Crystal Cape, 3 Diamond Locks and 50 World Locks" : ranks == 4 ? "2 Diamond Locks and 50 World Locks" : "1 Diamond Locks and 50 World Locks") + ".|size:small;color:255,255,255,255;icon:1796;|";
					if (Event()->top_dailyc[pa - Event()->top_dailyc.begin()].first > 0) top = "\nadd_smalltext|`3Your Rank`o: " + to_string(distance(Event()->top_dailyc.begin(), pa) + 1) + "    `3Total Points`o: " + Set_Count(Event()->top_dailyc[pa - Event()->top_dailyc.begin()].first) + "|";
				}
				long long time_ = time(nullptr);
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Daily Challenge|left|3142|\nadd_spacer|small|\nadd_textbox|`o" + (Event()->DailyChallenge ? "Daily Challenge time remaining : " + Time::Playmod(Event()->daily_current_time - time_) + "." : "The next Daily Challenge is in " + Time::Playmod(Event()->daily_wait_time - time_) + ".") + "|left|" + (Event()->DailyChallenge ? "\nadd_label_with_icon|small|`oThe Daily Challenge is `2" + Event()->dailyc_name + "``.|left|" + to_string(id) + "|" + banner + "\nadd_textbox|`oYou need to be a `5Supporter`` or `5Super Supporter`` to participate in the daily challenge|left|\nadd_spacer|small|\nadd_textbox|`oThe top players today are:|left|\nadd_spacer|small|" + Event()->top_dailyc_list + "|\nadd_spacer|small|\nadd_smalltext|`#(Scores are updated every 20 seconds)|left|\nadd_spacer|small|\nadd_button|dailyc_reward|`oRewards|0|0|" : "\nadd_spacer|small|" + (ranks == 0 ? "" : top + claimed)) + "\nend_dialog|dailyc|Close||\nadd_quick_exit|");
			}
			if (button == "dailyc_reward") {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`wDaily Challenge Rewards|left|3142|\nadd_spacer|small|\ntext_scaling_string|Subscribtions++++++++|\nadd_label|small|`o1st Rewards:|left|\nadd_button_with_icon||`oChallenge Crown|frame|3138|1|\nadd_button_with_icon||`oDIamond Locks|frame|1796|5|\nadd_button_with_icon||`oWorld Locks|frame|242|50|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_label|small|`o2nd Rewards:|left|\nadd_button_with_icon||`oFlaming Aura|frame|6284|1|\nadd_button_with_icon||`oDIamond Locks|frame|1796|4|\nadd_button_with_icon||`oWorld Locks|frame|242|50|\nadd_button_with_icon||END_LIST|noflags|0|\nadd_label|small|`o3rd Rewards:|left|\nadd_button_with_icon||`oCrystal Cape|frame|1738|1|\nadd_button_with_icon||`oDIamond Locks|frame|1796|3|\nadd_button_with_icon||`oWorld Locks|frame|242|50|\nadd_button_with_icon||END_LIST|noflags|0|\nadd_label|small|`o4th Rewards:|left|\nadd_button_with_icon||`oDIamond Locks|frame|1796|2|\nadd_button_with_icon||`oWorld Locks|frame|242|50|\nadd_button_with_icon||END_LIST|noflags|0|\nadd_label|small|`o5th Rewards:|left|\nadd_button_with_icon||`oDIamond Locks|frame|1796|1|\nadd_button_with_icon||`oWorld Locks|frame|242|50|\nadd_button_with_icon||END_LIST|noflags|0|\nadd_spacer|small|\nadd_button|back_to_dailyc|`oBack|0|0|\nend_dialog|dailyc|||");
			}
			if (button == "claim_dailyc_rewards") {
				string find = pInfo(peer)->tankIDName;
				std::vector<std::pair<long long int, string>>::iterator pa = find_if(Event()->top_dailyc.begin(), Event()->top_dailyc.end(), [&](const pair < long long int, string>& element) { return element.second == pInfo(peer)->tankIDName; });
				if (pa != Event()->top_dailyc.end()) {
					int place = distance(Event()->top_dailyc.begin(), pa) + 1, give_dl = 0, give_wl = 0, big_prize = 0, add = 1;
					if (place == 0) return;
					if (place == 1) {
						big_prize = 3138;
						give_dl = 5, give_wl = 50;
					}
					if (place == 2) {
						big_prize = 6284;
						give_dl = 4, give_wl = 50;
					}
					if (place == 3) {
						big_prize = 1738;
						give_dl = 3, give_wl = 50;
					}
					if (place == 4) give_dl = 2, give_wl = 50;
					if (place == 5) give_dl = 1, give_wl = 50;
					VarList::OnConsoleMessage(peer, "`oYou received a " + (big_prize != 0 ? items[big_prize].name + ", " : "") + "" + to_string(give_dl) + " Diamond Locks and " + to_string(give_wl) + " World Locks as a reward for being Rank " + to_string(place) + " in the Daily Challenge Leaderboard!");
					VarList::OnAddNotification(peer, "You claimed your Daily Challenge Reward!", "interface/guide_arrow.rttex", "audio/piano_nice.wav.wav");
					if (give_dl != 0) Inventory::Modify(peer, 1796, give_dl);
					if (give_wl != 0) Inventory::Modify(peer, 242, give_wl);
					if (big_prize != 0) Inventory::Modify(peer, big_prize, add);
					PlayerMoving data_{};
					data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
					BYTE* raw = packPlayerMoving(&data_);
					send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					delete[] raw;
					Event()->top_dailyc.erase(pa);
				}
			}
		}
	}
	static void gazette(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "shop") DialogHandle::Shop_Assets(peer);
		}
	}
	static void donation_box_edit(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = ""; int item = 0;
		if (parser.try_get("itemid", item)) {
			if (item < 0 or item > items.size() or Inventory::Contains(peer, item) == 0) return;
			if (items[item].untradeable == 1 || item == 1424 || item == 5816 || items[item].blockType == BlockTypes::FISH) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`7[```4You can't place that in the box, you need it!`7]``", 0, 0);
			}
			else if (items[item].rarity == 1) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`7[```4This box only accepts items rarity 2+ or greater`7]``", 0, 0);
			}
			else {
				pInfo(peer)->lastchoosenitem = item;
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|" + items[item].name + "``|left|" + to_string(item) + "|\nadd_textbox|How many to put in the box as a gift? (Note: You will `4LOSE`` the items you give!)|left|\nadd_text_input|count|Count:|" + to_string(Inventory::Contains(peer, item)) + "|5|\nadd_text_input|sign_text|Optional Note:||128|\nadd_spacer|small|\nadd_button|give|`4Give the item(s)``|noflags|0|0|\nadd_spacer|small|\nadd_button|cancel|`wCancel``|noflags|0|0|\nend_dialog|donation_box_edit|||\n");
			}
		}
		else if (parser.try_get("buttonClicked", button)) {
			if (button == "give") {
				string count_ = parser.get("count", 1);
				string text = parser.get("sign_text", 1);
				if (not is_number(count_) || pInfo(peer)->lastchoosenitem == 0 || pInfo(peer)->lastchoosenitem <= 0 || pInfo(peer)->lastchoosenitem > items.size()) return;
				replace_str(text, "\n", "");
				replace_str(text, "<CR>", "");
				int count = std::atoi(count_.c_str()), got = 0;
				Inventory::Modify(peer, pInfo(peer)->lastchoosenitem, got);
				if (text.size() > 128 || got <= 0 || count <= 0 || count > items.size()) return;
				if (count > got || items[pInfo(peer)->lastchoosenitem].untradeable == 1 || pInfo(peer)->lastchoosenitem == 1424 || pInfo(peer)->lastchoosenitem == 5816 || items[pInfo(peer)->lastchoosenitem].blockType == BlockTypes::FISH) {
					if (count > got) VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have that to give!");
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`7[```4You can't place that in the box, you need it!`7]``");
				}
				else {
					std::string name_ = pInfo(peer)->world;
					std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
					if (p != worlds.end()) {
						World* world_ = &worlds[p - worlds.begin()];
						world_->fresh_world = true;
						WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
						if (items[block_->fg].blockType != BlockTypes::DONATION) return;
						Donate donate_{};
						donate_.item = pInfo(peer)->lastchoosenitem, donate_.count = count, donate_.name = pInfo(peer)->tankIDName, donate_.text = text;
						block_->donates.push_back(donate_);
						{
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = pInfo(peer)->lastwrenchx, data_.punchY = pInfo(peer)->lastwrenchy, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
							BYTE* blc = raw + 56;
							block_->flags = (block_->flags & 0x00400000 ? block_->flags : block_->flags | 0x00400000);
							form_visual(blc, *block_, *world_, peer, false, true);
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
								if (pInfo(peer)->world != pInfo(cp_)->world) continue;
								send_raw(cp_, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
							}
							delete[] raw, blc;
							if (block_->locked) upd_lock(*block_, *world_, peer);
						}
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(peer)->world != pInfo(cp_)->world) continue;
							VarList::OnConsoleMessage(cp_, "`7[```5[```w" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) + "`` places `5" + to_string(count) + "`` `2" + items[pInfo(peer)->lastchoosenitem].name + "`` into the " + items[pInfo(peer)->lastwrenchb].name + "`5]```7]``");
							VarList::OnTalkBubble(cp_, pInfo(peer)->netID, "`7[```5[```w" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) + "`` places `5" + to_string(count) + "`` `2" + items[pInfo(peer)->lastchoosenitem].name + "`` into the " + items[pInfo(peer)->lastwrenchb].name + "`5]```7]``", 0, 0);
						}
						ServerPool::Logs::Add("player: `" + pInfo(peer)->tankIDName + "` lvl: " + to_string(pInfo(peer)->level) + " places " + to_string(count) + " `" + items[pInfo(peer)->lastchoosenitem].name + "` into the " + items[pInfo(peer)->lastwrenchb].name + " in: [" + pInfo(peer)->world + "]", "Donation Box");
						Inventory::Modify(peer, pInfo(peer)->lastchoosenitem, count *= -1);
					}
				}
			}
			if (button == "clear_selected") {
				try {
					bool took = false, fullinv = false;
					gamepacket_t p3;
					p3.Insert("OnTalkBubble"), p3.Insert(pInfo(peer)->netID);
					std::string name_ = pInfo(peer)->world;
					std::vector<std::string> t_ = explode("|", cch);
					if (t_.size() < 4) return;
					std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
					if (p != worlds.end()) {
						World* world_ = &worlds[p - worlds.begin()];
						world_->fresh_world = true;
						WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
						if (not block_access(peer, world_, block_) || items[block_->fg].blockType != BlockTypes::DONATION) return;
						for (int i_ = 0, remove_ = 0; i_ < block_->donates.size(); i_++, remove_++) {
							if (atoi(explode("\n", t_.at(4 + remove_)).at(0).c_str())) {
								int cc_ = block_->donates.at(i_).count, id_ = block_->donates.at(i_).item;
								if (Inventory::Modify(peer, id_, cc_) == 0) {
									took = true;
									gamepacket_t p;
									p.Insert("OnConsoleMessage"), p.Insert("`7[``" + pInfo(peer)->tankIDName + " receives `5" + to_string(block_->donates[i_].count) + "`` `w" + items[block_->donates[i_].item].name + "`` from `w" + block_->donates[i_].name + "``, how nice!`7]``");
									block_->donates.erase(block_->donates.begin() + i_), i_--;
									for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
										if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(peer)->world != pInfo(cp_)->world) continue;
										p.CreatePacket(cp_);
									}
								}
								else fullinv = true;
							}
						}
						if (block_->donates.size() == 0) {
							if (block_->flags & 0x00400000) block_->flags ^= 0x00400000;
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = pInfo(peer)->lastwrenchx, data_.punchY = pInfo(peer)->lastwrenchy, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
							BYTE* blc = raw + 56;
							form_visual(blc, *block_, *world_, peer, false);
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(peer)->world != pInfo(cp_)->world) continue;
								send_raw(cp_, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
							}
							delete[] raw, blc;
							if (block_->locked) upd_lock(*block_, *world_, peer);
						}
					}
					if (fullinv) {
						p3.Insert("I don't have enough room in my backpack to get the item(s) from the box!");
						gamepacket_t p2;
						p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert("`2(Couldn't get all of the gifts)``"), p2.CreatePacket(peer);
					}
					else if (took) p3.Insert("`2Box emptied.``");
					p3.Insert(0), p3.Insert(0);
					p3.CreatePacket(peer);
				}
				catch (out_of_range) {
					return;
				}
			}
			if (button == "takeall") {
				bool took = false, fullinv = false;
				std::string name_ = pInfo(peer)->world;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					world_->fresh_world = true;
					WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
					if (not Only_Access(peer, world_, block_) || items[block_->fg].blockType != BlockTypes::DONATION) return;
					for (auto it = block_->donates.begin(); it != block_->donates.end(); ) {
						int cc_ = it->count, id_ = it->item;
						if (Inventory::Modify(peer, id_, cc_) == 0) {
							took = true;
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
								if (pInfo(peer)->world != pInfo(cp_)->world) continue;
								VarList::OnConsoleMessage(cp_, "`7[``" + pInfo(peer)->tankIDName + " receives `5" + to_string(it->count) + "`` `w" + items[it->item].name + "`` from `w" + it->name + "``, how nice!`7]``");
							}
							it = block_->donates.erase(it);
						}
						else {
							++it;
							fullinv = true;
						}
					}
					if (block_->donates.size() == 0) {
						if (block_->flags & 0x00400000) block_->flags ^= 0x00400000;
						PlayerMoving data_{};
						data_.packetType = 5, data_.punchX = pInfo(peer)->lastwrenchx, data_.punchY = pInfo(peer)->lastwrenchy, data_.characterState = 0x8;
						BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
						BYTE* blc = raw + 56;
						form_visual(blc, *block_, *world_, peer, false);
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(peer)->world != pInfo(cp_)->world) continue;
							send_raw(cp_, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
						}
						delete[] raw, blc;
						if (block_->locked) upd_lock(*block_, *world_, peer);
					}
				}
				if (fullinv) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`2(Couldn't get all of the gifts)``", 0, 0);
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "I don't have enough room in my backpack to get the item(s) from the box!", 0, 0);
				}
				else if (took) VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`2Box emptied.``", 0, 0);
			}
		}
	}
	static void online_status(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		string checkbox_status_online = parser.get("checkbox_status_online", 1), checkbox_status_busy = parser.get("checkbox_status_busy", 1), checkbox_status_away = parser.get("checkbox_status_away", 1);
		if (!isValidCheckboxInput(checkbox_status_online) or !isValidCheckboxInput(checkbox_status_busy) or !isValidCheckboxInput(checkbox_status_away)) return;
		if (checkbox_status_online == "1") pInfo(peer)->p_status = 0;
		else if (checkbox_status_busy == "1") pInfo(peer)->p_status = 1;
		else if (checkbox_status_away == "1") pInfo(peer)->p_status = 2;
		send_wrench_self(peer);
	}
	static void balloonomatic_dialog(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		string amount = parser.get("amount", 1);
		if (!is_number(amount)) return;
		int count = std::atoi(amount.c_str()), got = 0;
		std::string name_ = pInfo(peer)->world;
		std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			int x_ = pInfo(peer)->lastwrenchx, y_ = pInfo(peer)->lastwrenchy;
			World* world_ = &worlds[p - worlds.begin()];
			world_->fresh_world = true;
			WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
			Inventory::Modify(peer, pInfo(peer)->lastchoosenitem, got);
			if (got < count || got <= 0 || count <= 0 || count > items.size() || items[pInfo(peer)->lastchoosenitem].untradeable == 1 || pInfo(peer)->lastchoosenitem == 1424 || pInfo(peer)->lastchoosenitem == 5816 || items[pInfo(peer)->lastchoosenitem].rarity >= 200 || items[pInfo(peer)->lastchoosenitem].rarity < 1) return;
			int remove = count * -1;
			Inventory::Modify(peer, pInfo(peer)->lastchoosenitem, remove);
			vector<int> list{ 4844, 4844, 4844 , 4844, 4844, 4846 , 4846, 4848 };
			std::vector<std::pair<int, int>> receive_items;
			int rarity_got = (block_->shelf_1 + items[pInfo(peer)->lastchoosenitem].rarity * count) / 200, total_rarity = items[pInfo(peer)->lastchoosenitem].rarity * count;
			for (int i = 0; i < rarity_got; i++) {
				int item = list[rand() % list.size()];
				std::vector<std::pair<int, int>>::iterator p = find_if(receive_items.begin(), receive_items.end(), [&](const pair < int, int>& element) { return element.second == item; });
				if (p != receive_items.end()) {
					if (receive_items[p - receive_items.begin()].first < 200) receive_items[p - receive_items.begin()].first++;
				}
				else receive_items.push_back(std::make_pair(1, item));
			}
			if (receive_items.size() != 0) {
				sort(receive_items.begin(), receive_items.end());
				reverse(receive_items.begin(), receive_items.end());
				string received = "";
				for (int i = 0; i < receive_items.size(); i++) {
					int give_count = receive_items[i].first;
					if (Inventory::Modify(peer, receive_items[i].second, give_count) == 0) {
					}
					else {
						WorldDrop drop_block_{};
						drop_block_.id = receive_items[i].second, drop_block_.count = receive_items[i].first, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
						VisualHandle::Drop(world_, drop_block_);
					}
					received += ", " + to_string(receive_items[i].first) + " " + (items[receive_items[i].second].ori_name);
				}
				if (not received.empty()) {
					VarList::OnConsoleMessage(peer, "The `5Balloon-O-Matic ``whirs to life and creates" + received + ".");
				}
			}
			pInfo(peer)->balloon_donated += total_rarity;
			if (pInfo(peer)->balloon_donated >= 8000) {
				pInfo(peer)->balloon_donated -= 8000;
			}
			block_->shelf_1 += total_rarity;
			block_->shelf_1 += (total_rarity)-(rarity_got >= 1 ? rarity_got * 200 : 0);
			if (block_->shelf_1 > 250000 && rand() % 100 < 5) {
				block_->fg = 4832;
				block_->shelf_1 = 0;
				block_->shelf_1 = 0;
				for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
					if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
					if (pInfo(cp_)->world == pInfo(peer)->world) {
						update_tile(cp_, x_, y_, 4832, false, false);
						CAction::Effect_V2(cp_, 8, (float)x_ * 32 + 16, (float)y_ * 32 + 16);
					}
				}
				vector<int> list{ 4878,4920, 4922, 7528, 7526, 7524, 7520, 7522, 7506, 7508, 7510, 7512, }, rare_list{ 4842, 4856, 4884, 4858,4840, 4922, 4892, }, random_xy{ 1, 0, -1 };
				list.insert(list.end(), { 10428 + (pInfo(peer)->balloon_faction * 2), 4832 + (pInfo(peer)->balloon_faction * 2),4884 + (pInfo(peer)->balloon_faction * 2),4858 + (pInfo(peer)->balloon_faction * 2),4864 + (pInfo(peer)->balloon_faction * 2),4922 + (pInfo(peer)->balloon_faction * 2),4870 + (pInfo(peer)->balloon_faction * 2),4928 + (pInfo(peer)->balloon_faction * 2),4934 + (pInfo(peer)->balloon_faction * 2) });
				for (int i = 0; i < 3; i++) {
					int item = list[rand() % list.size()];
					WorldDrop drop_block_{};
					if (rand() % 2 < 1) item = rare_list[rand() % rare_list.size()];
					drop_block_.id = item, drop_block_.count = (item == 850 || item == 442 || item == 822 || item == 832 || item == 846 ? 10 : (item == 834 ? 5 : 1));
					int randomx = random_xy[rand() % random_xy.size()], randomy = random_xy[rand() % random_xy.size()];
					if (randomx + x_ > 0 && randomx + x_ < world_->max_x && randomy + y_ > 0 && randomy + y_ < world_->max_y) {
						if (world_->blocks[(x_ + randomx) + ((y_ + randomy) * 100)].fg != 0) drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						else drop_block_.x = ((x_ + randomx) * 32) + rand() % 17, drop_block_.y = ((y_ + randomy) * 32) + rand() % 17;
					}
					else drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					VisualHandle::Drop(world_, drop_block_);
				}
			}
		}
	}
	static void fruit_mixer_dialog(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "blend") {
				int total = pInfo(peer)->fruit_1_c + pInfo(peer)->fruit_2_c + pInfo(peer)->fruit_3_c;
				if (total == 50) {
					vector<int> list{ 13498, 13568, 13570 };
					if (pInfo(peer)->fruit_1 == 13502 || pInfo(peer)->fruit_2 == 13502 || pInfo(peer)->fruit_3 == 13502) {
						list.insert(list.end(), { 13528, 13486, 13502, 13526, 13502, 13526, 13502, 13526, 13502, 13526, 13502, 13526, 13502, 13526, 13502, 13526, 13502, 13526, 13502, 13526, 13502, 13526, 13502, 13526, 13502, 13526, 13502, 13526, 13502, 13526, 13502, 13526, 13502, 13526, 13502, 13526, 13502, 13526, 13502, 13526, 13502, 13526, 13502, 13526, 13502, 13526, 13502, 13526, 13502, 13526, 13502, 13526, 13502, 13526, 13502, 13526, 13502, 13526 });
					}
					if (pInfo(peer)->fruit_1 == 13540 || pInfo(peer)->fruit_2 == 13540 || pInfo(peer)->fruit_3 == 13540) {
						list.insert(list.end(), { 13532, 13488, 13520, 13518,13520, 13518,13520, 13518,13520, 13518,13520, 13518,13520, 13518,13520, 13518,13520, 13518,13520, 13518,13520, 13518,13520, 13518,13520, 13518,13520, 13518,13520, 13518,13520, 13518, 13520, 13518,13520, 13518,13520, 13518,13520, 13518,13520, 13518,13520, 13518,13520, 13518,13520, 13518,13520, 13518,13520, 13518,13520, 13518,13520, 13518,13520, 13518,13520, 13518,13520, 13518 });
					}
					if (pInfo(peer)->fruit_1 == 13542 || pInfo(peer)->fruit_2 == 13542 || pInfo(peer)->fruit_3 == 13542) {
						list.insert(list.end(), { 13534, 13490, 13516, 13514, 13516, 13514, 13516, 13514, 13516, 13514, 13516, 13514, 13516, 13514, 13516, 13514, 13516, 13514, 13516, 13514, 13516, 13514, 13516, 13514, 13516, 13514, 13516, 13514, 13516, 13514, 13516, 13514, 13516, 13514, 13516, 13514, 13516, 13514, 13516, 13514, 13516, 13514, 13516, 13514, 13516, 13514, 13516, 13514, 13516, 13514, 13516, 13514, 13516, 13514, 13516, 13514, 13516, 13514 });
					}
					if (pInfo(peer)->fruit_1 == 13538 || pInfo(peer)->fruit_2 == 13538 || pInfo(peer)->fruit_3 == 13538) {
						list.insert(list.end(), { 13536, 13492, 13510, 13512, 13510, 13512, 13510, 13512, 13510, 13512, 13510, 13512, 13510, 13512, 13510, 13512, 13510, 13512, 13510, 13512, 13510, 13512, 13510, 13512, 13510, 13512, 13510, 13512, 13510, 13512, 13510, 13512, 13510, 13512, 13510, 13512, 13510, 13512, 13510, 13512, 13510, 13512, 13510, 13512, 13510, 13512, 13510, 13512, 13510, 13512, 13510, 13512, 13510, 13512, 13510, 13512, 13510, 13512 });
					}
					if (pInfo(peer)->fruit_1 == 13544 || pInfo(peer)->fruit_2 == 13544 || pInfo(peer)->fruit_3 == 13544) {
						list.insert(list.end(), { 13530, 13494, 13500, 13522, 13524 , 13522, 13524,  13522, 13524 , 13522, 13524,  13522, 13524 , 13522, 13524,  13522, 13524 , 13522, 13524,  13522, 13524 , 13522, 13524,  13522, 13524 , 13522, 13524, 13522, 13524 , 13522, 13524 , 13522, 13524,  13522, 13524 , 13522, 13524,  13522, 13524 , 13522, 13524,  13522, 13524 , 13522, 13524,  13522, 13524 , 13522, 13524,  13522, 13524 , 13522, 13524, 13522, 13524 });
					}
					int free = Inventory::Get_Slots(pInfo(peer)), slot = 1, getcount = 1, inventoryfull = 0;
					if (free >= slot) {
						int itemid = list[rand() % list.size()];
						if (itemid == 13502 || itemid == 13526 || itemid == 13520 || itemid == 13518 || itemid == 13516 || itemid == 13514 || itemid == 13510 || itemid == 13512 || itemid == 13524) getcount = 8;
						else if (itemid == 13522) getcount = 20;
						else getcount = 1;
						int itemcount = 0;
						Inventory::Modify(peer, itemid, itemcount);
						if (itemcount + getcount > 200) inventoryfull = 1;
						if (inventoryfull == 0) {
							pInfo(peer)->fruit_1 = 0, pInfo(peer)->fruit_2 = 0, pInfo(peer)->fruit_3 = 0;
							pInfo(peer)->fruit_1_c = 0, pInfo(peer)->fruit_2_c = 0, pInfo(peer)->fruit_3_c = 0;
							int give_ = getcount;
							Inventory::Modify(peer, itemid, getcount);
							VarList::OnConsoleMessage(peer, "You received `2" + to_string(give_) + " " + items[itemid].ori_name + "`` from blending the fruits.");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You received `2" + to_string(give_) + " " + items[itemid].ori_name + "`` from blending the fruits.", 0, 1);
						}
					}
				}
			}
			if (button == "spp_slot_btn_") {
				std::vector<std::string> t_ = explode("|", cch);
				if (t_.size() < 3) return;
				std::string button_name = explode("\n", t_[3])[0].c_str();
				int slot = 1;
				if (button_name == "spp_slot_btn_0") {
					slot = 1;
					if (pInfo(peer)->fruit_1_c != 0) {
						int give_back = pInfo(peer)->fruit_1_c;
						if (Inventory::Modify(peer, pInfo(peer)->fruit_1, give_back) == 0) {
							pInfo(peer)->fruit_1 = 0;
							pInfo(peer)->fruit_1_c = 0;
						}
						else VarList::OnConsoleMessage(peer, "No inventory space.");
					}
				}
				else if (button_name == "spp_slot_btn_1") {
					slot = 2;
					if (pInfo(peer)->fruit_2_c != 0) {
						int give_back = pInfo(peer)->fruit_2_c;
						if (Inventory::Modify(peer, pInfo(peer)->fruit_2, give_back) == 0) {
							pInfo(peer)->fruit_2 = 0;
							pInfo(peer)->fruit_2_c = 0;
						}
						else VarList::OnConsoleMessage(peer, "No inventory space.");
					}
				}
				else if (button_name == "spp_slot_btn_2") {
					slot = 3;
					if (pInfo(peer)->fruit_3_c != 0) {
						int give_back = pInfo(peer)->fruit_3_c;
						if (Inventory::Modify(peer, pInfo(peer)->fruit_3, give_back) == 0) {
							pInfo(peer)->fruit_3 = 0;
							pInfo(peer)->fruit_3_c = 0;
						}
						else VarList::OnConsoleMessage(peer, "No inventory space.");
					}
				}
				int i_2734 = Inventory::Contains(peer, 2734), i_13538 = Inventory::Contains(peer, 13538), i_13540 = Inventory::Contains(peer, 13540), i_13542 = Inventory::Contains(peer, 13542), i_13544 = Inventory::Contains(peer, 13544);
				VarList::OnDialogRequest(peer, SetColor(peer) + "\nadd_label_with_icon|big|`wSuper Fruit Mixing Machine``|left|13548|\nadd_spacer|small|\nadd_textbox|Select a tropical fruit to put in `2Slot " + to_string(slot) + "``:|left|\nadd_spacer|small|\ntext_scaling_string|Defibrillators|\nadd_button_with_icon|" + (i_2734 == 0 || pInfo(peer)->fruit_1 == 2734 || pInfo(peer)->fruit_2 == 2734 || pInfo(peer)->fruit_3 == 2734 ? "" : "fruit_2734") + "|Pineapple|" + (i_2734 == 0 || pInfo(peer)->fruit_1 == 2734 || pInfo(peer)->fruit_2 == 2734 || pInfo(peer)->fruit_3 == 2734 ? "frame,disabled" : "staticPurpleFrame") + "|2734|" + to_string(i_2734) + "|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon|" + (i_13538 == 0 || pInfo(peer)->fruit_1 == 13538 || pInfo(peer)->fruit_2 == 13538 || pInfo(peer)->fruit_3 == 13538 ? "" : "fruit_13538") + "|Watermelon|" + (i_13538 == 0 || pInfo(peer)->fruit_1 == 13538 || pInfo(peer)->fruit_2 == 13538 || pInfo(peer)->fruit_3 == 13538 ? "frame,disabled" : "staticPurpleFrame") + "|13538|" + to_string(i_13538) + "|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon|" + (i_13540 == 0 || pInfo(peer)->fruit_1 == 13540 || pInfo(peer)->fruit_2 == 13540 || pInfo(peer)->fruit_3 == 13540 ? "" : "fruit_13540") + "|Kiwi|" + (i_13540 == 0 || pInfo(peer)->fruit_1 == 13540 || pInfo(peer)->fruit_2 == 13540 || pInfo(peer)->fruit_3 == 13540 ? "frame,disabled" : "staticPurpleFrame") + "|13540|" + to_string(i_13540) + "|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon|" + (i_13542 == 0 || pInfo(peer)->fruit_1 == 13542 || pInfo(peer)->fruit_2 == 13542 || pInfo(peer)->fruit_3 == 13542 ? "" : "fruit_13542") + "|Papaya|" + (i_13542 == 0 || pInfo(peer)->fruit_1 == 13542 || pInfo(peer)->fruit_2 == 13542 || pInfo(peer)->fruit_3 == 13542 ? "frame,disabled" : "staticPurpleFrame") + "|13542|" + to_string(i_13542) + "|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon|" + (i_13544 == 0 || pInfo(peer)->fruit_1 == 13544 || pInfo(peer)->fruit_2 == 13544 || pInfo(peer)->fruit_3 == 13544 ? "" : "fruit_13544") + "|Dragon Fruit|" + (i_13544 == 0 || pInfo(peer)->fruit_1 == 13544 || pInfo(peer)->fruit_2 == 13544 || pInfo(peer)->fruit_3 == 13544 ? "frame,disabled" : "staticPurpleFrame") + "|13544|" + to_string(i_13544) + "|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_custom_margin|x:0;y:10|\nadd_spacer|small|\nadd_button|goto_maindialog|Back|noflags|\nembed_data|slot|" + to_string(slot) + "\nend_dialog|fruit_mixer_choose_dialog|||");
			}
		}
	}
	static void fruit_mixer_choose_dialog(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "goto_maindialog") {
				VarList::OnDialogRequest(peer, SetColor(peer) + "\nadd_label_with_icon|big|`wSuper Fruit Mixing Machine``|left|13548|\nadd_spacer|small|\nadd_textbox|Combine 3 different types of tropical fruit into the mixer! Depending on which fruit you mix, the chance of receiving a tropical item related to that fruit increases.|left|\nadd_spacer|small|\nadd_textbox|The total number of fruits should add up to 50 to juice a new item.|left|\nadd_spacer|small|\ntext_scaling_string|Defibrillators|\nadd_button_with_icon|spp_slot_btn_0||staticGreyFrame|" + to_string(pInfo(peer)->fruit_1) + "|" + (pInfo(peer)->fruit_1_c == 0 ? "" : to_string(pInfo(peer)->fruit_1_c)) + "|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon|spp_slot_btn_1||staticGreyFrame|" + to_string(pInfo(peer)->fruit_2) + "|" + (pInfo(peer)->fruit_2_c == 0 ? "" : to_string(pInfo(peer)->fruit_2_c)) + "|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon|spp_slot_btn_2||staticGreyFrame|" + to_string(pInfo(peer)->fruit_3) + "|" + (pInfo(peer)->fruit_3_c == 0 ? "" : to_string(pInfo(peer)->fruit_3_c)) + "|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_textbox|Total Fruits: `4" + to_string(pInfo(peer)->fruit_1_c + pInfo(peer)->fruit_2_c + pInfo(peer)->fruit_3_c) + "``/50|left|\nadd_spacer|small|\nadd_button|" + (pInfo(peer)->fruit_1_c + pInfo(peer)->fruit_2_c + pInfo(peer)->fruit_3_c == 50 ? "blend" : "") + "|Blend Fruits|" + (pInfo(peer)->fruit_1_c + pInfo(peer)->fruit_2_c + pInfo(peer)->fruit_3_c == 50 ? "noflags" : "off") + "|0|0|\nadd_quick_exit|\nend_dialog|fruit_mixer_dialog|Close||");
			}
			if (button.substr(0, 6) == "fruit_") {
				int item = std::atoi(button.substr(6).c_str()), has = Inventory::Contains(peer, item);
				string slot_ = parser.get("slot", 1);
				int slot = std::atoi(slot_.c_str());
				if (item == 2734 || item == 13538 || item == 13540 || item == 13542 || item == 13544) {
					if (slot < 0 || slot > 3 || item < 0 || item > items.size() || has == 0) return;
					int total = pInfo(peer)->fruit_1_c + pInfo(peer)->fruit_2_c + pInfo(peer)->fruit_3_c;
					int only_need = (total == 0 ? 48 : 50 - total);
					if (total == 0) {
						only_need = 48;
					}
					else {
						int normal = 51;
						if (pInfo(peer)->fruit_1_c != 0) normal -= pInfo(peer)->fruit_1_c;
						else normal -= 1;
						if (pInfo(peer)->fruit_2_c != 0) normal -= pInfo(peer)->fruit_2_c;
						else normal -= 1;
						if (pInfo(peer)->fruit_3_c != 0) normal -= pInfo(peer)->fruit_3_c;
						else normal -= 1;
						only_need = normal;
					}
					int so_put = (only_need != 0 ? (has >= only_need ? only_need : has) : 0);
					VarList::OnDialogRequest(peer, SetColor(peer) + "\nadd_label_with_icon|big|`wSuper Fruit Mixing Machine``|left|13548|\nadd_textbox|How many `2" + items[item].ori_name + "`` would you like to put in the machine?|left|\nadd_textbox|You currently have `2" + to_string(has) + "`` in your inventory.|left|\nadd_text_input|count||" + to_string(so_put) + "|3|\nembed_data|slot|" + to_string(slot) + "\nembed_data|itemID|" + to_string(item) + "\nadd_spacer|small|\nadd_button|goto_choose_fruit_dialog|Back|noflags|\nadd_custom_button|add_fruit|textLabel:Put in Slot " + to_string(slot) + ";anchor:_button_goto_choose_fruit_dialog;left:1;margin:40,0;|\nadd_spacer|small|\nend_dialog|tropical_fruits_count_dialog|||");
				}
			}
		}
	}
	static void tropical_fruits_count_dialog(ENetPeer* peer, std::string cch) {
		std::vector<std::string> t_ = explode("|", cch);
		if (t_.size() < 8) return;
		int slot = std::atoi(explode("\n", t_[3])[0].c_str()), item = std::atoi(explode("\n", t_[5])[0].c_str()), has = Inventory::Contains(peer, item);
		string btn = explode("\n", t_[7])[0].c_str();
		if (btn == "goto_choose_fruit_dialog") {
		}
		else {
			if (item == 2734 || item == 13538 || item == 13540 || item == 13542 || item == 13544) {
				if (atoi(explode("\n", t_[8])[0].c_str()) <= 0 || atoi(explode("\n", t_[8])[0].c_str()) > 48) return;
				int add_ = std::atoi(explode("\n", t_[8])[0].c_str()) * -1;
				if (slot < 0 || slot > 3 || item < 0 || item > items.size() || has == 0 || abs(add_) <= 0) return;
				int total = pInfo(peer)->fruit_1_c + pInfo(peer)->fruit_2_c + pInfo(peer)->fruit_3_c;
				int only_need = (total == 0 ? 48 : 50 - total);
				if (total == 0) {
					only_need = 48;
				}
				else {
					int normal = 51;
					if (pInfo(peer)->fruit_1_c != 0) normal -= pInfo(peer)->fruit_1_c;
					else normal -= 1;
					if (pInfo(peer)->fruit_2_c != 0) normal -= pInfo(peer)->fruit_2_c;
					else normal -= 1;
					if (pInfo(peer)->fruit_3_c != 0) normal -= pInfo(peer)->fruit_3_c;
					else normal -= 1;
					only_need = normal;
				}
				if (abs(add_) > only_need) add_ = only_need * -1;
				if (slot == 1) {
					pInfo(peer)->fruit_1 = item;
					pInfo(peer)->fruit_1_c += abs(add_);
				}
				else if (slot == 2) {
					pInfo(peer)->fruit_2 = item;
					pInfo(peer)->fruit_2_c += abs(add_);
				}
				else if (slot == 3) {
					pInfo(peer)->fruit_3 = item;
					pInfo(peer)->fruit_3_c += abs(add_);
				}
				Inventory::Modify(peer, item, add_);
			}
		}
		VarList::OnDialogRequest(peer, SetColor(peer) + "\nadd_label_with_icon|big|`wSuper Fruit Mixing Machine``|left|13548|\nadd_spacer|small|\nadd_textbox|Combine 3 different types of tropical fruit into the mixer! Depending on which fruit you mix, the chance of receiving a tropical item related to that fruit increases.|left|\nadd_spacer|small|\nadd_textbox|The total number of fruits should add up to 50 to juice a new item.|left|\nadd_spacer|small|\ntext_scaling_string|Defibrillators|\nadd_button_with_icon|spp_slot_btn_0||staticGreyFrame|" + to_string(pInfo(peer)->fruit_1) + "|" + (pInfo(peer)->fruit_1_c == 0 ? "" : to_string(pInfo(peer)->fruit_1_c)) + "|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon|spp_slot_btn_1||staticGreyFrame|" + to_string(pInfo(peer)->fruit_2) + "|" + (pInfo(peer)->fruit_2_c == 0 ? "" : to_string(pInfo(peer)->fruit_2_c)) + "|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon|spp_slot_btn_2||staticGreyFrame|" + to_string(pInfo(peer)->fruit_3) + "|" + (pInfo(peer)->fruit_3_c == 0 ? "" : to_string(pInfo(peer)->fruit_3_c)) + "|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_textbox|Total Fruits: `4" + to_string(pInfo(peer)->fruit_1_c + pInfo(peer)->fruit_2_c + pInfo(peer)->fruit_3_c) + "``/50|left|\nadd_spacer|small|\nadd_button|" + (pInfo(peer)->fruit_1_c + pInfo(peer)->fruit_2_c + pInfo(peer)->fruit_3_c == 50 ? "blend" : "") + "|Blend Fruits|" + (pInfo(peer)->fruit_1_c + pInfo(peer)->fruit_2_c + pInfo(peer)->fruit_3_c == 50 ? "noflags" : "off") + "|0|0|\nadd_quick_exit|\nend_dialog|fruit_mixer_dialog|Close||");
	}
	static void bulletin_edit(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "clear") {
				std::string name_ = pInfo(peer)->world;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					world_->fresh_world = true;
					WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
					if (Only_Access(peer, world_, block_) == false && !guild_access(peer, world_->guild_id)) return;
					if (items[block_->fg].blockType == BlockTypes::BULLETIN_BOARD || items[block_->fg].blockType == BlockTypes::MAILBOX) {
						for (int i_ = 0; i_ < world_->bulletin.size(); i_++) {
							if (world_->bulletin[i_].x == pInfo(peer)->lastwrenchx and world_->bulletin[i_].y == pInfo(peer)->lastwrenchy) {
								world_->bulletin.erase(world_->bulletin.begin() + i_);
								i_--;
							}
						}
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, items[pInfo(peer)->lastwrenchb].blockType == BlockTypes::MAILBOX ? "`2Mailbox emptied.``" : "`2Text cleared.``", 0, 0);
						if (block_->flags & 0x00400000) block_->flags ^= 0x00400000;
						PlayerMoving data_{};
						data_.packetType = 5, data_.punchX = pInfo(peer)->lastwrenchx, data_.punchY = pInfo(peer)->lastwrenchy, data_.characterState = 0x8;
						BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
						BYTE* blc = raw + 56;
						form_visual(blc, *block_, *world_, peer, false);
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
							if (pInfo(peer)->world != pInfo(cp_)->world) continue;
							send_raw(cp_, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
						}
						delete[] raw, blc;
						if (block_->locked) upd_lock(*block_, *world_, peer);
					}
				}
			}
			if (button.substr(0, 4) == "edit") {
				pInfo(peer)->lastchoosennr = std::atoi(button.substr(4).c_str());
				std::string name_ = pInfo(peer)->world;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
					for (int i_ = 0; i_ < world_->bulletin.size(); i_++) {
						if (i_ == pInfo(peer)->lastchoosennr) {
							if (Only_Access(peer, world_, block_) == false && !guild_access(peer, world_->guild_id) or items[block_->fg].blockType != BlockTypes::BULLETIN_BOARD) return;
							if (pInfo(peer)->lastchoosennr > world_->bulletin.size() || pInfo(peer)->lastchoosennr < 0) return;
							world_->fresh_world = true;
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|small|Remove`` \"`w" + world_->bulletin[pInfo(peer)->lastchoosennr].text + "\"`` from your board?|left|" + to_string(pInfo(peer)->lastwrenchb) + "|\nend_dialog|remove_bulletin|Cancel|OK|");
						}
					}
				}
			}
			if (button == "send") {
				if (cch.find("sign_text|") != string::npos) {
					std::vector<std::string> t_ = explode("|", cch);
					if (t_.size() < 4) return;
					string text = explode("\n", t_[4])[0].c_str();
					replace_str(text, "\n", "");
					replace_str(text, "<CR>", "");
					if (text.length() <= 2 || text.length() >= 100) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "That's not interesting enough to post.", 0, 0);
					}
					else {
						std::string name_ = pInfo(peer)->world;
						std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
						if (p != worlds.end()) {
							{
								World* world_ = &worlds[p - worlds.begin()];
								world_->fresh_world = true;
								if (items[pInfo(peer)->lastwrenchb].blockType == BlockTypes::MAILBOX || items[pInfo(peer)->lastwrenchb].blockType == BlockTypes::BULLETIN_BOARD) {
									int letter = 0;
									for (int i_ = 0; i_ < world_->bulletin.size(); i_++) if (world_->bulletin[i_].x == pInfo(peer)->lastwrenchx and world_->bulletin[i_].y == pInfo(peer)->lastwrenchy) letter++;
									if (letter == 21) world_->bulletin.erase(world_->bulletin.begin() + 0);
									WorldBulletin bulletin_{};
									bulletin_.x = pInfo(peer)->lastwrenchx, bulletin_.y = pInfo(peer)->lastwrenchy;
									if (pInfo(peer)->name_color == "`p@" || pInfo(peer)->name_color == "`8@" || pInfo(peer)->name_color == "`6@" || pInfo(peer)->name_color == "`b@" || pInfo(peer)->name_color == "`#@" || pInfo(peer)->name_color == "`0") bulletin_.name = (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + "``";
									else bulletin_.name = "`0" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) + "``";
									bulletin_.text = text;
									world_->bulletin.push_back(bulletin_);
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, items[pInfo(peer)->lastwrenchb].blockType == BlockTypes::MAILBOX ? "`2You place your letter in the " + items[pInfo(peer)->lastwrenchb].name + ".``" : "`2Bulletin posted.``", 0, 0);
									if (items[pInfo(peer)->lastwrenchb].blockType == BlockTypes::MAILBOX) {
										WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
										block_->flags = (block_->flags & 0x00400000 ? block_->flags : block_->flags | 0x00400000);
										PlayerMoving data_{};
										data_.packetType = 5, data_.punchX = pInfo(peer)->lastwrenchx, data_.punchY = pInfo(peer)->lastwrenchy, data_.characterState = 0x8;
										BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
										BYTE* blc = raw + 56;
										form_visual(blc, *block_, *world_, peer, false, true);
										for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
											if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(peer)->world != pInfo(cp_)->world) continue;
											send_raw(cp_, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
										}
										delete[] raw, blc;
										if (block_->locked) upd_lock(*block_, *world_, peer);
									}
								}
							}
						}
					}
				}
			}
		}
		else {
			if (cch.find("sign_text|\ncheckbox_locked|") != string::npos) {
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [&](const World& a) { return a.name == pInfo(peer)->world; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					world_->fresh_world = true;
					WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
					if (Only_Access(peer, world_, block_) == false or items[block_->fg].blockType != BlockTypes::BULLETIN_BOARD) return;
					int minimum = 6;
					std::vector<std::string> t_ = explode("|", cch);
					if (t_.size() < minimum) return;
					block_->spin = std::atoi(explode("\n", t_[minimum - 2])[0].c_str());
					block_->invert = std::atoi(explode("\n", t_[minimum - 1])[0].c_str());
				}
				return;
			}
		}
	}
	static void storageboxxtreme(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = ""; int item = 0;
		if (parser.try_get("itemid", item)) {
			if (item <= 0 || item >= items.size() || items[pInfo(peer)->lastwrenchb].blockType != BlockTypes::STORAGE) return;
			if (pInfo(peer)->lastwrenchb != 4516 and items[item].untradeable == 1 or item == 1424 or item == 5816) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You can't store Untradeable items there!", 0, 0);
			}
			else if (pInfo(peer)->lastwrenchb == 4516 and items[item].untradeable == 0 or item == 18 || item == 32 || item == 6336 || item == 9384 || item == 1424 || item == 5816 || item == 8430) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You can't store Tradeable items there!", 0, 0);
			}
			else {
				int receive = Inventory::Contains(peer, item);
				if (receive == 0) return;
				pInfo(peer)->lastchoosenitem = item;
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`w" + items[pInfo(peer)->lastwrenchb].name + "``|left|" + to_string(pInfo(peer)->lastwrenchb) + "|\nadd_textbox|You have " + to_string(receive) + " " + items[item].name + ". How many to store?|left|\nadd_text_input|itemcount||" + to_string(receive) + "|3|\nadd_spacer|small|\nadd_button|do_add|Store Items|noflags|0|0|\nend_dialog|storageboxxtreme|Cancel||\n");
			}
		}
		else if (parser.try_get("buttonClicked", button)) {
			std::string name_ = pInfo(peer)->world;
			std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				world_->fresh_world = true;
				WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
				if (items[block_->fg].blockType != BlockTypes::STORAGE) return;
				if (button == "change_password") {
					if (Only_Access(peer, world_, block_) == false && !guild_access(peer, world_->guild_id)) return;
					if (block_->fg == 8878) {
						if (Only_Access(peer, world_, block_, false, true)) {
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSafe Vault``|left|8878|\nadd_smalltext|The ingenious minds at GrowTech bring you the `2Safe Vault`` - a place to store your items safely with its integrated password option!|left|\nadd_smalltext|How the password works:|left|\nadd_smalltext|The Safe Vault requires both a `2password`` and a `2recovery answer`` to be entered to use a password.|left|\nadd_smalltext|Enter your `2password`` and `2recovery answer`` below - keep them safe and `4DO NOT`` share them with anyone you do not trust!|left|\nadd_smalltext|The password and recovery answer can be no longer than 12 characters in length - number and alphabet only please, no special characters are allowed!|left|\nadd_smalltext|If you forget your password, enter your recovery answer to access the Safe Vault - The Safe Vault will `4NOT be password protected now``. You will need to enter a new password.|left|\nadd_smalltext|You can change your password, however you will need to enter the old password before a new one can be used.|left|\nadd_smalltext|`4WARNING``: DO NOT forget your password and recovery answer or you will not be able to access the Safe Vault!|left|\nadd_textbox|`4There is no password currently set on this Safe Vault.``|left|\nadd_textbox|Enter a new password.|left|\nadd_text_input_password|storage_newpassword|||18|\nadd_textbox|Enter a recovery answer.|left|\nadd_text_input|storage_recoveryanswer|||12|\nadd_button|s_password|Update Password|noflags|0|0|\nend_dialog|ss_storage|Exit||\nadd_quick_exit|");
						}
					}
				}
				if (button == "cancel") {
					if (to_lower(world_->owner_name) == to_lower(pInfo(peer)->tankIDName) || Role::Administrator(peer)) DialogHandle::Storage_Box(peer, world_, block_);
				}
				if (button == "do_take") {
					if (cch.find("itemcount|") != string::npos) {
						int itemnr = pInfo(peer)->lastchoosennr, countofremoval = std::atoi(cch.substr(83, cch.length() - 83).c_str()), removed = countofremoval, itemcount = 0;
						if (countofremoval <= 0 || items[pInfo(peer)->lastwrenchb].blockType != BlockTypes::STORAGE) return;
						if (world_->sbox1.size() > itemnr) {
							if (Only_Access(peer, world_, block_, false, true)) {
								if (world_->sbox1[itemnr].x == pInfo(peer)->lastwrenchx and world_->sbox1[itemnr].y == pInfo(peer)->lastwrenchy) {
									if (world_->sbox1[itemnr].count <= 0) return;
									if (countofremoval <= world_->sbox1[itemnr].count) {
										if (Inventory::Modify(peer, world_->sbox1[itemnr].id, countofremoval) == 0) {
											world_->sbox1[itemnr].count -= removed;
											VarList::OnConsoleMessage(peer, "Removed `w" + to_string(removed) + " " + items[world_->sbox1[itemnr].id].name + "`` in the " + items[pInfo(peer)->lastwrenchb].name + ".");
											VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Removed `w" + to_string(removed) + " " + items[world_->sbox1[itemnr].id].name + "`` in the " + items[pInfo(peer)->lastwrenchb].name + ".", 0, 0);
											PlayerMoving data_{};
											data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = world_->sbox1[itemnr].id, data_.punchY = pInfo(peer)->netID;
											int32_t to_netid = pInfo(peer)->netID;
											BYTE* raw = packPlayerMoving(&data_);
											raw[3] = 5;
											Memory_Copy(raw + 8, &to_netid, 4);
											send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											delete[] raw;
											if (world_->sbox1[itemnr].count <= 0) world_->sbox1.erase(world_->sbox1.begin() + itemnr);
										}
									}
								}
							}
						}
					}
				}
				if (button.find("searchableItemListButton") != string::npos) {
					std::regex number_regex("\\d+");
					std::smatch matches;
					int id = 0, count = 0;
					auto search_start = button.cbegin();
					for (int match_index = 0; std::regex_search(search_start, button.cend(), matches, number_regex); ++match_index) {
						int number = std::stoi(matches[0]);
						if (match_index == 0) id = number;
						else if (match_index == 1) count = number;
						search_start = matches.suffix().first;
					}
					if (id < 0 or id > items.size() or count < 0) return;
					std::string name_ = pInfo(peer)->world;
					std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
					if (p != worlds.end()) {
						World* world_ = &worlds[p - worlds.begin()];
						world_->fresh_world = true;
						WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
						if (items[block_->fg].blockType != BlockTypes::STORAGE) return;
						if (Only_Access(peer, world_, block_, false, true)) {
							for (int i_ = 0; i_ < world_->sbox1.size(); i_++) {
								if (world_->sbox1[i_].x == pInfo(peer)->lastwrenchx and world_->sbox1[i_].y == pInfo(peer)->lastwrenchy and world_->sbox1[i_].id == id) {
									pInfo(peer)->lastchoosennr = i_;
									int have = Inventory::Contains(peer, world_->sbox1[i_].id), set_have = world_->sbox1[i_].count;
									if (have != 0) {
										if (world_->sbox1[i_].count >= 200 - have) set_have = 200 - have;
									}
									VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`w" + items[pInfo(peer)->lastwrenchb].name + "``|left|" + to_string(pInfo(peer)->lastwrenchb) + "|\nadd_textbox|You have `w" + to_string(world_->sbox1[i_].count) + " " + items[world_->sbox1[i_].id].name + "`` stored.|left|\nadd_textbox|Withdraw how many?|left|\nadd_text_input|itemcount||" + to_string(set_have) + "|3|\nadd_spacer|small|\nadd_button|do_take|Remove Items|noflags|0|0|\nadd_button|cancel|Back|noflags|0|0|\nend_dialog|storageboxxtreme|Exit||\n");
								}
							}
						}
					}
				}
				if (button == "do_add") {
					string itemcount = parser.get("itemcount", 1);
					if (!is_number(itemcount)) return;
					int count = std::atoi(itemcount.c_str());
					if (pInfo(peer)->lastchoosenitem <= 0 || pInfo(peer)->lastchoosenitem >= items.size() || items[pInfo(peer)->lastwrenchb].blockType != BlockTypes::STORAGE) return;
					if (pInfo(peer)->lastwrenchb != 4516 and items[pInfo(peer)->lastchoosenitem].untradeable == 1 or pInfo(peer)->lastchoosenitem == 1424 or pInfo(peer)->lastchoosenitem == 5816 or items[pInfo(peer)->lastchoosenitem].blockType == BlockTypes::FISH) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You can't store Untradeable items there!", 0, 0);
					}
					else if (pInfo(peer)->lastwrenchb == 4516 and items[pInfo(peer)->lastchoosenitem].untradeable == 0 or pInfo(peer)->lastchoosenitem == 1424 or pInfo(peer)->lastchoosenitem == 5816 || items[pInfo(peer)->lastchoosenitem].blockType == BlockTypes::FISH || pInfo(peer)->lastchoosenitem == 18 || pInfo(peer)->lastchoosenitem == 32 || pInfo(peer)->lastchoosenitem == 9384 || pInfo(peer)->lastchoosenitem == 6336 || pInfo(peer)->lastchoosenitem == 8430) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You can't store Tradeable items there!", 0, 0);
					}
					else {
						int itemcount_ = 0, got = 0, receive = 0;
						Inventory::Modify(peer, pInfo(peer)->lastchoosenitem, got);
						if (count <= 0 || count > got) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have that many!", 0, 0);
						}
						else {
							receive = count * -1;
							std::string name_ = pInfo(peer)->world;
							std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								world_->fresh_world = true;
								WorldBlock block_ = world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
								for (int i_ = 0; i_ < world_->sbox1.size(); i_++) {
									if (world_->sbox1[i_].x == pInfo(peer)->lastwrenchx and world_->sbox1[i_].y == pInfo(peer)->lastwrenchy) {
										itemcount_++;
									}
								}
								if (itemcount_ >= items[pInfo(peer)->lastwrenchb].box_size or items[pInfo(peer)->lastchoosenitem].untradeable == 1 && block_.fg != 4516) return;
								if (items[block_.fg].blockType != BlockTypes::STORAGE) return;
								VarList::OnConsoleMessage(peer, "Stored `w" + to_string(count) + " " + items[pInfo(peer)->lastchoosenitem].name + "`` in " + items[pInfo(peer)->lastwrenchb].name + ".");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Stored `w" + to_string(count) + " " + items[pInfo(peer)->lastchoosenitem].name + "`` in " + items[pInfo(peer)->lastwrenchb].name + ".", 0, 0);
								Inventory::Modify(peer, pInfo(peer)->lastchoosenitem, receive);
								bool dublicated = true;
								for (int i_ = 0; i_ < world_->sbox1.size(); i_++) {
									if (dublicated) {
										if (world_->sbox1[i_].x == pInfo(peer)->lastwrenchx and world_->sbox1[i_].y == pInfo(peer)->lastwrenchy and world_->sbox1[i_].id == pInfo(peer)->lastchoosenitem and world_->sbox1[i_].count + count <= 200) {
											world_->sbox1[i_].count += count;
											dublicated = false;
										}
									}
								}
								if (dublicated) {
									WorldSBOX1 sbox1_{};
									sbox1_.x = pInfo(peer)->lastwrenchx, sbox1_.y = pInfo(peer)->lastwrenchy;
									sbox1_.id = pInfo(peer)->lastchoosenitem, sbox1_.count = count;
									world_->sbox1.push_back(sbox1_);
								}
								PlayerMoving data_{};
								data_.packetType = 19, data_.netID = -1, data_.plantingTree = 0;
								data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16;
								data_.XSpeed = pInfo(peer)->x + 16, data_.YSpeed = pInfo(peer)->y + 16;
								data_.punchX = pInfo(peer)->lastchoosenitem;
								BYTE* raw = packPlayerMoving(&data_);
								raw[3] = 6;
								send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								delete[] raw;
								DialogHandle::Storage_Box(peer, world_, &block_);
							}
						}
					}
				}
			}
		}
	}
	static void giantpotogold(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		string amt = parser.get("amt", 1);
		int count = std::atoi(amt.c_str()), got = 0;
		Inventory::Modify(peer, pInfo(peer)->lastchoosenitem, got);
		if (got <= 0 || count <= 0 || count > items.size()) return;
		int item = pInfo(peer)->lastchoosenitem;
		if (items[item].untradeable == 1 || item == 1424 || item == 5816 || items[item].rarity >= 363 || items[item].rarity == 0 || items[item].rarity < 1 || count > got) {
			gamepacket_t p;
			p.Insert("OnTalkBubble");
			p.Insert(pInfo(peer)->netID);
			if (count > got) p.Insert("You don't have that to give!");
			else p.Insert("I'm sorry, we can't accept items without rarity!");
			p.Insert(0), p.Insert(0);
			p.CreatePacket(peer);
		}
		else {
			pInfo(peer)->b_ra += count * items[item].rarity;
			Inventory::Modify(peer, pInfo(peer)->lastchoosenitem, count *= -1);
			if (pInfo(peer)->b_ra >= 20000) pInfo(peer)->b_lvl = 2;
			int chance = 29;
			if (pInfo(peer)->b_ra > 25000) chance += 7;
			if (pInfo(peer)->b_ra > 40000) chance += 25;
			if (rand() % 100 < chance && pInfo(peer)->b_ra >= 20000) {
				int give_count = 1, given_count = 1;
				vector<int> list{ 7978,5734, 7986,5724,7980,7990,5730,5726,5728,7988,7992 };
				if (pInfo(peer)->b_ra >= 40000 && rand() % 100 < 15) list = { 7978,5734, 7986,5724,7980,7990,5730,5726,5728,7988,7992, 7996,5718,5720,9418,5732,5722,8000,5740,8002,9414,11728,11730 };
				int given_item = list[rand() % list.size()];
				if (given_item == 7978 || given_item == 5734 || given_item == 7986 || given_item == 5724 || given_item == 7992 || given_item == 7980 || given_item == 7990) give_count = 5, given_count = 5;
				if (given_item == 5730 || given_item == 5726 || given_item == 5728 || given_item == 7988 || given_item == 7980 || given_item == 7990) give_count = 10, given_count = 10;
				if (Inventory::Modify(peer, given_item, given_count) == 0) {
					gamepacket_t p, p2;
					p.Insert("OnConsoleMessage"), p.Insert(a + "Thanks for your generosity! The pot overflows with `6" + (pInfo(peer)->b_ra < 40000 ? "20" : "40") + ",000 rarity``! Your `6Level 2 prize`` is a fabulous `2" + items[given_item].name + "!``"), p.CreatePacket(peer);
					p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert(a + "Thanks for your generosity! The pot overflows with `6" + (pInfo(peer)->b_ra < 40000 ? "20" : "40") + ",000 rarity``! Your `6Level 2 prize`` is a fabulous `2" + items[given_item].name + "!``"), p2.Insert(0), p2.Insert(0), p2.CreatePacket(peer);
					pInfo(peer)->b_lvl = 1, pInfo(peer)->b_ra = 0;
				}
				else {
					VarList::OnConsoleMessage(peer, "No inventory space.");
				}
			}
			else {
				gamepacket_t p;
				p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Thank you for your generosity!"), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
			}
		}
	}
	static void transmutated_linkitem_edit(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = ""; int itemnr = 0;
		if (parser.try_get("linkitemid", itemnr)) {
			int got = Inventory::Contains(peer, itemnr);
			if (itemnr <= 0 || itemnr > items.size() || got == 0) return;
			if (itemnr == pInfo(peer)->transmute_item1) {
				pInfo(peer)->transmute_item1 = 0, pInfo(peer)->transmute_item2 = 0;
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`4You can't transmute the same item... that would be silly!``", 0, 0);
				return;
			}
			else if (items[pInfo(peer)->transmute_item1].clothType != items[itemnr].clothType) {
				pInfo(peer)->transmute_item1 = 0, pInfo(peer)->transmute_item2 = 0;
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`4" + items[itemnr].ori_name + "`` does not fit in the Transmutabooth.", 0, 0);
				return;
			}
			pInfo(peer)->transmute_item2 = itemnr;
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wTransmutabooth``|left|9170|\nadd_spacer|small|\nadd_textbox|This item is about to get a NEW look! |left|\nadd_label_with_icon|small|" + items[pInfo(peer)->transmute_item1].ori_name + "``|left|" + to_string(pInfo(peer)->transmute_item1) + "|\nadd_spacer|small|\nadd_textbox|This is the item it's going to look like:|left|\nadd_label_with_icon|small|" + items[pInfo(peer)->transmute_item2].ori_name + "``|left|" + to_string(pInfo(peer)->transmute_item2) + "|\nadd_spacer|small|\nadd_textbox|`4Warning:`` There are no mods on your target - this transmute is kind of a waste! Are you SURE you want to proceed?``|left|\nadd_spacer|small|\nadd_textbox|Ready to go? Remember, your `4" + items[pInfo(peer)->transmute_item2].ori_name + "`` will be HELD in the Transmutabooth to power this change until you end the transmutation!|left|\nadd_spacer|small|\nadd_button|permanenttransmutation|I know - do it anyway!|noflags|0|0|\nadd_spacer|small|\nadd_button|fromBothItemBackToModes|Back|noflags|0|0|\nend_dialog|transmutated_linkitem_edit|Cancel||\nadd_quick_exit|");
		}
		if (parser.try_get("buttonClicked", button)) {
			if (button == "fromBothItemBackToModes") {
				if (pInfo(peer)->transmute.size() >= 12) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You have reached the limit of Transmutabooth.", 0, 0);
					return;
				}
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wTransmutabooth``|left|9170|\nadd_spacer|small|\nadd_textbox|Tired of how an item looks but want to keep its abilities? Here is where you can overwrite its appearance with that of another item from the SAME slot!|left|\nadd_textbox|Cost: `210,000`` Gems.|left|\nadd_spacer|small|\nadd_textbox|To begin, you'll need to pick the item you want to change (its mods will remain)...|left|\nadd_spacer|small|\nadd_item_picker|mainitemid|`wStart Transmuting!``|Choose the item you want to change!|\nadd_spacer|small|\nadd_button|beforeMainBackToModes|Back|noflags|0|0|\nend_dialog|transmutated_device_edit|Close||\nadd_quick_exit|");
			}
			if (button == "permanenttransmutation") {
				if (items[pInfo(peer)->transmute_item1].clothType != items[pInfo(peer)->transmute_item2].clothType or pInfo(peer)->transmute_item2 == pInfo(peer)->transmute_item1) {
					pInfo(peer)->transmute_item1 = 0, pInfo(peer)->transmute_item2 = 0;
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`4You can't transmute the that item... that would be silly!``", 0, 0);
					return;
				}
				if (pInfo(peer)->gems >= 10000) {
					int got1 = 0, got2 = 0;
					Inventory::Modify(peer, pInfo(peer)->transmute_item1, got1);
					Inventory::Modify(peer, pInfo(peer)->transmute_item2, got2);
					if (got1 == 0 or got2 == 0) return;
					int remove = -1;
					Inventory::Modify(peer, pInfo(peer)->transmute_item2, remove);
					VarList::OnBuxGems(peer, 10000 * -1);
					pInfo(peer)->transmute.push_back(std::make_pair(pInfo(peer)->transmute_item1, pInfo(peer)->transmute_item2));
					pInfo(peer)->transmute_item1 = 0, pInfo(peer)->transmute_item2 = 0;
					Clothing_V2::Update_Value(peer);
					Clothing_V2::Update(peer);
				}
				else {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough gems!", 0, false);
				}
			}
		}
	}
	static void valentines_quest(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "claimreward" and Event()->Valentine) {
				std::string name_ = pInfo(peer)->world;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					if (pInfo(peer)->booty_broken >= 100) {
						WorldDrop drop_block_{};
						pInfo(peer)->booty_broken -= 100;
						if (Event()->Valentine) VarList::OnProgressUIUpdateValue(peer, pInfo(peer)->booty_broken, 100);
						int c_ = 1;
						if (Inventory::Modify(peer, 9350, c_) != 0) {
							drop_block_.id = 9350, drop_block_.count = 1, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
							VisualHandle::Drop(world_, drop_block_);
						}
						VarList::OnConsoleMessage(peer, "You received " + items[9350].name + "!");
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You received " + items[9350].name + "!", 0, 1);
						PlayerMoving data_{};
						data_.packetType = 19, data_.plantingTree = 0, data_.netID = 0, data_.punchX = 9350, data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16;
						int32_t to_netid = pInfo(peer)->netID;
						BYTE* raw = packPlayerMoving(&data_);
						raw[3] = 5;
						Memory_Copy(raw + 8, &to_netid, 4);
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(cp_)->world != world_->name) continue;
							send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
						delete[]raw;
					}
				}
			}
		}
	}
	static void wishing_well(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "wishing_well") {
				std::string name_ = pInfo(peer)->world;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					world_->fresh_world = true;
					WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
					if (not Only_Access(peer, world_, block_) or block_->fg != 10656 or block_->shelf_1 >= 200) return;
					int got = 0;
					Inventory::Modify(peer, 3402, got);
					if (got >= 5) {
						got = 5;
						int remove_ = -1 * got;
						Inventory::Modify(peer, 3402, remove_);
						block_->shelf_1 += got;
						drop_valentine_box(peer, world_, block_, pInfo(peer)->lastwrenchx, pInfo(peer)->lastwrenchy, true, 5);
						if (block_->shelf_1 >= 200) {
							block_->planted = 0;
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = pInfo(peer)->lastwrenchx, data_.punchY = pInfo(peer)->lastwrenchy, data_.characterState = 0x8;
							int alloc = alloc_(world_, block_);
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc);
							BYTE* blc = raw + 56;
							form_visual(blc, *block_, *world_, peer, false);
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
								if (pInfo(cp_)->world == world_->name) {
									send_raw(cp_, 4, raw, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw, blc;
							if (block_->locked) upd_lock(*block_, *world_, peer);
						}
					}
				}
			}
		}
	}
	static void daily_login(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "claim_dailybonus") {
				if (pInfo(peer)->claimed_daily_today or pInfo(peer)->is_day > 7) return;
				int id_ = 0, count_ = 0;
				if (pInfo(peer)->is_day == 1) id_ = 9266, count_ = 1;
				if (pInfo(peer)->is_day == 2) id_ = 14084, count_ = 15;
				if (pInfo(peer)->is_day == 3) id_ = 242, count_ = 20;
				if (pInfo(peer)->is_day == 4) id_ = 7960, count_ = 10;
				if (pInfo(peer)->is_day == 5) id_ = 1796, count_ = 1;
				if (pInfo(peer)->is_day == 6) id_ = 10400, count_ = 1;
				if (id_ != 0) {
					Inventory::Modify(peer, id_, count_);
				}
				pInfo(peer)->daily_login.push_back(pInfo(peer)->is_day);
				pInfo(peer)->claimed_daily_today = true;
				VarList::OnAddNotification(peer, "You claimed your Daily Rewards : DAY " + to_string(pInfo(peer)->is_day) + "!", "interface/guide_arrow.rttex", "audio/piano_nice.wav.wav");
				PlayerMoving data_{};
				data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
				BYTE* raw = packPlayerMoving(&data_);
				send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				delete[] raw;
			}
		}
	}
	static void ancient_goddess(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "ancient_goddess_dialog") {
				int current_ances = current_ances = pInfo(peer)->ances, item_1 = 0, item_2 = 0, item_3 = 0, req_1 = 0, req_2 = 0, req_3 = 1, id_req_1 = 0, id_req_2 = 0, id_req_3 = 0;
				bool can_upgrade = false, stone = false, item1 = false, item2 = false, item3 = false;
				string item_1_text = "", item_2_text = "", item_3_text = "";
				string soul_ = "";
				int soul_stone = Inventory::Contains(peer, 5202);
				for (const auto& list : Environment()->Ancient_Riddle) {
					id_req_3 = list.first;
					item_3_text = list.second;
				}
				/*Totem of Wisdom*/
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Totem of Wisdom : Level 2") {
					req_1 = 1, req_2 = 1, id_req_1 = 5104, id_req_2 = 5074;
					item_1 = Inventory::Contains(peer, id_req_1), item_2 = Inventory::Contains(peer, id_req_2), item_3 = Inventory::Contains(peer, id_req_3);
					item_1_text = "\nadd_textbox|`8- " + items[id_req_1].description + " (" + to_string(item_1) + "/" + to_string(req_1) + ")|left|", item_2_text = "\nadd_textbox|`8- " + items[id_req_2].description + " (" + to_string(item_2) + "/" + to_string(req_2) + ")|left|";
					soul_ = "\nadd_textbox|`8- " + items[5202].description + " (" + to_string(soul_stone) + "/1)|left|";
					if (soul_stone >= 1) {
						stone = true;
						soul_ = "\nadd_textbox|`2- 1 Soul Stone (OK!)|left|";
					}
					if (item_1 >= req_1) {
						item1 = true;
						item_1_text = "\nadd_textbox|`2- " + to_string(req_1) + " " + items[id_req_1].name + " (OK!)|left|";
					}
					if (item_2 >= req_2) {
						item2 = true;
						item_2_text = "\nadd_textbox|`2- " + to_string(req_2) + " " + items[id_req_2].name + " (OK!)|left|";
					}
					if (item_3 >= req_3) {
						item3 = true;
						item_3_text = "\nadd_textbox|`2- " + to_string(req_3) + " " + items[id_req_3].name + " (OK!)|left|";
					}
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Totem of Wisdom : Level 3") {
					req_1 = 1, req_2 = 1, id_req_1 = 5106, id_req_2 = 5074;
					item_1 = Inventory::Contains(peer, id_req_1), item_2 = Inventory::Contains(peer, id_req_2), item_3 = Inventory::Contains(peer, id_req_3);
					item_1_text = "\nadd_textbox|`8- " + items[id_req_1].description + " (" + to_string(item_1) + "/" + to_string(req_1) + ")|left|", item_2_text = "\nadd_textbox|`8- " + items[id_req_2].description + " (" + to_string(item_2) + "/" + to_string(req_2) + ")|left|";
					soul_ = "\nadd_textbox|`8- " + items[5202].description + " (" + to_string(soul_stone) + "/1)|left|";
					if (soul_stone >= 1) {
						stone = true;
						soul_ = "\nadd_textbox|`2- 1 Soul Stone (OK!)|left|";
					}
					if (item_1 >= req_1) {
						item1 = true;
						item_1_text = "\nadd_textbox|`2- " + to_string(req_1) + " " + items[id_req_1].name + " (OK!)|left|";
					}
					if (item_2 >= req_2) {
						item2 = true;
						item_2_text = "\nadd_textbox|`2- " + to_string(req_2) + " " + items[id_req_2].name + " (OK!)|left|";
					}
					if (item_3 >= req_3) {
						item3 = true;
						item_3_text = "\nadd_textbox|`2- " + to_string(req_3) + " " + items[id_req_3].name + " (OK!)|left|";
					}
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Totem of Wisdom : Level 4") {
					req_1 = 1, req_2 = 1, id_req_1 = 5204, id_req_2 = 5074;
					item_1 = Inventory::Contains(peer, id_req_1), item_2 = Inventory::Contains(peer, id_req_2), item_3 = Inventory::Contains(peer, id_req_3);
					item_1_text = "\nadd_textbox|`8- " + items[id_req_1].description + " (" + to_string(item_1) + "/" + to_string(req_1) + ")|left|", item_2_text = "\nadd_textbox|`8- " + items[id_req_2].description + " (" + to_string(item_2) + "/" + to_string(req_2) + ")|left|";
					soul_ = "\nadd_textbox|`8- " + items[5202].description + " (" + to_string(soul_stone) + "/2)|left|";
					if (soul_stone >= 2) {
						stone = true;
						soul_ = "\nadd_textbox|`2- 2 Soul Stone (OK!)|left|";
					}
					if (item_1 >= req_1) {
						item1 = true;
						item_1_text = "\nadd_textbox|`2- " + to_string(req_1) + " " + items[id_req_1].name + " (OK!)|left|";
					}
					if (item_2 >= req_2) {
						item2 = true;
						item_2_text = "\nadd_textbox|`2- " + to_string(req_2) + " " + items[id_req_2].name + " (OK!)|left|";
					}
					if (item_3 >= req_3) {
						item3 = true;
						item_3_text = "\nadd_textbox|`2- " + to_string(req_3) + " " + items[id_req_3].name + " (OK!)|left|";
					}
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Totem of Wisdom : Level 5") {
					req_1 = 2, req_2 = 2, id_req_1 = 5104, id_req_2 = 5074;
					item_1 = Inventory::Contains(peer, id_req_1), item_2 = Inventory::Contains(peer, id_req_2), item_3 = Inventory::Contains(peer, id_req_3);
					item_1_text = "\nadd_textbox|`8- " + items[id_req_1].description + " (" + to_string(item_1) + "/" + to_string(req_1) + ")|left|", item_2_text = "\nadd_textbox|`8- " + items[id_req_2].description + " (" + to_string(item_2) + "/" + to_string(req_2) + ")|left|";
					soul_ = "\nadd_textbox|`8- " + items[5202].description + " (" + to_string(soul_stone) + "/2)|left|";
					if (soul_stone >= 2) {
						stone = true;
						soul_ = "\nadd_textbox|`2- 2 Soul Stone (OK!)|left|";
					}
					if (item_1 >= req_1) {
						item1 = true;
						item_1_text = "\nadd_textbox|`2- " + to_string(req_1) + " " + items[id_req_1].name + " (OK!)|left|";
					}
					if (item_2 >= req_2) {
						item2 = true;
						item_2_text = "\nadd_textbox|`2- " + to_string(req_2) + " " + items[id_req_2].name + " (OK!)|left|";
					}
					if (item_3 >= req_3) {
						item3 = true;
						item_3_text = "\nadd_textbox|`2- " + to_string(req_3) + " " + items[id_req_3].name + " (OK!)|left|";
					}
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Totem of Wisdom : Level 6") {
					req_1 = 3, req_2 = 2, id_req_1 = 5106, id_req_2 = 5074;
					item_1 = Inventory::Contains(peer, id_req_1), item_2 = Inventory::Contains(peer, id_req_2), item_3 = Inventory::Contains(peer, id_req_3);
					item_1_text = "\nadd_textbox|`8- " + items[id_req_1].description + " (" + to_string(item_1) + "/" + to_string(req_1) + ")|left|", item_2_text = "\nadd_textbox|`8- " + items[id_req_2].description + " (" + to_string(item_2) + "/" + to_string(req_2) + ")|left|";
					soul_ = "\nadd_textbox|`8- " + items[5202].description + " (" + to_string(soul_stone) + "/2)|left|";
					if (soul_stone >= 2) {
						stone = true;
						soul_ = "\nadd_textbox|`2- 2 Soul Stone (OK!)|left|";
					}
					if (item_1 >= req_1) {
						item1 = true;
						item_1_text = "\nadd_textbox|`2- " + to_string(req_1) + " " + items[id_req_1].name + " (OK!)|left|";
					}
					if (item_2 >= req_2) {
						item2 = true;
						item_2_text = "\nadd_textbox|`2- " + to_string(req_2) + " " + items[id_req_2].name + " (OK!)|left|";
					}
					if (item_3 >= req_3) {
						item3 = true;
						item_3_text = "\nadd_textbox|`2- " + to_string(req_3) + " " + items[id_req_3].name + " (OK!)|left|";
					}
				}
				/*Tesseract of Dimensions*/
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Tesseract of Dimensions : Level 2") {
					req_1 = 1, req_2 = 1, id_req_1 = 5204, id_req_2 = 5070;
					item_1 = Inventory::Contains(peer, id_req_1), item_2 = Inventory::Contains(peer, id_req_2), item_3 = Inventory::Contains(peer, id_req_3);
					item_1_text = "\nadd_textbox|`8- " + items[id_req_1].description + " (" + to_string(item_1) + "/" + to_string(req_1) + ")|left|", item_2_text = "\nadd_textbox|`8- " + items[id_req_2].description + " (" + to_string(item_2) + "/" + to_string(req_2) + ")|left|";
					soul_ = "\nadd_textbox|`8- " + items[5202].description + " (" + to_string(soul_stone) + "/1)|left|";
					if (soul_stone >= 1) {
						stone = true;
						soul_ = "\nadd_textbox|`2- 1 Soul Stone (OK!)|left|";
					}
					if (item_1 >= req_1) {
						item1 = true;
						item_1_text = "\nadd_textbox|`2- " + to_string(req_1) + " " + items[id_req_1].name + " (OK!)|left|";
					}
					if (item_2 >= req_2) {
						item2 = true;
						item_2_text = "\nadd_textbox|`2- " + to_string(req_2) + " " + items[id_req_2].name + " (OK!)|left|";
					}
					if (item_3 >= req_3) {
						item3 = true;
						item_3_text = "\nadd_textbox|`2- " + to_string(req_3) + " " + items[id_req_3].name + " (OK!)|left|";
					}
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Tesseract of Dimensions : Level 3") {
					req_1 = 1, req_2 = 1, id_req_1 = 5104, id_req_2 = 5070;
					item_1 = Inventory::Contains(peer, id_req_1), item_2 = Inventory::Contains(peer, id_req_2), item_3 = Inventory::Contains(peer, id_req_3);
					item_1_text = "\nadd_textbox|`8- " + items[id_req_1].description + " (" + to_string(item_1) + "/" + to_string(req_1) + ")|left|", item_2_text = "\nadd_textbox|`8- " + items[id_req_2].description + " (" + to_string(item_2) + "/" + to_string(req_2) + ")|left|";
					soul_ = "\nadd_textbox|`8- " + items[5202].description + " (" + to_string(soul_stone) + "/1)|left|";
					if (soul_stone >= 1) {
						stone = true;
						soul_ = "\nadd_textbox|`2- 1 Soul Stone (OK!)|left|";
					}
					if (item_1 >= req_1) {
						item1 = true;
						item_1_text = "\nadd_textbox|`2- " + to_string(req_1) + " " + items[id_req_1].name + " (OK!)|left|";
					}
					if (item_2 >= req_2) {
						item2 = true;
						item_2_text = "\nadd_textbox|`2- " + to_string(req_2) + " " + items[id_req_2].name + " (OK!)|left|";
					}
					if (item_3 >= req_3) {
						item3 = true;
						item_3_text = "\nadd_textbox|`2- " + to_string(req_3) + " " + items[id_req_3].name + " (OK!)|left|";
					}
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Tesseract of Dimensions : Level 4") {
					req_1 = 1, req_2 = 1, id_req_1 = 5106, id_req_2 = 5070;
					item_1 = Inventory::Contains(peer, id_req_1), item_2 = Inventory::Contains(peer, id_req_2), item_3 = Inventory::Contains(peer, id_req_3);
					item_1_text = "\nadd_textbox|`8- " + items[id_req_1].description + " (" + to_string(item_1) + "/" + to_string(req_1) + ")|left|", item_2_text = "\nadd_textbox|`8- " + items[id_req_2].description + " (" + to_string(item_2) + "/" + to_string(req_2) + ")|left|";
					soul_ = "\nadd_textbox|`8- " + items[5202].description + " (" + to_string(soul_stone) + "/2)|left|";
					if (soul_stone >= 2) {
						stone = true;
						soul_ = "\nadd_textbox|`2- 2 Soul Stone (OK!)|left|";
					}
					if (item_1 >= req_1) {
						item1 = true;
						item_1_text = "\nadd_textbox|`2- " + to_string(req_1) + " " + items[id_req_1].name + " (OK!)|left|";
					}
					if (item_2 >= req_2) {
						item2 = true;
						item_2_text = "\nadd_textbox|`2- " + to_string(req_2) + " " + items[id_req_2].name + " (OK!)|left|";
					}
					if (item_3 >= req_3) {
						item3 = true;
						item_3_text = "\nadd_textbox|`2- " + to_string(req_3) + " " + items[id_req_3].name + " (OK!)|left|";
					}
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Tesseract of Dimensions : Level 5") {
					req_1 = 2, req_2 = 2, id_req_1 = 5204, id_req_2 = 5070;
					item_1 = Inventory::Contains(peer, id_req_1), item_2 = Inventory::Contains(peer, id_req_2), item_3 = Inventory::Contains(peer, id_req_3);
					item_1_text = "\nadd_textbox|`8- " + items[id_req_1].description + " (" + to_string(item_1) + "/" + to_string(req_1) + ")|left|", item_2_text = "\nadd_textbox|`8- " + items[id_req_2].description + " (" + to_string(item_2) + "/" + to_string(req_2) + ")|left|";
					soul_ = "\nadd_textbox|`8- " + items[5202].description + " (" + to_string(soul_stone) + "/2)|left|";
					if (soul_stone >= 2) {
						stone = true;
						soul_ = "\nadd_textbox|`2- 2 Soul Stone (OK!)|left|";
					}
					if (item_1 >= req_1) {
						item1 = true;
						item_1_text = "\nadd_textbox|`2- " + to_string(req_1) + " " + items[id_req_1].name + " (OK!)|left|";
					}
					if (item_2 >= req_2) {
						item2 = true;
						item_2_text = "\nadd_textbox|`2- " + to_string(req_2) + " " + items[id_req_2].name + " (OK!)|left|";
					}
					if (item_3 >= req_3) {
						item3 = true;
						item_3_text = "\nadd_textbox|`2- " + to_string(req_3) + " " + items[id_req_3].name + " (OK!)|left|";
					}
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Tesseract of Dimensions : Level 6") {
					req_1 = 3, req_2 = 2, id_req_1 = 5104, id_req_2 = 5070;
					item_1 = Inventory::Contains(peer, id_req_1), item_2 = Inventory::Contains(peer, id_req_2), item_3 = Inventory::Contains(peer, id_req_3);
					item_1_text = "\nadd_textbox|`8- " + items[id_req_1].description + " (" + to_string(item_1) + "/" + to_string(req_1) + ")|left|", item_2_text = "\nadd_textbox|`8- " + items[id_req_2].description + " (" + to_string(item_2) + "/" + to_string(req_2) + ")|left|";
					soul_ = "\nadd_textbox|`8- " + items[5202].description + " (" + to_string(soul_stone) + "/2)|left|";
					if (soul_stone >= 2) {
						stone = true;
						soul_ = "\nadd_textbox|`2- 2 Soul Stone (OK!)|left|";
					}
					if (item_1 >= req_1) {
						item1 = true;
						item_1_text = "\nadd_textbox|`2- " + to_string(req_1) + " " + items[id_req_1].name + " (OK!)|left|";
					}
					if (item_2 >= req_2) {
						item2 = true;
						item_2_text = "\nadd_textbox|`2- " + to_string(req_2) + " " + items[id_req_2].name + " (OK!)|left|";
					}
					if (item_3 >= req_3) {
						item3 = true;
						item_3_text = "\nadd_textbox|`2- " + to_string(req_3) + " " + items[id_req_3].name + " (OK!)|left|";
					}
				}
				/*Seed of Life*/
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Seed of Life : Level 2") {
					req_1 = 1, req_2 = 1, id_req_1 = 5106, id_req_2 = 5076;
					item_1 = Inventory::Contains(peer, id_req_1), item_2 = Inventory::Contains(peer, id_req_2), item_3 = Inventory::Contains(peer, id_req_3);
					item_1_text = "\nadd_textbox|`8- " + items[id_req_1].description + " (" + to_string(item_1) + "/" + to_string(req_1) + ")|left|", item_2_text = "\nadd_textbox|`8- " + items[id_req_2].description + " (" + to_string(item_2) + "/" + to_string(req_2) + ")|left|";
					soul_ = "\nadd_textbox|`8- " + items[5202].description + " (" + to_string(soul_stone) + "/1)|left|";
					if (soul_stone >= 1) {
						stone = true;
						soul_ = "\nadd_textbox|`2- 1 Soul Stone (OK!)|left|";
					}
					if (item_1 >= req_1) {
						item1 = true;
						item_1_text = "\nadd_textbox|`2- " + to_string(req_1) + " " + items[id_req_1].name + " (OK!)|left|";
					}
					if (item_2 >= req_2) {
						item2 = true;
						item_2_text = "\nadd_textbox|`2- " + to_string(req_2) + " " + items[id_req_2].name + " (OK!)|left|";
					}
					if (item_3 >= req_3) {
						item3 = true;
						item_3_text = "\nadd_textbox|`2- " + to_string(req_3) + " " + items[id_req_3].name + " (OK!)|left|";
					}
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Seed of Life : Level 3") {
					req_1 = 1, req_2 = 1, id_req_1 = 5204, id_req_2 = 5076;
					item_1 = Inventory::Contains(peer, id_req_1), item_2 = Inventory::Contains(peer, id_req_2), item_3 = Inventory::Contains(peer, id_req_3);
					item_1_text = "\nadd_textbox|`8- " + items[id_req_1].description + " (" + to_string(item_1) + "/" + to_string(req_1) + ")|left|", item_2_text = "\nadd_textbox|`8- " + items[id_req_2].description + " (" + to_string(item_2) + "/" + to_string(req_2) + ")|left|";
					soul_ = "\nadd_textbox|`8- " + items[5202].description + " (" + to_string(soul_stone) + "/1)|left|";
					if (soul_stone >= 1) {
						stone = true;
						soul_ = "\nadd_textbox|`2- 1 Soul Stone (OK!)|left|";
					}
					if (item_1 >= req_1) {
						item1 = true;
						item_1_text = "\nadd_textbox|`2- " + to_string(req_1) + " " + items[id_req_1].name + " (OK!)|left|";
					}
					if (item_2 >= req_2) {
						item2 = true;
						item_2_text = "\nadd_textbox|`2- " + to_string(req_2) + " " + items[id_req_2].name + " (OK!)|left|";
					}
					if (item_3 >= req_3) {
						item3 = true;
						item_3_text = "\nadd_textbox|`2- " + to_string(req_3) + " " + items[id_req_3].name + " (OK!)|left|";
					}
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Seed of Life : Level 4") {
					req_1 = 1, req_2 = 1, id_req_1 = 5104, id_req_2 = 5076;
					item_1 = Inventory::Contains(peer, id_req_1), item_2 = Inventory::Contains(peer, id_req_2), item_3 = Inventory::Contains(peer, id_req_3);
					item_1_text = "\nadd_textbox|`8- " + items[id_req_1].description + " (" + to_string(item_1) + "/" + to_string(req_1) + ")|left|", item_2_text = "\nadd_textbox|`8- " + items[id_req_2].description + " (" + to_string(item_2) + "/" + to_string(req_2) + ")|left|";
					soul_ = "\nadd_textbox|`8- " + items[5202].description + " (" + to_string(soul_stone) + "/2)|left|";
					if (soul_stone >= 2) {
						stone = true;
						soul_ = "\nadd_textbox|`2- 2 Soul Stone (OK!)|left|";
					}
					if (item_1 >= req_1) {
						item1 = true;
						item_1_text = "\nadd_textbox|`2- " + to_string(req_1) + " " + items[id_req_1].name + " (OK!)|left|";
					}
					if (item_2 >= req_2) {
						item2 = true;
						item_2_text = "\nadd_textbox|`2- " + to_string(req_2) + " " + items[id_req_2].name + " (OK!)|left|";
					}
					if (item_3 >= req_3) {
						item3 = true;
						item_3_text = "\nadd_textbox|`2- " + to_string(req_3) + " " + items[id_req_3].name + " (OK!)|left|";
					}
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Seed of Life : Level 5") {
					req_1 = 2, req_2 = 2, id_req_1 = 5106, id_req_2 = 5076;
					item_1 = Inventory::Contains(peer, id_req_1), item_2 = Inventory::Contains(peer, id_req_2), item_3 = Inventory::Contains(peer, id_req_3);
					item_1_text = "\nadd_textbox|`8- " + items[id_req_1].description + " (" + to_string(item_1) + "/" + to_string(req_1) + ")|left|", item_2_text = "\nadd_textbox|`8- " + items[id_req_2].description + " (" + to_string(item_2) + "/" + to_string(req_2) + ")|left|";
					soul_ = "\nadd_textbox|`8- " + items[5202].description + " (" + to_string(soul_stone) + "/2)|left|";
					if (soul_stone >= 2) {
						stone = true;
						soul_ = "\nadd_textbox|`2- 2 Soul Stone (OK!)|left|";
					}
					if (item_1 >= req_1) {
						item1 = true;
						item_1_text = "\nadd_textbox|`2- " + to_string(req_1) + " " + items[id_req_1].name + " (OK!)|left|";
					}
					if (item_2 >= req_2) {
						item2 = true;
						item_2_text = "\nadd_textbox|`2- " + to_string(req_2) + " " + items[id_req_2].name + " (OK!)|left|";
					}
					if (item_3 >= req_3) {
						item3 = true;
						item_3_text = "\nadd_textbox|`2- " + to_string(req_3) + " " + items[id_req_3].name + " (OK!)|left|";
					}
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Seed of Life : Level 6") {
					req_1 = 3, req_2 = 2, id_req_1 = 5204, id_req_2 = 5076;
					item_1 = Inventory::Contains(peer, id_req_1), item_2 = Inventory::Contains(peer, id_req_2), item_3 = Inventory::Contains(peer, id_req_3);
					item_1_text = "\nadd_textbox|`8- " + items[id_req_1].description + " (" + to_string(item_1) + "/" + to_string(req_1) + ")|left|", item_2_text = "\nadd_textbox|`8- " + items[id_req_2].description + " (" + to_string(item_2) + "/" + to_string(req_2) + ")|left|";
					soul_ = "\nadd_textbox|`8- " + items[5202].description + " (" + to_string(soul_stone) + "/2)|left|";
					if (soul_stone >= 2) {
						stone = true;
						soul_ = "\nadd_textbox|`2- 2 Soul Stone (OK!)|left|";
					}
					if (item_1 >= req_1) {
						item1 = true;
						item_1_text = "\nadd_textbox|`2- " + to_string(req_1) + " " + items[id_req_1].name + " (OK!)|left|";
					}
					if (item_2 >= req_2) {
						item2 = true;
						item_2_text = "\nadd_textbox|`2- " + to_string(req_2) + " " + items[id_req_2].name + " (OK!)|left|";
					}
					if (item_3 >= req_3) {
						item3 = true;
						item_3_text = "\nadd_textbox|`2- " + to_string(req_3) + " " + items[id_req_3].name + " (OK!)|left|";
					}
				}
				/*Lens of Riches*/
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Lens of Riches : Level 2") {
					req_1 = 2, req_2 = 1, id_req_1 = 5104, id_req_2 = 5072;
					item_1 = Inventory::Contains(peer, id_req_1), item_2 = Inventory::Contains(peer, id_req_2), item_3 = Inventory::Contains(peer, id_req_3);
					item_1_text = "\nadd_textbox|`8- " + items[id_req_1].description + " (" + to_string(item_1) + "/" + to_string(req_1) + ")|left|", item_2_text = "\nadd_textbox|`8- " + items[id_req_2].description + " (" + to_string(item_2) + "/" + to_string(req_2) + ")|left|";
					soul_ = "\nadd_textbox|`8- " + items[5202].description + " (" + to_string(soul_stone) + "/1)|left|";
					if (soul_stone >= 1) {
						stone = true;
						soul_ = "\nadd_textbox|`2- 1 Soul Stone (OK!)|left|";
					}
					if (item_1 >= req_1) {
						item1 = true;
						item_1_text = "\nadd_textbox|`2- " + to_string(req_1) + " " + items[id_req_1].name + " (OK!)|left|";
					}
					if (item_2 >= req_2) {
						item2 = true;
						item_2_text = "\nadd_textbox|`2- " + to_string(req_2) + " " + items[id_req_2].name + " (OK!)|left|";
					}
					if (item_3 >= req_3) {
						item3 = true;
						item_3_text = "\nadd_textbox|`2- " + to_string(req_3) + " " + items[id_req_3].name + " (OK!)|left|";
					}
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Lens of Riches : Level 3") {
					req_1 = 2, req_2 = 1, id_req_1 = 5204, id_req_2 = 5072;
					item_1 = Inventory::Contains(peer, id_req_1), item_2 = Inventory::Contains(peer, id_req_2), item_3 = Inventory::Contains(peer, id_req_3);
					item_1_text = "\nadd_textbox|`8- " + items[id_req_1].description + " (" + to_string(item_1) + "/" + to_string(req_1) + ")|left|", item_2_text = "\nadd_textbox|`8- " + items[id_req_2].description + " (" + to_string(item_2) + "/" + to_string(req_2) + ")|left|";
					soul_ = "\nadd_textbox|`8- " + items[5202].description + " (" + to_string(soul_stone) + "/1)|left|";
					if (soul_stone >= 1) {
						stone = true;
						soul_ = "\nadd_textbox|`2- 1 Soul Stone (OK!)|left|";
					}
					if (item_1 >= req_1) {
						item1 = true;
						item_1_text = "\nadd_textbox|`2- " + to_string(req_1) + " " + items[id_req_1].name + " (OK!)|left|";
					}
					if (item_2 >= req_2) {
						item2 = true;
						item_2_text = "\nadd_textbox|`2- " + to_string(req_2) + " " + items[id_req_2].name + " (OK!)|left|";
					}
					if (item_3 >= req_3) {
						item3 = true;
						item_3_text = "\nadd_textbox|`2- " + to_string(req_3) + " " + items[id_req_3].name + " (OK!)|left|";
					}
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Lens of Riches : Level 4") {
					req_1 = 2, req_2 = 1, id_req_1 = 5106, id_req_2 = 5072;
					item_1 = Inventory::Contains(peer, id_req_1), item_2 = Inventory::Contains(peer, id_req_2), item_3 = Inventory::Contains(peer, id_req_3);
					item_1_text = "\nadd_textbox|`8- " + items[id_req_1].description + " (" + to_string(item_1) + "/" + to_string(req_1) + ")|left|", item_2_text = "\nadd_textbox|`8- " + items[id_req_2].description + " (" + to_string(item_2) + "/" + to_string(req_2) + ")|left|";
					soul_ = "\nadd_textbox|`8- " + items[5202].description + " (" + to_string(soul_stone) + "/2)|left|";
					if (soul_stone >= 2) {
						stone = true;
						soul_ = "\nadd_textbox|`2- 2 Soul Stone (OK!)|left|";
					}
					if (item_1 >= req_1) {
						item1 = true;
						item_1_text = "\nadd_textbox|`2- " + to_string(req_1) + " " + items[id_req_1].name + " (OK!)|left|";
					}
					if (item_2 >= req_2) {
						item2 = true;
						item_2_text = "\nadd_textbox|`2- " + to_string(req_2) + " " + items[id_req_2].name + " (OK!)|left|";
					}
					if (item_3 >= req_3) {
						item3 = true;
						item_3_text = "\nadd_textbox|`2- " + to_string(req_3) + " " + items[id_req_3].name + " (OK!)|left|";
					}
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Lens of Riches : Level 5") {
					req_1 = 3, req_2 = 2, id_req_1 = 5104, id_req_2 = 5072;
					item_1 = Inventory::Contains(peer, id_req_1), item_2 = Inventory::Contains(peer, id_req_2), item_3 = Inventory::Contains(peer, id_req_3);
					item_1_text = "\nadd_textbox|`8- " + items[id_req_1].description + " (" + to_string(item_1) + "/" + to_string(req_1) + ")|left|", item_2_text = "\nadd_textbox|`8- " + items[id_req_2].description + " (" + to_string(item_2) + "/" + to_string(req_2) + ")|left|";
					soul_ = "\nadd_textbox|`8- " + items[5202].description + " (" + to_string(soul_stone) + "/2)|left|";
					if (soul_stone >= 2) {
						stone = true;
						soul_ = "\nadd_textbox|`2- 2 Soul Stone (OK!)|left|";
					}
					if (item_1 >= req_1) {
						item1 = true;
						item_1_text = "\nadd_textbox|`2- " + to_string(req_1) + " " + items[id_req_1].name + " (OK!)|left|";
					}
					if (item_2 >= req_2) {
						item2 = true;
						item_2_text = "\nadd_textbox|`2- " + to_string(req_2) + " " + items[id_req_2].name + " (OK!)|left|";
					}
					if (item_3 >= req_3) {
						item3 = true;
						item_3_text = "\nadd_textbox|`2- " + to_string(req_3) + " " + items[id_req_3].name + " (OK!)|left|";
					}
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Lens of Riches : Level 6") {
					req_1 = 3, req_2 = 2, id_req_1 = 5204, id_req_2 = 5072;
					item_1 = Inventory::Contains(peer, id_req_1), item_2 = Inventory::Contains(peer, id_req_2), item_3 = Inventory::Contains(peer, id_req_3);
					item_1_text = "\nadd_textbox|`8- " + items[id_req_1].description + " (" + to_string(item_1) + "/" + to_string(req_1) + ")|left|", item_2_text = "\nadd_textbox|`8- " + items[id_req_2].description + " (" + to_string(item_2) + "/" + to_string(req_2) + ")|left|";
					soul_ = "\nadd_textbox|`8- " + items[5202].description + " (" + to_string(soul_stone) + "/2)|left|";
					if (soul_stone >= 2) {
						stone = true;
						soul_ = "\nadd_textbox|`2- 2 Soul Stone (OK!)|left|";
					}
					if (item_1 >= req_1) {
						item1 = true;
						item_1_text = "\nadd_textbox|`2- " + to_string(req_1) + " " + items[id_req_1].name + " (OK!)|left|";
					}
					if (item_2 >= req_2) {
						item2 = true;
						item_2_text = "\nadd_textbox|`2- " + to_string(req_2) + " " + items[id_req_2].name + " (OK!)|left|";
					}
					if (item_3 >= req_3) {
						item3 = true;
						item_3_text = "\nadd_textbox|`2- " + to_string(req_3) + " " + items[id_req_3].name + " (OK!)|left|";
					}
				}
				/*Orb of Time*/
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Orb of Time : Level 2") {
					req_1 = 1, req_2 = 1, id_req_1 = 5106, id_req_2 = 7186;
					item_1 = Inventory::Contains(peer, id_req_1), item_2 = Inventory::Contains(peer, id_req_2), item_3 = Inventory::Contains(peer, id_req_3);
					item_1_text = "\nadd_textbox|`8- " + items[id_req_1].description + " (" + to_string(item_1) + "/" + to_string(req_1) + ")|left|", item_2_text = "\nadd_textbox|`8- " + items[id_req_2].description + " (" + to_string(item_2) + "/" + to_string(req_2) + ")|left|";
					soul_ = "\nadd_textbox|`8- " + items[5202].description + " (" + to_string(soul_stone) + "/1)|left|";
					if (soul_stone >= 1) {
						stone = true;
						soul_ = "\nadd_textbox|`2- 1 Soul Stone (OK!)|left|";
					}
					if (item_1 >= req_1) {
						item1 = true;
						item_1_text = "\nadd_textbox|`2- " + to_string(req_1) + " " + items[id_req_1].name + " (OK!)|left|";
					}
					if (item_2 >= req_2) {
						item2 = true;
						item_2_text = "\nadd_textbox|`2- " + to_string(req_2) + " " + items[id_req_2].name + " (OK!)|left|";
					}
					if (item_3 >= req_3) {
						item3 = true;
						item_3_text = "\nadd_textbox|`2- " + to_string(req_3) + " " + items[id_req_3].name + " (OK!)|left|";
					}
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Orb of Time : Level 3") {
					req_1 = 1, req_2 = 1, id_req_1 = 5104, id_req_2 = 7186;
					item_1 = Inventory::Contains(peer, id_req_1), item_2 = Inventory::Contains(peer, id_req_2), item_3 = Inventory::Contains(peer, id_req_3);
					item_1_text = "\nadd_textbox|`8- " + items[id_req_1].description + " (" + to_string(item_1) + "/" + to_string(req_1) + ")|left|", item_2_text = "\nadd_textbox|`8- " + items[id_req_2].description + " (" + to_string(item_2) + "/" + to_string(req_2) + ")|left|";
					soul_ = "\nadd_textbox|`8- " + items[5202].description + " (" + to_string(soul_stone) + "/1)|left|";
					if (soul_stone >= 1) {
						stone = true;
						soul_ = "\nadd_textbox|`2- 1 Soul Stone (OK!)|left|";
					}
					if (item_1 >= req_1) {
						item1 = true;
						item_1_text = "\nadd_textbox|`2- " + to_string(req_1) + " " + items[id_req_1].name + " (OK!)|left|";
					}
					if (item_2 >= req_2) {
						item2 = true;
						item_2_text = "\nadd_textbox|`2- " + to_string(req_2) + " " + items[id_req_2].name + " (OK!)|left|";
					}
					if (item_3 >= req_3) {
						item3 = true;
						item_3_text = "\nadd_textbox|`2- " + to_string(req_3) + " " + items[id_req_3].name + " (OK!)|left|";
					}
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Orb of Time : Level 4") {
					req_1 = 1, req_2 = 1, id_req_1 = 5204, id_req_2 = 7186;
					item_1 = Inventory::Contains(peer, id_req_1), item_2 = Inventory::Contains(peer, id_req_2), item_3 = Inventory::Contains(peer, id_req_3);
					item_1_text = "\nadd_textbox|`8- " + items[id_req_1].description + " (" + to_string(item_1) + "/" + to_string(req_1) + ")|left|", item_2_text = "\nadd_textbox|`8- " + items[id_req_2].description + " (" + to_string(item_2) + "/" + to_string(req_2) + ")|left|";
					soul_ = "\nadd_textbox|`8- " + items[5202].description + " (" + to_string(soul_stone) + "/2)|left|";
					if (soul_stone >= 2) {
						stone = true;
						soul_ = "\nadd_textbox|`2- 2 Soul Stone (OK!)|left|";
					}
					if (item_1 >= req_1) {
						item1 = true;
						item_1_text = "\nadd_textbox|`2- " + to_string(req_1) + " " + items[id_req_1].name + " (OK!)|left|";
					}
					if (item_2 >= req_2) {
						item2 = true;
						item_2_text = "\nadd_textbox|`2- " + to_string(req_2) + " " + items[id_req_2].name + " (OK!)|left|";
					}
					if (item_3 >= req_3) {
						item3 = true;
						item_3_text = "\nadd_textbox|`2- " + to_string(req_3) + " " + items[id_req_3].name + " (OK!)|left|";
					}
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Orb of Time : Level 5") {
					req_1 = 2, req_2 = 2, id_req_1 = 5106, id_req_2 = 7186;
					item_1 = Inventory::Contains(peer, id_req_1), item_2 = Inventory::Contains(peer, id_req_2), item_3 = Inventory::Contains(peer, id_req_3);
					item_1_text = "\nadd_textbox|`8- " + items[id_req_1].description + " (" + to_string(item_1) + "/" + to_string(req_1) + ")|left|", item_2_text = "\nadd_textbox|`8- " + items[id_req_2].description + " (" + to_string(item_2) + "/" + to_string(req_2) + ")|left|";
					soul_ = "\nadd_textbox|`8- " + items[5202].description + " (" + to_string(soul_stone) + "/2)|left|";
					if (soul_stone >= 2) {
						stone = true;
						soul_ = "\nadd_textbox|`2- 2 Soul Stone (OK!)|left|";
					}
					if (item_1 >= req_1) {
						item1 = true;
						item_1_text = "\nadd_textbox|`2- " + to_string(req_1) + " " + items[id_req_1].name + " (OK!)|left|";
					}
					if (item_2 >= req_2) {
						item2 = true;
						item_2_text = "\nadd_textbox|`2- " + to_string(req_2) + " " + items[id_req_2].name + " (OK!)|left|";
					}
					if (item_3 >= req_3) {
						item3 = true;
						item_3_text = "\nadd_textbox|`2- " + to_string(req_3) + " " + items[id_req_3].name + " (OK!)|left|";
					}
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Orb of Time : Level 6") {
					req_1 = 3, req_2 = 2, id_req_1 = 5104, id_req_2 = 7186;
					item_1 = Inventory::Contains(peer, id_req_1), item_2 = Inventory::Contains(peer, id_req_2), item_3 = Inventory::Contains(peer, id_req_3);
					item_1_text = "\nadd_textbox|`8- " + items[id_req_1].description + " (" + to_string(item_1) + "/" + to_string(req_1) + ")|left|", item_2_text = "\nadd_textbox|`8- " + items[id_req_2].description + " (" + to_string(item_2) + "/" + to_string(req_2) + ")|left|";
					soul_ = "\nadd_textbox|`8- " + items[5202].description + " (" + to_string(soul_stone) + "/2)|left|";
					if (soul_stone >= 2) {
						stone = true;
						soul_ = "\nadd_textbox|`2- 2 Soul Stone (OK!)|left|";
					}
					if (item_1 >= req_1) {
						item1 = true;
						item_1_text = "\nadd_textbox|`2- " + to_string(req_1) + " " + items[id_req_1].name + " (OK!)|left|";
					}
					if (item_2 >= req_2) {
						item2 = true;
						item_2_text = "\nadd_textbox|`2- " + to_string(req_2) + " " + items[id_req_2].name + " (OK!)|left|";
					}
					if (item_3 >= req_3) {
						item3 = true;
						item_3_text = "\nadd_textbox|`2- " + to_string(req_3) + " " + items[id_req_3].name + " (OK!)|left|";
					}
				}
				if (stone and item1 and item2) can_upgrade = true;
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`9Ancient Goddess|left|5086|\nadd_spacer|small|\nadd_textbox|`9You are upgrading to " + items[Ancient_Goddess::Ances(peer, current_ances)].name + "|left|\nadd_spacer|small|\nadd_textbox|`oI will gift a part of my power to enhance your miraculous device, but this exchange, you must bring me the answers to my riddles:|\nadd_spacer|small|\nadd_textbox|`2- " + items[pInfo(peer)->ances].name + " (OK!)|" + soul_ + "|" + item_1_text + "|" + item_2_text + "|\nadd_spacer|small|\nadd_smalltext|`1The upgraded item will be untradeable|left|\nadd_spacer|small|" + (not can_upgrade ? "\nadd_button||`$I will get these items|0|0|" : "\nadd_button|complete_ritual|`$Complete the Ritual|0|0|") + "\nend_dialog|ancient_goddess|Return||");
				return;
			}
			if (button == "complete_ritual") {
				int current_ances = current_ances = pInfo(peer)->ances;
				int itemid3 = 0, c = -1, c_ = 1, new_ances = Ancient_Goddess::Ances(peer, current_ances);
				for (const auto& list : Environment()->Ancient_Riddle) {
					itemid3 = list.first;
				}
				/*Lens of Riches*/
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Lens of Riches : Level 2") {
					int item1 = -1, item2 = -1, souls = -1;
					/*soul stone*/Inventory::Modify(peer, 5202, souls);
					/*item 1*/Inventory::Modify(peer, 5104, item1);
					/*item 2*/Inventory::Modify(peer, 5072, item2);
					/*item 3*/Inventory::Modify(peer, itemid3, c);
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Lens of Riches : Level 3") {
					int item1 = -1, item2 = -1, souls = -1;
					/*soul stone*/Inventory::Modify(peer, 5202, souls);
					/*item 1*/Inventory::Modify(peer, 5204, item1);
					/*item 2*/Inventory::Modify(peer, 5072, item2);
					/*item 3*/Inventory::Modify(peer, itemid3, c);
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Lens of Riches : Level 4") {
					int item1 = -1, item2 = -1, souls = -2;
					/*soul stone*/Inventory::Modify(peer, 5202, souls);
					/*item 1*/Inventory::Modify(peer, 5106, item1);
					/*item 2*/Inventory::Modify(peer, 5072, item2);
					/*item 3*/Inventory::Modify(peer, itemid3, c);
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Lens of Riches : Level 5") {
					int item1 = -2, item2 = -2, souls = -2;
					/*soul stone*/Inventory::Modify(peer, 5202, souls);
					/*item 1*/Inventory::Modify(peer, 5104, item1);
					/*item 2*/Inventory::Modify(peer, 5072, item2);
					/*item 3*/Inventory::Modify(peer, itemid3, c);
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Lens of Riches : Level 6") {
					int item1 = -3, item2 = -2, souls = -2;
					/*soul stone*/Inventory::Modify(peer, 5202, souls);
					/*item 1*/Inventory::Modify(peer, 5204, item1);
					/*item 2*/Inventory::Modify(peer, 5072, item2);
					/*item 3*/Inventory::Modify(peer, itemid3, c);
				}
				/*Seed of Life*/
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Seed of Life : Level 2") {
					int item1 = -1, item2 = -1, souls = -1;
					/*soul stone*/Inventory::Modify(peer, 5202, souls);
					/*item 1*/Inventory::Modify(peer, 5106, item1);
					/*item 2*/Inventory::Modify(peer, 5076, item2);
					/*item 3*/Inventory::Modify(peer, itemid3, c);
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Seed of Life : Level 3") {
					int item1 = -1, item2 = -1, souls = -1;
					/*soul stone*/Inventory::Modify(peer, 5202, souls);
					/*item 1*/Inventory::Modify(peer, 5204, item1);
					/*item 2*/Inventory::Modify(peer, 5076, item2);
					/*item 3*/Inventory::Modify(peer, itemid3, c);
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Seed of Life : Level 4") {
					int item1 = -1, item2 = -1, souls = -2;
					/*soul stone*/Inventory::Modify(peer, 5202, souls);
					/*item 1*/Inventory::Modify(peer, 5104, item1);
					/*item 2*/Inventory::Modify(peer, 5076, item2);
					/*item 3*/Inventory::Modify(peer, itemid3, c);
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Seed of Life : Level 5") {
					int item1 = -2, item2 = -2, souls = -2;
					/*soul stone*/Inventory::Modify(peer, 5202, souls);
					/*item 1*/Inventory::Modify(peer, 5106, item1);
					/*item 2*/Inventory::Modify(peer, 5076, item2);
					/*item 3*/Inventory::Modify(peer, itemid3, c);
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Seed of Life : Level 6") {
					int item1 = -3, item2 = -2, souls = -2;
					/*soul stone*/Inventory::Modify(peer, 5202, souls);
					/*item 1*/Inventory::Modify(peer, 5204, item1);
					/*item 2*/Inventory::Modify(peer, 5076, item2);
					/*item 3*/Inventory::Modify(peer, itemid3, c);
				}
				/*Tesseract of Dimensions*/
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Tesseract of Dimensions : Level 2") {
					int item1 = -1, item2 = -1, souls = -1;
					/*soul stone*/Inventory::Modify(peer, 5202, souls);
					/*item 1*/Inventory::Modify(peer, 5204, item1);
					/*item 2*/Inventory::Modify(peer, 5070, item2);
					/*item 3*/Inventory::Modify(peer, itemid3, c);
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Tesseract of Dimensions : Level 3") {
					int item1 = -1, item2 = -1, souls = -1;
					/*soul stone*/Inventory::Modify(peer, 5202, souls);
					/*item 1*/Inventory::Modify(peer, 5104, item1);
					/*item 2*/Inventory::Modify(peer, 5070, item2);
					/*item 3*/Inventory::Modify(peer, itemid3, c);
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Tesseract of Dimensions : Level 4") {
					int item1 = -1, item2 = -1, souls = -2;
					/*soul stone*/Inventory::Modify(peer, 5202, souls);
					/*item 1*/Inventory::Modify(peer, 5106, item1);
					/*item 2*/Inventory::Modify(peer, 5070, item2);
					/*item 3*/Inventory::Modify(peer, itemid3, c);
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Tesseract of Dimensions : Level 5") {
					int item1 = -2, item2 = -2, souls = -2;
					/*soul stone*/Inventory::Modify(peer, 5202, souls);
					/*item 1*/Inventory::Modify(peer, 5204, item1);
					/*item 2*/Inventory::Modify(peer, 5070, item2);
					/*item 3*/Inventory::Modify(peer, itemid3, c);
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Tesseract of Dimensions : Level 6") {
					int item1 = -3, item2 = -2, souls = -2;
					/*soul stone*/Inventory::Modify(peer, 5202, souls);
					/*item 1*/Inventory::Modify(peer, 5104, item1);
					/*item 2*/Inventory::Modify(peer, 5070, item2);
					/*item 3*/Inventory::Modify(peer, itemid3, c);
				}
				/*Totem of Wisdom*/
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Totem of Wisdom : Level 2") {
					int item1 = -1, item2 = -1, souls = -1;
					/*soul stone*/Inventory::Modify(peer, 5202, souls);
					/*item 1*/Inventory::Modify(peer, 5104, item1);
					/*item 2*/Inventory::Modify(peer, 5074, item2);
					/*item 3*/Inventory::Modify(peer, itemid3, c);
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Totem of Wisdom : Level 3") {
					int item1 = -1, item2 = -1, souls = -1;
					/*soul stone*/Inventory::Modify(peer, 5202, souls);
					/*item 1*/Inventory::Modify(peer, 5106, item1);
					/*item 2*/Inventory::Modify(peer, 5074, item2);
					/*item 3*/Inventory::Modify(peer, itemid3, c);
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Totem of Wisdom : Level 4") {
					int item1 = -1, item2 = -1, souls = -2;
					/*soul stone*/Inventory::Modify(peer, 5202, souls);
					/*item 1*/Inventory::Modify(peer, 5204, item1);
					/*item 2*/Inventory::Modify(peer, 5074, item2);
					/*item 3*/Inventory::Modify(peer, itemid3, c);
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Totem of Wisdom : Level 5") {
					int item1 = -2, item2 = -2, souls = -2;
					/*soul stone*/Inventory::Modify(peer, 5202, souls);
					/*item 1*/Inventory::Modify(peer, 5104, item1);
					/*item 2*/Inventory::Modify(peer, 5074, item2);
					/*item 3*/Inventory::Modify(peer, itemid3, c);
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Totem of Wisdom : Level 6") {
					int item1 = -3, item2 = -2, souls = -2;
					/*soul stone*/Inventory::Modify(peer, 5202, souls);
					/*item 1*/Inventory::Modify(peer, 5106, item1);
					/*item 2*/Inventory::Modify(peer, 5074, item2);
					/*item 3*/Inventory::Modify(peer, itemid3, c);
				}
				/*Orb of Time*/
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Orb of Time : Level 2") {
					int item1 = -1, item2 = -1, souls = -1;
					/*soul stone*/Inventory::Modify(peer, 5202, souls);
					/*item 1*/Inventory::Modify(peer, 5106, item1);
					/*item 2*/Inventory::Modify(peer, 7186, item2);
					/*item 3*/Inventory::Modify(peer, itemid3, c);
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Orb of Time : Level 3") {
					int item1 = -1, item2 = -1, souls = -1;
					/*soul stone*/Inventory::Modify(peer, 5202, souls);
					/*item 1*/Inventory::Modify(peer, 5104, item1);
					/*item 2*/Inventory::Modify(peer, 7186, item2);
					/*item 3*/Inventory::Modify(peer, itemid3, c);
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Orb of Time : Level 4") {
					int item1 = -1, item2 = -1, souls = -2;
					/*soul stone*/Inventory::Modify(peer, 5202, souls);
					/*item 1*/Inventory::Modify(peer, 5204, item1);
					/*item 2*/Inventory::Modify(peer, 7186, item2);
					/*item 3*/Inventory::Modify(peer, itemid3, c);
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Orb of Time : Level 5") {
					int item1 = -2, item2 = -2, souls = -2;
					/*soul stone*/Inventory::Modify(peer, 5202, souls);
					/*item 1*/Inventory::Modify(peer, 5106, item1);
					/*item 2*/Inventory::Modify(peer, 7186, item2);
					/*item 3*/Inventory::Modify(peer, itemid3, c);
				}
				if (items[Ancient_Goddess::Ances(peer, current_ances)].name == "Ancestral Orb of Time : Level 6") {
					int item1 = -3, item2 = -2, souls = -2;
					/*soul stone*/Inventory::Modify(peer, 5202, souls);
					/*item 1*/Inventory::Modify(peer, 5104, item1);
					/*item 2*/Inventory::Modify(peer, 7186, item2);
					/*item 3*/Inventory::Modify(peer, itemid3, c);
				}
				/*removed*/
				/*current ances*/Inventory::Modify(peer, pInfo(peer)->ances, c);
				/*added*/
				/*new ances*/Inventory::Modify(peer, new_ances, c_);
				Clothing::Equip(peer, new_ances);
				if (current_ances == 7174 || current_ances == 5186 || current_ances == 5150 || current_ances == 5168 || current_ances == 5132) {
					//Achievement::Add(peer, "Ancestral Being", pInfo(peer)->ances_being, 1, 1);
					//Achievement::Add(peer, "A Higher Power", pInfo(peer)->a_highter_p, 3, 1);
					//Achievement::Add(peer, "Power Overwhelming", pInfo(peer)->power_overwhelming, 5, 1);
				}
				CAction::Positioned(peer, pInfo(peer)->netID, "audio/change_clothes.wav", 0);
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`9Ancient Goddess|left|5086|\nadd_spacer|small|\nadd_textbox|`8You've pleased me, clever one.|\nadd_spacer|small|\nend_dialog||Return|");
			}
		}
	}
	static void pianowings(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "manual") {
				int volume = 50;
				string note = "C-C-D-C-E-F";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wMusical Wings``|left|10182|\nadd_spacer|small|\nadd_textbox|This wing will play up to 16 music notes. Each note is triggered as you pass over a block.|left|\nadd_textbox|In the `2Volume `obox, enter a volume level for these notes, from 1-100. 100 is the normal volume of music notes.|left|\nadd_textbox|In the `2Notes `obox, enter up to 16 music notes to play. For each note, you enter 2 symbols:|left|\nadd_smalltext|-The note to play, `2A to G`0, as in normal music notation. Lowercase for lower octave, uppercase for higher.|\nadd_smalltext|Spaces are optional, but sure make it easier to read.|\nadd_smalltext|- Last, a `2#`o for a sharp note, a - for a natural note, or a `2b `ofor a flat note.|\nadd_smalltext|Spaces are optional, but sure make it easier to read.|\nadd_text_input|volume|Volume|" + to_string(volume) + "|3|\nadd_text_input|text|Notes|" + note + "|50|\nend_dialog|pianowings|Cancel|Update| ");
			}
			if (button == "resoterdefault") {
				int volume = 100;
				string note = "C-F-G#G-F-B#A#G-F-G#G-D#G-C-";
				if (note.find_first_not_of("ABCDEFG-#abcdefg") != string::npos) {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wMusical Wings``|left|10182|\nadd_spacer|small|\nadd_textbox|`4Notes must be from A to G!``|left|\nadd_button|manual|Instructions|noflags|0|0|\nadd_spacer|small|\nadd_text_input|volume|Volume|" + to_string(volume) + "|3|\nadd_text_input|text|Notes|" + note + "|50|\nadd_spacer|small|\nadd_button|resoterdefault|Restore to Default|noflags|0|0|\nend_dialog|pianowings|Cancel|Update|");
					return;
				}
				else {
					pInfo(peer)->musical_volume = volume;
					pInfo(peer)->musical_note = note;
					Clothing_V2::Update(peer);
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wUpdated Musical Wings!", 0, 0);
				}
			}
		}
	}
	static void wizard(ENetPeer* peer, std::string cch) {
		if (cch.find("buttonClicked|") != string::npos) {
			string item_ = cch.substr(54, cch.length() - 54).c_str();
			replaceAll(item_, "\n", "");
			lwiz_quest(peer, "open_" + item_);
		}
	}
	static void wizard_start(ENetPeer* peer, std::string cch) {
		string type_ = get_embed(cch, "type");
		replaceAll(type_, "\n", "");
		lwiz_quest(peer, "start_" + type_);
	}
	static void wizard_quests(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "give_up") {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`9Legendary Wizard``|left|1790|\nadd_spacer|small|\nadd_textbox|Are you sure you want to give up your Legendary Wizard quest?|left|\nadd_spacer|small|\nadd_button|bye|Give up|noflags|0|0|\nend_dialog|wizard_quests|Cancel||\nadd_quick_exit|");
			}
			if (button == "yeslwz") {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`9Psssttt!|left|1790|\nadd_textbox|`oOkay, the Wizard's Council really has my hands tied on this. I can't actually tell you anything about it... buuuutt... well, they always let me say cryptic stuff, so here:|left|\nadd_spacer|small|\nadd_textbox|`2Beneath verdant skies|left|\nadd_textbox|`4Resting On moltin Scoria|left|\nadd_textbox|`3A delicate sapling takes root|left|\nadd_textbox|`8Child of the Heavens and the earth|left|\nadd_textbox|`&In time or bears fruit -|left|\nadd_textbox|`9WISDOM|left|\nadd_spacer|small|\nadd_smalltext|`1(The wizard then winks repeatedly and nudges you with his elbow, accasionlty muttering, 'Get it? Do ya? Come on'!)|left|\nend_dialog|cl0se|Uh, okay..||");
			}
			if (button == "bye") {
				pInfo(peer)->legendary_quest.clear();
				pInfo(peer)->lwiz_quest = 0;
				pInfo(peer)->lwiz_notification = 0;
				pInfo(peer)->lwiz_step = 1;
				lwiz_quest(peer, "open");
			}
			if (button == "deliver") {
				std::string name_ = pInfo(peer)->world;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					world_->fresh_world = true;
					WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
					if (not Only_Access(peer, world_, block_)) return;
					if (block_->fg == 1790) {
						if (pInfo(peer)->lwiz_quest != 0) {
							if (pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1].size() == 3) {
								int item = pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][2], got = 0;
								Inventory::Modify(peer, item, got);
								if (got != 0) {
									int give_back = 0;
									if (pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][0] + got >= pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][1])give_back = pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][0] + got - pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][1];
									add_lwiz_points(peer, got);
									Inventory::Modify(peer, item, got *= -1);
									if (give_back != 0) Inventory::Modify(peer, item, give_back);
									lwiz_points(peer);
								}
								else if (pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][0] >= pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][1]) {
									lwiz_points(peer);
								}
							}
							else if (pInfo(peer)->lwiz_step == 10 || pInfo(peer)->lwiz_step == 2) {
								int need_more = pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][1] - pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][0];
								if (pInfo(peer)->gems != 0) {
									if (pInfo(peer)->gems >= need_more) {
										add_lwiz_points(peer, need_more);
										VarList::OnBuxGems(peer, need_more * -1);
									}
									else {
										add_lwiz_points(peer, pInfo(peer)->gems);
										VarList::OnBuxGems(peer, pInfo(peer)->gems * -1);
									}
									lwiz_points(peer);
								}
							}
							else if (pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][0] >= pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][1]) {
								lwiz_points(peer);
							}
						}
					}
				}
			}
		}
	}
	static void washing_machine(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = ""; int item_ = 0;
		if (parser.try_get("itemid", item_)) {
			int got = Inventory::Contains(peer, item_);
			if (item_ <= 0 || item_ > items.size() || got == 0) return;
			if (items[item_].untradeable || items[item_].rarity <= 1 || items[item_].rarity == 999 || items[item_].block_possible_put == false) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`4" + items[item_].ori_name + "`` does not fit in the Washing Machine.", 0, 0);
				return;
			}
			pInfo(peer)->lastchoosenitem = item_;
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wWashing Machine``|left|9946|\nadd_textbox|How many to wash?|left|\nadd_text_input|count||" + to_string(got) + "|3|\nadd_spacer|small|\nend_dialog|washing_machine|Cancel|OK|\nadd_quick_exit|");
		}
		if (cch.find("count|") != string::npos) {
			int item_ = pInfo(peer)->lastchoosenitem, got = 0, want_ = std::atoi(cch.substr(55, cch.length() - 55).c_str());
			if (item_ <= 0 || item_ > items.size()) return;
			Inventory::Modify(peer, item_, got);
			if (got < want_ or want_ <= 0 or want_ > 200) return;
			if (items[item_].untradeable || items[item_].rarity <= 1 || items[item_].rarity == 999 || items[item_].block_possible_put == false) {
				gamepacket_t p;
				p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`4" + items[item_].ori_name + "`` does not fit in the Washing Machine."), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
				return;
			}
			gamepacket_t p2;
			p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert("Washing " + to_string(want_) + " " + items[item_].ori_name + ""), p2.CreatePacket(peer);
			std::string name_ = pInfo(peer)->world;
			std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				world_->fresh_world = true;
				WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
				if (block_->fg == 9946) {
					int i_ = pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100), x_ = (i_ % 100), y_ = (i_ / 100), remove_ = want_ * -1;
					Inventory::Modify(peer, item_, remove_);
					block_->shelf_1 = item_, block_->shelf_2 = want_;
					block_->fg = 9948;
					update_tile(peer, x_, y_, 9948, true);
					block_->planted = time(nullptr) - items[9948].growTime + rand() % 600 + 100;
					PlayerMoving data_{};
					data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
					int alloc = alloc_(world_, block_);
					BYTE* raw = packPlayerMoving(&data_, 112 + alloc);
					BYTE* blc = raw + 56;
					form_visual(blc, *block_, *world_, peer, false);
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (pInfo(cp_)->world == world_->name) {
							update_tile(cp_, x_, y_, 9948);
							send_raw(cp_, 4, raw, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[] raw, blc;
					if (block_->locked) upd_lock(*block_, *world_, peer);
				}
			}
		}
	}
	static void summerfest_quest(ENetPeer* peer, std::string cch) {
		if (cch.find("buttonClicked|") != string::npos) {
			int id = std::atoi(cch.substr(64, cch.length() - 64).c_str());
			vector<int> listid{ 1,10,30,75,150,300,400,500,600,700,800,900,1000,111 };
			if (find(listid.begin(), listid.end(), id) == listid.end() or not Event()->Summerfest) return;
			if ((id == 111 && pInfo(peer)->summer_surprise >= 20) or (id != 111 && pInfo(peer)->summer_total >= id && find(pInfo(peer)->summer_milestone.begin(), pInfo(peer)->summer_milestone.end(), id) == pInfo(peer)->summer_milestone.end())) {
				int give = 1, give_item = 836;
				if (id == 1) give = 25, give_item = 834;
				else if (id == 10) give = 150, give_item = 834;
				else if (id == 30) give = 1, give_item = 836;
				else if (id == 75) give = 2, give_item = 836;
				else if (id == 150) give = 1, give_item = 11038;
				else if (id == 300) give = 1, give_item = 1680;
				else if (id == 400) give = 1, give_item = 13604;
				else if (id == 500) give = 1, give_item = 1680;
				else if (id == 600) give = 1, give_item = 1680;
				else if (id == 700) give = 1, give_item = 13616;
				else if (id == 800) give = 1, give_item = 13614;
				else if (id == 900) give = 1, give_item = 13608;
				else if (id == 1000) give = 1, give_item = 13606;
				else if (id == 111) give = 1, give_item = 10004;
				int got = give;
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(peer)->netID);
				if (Inventory::Modify(peer, give_item, give) == 0) {
					if (id != 111) pInfo(peer)->summer_milestone.push_back(id);
					else {
						pInfo(peer)->summer_surprise -= 20;
						gamepacket_t p;
						p.Insert("OnProgressUIUpdateValue"), p.Insert(pInfo(peer)->summer_surprise), p.Insert(20);
						p.CreatePacket(peer);
					}
					CAction::Log(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
					p.Insert("Congratulations! You have claimed your reward `2" + to_string(got) + " " + items[give_item].ori_name + "``!");
					PlayerMoving data_{};
					data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
					BYTE* raw = packPlayerMoving(&data_);
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(peer)->world != pInfo(cp_)->world) continue;
						send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw;
				}
				else p.Insert("You have full inventory space!");
				p.Insert(0), p.Insert(0), p.CreatePacket(peer);
			}
		}
	}
	static void mooncake_reward_list_dialog(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "goto_maindialog") offering_table(peer);
		}
	}
	static void mooncake_altar_dialog(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "reward_list_btn") {
				offering_table(peer, 0, "reward");
			}
			if (button == "offer_btn") {
				offering_table(peer, 0, "offer");
			}
			if (button.substr(0, 8) == "slot_btn_") {
				int slot = std::atoi(button.substr(9).c_str());
				if (pInfo(peer)->lastwrenchb != 12598) return;
				string inventory = "", clear_slot = "";
				for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (items[pInfo(peer)->inv[i_].first].mooncake) inventory += "\nadd_button_with_icon|item_btn_" + to_string(pInfo(peer)->inv[i_].first) + "||frame|" + to_string(pInfo(peer)->inv[i_].first) + "|" + to_string(pInfo(peer)->inv[i_].second) + "|\nadd_custom_margin|x:-40;y:0|\nadd_textbox|" + items[pInfo(peer)->inv[i_].first].name + "|left||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_custom_margin|x:0;y:-80|";
				std::string name_ = pInfo(peer)->world;
				std::vector<World>::iterator pd = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (pd != worlds.end()) {
					World* world_ = &worlds[pd - worlds.begin()];
					world_->fresh_world = true;
					WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
					if (Only_Access(peer, world_, block_) and block_->fg == 12598) {
						for (int i_ = 0; i_ < block_->donates.size(); i_++) {
							if (i_ == slot) clear_slot = "\nadd_button|clear_slot|Clear slot|0|0|";
						}
					}
				}
				if (clear_slot.empty() && inventory.empty()) VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wNot Enough Mooncakes``|left|1432|\nadd_textbox|You don't have any Mooncakes!|left|\nadd_spacer|small|\nadd_button|goto_maindialog|OK|0|0|\nadd_spacer|small|\nend_dialog|altar_warning_dialog|||");
				else VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`w\nadd_label_with_icon|big|`wSelect a Mooncake``|left|12598|\nadd_spacer|small|\nadd_textbox|Select a Mooncake to place on the offering table.|left|" + (inventory.empty() ? "" : inventory) + "\nadd_spacer|small|" + clear_slot + "\nadd_button|goto_maindialog|Not right now|0|0|\nembed_data|slot|" + to_string(slot) + "\nend_dialog|mooncake_choose_dialog|||");
			}
		}
	}
	static void mooncake_reward_dialog(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "reroll") {
				offering_table(peer, 0, "reroll");
			}
			if (button == "take_reward") {
				std::string name_ = pInfo(peer)->world;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					world_->fresh_world = true;
					WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
					if (!Only_Access(peer, world_, block_) or block_->fg != 12598) return;
					if (block_->shelf_1 != 0) {
						block_->shelf_1 = 0;
						int give = 1;
						if (Inventory::Modify(peer, block_->shelf_1, give) == 0) {
							block_->shelf_1 = 0;
						}
						else {
							VarList::OnConsoleMessage(peer, "No inventory space.");
						}
					}
				}
			}
		}
	}
	static void billboard_edit(ENetPeer* peer, std::string cch) {
		if (cch.find("billboard_toggle|") != string::npos) {
			std::vector<std::string> t_ = explode("|", cch);
			if (t_.size() < 8) return;
			bool billboard_active = std::atoi(explode("\n", t_[3])[0].c_str()), billboard_buying = std::atoi(explode("\n", t_[4])[0].c_str());
			int billboard_price = std::atoi(explode("\n", t_[5])[0].c_str());
			bool peritem = std::atoi(explode("\n", t_[6])[0].c_str()), perlock = std::atoi(explode("\n", t_[7])[0].c_str());
			bool update_billboard = true;
			if (peritem == perlock or peritem == 0 and perlock == 0 or peritem == 1 and perlock == 1) {
				update_billboard = false;
				VarList::OnConsoleMessage(peer, "You need to pick one pricing method - 'locks per item' or 'items per lock'");
				gamepacket_t p2;
				p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert("You need to pick one pricing method - 'locks per item' or 'items per lock'"), p2.Insert(0), p2.Insert(1), p2.CreatePacket(peer);
			}
			else {
				if (peritem == 1) pInfo(peer)->b_w = 1;
				if (perlock == 1) pInfo(peer)->b_w = 0;
			}
			pInfo(peer)->b_bill = to_string(billboard_active) + "," + to_string(billboard_buying);
			if (billboard_price < 0 or billboard_price > 99999) {
				update_billboard = false;
				gamepacket_t  p2;
				VarList::OnConsoleMessage(peer, "Price can't be negative. That's beyond science.");
				p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert("Price can't be negative. That's beyond science."), p2.Insert(0), p2.Insert(1), p2.CreatePacket(peer);
			}
			else pInfo(peer)->b_p = billboard_price;
			if (update_billboard && pInfo(peer)->b_p != 0 && pInfo(peer)->b_i != 0) {
				gamepacket_t p(0, pInfo(peer)->netID);
				p.Insert("OnBillboardChange"), p.Insert(pInfo(peer)->netID), p.Insert(pInfo(peer)->b_i), p.Insert(pInfo(peer)->b_bill), p.Insert(pInfo(peer)->b_p), p.Insert(pInfo(peer)->b_w);
				for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
					if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(cp_)->world != pInfo(peer)->world) continue;
					p.CreatePacket(cp_);
				}
			}
		}
		if (cch.find("billboard_item|") != string::npos) {
			std::vector<std::string> t_ = explode("|", cch);
			if (t_.size() < 4) return;
			int billboard_item = std::atoi(explode("\n", t_[3])[0].c_str());
			if (billboard_item > 0 && billboard_item < items.size()) {
				int got = Inventory::Contains(peer, billboard_item);
				if (got == 0) return;
				if (items[billboard_item].untradeable == 1 or billboard_item == 1424 or billboard_item == 5816 or items[billboard_item].blockType == BlockTypes::LOCK or items[billboard_item].blockType == BlockTypes::FISH) {
					VarList::OnConsoleMessage(peer, "Item can not be untradeable.");
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Item can not be untradeable.", 0, 1);
				}
				else {
					pInfo(peer)->b_i = billboard_item;
					if (pInfo(peer)->b_p != 0 && pInfo(peer)->b_i != 0) {
						gamepacket_t p(0, pInfo(peer)->netID);
						p.Insert("OnBillboardChange"), p.Insert(pInfo(peer)->netID), p.Insert(pInfo(peer)->b_i), p.Insert(pInfo(peer)->b_bill), p.Insert(pInfo(peer)->b_p), p.Insert(pInfo(peer)->b_w);
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(cp_)->world != pInfo(peer)->world) continue;
							p.CreatePacket(cp_);
						}
					}
				}
			}
		}
	}
	static void dialog_eqaura(ENetPeer* peer, std::string cch) {
		if (cch.find("change_item|") != string::npos) {
			if (pInfo(peer)->ances == 12634) {
				std::vector<std::string> t_ = explode("|", cch);
				if (t_.size() >= 3) {
					int item = std::atoi(explode("\n", t_[3])[0].c_str());
					if (item < 0 || item > items.size()) return;
					if (items[item].musical_block) pInfo(peer)->eq_aura = item, Clothing_V2::Update(peer);
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Please choose a musical block!", 0, 0);
				}
				else pInfo(peer)->eq_aura = 0;
			}
		}
		if (cch.find("buttonClicked") != string::npos) {
			if (pInfo(peer)->ances == 12634) pInfo(peer)->eq_aura = 0, Clothing_V2::Update(peer);
		}
	}
	static void worldreport(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		string report = parser.get("report_reason", 1);
		bool warned = false;
		pInfo(peer)->not_same++;
		if (pInfo(peer)->last_input_text == report) pInfo(peer)->same_input++;
		pInfo(peer)->last_input_text = report;
		if (pInfo(peer)->last_spam_detection + 1200000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
			pInfo(peer)->last_spam_detection = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			pInfo(peer)->same_input = 0;
			pInfo(peer)->not_same = 0;
		}
		if (pInfo(peer)->same_input >= 1 || pInfo(peer)->not_same >= 2) {
			if (!warned) {
				VarList::OnConsoleMessage(peer, "`6>>`4Spam detected! ``Please wait a bit before typing anything else.  Please note, any form of bot/macro/auto-paste will get all your accounts banned, so don't do it!");
				warned = true;
				pInfo(peer)->Warning_Spam++;
				pInfo(peer)->Warning_Message.push_back("Trying spam text");
				VarList::OnAddNotification(peer, "Warning from `4System``: Trying to spam? Nice try but it won't work here", "interface/atomic_button.rttex", "audio/hub_open.wav");
				if (pInfo(peer)->Warning_Spam >= 5) {
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						Punishment::Banned(peer, 6.307e+7, "You has've been reach 5 warnings!", pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``", 76);
						ServerPool::ModLogs::Add(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, " `4BANNED ``(has've been reach 5 warnings!)", "");
					}
				}
			}
		}
		else {
			ServerPool::ModLogs::Add(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, "`4reports:`` " + report, " (/reports - to see)");
			Environment()->World_Report.emplace_back(pInfo(peer)->world, report);
			VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Thank you for your report. Now leave this world so you don't get punished along with the scammers!", 0, 0);
			return;
		}
	}
	static void playerreport(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		string report = parser.get("reason", 1);
		bool warned = false;
		pInfo(peer)->not_same++;
		if (pInfo(peer)->last_input_text == report) pInfo(peer)->same_input++;
		pInfo(peer)->last_input_text = report;
		if (pInfo(peer)->last_spam_detection + 1200000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
			pInfo(peer)->last_spam_detection = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			pInfo(peer)->same_input = 0;
			pInfo(peer)->not_same = 0;
		}
		if (pInfo(peer)->same_input >= 1 || pInfo(peer)->not_same >= 2) {
			if (!warned) {
				VarList::OnConsoleMessage(peer, "`6>>`4Spam detected! ``Please wait a bit before typing anything else.  Please note, any form of bot/macro/auto-paste will get all your accounts banned, so don't do it!");
				warned = true;
				pInfo(peer)->Warning_Spam++;
				pInfo(peer)->Warning_Message.push_back("Trying spam text");
				VarList::OnAddNotification(peer, "Warning from `4System``: Trying to spam? Nice try but it won't work here", "interface/atomic_button.rttex", "audio/hub_open.wav");
				if (pInfo(peer)->Warning_Spam >= 5) {
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						Punishment::Banned(peer, 6.307e+7, "You has've been reach 5 warnings!", pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``", 76);
						ServerPool::ModLogs::Add(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, " `4BANNED ``(has've been reach 5 warnings!)", "");
					}
				}
			}
		}
		else {
			ServerPool::ModLogs::Add(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, "`4Reports Player:`` [" + pInfo(peer)->last_wrenched + "] Reports: " + report, " (/playerreport - to see)");
			Environment()->Player_Report.emplace_back(pInfo(peer)->last_wrenched, report);
			VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Thank you for your report!", 0, 0);
			return;
		}
	}
	static void grinder(ENetPeer* peer, std::string cch) {
		if (cch.find("count|") != string::npos) {
			int count = std::atoi(cch.substr(47, cch.length() - 47).c_str()), item = pInfo(peer)->lastchoosenitem, got = Inventory::Contains(peer, item);
			if (item < 0 or item > items.size() or items[item].grindable_count == 0 || got == 0 || count <= 0 || count * items[item].grindable_count > got) return;
			int remove = (count * items[item].grindable_count) * -1;
			if (Inventory::Modify(peer, item, remove) == 0) {
				VarList::OnConsoleMessage(peer, "Ground up " + to_string(count * items[item].grindable_count) + " " + items[item].name + " into " + to_string(count) + " " + items[items[item].grindable_prize].name + "!");
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Ground up " + to_string(count * items[item].grindable_count) + " " + items[item].name + " into " + to_string(count) + " " + items[items[item].grindable_prize].name + "!", 0, 1);
				{
					std::string name_ = pInfo(peer)->world;
					std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
					if (p != worlds.end()) {
						World* world_ = &worlds[p - worlds.begin()];
						world_->fresh_world = true;
						PlayerMoving data_{};
						data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = items[item].grindable_prize, data_.punchY = pInfo(peer)->netID;
						int32_t to_netid = pInfo(peer)->netID;
						BYTE* raw = packPlayerMoving(&data_);
						raw[3] = 5;
						Memory_Copy(raw + 8, &to_netid, 4);
						send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						delete[] raw;
						int c_ = count;
						if (Inventory::Modify(peer, items[item].grindable_prize, c_) != 0) {
							WorldDrop drop_block_{};
							drop_block_.id = items[item].grindable_prize, drop_block_.count = count, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
							VisualHandle::Drop(world_, drop_block_);
						}
						{
							PlayerMoving data_{};
							data_.packetType = 17, data_.netID = 221, data_.YSpeed = 221, data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.XSpeed = item;
							BYTE* raw = packPlayerMoving(&data_);
							send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							delete[] raw;
						}
					}
				}
			}
		}
	}
	static void a2646(ENetPeer* peer, std::string cch) {
		if (cch.find("buttonClicked|off") != string::npos) {
			std::string name_ = pInfo(peer)->world;
			std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				world_->fresh_world = true;
				WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
				if (!Only_Access(peer, world_, block_) or block_->fg != 2646) return;
				for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
					if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(peer)->world != pInfo(cp_)->world or block_->heart_monitor != pInfo(cp_)->tankIDName) continue;
					pInfo(cp_)->spotlight = false;
					VisualHandle::State(pInfo(cp_));
					Clothing_V2::Update(cp_, true);
					VarList::OnConsoleMessage(peer, "Back to anonymity. (`$In the Spotlight`` mod removed)");
				}
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Lights out!", 0, 0);
				block_->heart_monitor = "";
			}
		}
		if (cch.find("ID|") != string::npos) {
			int netID = std::atoi(cch.substr(41, cch.length() - 41).c_str());
			std::string name_ = pInfo(peer)->world;
			std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				string new_spotlight = "";
				World* world_ = &worlds[p - worlds.begin()];
				world_->fresh_world = true;
				WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
				if (!Only_Access(peer, world_, block_) or block_->fg != 2646) return;
				for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
					if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(peer)->world != pInfo(cp_)->world) continue;
					if (block_->heart_monitor == pInfo(cp_)->tankIDName || pInfo(cp_)->netID == netID) {
						if (pInfo(cp_)->netID == netID) {
							new_spotlight = pInfo(cp_)->tankIDName, pInfo(cp_)->spotlight = true;
							VarList::OnConsoleMessage(peer, "All eyes are on you! (`$In the Spotlight`` mod added)");
						}
						else {
							VarList::OnConsoleMessage(peer, "Back to anonymity. (`$In the Spotlight`` mod removed)");
							pInfo(cp_)->spotlight = false;
						}
						if (new_spotlight != "") {
							std::vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return a.heart_monitor == new_spotlight; });
							if (p != world_->blocks.end()) {
								WorldBlock* block__ = &world_->blocks[p - world_->blocks.begin()];
								block__->heart_monitor = "";
							}
						}
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You shine the light on " + (new_spotlight == pInfo(peer)->tankIDName ? "yourself" : new_spotlight) + "!", 0, 0);
						VisualHandle::State(pInfo(cp_));
						Clothing_V2::Update(cp_, true);
					}
				}
				block_->heart_monitor = new_spotlight;
			}
		}
	}
	static void password_reply(ENetPeer* peer, std::string cch) {
		if (cch.find("password|") != string::npos) {
			string password = cch.substr(57, cch.length() - 58).c_str();
			std::string name_ = pInfo(peer)->world;
			std::vector<World>::iterator pa = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (pa != worlds.end()) {
				World* world_ = &worlds[pa - worlds.begin()];
				world_->fresh_world = true;
				WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
				if (block_->fg == 762 && block_->door_id != "") {
					transform(password.begin(), password.end(), password.begin(), ::toupper);
					if (block_->door_id != password) VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`4Wrong password!``");
					else {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, a + "`2The door opens!" + (block_->door_destination.empty() ? " But nothing is behind it." : "") + "``");
						if (block_->door_destination != "") {
							CAction::Positioned(peer, pInfo(peer)->netID, "audio/door_open.wav", 0);
							string door_target = block_->door_destination, door_id = "";
							World target_world = worlds[pa - worlds.begin()];
							int spawn_x = 0, spawn_y = 0;
							if (door_target.find(":") != string::npos) {
								std::vector<std::string> detales = explode(":", door_target);
								door_target = detales[0], door_id = detales[1];
							}
							bool found_ = true;
							if (not door_id.empty()) {
								std::vector<WorldBlock>::iterator p = find_if(target_world.blocks.begin(), target_world.blocks.end(), [&](const WorldBlock& a) { return (items[a.fg].path_marker || items[a.fg].blockType == BlockTypes::DOOR || items[a.fg].blockType == BlockTypes::PORTAL) && a.door_id == door_id; });
								if (p != target_world.blocks.end()) {
									int i_ = p - target_world.blocks.begin();
									spawn_x = i_ % 100, spawn_y = i_ / 100;
									found_ = false;
								}
							}
							else found_ = true;
							Enter_World(peer, target_world.name, spawn_x, spawn_y, 250, false, true, found_);
						}
					}
				}
			}
		}
	}
	static void ticket_booth(ENetPeer* peer, std::string cch) {
		if (cch.find("count|") != string::npos) {
			int count = std::atoi(cch.substr(52, cch.length() - 52).c_str()), item = pInfo(peer)->lastchoosenitem, got = 0;
			if (item != 242 && (items[item].name.find("null") != string::npos or items[item].name.find("null_item") != string::npos or items[item].untradeable == 1 || item == 5816 || item == 1424 || items[item].rarity == 999 || items[item].rarity > 360 || items[item].rarity <= 0)) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`5[```2That item is just too valuable to trade for tickets```5]``", 0, 0);
				return;
			}
			if (count <= 0 || count > 200)return;
			Inventory::Modify(peer, item, got);
			if (count > got or got <= 0) return;
			int total_points_ticket = (item == 242 ? 3000 * count : items[item].rarity * count) + pInfo(peer)->carnival_credit;
			int give_points_for_ticket = total_points_ticket / 100;
			pInfo(peer)->carnival_credit = 0;
			if (total_points_ticket - (give_points_for_ticket * 100) > 0) pInfo(peer)->carnival_credit += total_points_ticket - (give_points_for_ticket * 100);
			int remove_t = give_points_for_ticket;
			if (give_points_for_ticket >= 1) {
				if (Inventory::Modify(peer, 1898, give_points_for_ticket) == 0) {
					Inventory::Modify(peer, item, count *= -1);
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`9You got " + to_string(remove_t) + " Golden Tickets.``"), p.CreatePacket(peer);
					VarList::OnConsoleMessage(peer, "`9You got " + to_string(remove_t) + " Golden Tickets.``");
				}
				else {
					VarList::OnConsoleMessage(peer, "No inventory space.");
				}
			}
			else {
				pInfo(peer)->carnival_credit += total_points_ticket - (give_points_for_ticket * 100);
				VarList::OnConsoleMessage(peer, "`9You have a credit of " + to_string(pInfo(peer)->carnival_credit) + " Rarity.``");
			}
		}
	}
	static void handleRubblePartyShopPopup(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "back") {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wRubbles Shop``|left|10992|\nadd_image_button||interface/large/rubble_banner.rttex|bannerlayout|||\nadd_spacer|small|\nadd_smalltext|Hey there growtopian! you can exchange your rubbles with me for toxic waste and perhaps some rare items! Take a look..|left|\nadd_smalltext|`9You currently have " + Set_Count(pInfo(peer)->rubble) + " Rubbles``.|left|\nadd_spacer|small|\ntext_scaling_string|10,000BZ|\nadd_button_with_icon|beachparty_store_item_open_purchase_0|500|noflags|11402||\nadd_button_with_icon|beachparty_store_item_open_purchase_1|2500|noflags|11404||\nadd_button_with_icon||END_LIST|noflags|0||\nend_dialog|handleRubblePartyShopPopup|OK|\nadd_quick_exit|");
			}
			if (button.substr(0, 9) == "purchase_") {
				uint8_t id = std::atoi(button.substr(9).c_str());
				if (id >= 0 && id <= 1) {
					int count = 500, itemid = 0;
					if (id == 0) count = 500, itemid = 11402;
					else if (id == 1) count = 2500, itemid = 11404;
					else return;
					if (pInfo(peer)->rubble < count) VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wRubbles Shop``|left|10992|\nadd_spacer|small|\nadd_textbox|" + items[itemid].ori_name + " costs " + to_string(count) + " rubbles. You only have " + to_string(pInfo(peer)->rubble) + " so you can't afford it. Sorry!|left|\nadd_spacer|small|\nadd_button|back|Back|noflags|0|0|\nend_dialog|handleRubblePartyShopPopup||\nadd_quick_exit|");
					else {
						int give = 1;
						if (Inventory::Modify(peer, itemid, give) == 0) {
							pInfo(peer)->rubble -= count;
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wRubbles Shop``|left|10992|\nadd_spacer|small|\nadd_textbox|You purchased " + items[itemid].ori_name + " which costed you " + to_string(count) + ".|left|\nadd_spacer|small|\nadd_button|back|Back|noflags|0|0|\nend_dialog|handleRubblePartyShopPopup||\nadd_quick_exit|");
						}
						else VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wRubbles Shop``|left|10992|\nadd_spacer|small|\nadd_textbox|You have full inventory space!|left|\nadd_spacer|small|\nadd_button|back|Back|noflags|0|0|\nend_dialog|handleRubblePartyShopPopup||\nadd_quick_exit|");
					}
				}
			}
		}
	}
	static void logs(ENetPeer* peer, std::string cch) {
		if (cch.find("buttonClicked|") != string::npos) {
			if (Role::Administrator(peer)) {
				string button = "", search = "";
				std::vector<std::string> t_ = explode("|", cch);
				if (t_.size() > 3) {
					button = explode("\n", t_[3])[0].c_str();
					if (button == "Empty Logs" && Role::Clist(pInfo(peer)->tankIDName)) Environment()->Logs.clear();
				}
				if (t_.size() > 5) {
					search = explode("\n", t_[5])[0].c_str();
					if (search == "Next page") {
						pInfo(peer)->search_page += 20;
						search = "";
					}
					else if (search == "Previous page") {
						pInfo(peer)->search_page -= 20;
						if (pInfo(peer)->search_page < 20) pInfo(peer)->search_page = 20;
						search = "";
					}
				}
				ServerPool::Logs::Load(peer, button, search);
			}
		}
	}
	static void logs_search(ENetPeer* peer, std::string cch) {
		if (Role::Administrator(peer)) {
			string button = "", search = "";
			std::vector<std::string> t_ = explode("|", cch);
			if (t_.size() > 3) {
				button = explode("\n", t_[3])[0].c_str();
				if (button == "Empty Logs" && Role::Clist(pInfo(peer)->tankIDName)) Environment()->Logs.clear();
			}
			if (t_.size() > 5) {
				search = explode("\n", t_[5])[0].c_str();
				if (search == "Next page") {
					pInfo(peer)->search_page += 20;
					search = "";
				}
				else if (search == "Previous page") {
					pInfo(peer)->search_page -= 20;
					if (pInfo(peer)->search_page < 20) pInfo(peer)->search_page = 20;
					search = "";
				}
			}
			ServerPool::Logs::Load(peer, button, search);
		}
	}
	static void compactor(ENetPeer* peer, std::string cch) {
		if (cch.find("count|") != string::npos) {
			int count = std::atoi(cch.substr(49, cch.length() - 49).c_str()), item = pInfo(peer)->lastchoosenitem, got = 0;
			Inventory::Modify(peer, item, got);
			if (got < count) return;
			if (items[item].r_1 == 2037 || items[item].r_2 == 2037 || items[item].r_1 == 2035 || items[item].r_2 == 2035 || items[item].r_1 + items[item].r_2 == 0 || items[item].blockType != BlockTypes::CLOTHING || items[item].untradeable || item == 1424 || item == 5816 || items[item].rarity > 200) return;
			else {
				std::string name_ = pInfo(peer)->world;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					world_->fresh_world = true;
					string received = "";
					std::vector<std::pair<int, int>> receivingitems;
					vector<int> list = { items[item].r_1,  items[item].r_2,  items[item].r_1 - 1 ,  items[item].r_2 - 1 }, random_compactor_rare = { 3178, 2936, 5010, 2644, 2454, 2456, 2458, 2460, 6790, 9004, 11060 };
					for (int i = 0; i < count; i++) {
						if (rand() % items[item].newdropchance < 20) {
							bool dublicate = false;
							int given_item = list[rand() % list.size()];
							for (int i = 0; i < receivingitems.size(); i++) {
								if (receivingitems[i].first == given_item) {
									dublicate = true;
									receivingitems[i].second += 1;
								}
							}
							if (dublicate == false) receivingitems.push_back(std::make_pair(given_item, 1));
						}
						else if (rand() % 50 < 1) {
							bool dublicate = false;
							int given_item = 0;
							if (rand() % 100 < 1) given_item = random_compactor_rare[rand() % random_compactor_rare.size()];
							else given_item = 2462;
							for (int i = 0; i < receivingitems.size(); i++) {
								if (receivingitems[i].first == given_item) {
									dublicate = true;
									receivingitems[i].second += 1;
								}
							}
							if (dublicate == false) receivingitems.push_back(std::make_pair(given_item, 1));
						}
						else {
							bool dublicate = false;
							int given_item = 112, given_count = ((items[item].max_gems == 0 ? 5 : rand() % items[item].max_gems)) / 2 + 1;
							if (rand() % 3 < 1) given_item = 856, given_count = 1;
							for (int i = 0; i < receivingitems.size(); i++) {
								if (receivingitems[i].first == given_item) {
									dublicate = true;
									receivingitems[i].second += given_count;
								}
							}
							if (dublicate == false) receivingitems.push_back(std::make_pair(given_item, given_count));
						}
					}
					int remove = count * -1;
					Inventory::Modify(peer, item, remove);
					for (int i = 0; i < receivingitems.size(); i++) {
						if (receivingitems.size() == 1) received += to_string(receivingitems[i].second) + " " + (items[item].r_1 == receivingitems[i].first || items[item].r_2 == receivingitems[i].first || items[item].r_2 - 1 == receivingitems[i].first || items[item].r_1 - 1 == receivingitems[i].first ? "`2" + items[receivingitems[i].first].name + "``" : (receivingitems[i].first == 112) ? items[receivingitems[i].first].name : "`1" + items[receivingitems[i].first].name + "``");
						else {
							if (receivingitems.size() - 1 == i)received += "and " + to_string(receivingitems[i].second) + " " + (items[item].r_1 == receivingitems[i].first || items[item].r_2 == receivingitems[i].first || items[item].r_2 - 1 == receivingitems[i].first || items[item].r_1 - 1 == receivingitems[i].first ? "`2" + items[receivingitems[i].first].name + "``" : (receivingitems[i].first == 112) ? items[receivingitems[i].first].name : "`1" + items[receivingitems[i].first].name + "``");
							else if (i != receivingitems.size()) received += to_string(receivingitems[i].second) + " " + (items[item].r_1 == receivingitems[i].first || items[item].r_2 == receivingitems[i].first || items[item].r_2 - 1 == receivingitems[i].first || items[item].r_1 - 1 == receivingitems[i].first ? "`2" + items[receivingitems[i].first].name + "``" : (receivingitems[i].first == 112) ? items[receivingitems[i].first].name : "`1" + items[receivingitems[i].first].name + "``") + ", ";
						}
						int given_count = receivingitems[i].second;
						if (receivingitems[i].first != 112) {
							if (receivingitems[i].first == 2644) Epic_Quest::Add(peer, "Compact a dress into a Mystery Dress", pInfo(peer)->epicq_compactdress, 1, 1);
							if (Inventory::Modify(peer, receivingitems[i].first, given_count) == 0) {
							}
							else {
								WorldDrop drop_block_{};
								drop_block_.id = receivingitems[i].first, drop_block_.count = given_count, drop_block_.x = (pInfo(peer)->lastwrenchx * 32) + rand() % 17, drop_block_.y = (pInfo(peer)->lastwrenchy * 32) + rand() % 17;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						else VarList::OnBuxGems(peer, given_count);
					}
					for (ENetPeer* cp__event = server->peers; cp__event < &server->peers[server->peerCount]; ++cp__event) {
						if (cp__event->state != ENET_PEER_STATE_CONNECTED or cp__event->data == NULL or pInfo(cp__event)->world != name_) continue;
						VarList::OnConsoleMessage(cp__event, "`7[``From crushing " + to_string(count) + " " + items[item].name + ", " + pInfo(peer)->tankIDName + " extracted " + received + ".`7]``");
						VarList::OnTalkBubble(cp__event, pInfo(peer)->netID, "`7[``From crushing " + to_string(count) + " " + items[item].name + ", " + pInfo(peer)->tankIDName + " extracted " + received + ".`7]``", 0, 0);
					}
				}
			}
		}
	}
	static void zombie_back(ENetPeer* peer, std::string cch) {
		if (cch.find("buttonClicked|53785") != string::npos) {
			VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSales-Man``|left|4358|\nadd_textbox|It is I, Sales-Man, savior of the wealthy! Let me rescue you from your riches. What would you like to buy today?|left|\nadd_button|chc4_1|Surgery Items|noflags|0|0|\nadd_button|chc5_1|Wolfworld Items|noflags|0|0|\nadd_button|chc3_1|Zombie Defense Items|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
		}
		if (cch.find("buttonClicked|zomb_price_") != string::npos) {
			int item = std::atoi(cch.substr(70, cch.length() - 70).c_str());
			if (item <= 0 || item >= items.size() || items[item].zombieprice == 0) return;
			pInfo(peer)->lockeitem = item;
			int zombie_brain = 0, pile = 0, total = 0;
			Inventory::Modify(peer, 4450, zombie_brain);
			Inventory::Modify(peer, 4452, pile);
			total += zombie_brain + (pile * 100);
			if (total >= items[item].zombieprice) VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSales-Man``|left|4358|\nadd_textbox|" + items[item].name + " costs " + Set_Count(items[item].zombieprice) + " Zombie Brains. Are you sure you want to buy it? You have " + Set_Count(total) + " Zombie Brains.|left|\nadd_button|zomb_item_|Yes, please|noflags|0|0|\nadd_button|back|No, thanks|noflags|0|0|\nend_dialog|zombie_purchase|Hang Up||\n");
			else VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSales-Man``|left|4358|\nadd_textbox|" + items[item].name + " costs " + Set_Count(items[item].zombieprice) + " Zombie Brains. You only have " + Set_Count(total) + " Zombie Brains so you can't afford it. Sorry!|left|\nadd_button|chc3_1|Back|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
		}
	}
	static void zombie_purchase(ENetPeer* peer, std::string cch) {
		if (cch.find("buttonClicked|chc3_1") != string::npos) {
			int zombie_brain = 0, pile = 0, total = 0;
			Inventory::Modify(peer, 4450, zombie_brain);
			Inventory::Modify(peer, 4452, pile);
			total += zombie_brain + (pile * 100);
			VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSales-Man: Zombie Defense``|left|4358|\nadd_textbox|Excellent! I'm happy to sell you Zombie Defense supplies in exchange for Zombie Brains.|left|\nadd_smalltext|You currently have " + Set_Count(total) + " Zombie Brains.|left|\nadd_spacer|small|\ntext_scaling_string|5,000ZB|\n" + Environment()->zombie_list + "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|53785|Back|noflags|0|0|\nend_dialog|zombie_back|Hang Up||\n");
		}
		if (cch.find("buttonClicked|zomb_item_") != string::npos) {
			int item = pInfo(peer)->lockeitem;
			if (item <= 0 || item >= items.size() || items[item].zombieprice == 0) return;
			int allwl = 0, wl = 0, dl = 0, price = items[item].zombieprice;
			Inventory::Modify(peer, 4450, wl);
			Inventory::Modify(peer, 4452, dl);
			allwl = wl + (dl * 100);
			if (allwl >= price) {
				int c_ = 1;
				if (Inventory::Modify(peer, item, c_) == 0) {
					if (wl >= price) Inventory::Modify(peer, 4450, price *= -1);
					else {
						Inventory::Modify(peer, 4450, wl *= -1);
						Inventory::Modify(peer, 4452, dl *= -1);
						int givedl = (allwl - price) / 100;
						int givewl = (allwl - price) - (givedl * 100);
						Inventory::Modify(peer, 4450, givewl);
						Inventory::Modify(peer, 4452, givedl);
					}
					if (item == 1486) if (pInfo(peer)->lwiz_step == 6) add_lwiz_points(peer, 1);
					if (item == 1486 && pInfo(peer)->C_QuestActive && pInfo(peer)->C_QuestKind == 11 && pInfo(peer)->C_QuestProgress < pInfo(peer)->C_ProgressNeeded) {
						pInfo(peer)->C_QuestProgress += 1;
						if (pInfo(peer)->C_QuestProgress >= pInfo(peer)->C_ProgressNeeded) {
							pInfo(peer)->C_QuestProgress = pInfo(peer)->C_ProgressNeeded;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`9Ring Quest task complete! Go tell the Ringmaster!", 0, 0);
						}
					}
					PlayerMoving data_{};
					data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = item, data_.punchY = pInfo(peer)->netID;
					int32_t to_netid = pInfo(peer)->netID;
					BYTE* raw = packPlayerMoving(&data_);
					raw[3] = 5;
					Memory_Copy(raw + 8, &to_netid, 4);
					send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					delete[] raw;
					VarList::OnConsoleMessage(peer, "`3You bought " + items[item].name + " for " + Set_Count(items[item].zombieprice) + " Zombie Brains.");
				}
				else VarList::OnConsoleMessage(peer, "No inventory space.");
			}
			else VarList::OnConsoleMessage(peer, "`9You don't have enough Zombie Brains!``");
		}
	}
	static void zurgery_back(ENetPeer* peer, std::string cch) {
		if (cch.find("buttonClicked|53785") != string::npos) {
			VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSales-Man``|left|4358|\nadd_textbox|It is I, Sales-Man, savior of the wealthy! Let me rescue you from your riches. What would you like to buy today?|left|\nadd_button|chc4_1|Surgery Items|noflags|0|0|\nadd_button|chc5_1|Wolfworld Items|noflags|0|0|\nadd_button|chc3_1|Zombie Defense Items|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
		}
		if (cch.find("buttonClicked|zurg_price_") != string::npos) {
			int item = std::atoi(cch.substr(71, cch.length() - 71).c_str());
			if (item <= 0 || item >= items.size() || items[item].surgeryprice == 0) return;
			pInfo(peer)->lockeitem = item;
			int zombie_brain = 0, pile = 0, total = 0;
			Inventory::Modify(peer, 4298, zombie_brain);
			Inventory::Modify(peer, 4300, pile);
			total += zombie_brain + (pile * 100);
			if (total >= items[item].surgeryprice) VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSales-Man``|left|4358|\nadd_textbox|" + items[item].name + " costs " + Set_Count(items[item].surgeryprice) + " Caduceus. Are you sure you want to buy it? You have " + Set_Count(total) + " Caduceus.|left|\nadd_button|zurg_item_|Yes, please|noflags|0|0|\nadd_button|chc4_1|No, thanks|noflags|0|0|\nend_dialog|zurgery_purchase|Hang Up||\n");
			else VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSales-Man``|left|4358|\nadd_textbox|" + items[item].name + " costs " + Set_Count(items[item].surgeryprice) + " Caduceus. You only have " + Set_Count(total) + " Caduceus so you can't afford it. Sorry!|left|\nadd_button|chc4_1|Back|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
		}
	}
	static void zurgery_purchase(ENetPeer* peer, std::string cch) {
		if (cch.find("buttonClicked|chc4_1") != string::npos) {
			int zombie_brain = 0, pile = 0, total = 0;
			Inventory::Modify(peer, 4298, zombie_brain);
			Inventory::Modify(peer, 4300, pile);
			total += zombie_brain + (pile * 100);
			VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSales-Man: Surgery``|left|4358|\nadd_textbox|Excellent! I'm happy to sell you rare and precious Surgery prizes in exchange for Caduceus medals.|left|\nadd_smalltext|You currently have " + Set_Count(total) + " Caducei.|left|\nadd_spacer|small|\ntext_scaling_string|50,000ZB|\n" + Environment()->surgery_list + "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|53785|Back|noflags|0|0|\nend_dialog|zurgery_back|Hang Up||\n");
		}
		if (cch.find("buttonClicked|zurg_item_") != string::npos) {
			int item = pInfo(peer)->lockeitem;
			if (item <= 0 || item >= items.size() || items[item].surgeryprice == 0) return;
			int allwl = 0, wl = 0, dl = 0, price = items[item].surgeryprice;
			Inventory::Modify(peer, 4298, wl);
			Inventory::Modify(peer, 4300, dl);
			allwl = wl + (dl * 100);
			if (allwl >= price) {
				int c_ = 1;
				if (Inventory::Modify(peer, item, c_) == 0) {
					if (wl >= price) Inventory::Modify(peer, 4298, price *= -1);
					else {
						Inventory::Modify(peer, 4298, wl *= -1);
						Inventory::Modify(peer, 4300, dl *= -1);
						int givedl = (allwl - price) / 100;
						int givewl = (allwl - price) - (givedl * 100);
						Inventory::Modify(peer, 4298, givewl);
						Inventory::Modify(peer, 4300, givedl);
					}
					if (item == 1486) {
						if (pInfo(peer)->lwiz_step == 6) add_lwiz_points(peer, 1);
						if (item == 1486 && pInfo(peer)->C_QuestActive && pInfo(peer)->C_QuestKind == 11 && pInfo(peer)->C_QuestProgress < pInfo(peer)->C_ProgressNeeded) {
							pInfo(peer)->C_QuestProgress++;
							if (pInfo(peer)->C_QuestProgress >= pInfo(peer)->C_ProgressNeeded) {
								pInfo(peer)->C_QuestProgress = pInfo(peer)->C_ProgressNeeded;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`9Ring Quest task complete! Go tell the Ringmaster!", 0, 0);
							}
						}
					}
					PlayerMoving data_{};
					data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = item, data_.punchY = pInfo(peer)->netID;
					int32_t to_netid = pInfo(peer)->netID;
					BYTE* raw = packPlayerMoving(&data_);
					raw[3] = 5;
					Memory_Copy(raw + 8, &to_netid, 4);
					send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					delete[] raw;
					VarList::OnConsoleMessage(peer, "`3You bought " + items[item].name + " for " + Set_Count(items[item].surgeryprice) + " Caduceus.");
				}
				else VarList::OnConsoleMessage(peer, "No inventory space.");
			}
			else VarList::OnConsoleMessage(peer, "`9You don't have enough Caduceus!``");
			return;
		}
	}
	static void wolf_back(ENetPeer* peer, std::string cch) {
		if (cch.find("buttonClicked|53785") != string::npos) {
			VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSales-Man``|left|4358|\nadd_textbox|It is I, Sales-Man, savior of the wealthy! Let me rescue you from your riches. What would you like to buy today?|left|\nadd_button|chc4_1|Surgery Items|noflags|0|0|\nadd_button|chc5_1|Wolfworld Items|noflags|0|0|\nadd_button|chc3_1|Zombie Defense Items|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
		}
		if (cch.find("buttonClicked|wolf_price_") != string::npos) {
			int item = std::atoi(cch.substr(68, cch.length() - 68).c_str());
			if (item <= 0 || item >= items.size() || items[item].wolfprice == 0) return;
			pInfo(peer)->lockeitem = item;
			int zombie_brain = 0, pile = 0, total = 0;
			Inventory::Modify(peer, 4354, zombie_brain);
			Inventory::Modify(peer, 4356, pile);
			total += zombie_brain + (pile * 100);
			if (total >= items[item].wolfprice) VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSales-Man``|left|4358|\nadd_textbox|" + items[item].name + " costs " + Set_Count(items[item].wolfprice) + " Wolf Ticket. Are you sure you want to buy it? You have " + Set_Count(total) + " Wolf Ticket.|left|\nadd_button|wolf_item_|Yes, please|noflags|0|0|\nadd_button|chc5_1|No, thanks|noflags|0|0|\nend_dialog|wolf_purchase|Hang Up||\n");
			else VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSales-Man``|left|4358|\nadd_textbox|" + items[item].name + " costs " + Set_Count(items[item].wolfprice) + " Wolf Ticket. You only have " + Set_Count(total) + " Wolf Ticket so you can't afford it. Sorry!|left|\nadd_button|chc5_1|Back|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
		}
	}
	static void wolf_purchase(ENetPeer* peer, std::string cch) {
		if (cch.find("buttonClicked|chc5_1") != string::npos) {
			int zombie_brain = 0, pile = 0, total = 0;
			Inventory::Modify(peer, 4354, zombie_brain);
			Inventory::Modify(peer, 4356, pile);
			total += zombie_brain + (pile * 100);
			VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSales-Man: Wolfworld``|left|4358|\nadd_textbox|Excellent! I'm happy to sell you rare and precious Woflworld prizes in exchange for Wolf Tickets.|left|\nadd_smalltext|You currently have " + Set_Count(total) + " Wolf Tickets.|left|\nadd_spacer|small|\ntext_scaling_string|50,000WT|\n" + Environment()->wolf_list + "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|53785|Back|noflags|0|0|\nend_dialog|wolf_back|Hang Up||\n");
		}
		if (cch.find("buttonClicked|wolf_item_") != string::npos) {
			int item = pInfo(peer)->lockeitem;
			if (item <= 0 || item >= items.size() || items[item].wolfprice == 0) return;
			int allwl = 0, wl = 0, dl = 0, price = items[item].wolfprice;
			Inventory::Modify(peer, 4354, wl);
			Inventory::Modify(peer, 4356, dl);
			allwl = wl + (dl * 100);
			if (allwl >= price) {
				int c_ = 1;
				if (Inventory::Modify(peer, item, c_) == 0) {
					if (wl >= price) Inventory::Modify(peer, 4354, price *= -1);
					else {
						Inventory::Modify(peer, 4354, wl *= -1);
						Inventory::Modify(peer, 4356, dl *= -1);
						int givedl = (allwl - price) / 100;
						int givewl = (allwl - price) - (givedl * 100);
						Inventory::Modify(peer, 4354, givewl);
						Inventory::Modify(peer, 4356, givedl);
					}
					if (item == 1486) if (pInfo(peer)->lwiz_step == 6) add_lwiz_points(peer, 1);
					if (item == 1486 && pInfo(peer)->C_QuestActive && pInfo(peer)->C_QuestKind == 11 && pInfo(peer)->C_QuestProgress < pInfo(peer)->C_ProgressNeeded) {
						pInfo(peer)->C_QuestProgress += 1;
						if (pInfo(peer)->C_QuestProgress >= pInfo(peer)->C_ProgressNeeded) {
							pInfo(peer)->C_QuestProgress = pInfo(peer)->C_ProgressNeeded;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`9Ring Quest task complete! Go tell the Ringmaster!", 0, 0);
						}
					}
					PlayerMoving data_{};
					data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = item, data_.punchY = pInfo(peer)->netID;
					int32_t to_netid = pInfo(peer)->netID;
					BYTE* raw = packPlayerMoving(&data_);
					raw[3] = 5;
					Memory_Copy(raw + 8, &to_netid, 4);
					send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					delete[] raw;
					VarList::OnConsoleMessage(peer, "`3You bought " + items[item].name + " for " + Set_Count(items[item].wolfprice) + " Wolf Ticket.");
				}
				else VarList::OnConsoleMessage(peer, "No inventory space.");
			}
			else VarList::OnConsoleMessage(peer, "`9You don't have enough Wolf Ticket!``");
		}
	}
	static void a3898(ENetPeer* peer, std::string cch) {
		if (cch.find("buttonClicked|") != string::npos) {
			string btn = cch.substr(52, cch.length() - 52).c_str();
			bool fail = false;
			replace_str(btn, "\n", "");
			/*Crazy Jim*/if (btn == "12345") VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wCrazy Jim's Quest Emporium``|left|3902|\nadd_textbox|HEEEEYYY there Growtopian! I'm Crazy Jim, and my quests are so crazy they're KERRRRAAAAZZY!! And that is clearly very crazy, so please, be cautious around them. What can I do ya for, partner?|left|\nadd_button|chc1_1|Daily Quest|noflags|0|0|\nadd_button|life_goals|`oGoals|noflags|0|0|\nadd_button|epic_quest|`oEpic Quests|noflags|0|0|\nadd_button|biweekly_quest|`oBiweekly Quests|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
			/*Salesman*/else if (btn == "53785") VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSales-Man``|left|4358|\nadd_textbox|It is I, Sales-Man, savior of the wealthy! Let me rescue you from your riches. What would you like to buy today?|left|\nadd_button|chc4_1|Surgery Items|noflags|0|0|\nadd_button|chc5_1|Wolfworld Items|noflags|0|0|\nadd_button|chc3_1|Zombie Defense Items|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
			/*nobody*/else if (btn == "77777") VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wNobody``|left|3898|\nadd_popup_name|Telephone77777|\nadd_textbox|There's nobody there. I know, it really seemed like 77777 would be a valid phone number, didn't it? Sorry, it's not. You just wasted 3 seconds of your life. And now you're wasting like 5 more reading this text. Anyway, have fun playing Growtopia! We put in goofy stuff like this just to amuse you!|left|\nadd_button|chc0|We are not amused|noflags|0|0|0|\nend_dialog|3898|Hang Up||");
			/*Converter*/else if (btn == "11111") VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wConverter Lock's``|left|4210|\nadd_textbox|Yup, this is the Converter. Whatcha need?|left|\nadd_spacer|small|\ntext_scaling_string|Subscribtions++++++++|\nadd_button_with_icon||`$Diamond Lock|noflags|1796|100|\nadd_custom_button|btn_1|icon:482;state:disabled;color:255,255,255,255;margin_rself:1,0;width:0.125;display:inline_free;|\nadd_custom_margin|x:100;y:0|\nadd_button_with_icon||`$Platinum Gem Lock|noflags|7188|1|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_custom_button|chc2_1|textLabel:Convert;middle_colour:75947213;border_colour:75947213;|\nadd_custom_break|\nadd_spacer|small|\nadd_button_with_icon||`$Platinum Gem Lock|noflags|7188|100|\nadd_custom_button|btn_1|icon:482;state:disabled;color:255,255,255,255;margin_rself:1,0;width:0.125;display:inline_free;|\nadd_custom_margin|x:100;y:0|\nadd_button_with_icon||`$Ruthemium Gem Lock|noflags|8470|1|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_custom_button|chc2_2|textLabel:Convert;middle_colour:75947213;border_colour:75947213;|\nadd_custom_break|\nadd_spacer|small|\nadd_button_with_icon||`$" + Environment()->server_name + " Gem Lock|noflags|8470|1|\nadd_custom_button|btn_1|icon:482;state:disabled;color:255,255,255,255;margin_rself:1,0;width:0.125;display:inline_free;|\nadd_custom_margin|x:100;y:0|\nadd_button_with_icon||`$Platinum Gem Lock|noflags|7188|100|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_custom_button|chc2_3|textLabel:Convert;middle_colour:75947213;border_colour:75947213;|"
				"\nadd_custom_break|\nadd_spacer|small|\nadd_button_with_icon||`$" + Environment()->server_name + " Gem Lock|noflags|8470|100|\nadd_custom_button|btn_1|icon:482;state:disabled;color:255,255,255,255;margin_rself:1,0;width:0.125;display:inline_free;|\nadd_custom_margin|x:100;y:0|\nadd_button_with_icon||`$Infinity Gem Lock|noflags|13200|1|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_custom_button|chc2_4|textLabel:Convert;middle_colour:75947213;border_colour:75947213;|"
				"\nadd_custom_break|\nadd_spacer|small|\nadd_button_with_icon||`$Infinity Gem Lock|noflags|13200|1|\nadd_custom_button|btn_1|icon:482;state:disabled;color:255,255,255,255;margin_rself:1,0;width:0.125;display:inline_free;|\nadd_custom_margin|x:100;y:0|\nadd_button_with_icon||`$" + Environment()->server_name + " Gem Lock|noflags|8470|100|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_custom_button|chc2_5|textLabel:Convert;middle_colour:75947213;border_colour:75947213;|"
				"\nadd_custom_break|\nadd_spacer|small|\nend_dialog|3898|Hang Up||");
			/*******/
			else if (btn == "chc1_1") {
				if (pInfo(peer)->dd == 0) {
					int haveitem1 = 0, haveitem2 = 0, received = 0;
					Inventory::Modify(peer, Environment()->Dq_Item1, haveitem1);
					Inventory::Modify(peer, Environment()->Dq_Item2, haveitem2);
					if (haveitem1 >= Environment()->Dq_Count1 && haveitem2 >= Environment()->Dq_Count2) received = 1;
					VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wCrazy Jim's Daily Quest``|left|3902|\nadd_textbox|I guess some people call me Crazy Jim because I'm a bit of a hoarder. But I'm very particular about what I want! And today, what I want is this:|left|\nadd_label_with_icon|small|`2" + to_string(Environment()->Dq_Count1) + " " + items[Environment()->Dq_Item1].name + "|left|" + to_string(Environment()->Dq_Item1) + "|\nadd_smalltext|and|left|\nadd_label_with_icon|small|`2" + to_string(Environment()->Dq_Count2) + " " + items[Environment()->Dq_Item2].name + "|left|" + to_string(Environment()->Dq_Item2) + "|\nadd_spacer|small|\nadd_smalltext|You shove all that through the phone (it works, I've tried it), and I will hand you one of the `2Growtokens`` from my personal collection!  But hurry, this offer is only good until midnight, and only one `2Growtoken`` per person!|left|\nadd_spacer|small|\nadd_smalltext|`6(You have " + to_string(haveitem1) + " " + items[Environment()->Dq_Item1].name + " and " + to_string(haveitem2) + " " + items[Environment()->Dq_Item2].name + ")``|left|\nadd_spacer|small|" + (received == 1 ? "\nadd_button|turnin|Turn in items|noflags|0|0|" : "") + "\nadd_spacer|small|\nadd_button|12345|Back|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
				}
				else VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wCrazy Jim's Daily Quest``|left|3902|\nadd_textbox|You've already completed my Daily Quest for today! Call me back after midnight to hear about my next cravings.|left|\nadd_button|12345|Back|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
			}
			else if (btn == "viewgpass") {
				DialogHandle::GrowPass(peer, "Tasks");
			}
			else if (btn == "epic_quest") {
				VarList::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`wCrazy Jim's Epic Quests|left|3902|\nadd_textbox|`oEpic Quests are the ultimate goals in Growtopia. It will take you thousand of hours and absolute dedication to complete all. But if you can complete all of these - while maintaining a `2Clean record ``of behavior - we'll make you your own original in-game items! Press below to learn more.|left|\nadd_url_button|comment|`2Rules & Regulations``|noflags|https://www.growtopiagame.com/forums|Open the Rules webpage in your browser?|0|0|\nadd_textbox|`oEpic Quests``|left|" + a + (pInfo(peer)->epicq_emeraldlock == 0 ? "\nadd_label_with_icon|small|`3Lock a world with an Emerald Lock``|left|482|" : "") + (pInfo(peer)->epicq_plant_wiz == 0 ? "\nadd_label_with_icon|small|`3Plant a Wizard's Staff Tree``|left|482|" : "") + (pInfo(peer)->epicq_splice_wm_comet == 0 ? "\nadd_label_with_icon|small|`3Splice a Weather Machine - Comet``|left|482|" : "") + (pInfo(peer)->epicq_lvl100 == 0 ? "\nadd_label_with_icon|small|`3Level up to level 100``|left|482|" : "") + (pInfo(peer)->epicq_teddybear == 0 ? "\nadd_label_with_icon|small|`3Get a Teddy Bear from an Awkward Friendly Unicorn``|left|482|" : "") + (pInfo(peer)->epicq_ghostcharm == 0 ? "\nadd_label_with_icon|small|`3Get a Ghost Charm from a Spirit Storage explosion``|left|482|" : "") + (pInfo(peer)->epic_quest_total != 0 ? "\nadd_textbox|`9Completed Epic Quests:|left|" + a + (pInfo(peer)->epicq_emeraldlock != 0 ? "\nadd_label_with_icon|small|`9Lock a world with an Emerald Lock``|left|3764|" : "") + (pInfo(peer)->epicq_plant_wiz != 0 ? "\nadd_label_with_icon|small|`9Plant a Wizard's Staff Tree``|left|3764|" : "") + (pInfo(peer)->epicq_splice_wm_comet != 0 ? "\nadd_label_with_icon|small|`9Splice a Weather Machine - Comet``|left|3764|" : "") + (pInfo(peer)->epicq_lvl100 != 0 ? "\nadd_label_with_icon|small|`9Level up to level 100``|left|3764|" : "") + (pInfo(peer)->epicq_teddybear != 0 ? "\nadd_label_with_icon|small|`9Get a Teddy Bear from an Awkward Friendly Unicorn``|left|3764|" : "") + (pInfo(peer)->epicq_ghostcharm != 0 ? "\nadd_label_with_icon|small|`9Get a Ghost Charm from a Spirit Storage explosion``|left|3764|" : "") + "" : "") + "\nadd_spacer|small|\nadd_button|12345|`oBack|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
			}
			else if (btn == "life_goals") {
				DialogHandle::Life_Goals(peer);
			}
			else if (btn == "biweekly_quest") {
				VarList::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`wCrazy Jim's Soul Stone Quest|left|3902|\nadd_textbox|`oI guess some poeple call me Crazy Jim because i'm a bit of a noarder, but i'm very particular about what i want! And today, what i want is this:|left|\nadd_spacer|small|" + (pInfo(peer)->biweekly_completed ? "\nadd_textbox|`oQuest Complete!|left|" : "\nadd_textbox|`o- Smash 10000 rarity of blocks " + (pInfo(peer)->BiweeklyQ_1 == 10000 ? "`2(OK!)" : "`o(" + to_string(pInfo(peer)->BiweeklyQ_1) + "/10000)") + "|left|\nadd_textbox|`o- Find 20 radioactive items from a Geiger Counter " + (pInfo(peer)->BiweeklyQ_2 == 20 ? "`2(OK!)" : "`o(" + to_string(pInfo(peer)->BiweeklyQ_2) + "/20)") + "|left|\nadd_textbox|`o- Earn 3 Growtokens " + (pInfo(peer)->BiweeklyQ_3 == 3 ? "`2(OK!)" : "`o(" + to_string(pInfo(peer)->BiweeklyQ_3) + "/3)") + "|left|") + "\nadd_spacer|small|" + (pInfo(peer)->BiweeklyQ_1 == 10000 and pInfo(peer)->BiweeklyQ_2 == 20 and pInfo(peer)->BiweeklyQ_3 == 3 ? "\nadd_button|finish_biweeklygoals|`oFinish Goals|noflags|0|0|\nadd_spacer|small|" : "") + "\nadd_smalltext|`oYou shove all that throught the phone (It works, I've tried it), and i will hand you one of the `5Soul Stones`` from my personal collection! But hurry, this offer is only available during the Biweekly Soul Quests, and only one `5Soul Stone`` per person!|left|\nadd_spacer|small|\nadd_smalltext|`5- Earn 300 Grow Pass Points.|left|\nadd_button|viewgpass|`oView Grow Pass|noflags|0|0|\nadd_spacer|small|\nadd_textbox|`oBiweekly Soul Quests will reset in " + Time::Playmod(pInfo(peer)->biweekly_reset_day - time(nullptr)) + "|left|\nadd_spacer|small|\nadd_button|12345|`oBack|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
			}
			else if (btn == "finish_biweeklygoals") {
				int c_ = 1;
				if (pInfo(peer)->BiweeklyQ_1 == 10000 and pInfo(peer)->BiweeklyQ_2 == 20 and pInfo(peer)->BiweeklyQ_3 == 3) {
					pInfo(peer)->biweekly_completed = true;
					pInfo(peer)->BiweeklyQ_1 = 0, pInfo(peer)->BiweeklyQ_2 == 0, pInfo(peer)->BiweeklyQ_3 == 0;
					Inventory::Modify(peer, 5202, c_);
					if (pInfo(peer)->gp) {
						pInfo(peer)->growpass_points += 300;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You received `2300 Grow Pass Points``!", 0, 0);
					}
					std::string name_ = pInfo(peer)->world;
					std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
					if (p != worlds.end()) {
						World* world_ = &worlds[p - worlds.begin()];
						world_->fresh_world = true;
						PlayerMoving data_{};
						data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16;
						data_.packetType = 19, data_.plantingTree = 500;
						data_.punchX = 5202, data_.punchY = pInfo(peer)->netID;
						int32_t to_netid = pInfo(peer)->netID;
						BYTE* raw = packPlayerMoving(&data_);
						raw[3] = 5;
						memcpy(raw + 8, &to_netid, 4);
						for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
							if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
							if (pInfo(cp_)->world == world_->name) {
								send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw;
					}
				}
			}
			else if (btn == "lifegoal_turnin_1") {
				if (not pInfo(peer)->lifegoals_1) {
					int token = 1486, tcount = 0, itemid = Environment()->small_seed_pack[rand() % Environment()->small_seed_pack.size()], count = 6;
					Inventory::Modify(peer, itemid, count);
					pInfo(peer)->lifegoals_1 = true;
					if (pInfo(peer)->lifegoals_1 and pInfo(peer)->lifegoals_2 and pInfo(peer)->lifegoals_3) {
						tcount += 1;
						if (pInfo(peer)->pg_bank) Add_Piggy_Bank(peer, 15000);
						VarList::OnConsoleMessage(peer, "`8Daily Life Bonus Complete!\n`8Bonus: `2Growtoken!!");
					}
					if (pInfo(peer)->awesomeness == 100) tcount += 1;
					if (tcount != 0) Inventory::Modify(peer, token, tcount);
					if (pInfo(peer)->gp) {
						pInfo(peer)->growpass_points += 20;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You received `220 Grow Pass Points``!", 0, 0);
					}
					if (pInfo(peer)->awesomeness < 100) pInfo(peer)->awesomeness++;
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (pInfo(cp_)->world == pInfo(peer)->world) {
							CAction::Effect(cp_, 48, (float)pInfo(peer)->x + 10, (float)pInfo(peer)->y + 16);
						}
					}
					VarList::OnConsoleMessage(peer, "`9Seed Goal Completed! Reward: `26 " + items[itemid].name);
					VarList::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`wCrazy Jim: Goal Complete!|left|3902|\nadd_textbox|`oYou completed your Seed Goal for the day! Here, I'll give you `26 " + items[itemid].name + "``! You are as `9Awesome ``as someone can be!|left|\nadd_button|life_goals|`oHooray!|noflags|0|0|\nadd_spacer|small|\nend_dialog|3898|Hang Up||");
				}
			}
			else if (btn == "lifegoal_giveup_1") {
				VarList::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`wCrazy Jim Believes in You!|left|3902|\nadd_smalltext|`oWhat? Give Up? Come on, you can do it! Well. If i can't convince you to stick to your dreams, I guess you can give up on this one... but i won't give you a replacement goal until tomorrow! It will be impossible to complete today's Growtoken goal without 3 Goals.|left|\nadd_textbox|`oAre you sure you want to give up on the goal ''Earn 1,000 XP''?|left|\nadd_button|lifegoal_yesgiveup_1|`oYes!|noflags|0|0|\nadd_button|12345|`oNo, I will be strong!|noflags|0|0|\nadd_spacer|small|\nend_dialog|3898|Hang Up||");
			}
			else if (btn == "lifegoal_yesgiveup_1") {
				pInfo(peer)->lifegoals1 = false;
				DialogHandle::Life_Goals(peer);
			}
			else if (btn == "lifegoal_turnin_2") {
				if (not pInfo(peer)->lifegoals_2) {
					int count = rand() % 1000, token = 1486, tcount = 0;
					VarList::OnBuxGems(peer, count);
					pInfo(peer)->lifegoals_2 = true;
					if (pInfo(peer)->lifegoals_1 and pInfo(peer)->lifegoals_2 and pInfo(peer)->lifegoals_3) {
						tcount += 1;
						if (pInfo(peer)->pg_bank) Add_Piggy_Bank(peer, 15000);
						VarList::OnConsoleMessage(peer, "`8Daily Life Bonus Complete!\n`8Bonus: `2Growtoken!!");
					}
					if (pInfo(peer)->awesomeness == 100) tcount += 1;
					if (tcount != 0) Inventory::Modify(peer, token, tcount);
					if (pInfo(peer)->gp) {
						pInfo(peer)->growpass_points += 20;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You received `220 Grow Pass Points``!", 0, 0);
					}
					if (pInfo(peer)->awesomeness < 100) pInfo(peer)->awesomeness++;
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (pInfo(cp_)->world == pInfo(peer)->world) {
							CAction::Effect(cp_, 48, (float)pInfo(peer)->x + 10, (float)pInfo(peer)->y + 16);
						}
					}
					VarList::OnConsoleMessage(peer, "`9Gem Goal Completed! Reward: `2" + to_string(count) + " Gems");
					VarList::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`wCrazy Jim: Goal Complete!|left|3902|\nadd_textbox|`oYou completed your Seed Goal for the day! Here, I'll give you `2" + to_string(count) + " Gems``! You are as `9Awesome ``as someone can be!|left|\nadd_button|life_goals|`oHooray!|noflags|0|0|\nadd_spacer|small|\nend_dialog|3898|Hang Up||");
				}
			}
			else if (btn == "lifegoal_giveup_2") {
				VarList::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`wCrazy Jim Believes in You!|left|3902|\nadd_smalltext|`oWhat? Give Up? Come on, you can do it! Well. If i can't convince you to stick to your dreams, I guess you can give up on this one... but i won't give you a replacement goal until tomorrow! It will be impossible to complete today's Growtoken goal without 3 Goals.|left|\nadd_textbox|`oAre you sure you want to give up on the goal ''Smash 1000 rarity of blocks''?|left|\nadd_button|lifegoal_yesgiveup_2|`oYes!|noflags|0|0|\nadd_button|12345|`oNo, I will be strong!|noflags|0|0|\nadd_spacer|small|\nend_dialog|3898|Hang Up||");
			}
			else if (btn == "lifegoal_yesgiveup_2") {
				pInfo(peer)->lifegoals2 = false;
				DialogHandle::Life_Goals(peer);
			}
			else if (btn == "lifegoal_turnin_3") {
				if (not pInfo(peer)->lifegoals_3) {
					int token = 1486, tcount = 0;
					add_peer_xp(peer, 1000);
					pInfo(peer)->lifegoals_3 = true;
					if (pInfo(peer)->lifegoals_1 and pInfo(peer)->lifegoals_2 and pInfo(peer)->lifegoals_3) {
						tcount += 1;
						if (pInfo(peer)->pg_bank) Add_Piggy_Bank(peer, 15000);
						VarList::OnConsoleMessage(peer, "`8Daily Life Bonus Complete!\n`8Bonus: `2Growtoken!!");
					}
					if (pInfo(peer)->awesomeness == 100) tcount += 1;
					if (tcount != 0) Inventory::Modify(peer, token, tcount);
					if (pInfo(peer)->gp) {
						pInfo(peer)->growpass_points += 20;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You received `220 Grow Pass Points``!", 0, 0);
					}
					if (pInfo(peer)->awesomeness < 100) pInfo(peer)->awesomeness++;
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (pInfo(cp_)->world == pInfo(peer)->world) {
							CAction::Effect(cp_, 48, (float)pInfo(peer)->x + 10, (float)pInfo(peer)->y + 16);
						}
					}
					VarList::OnConsoleMessage(peer, "`9Experince Goal Completed! Reward: `21000 XP");
					VarList::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`wCrazy Jim: Goal Complete!|left|3902|\nadd_textbox|`oYou completed your Seed Goal for the day! Here, I'll give you `21000 XP``! You are as `9Awesome ``as someone can be!|left|\nadd_button|life_goals|`oHooray!|noflags|0|0|\nadd_spacer|small|\nend_dialog|3898|Hang Up||");
				}
			}
			else if (btn == "lifegoal_giveup_3") {
				VarList::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`wCrazy Jim Believes in You!|left|3902|\nadd_smalltext|`oWhat? Give Up? Come on, you can do it! Well. If i can't convince you to stick to your dreams, I guess you can give up on this one... but i won't give you a replacement goal until tomorrow! It will be impossible to complete today's Growtoken goal without 3 Goals.|left|\nadd_textbox|`oAre you sure you want to give up on the goal ''Harvest 800 rarity from trees''?|left|\nadd_button|lifegoal_yesgiveup_3|`oYes!|noflags|0|0|\nadd_button|12345|`oNo, I will be strong!|noflags|0|0|\nadd_spacer|small|\nend_dialog|3898|Hang Up||");
			}
			else if (btn == "lifegoal_yesgiveup_3") {
				pInfo(peer)->lifegoals3 = false;
				DialogHandle::Life_Goals(peer);
			}
			else if (btn == "turnin") {
				if (pInfo(peer)->dd == 0) {
					int haveitem1 = 0, haveitem2 = 0, received = 0, remove = -1, remove2 = -1, giveitem = 1;
					Inventory::Modify(peer, Environment()->Dq_Item1, haveitem1);
					Inventory::Modify(peer, Environment()->Dq_Item2, haveitem2);
					if (haveitem1 >= Environment()->Dq_Count1 && haveitem2 >= Environment()->Dq_Count2) received = 1;
					if (received == 1) {
						if (Playmods::HasById(pInfo(peer), 112)) {
							if (rand() % 100 < 25) giveitem *= 2;
						}
						if (pInfo(peer)->gp) {
							if (complete_gpass_task(peer, "Growtoken")) giveitem++;
						}
						if (pInfo(peer)->pg_bank) Add_Piggy_Bank(peer, 20000);
						if (pInfo(peer)->C_QuestActive && pInfo(peer)->C_QuestKind == 11 && pInfo(peer)->C_QuestProgress < pInfo(peer)->C_ProgressNeeded) {
							pInfo(peer)->C_QuestProgress += giveitem;
							if (pInfo(peer)->C_QuestProgress >= pInfo(peer)->C_ProgressNeeded) {
								pInfo(peer)->C_QuestProgress = pInfo(peer)->C_ProgressNeeded;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`9Ring Quest task complete! Go tell the Ringmaster!", 0, 0);
							}
						}
						if (pInfo(peer)->BiweeklyQ_3 < 3) {
							pInfo(peer)->BiweeklyQ_3 += giveitem;
							if (pInfo(peer)->BiweeklyQ_3 >= 3) {
								pInfo(peer)->BiweeklyQ_3 = 3;
								VarList::OnConsoleMessage(peer, "`9Biweekly Goal ''`2Earn 3 Growtokens``'' is complete! Go call Crazy Jim!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`9Biweekly Goal ''`2Earn 3 Growtokens``'' is complete! Go call Crazy Jim!", 0, 0);
							}
						}
						int gots = giveitem;
						if (pInfo(peer)->lwiz_step == 6) add_lwiz_points(peer, giveitem);
						pInfo(peer)->dd = 1;
						Inventory::Modify(peer, Environment()->Dq_Item1, remove *= Environment()->Dq_Count1);
						Inventory::Modify(peer, Environment()->Dq_Item2, remove2 *= Environment()->Dq_Count2);
						Inventory::Modify(peer, 1486, giveitem);
						std::string name_ = pInfo(peer)->world;
						std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
						if (p != worlds.end()) {
							World* world_ = &worlds[p - worlds.begin()];
							world_->fresh_world = true;
							PlayerMoving data_{};
							data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16;
							data_.packetType = 19, data_.plantingTree = 500;
							data_.punchX = 1486, data_.punchY = pInfo(peer)->netID;
							int32_t to_netid = pInfo(peer)->netID;
							BYTE* raw = packPlayerMoving(&data_);
							raw[3] = 5;
							Memory_Copy(raw + 8, &to_netid, 4);
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
								if (pInfo(cp_)->world == world_->name) {
									send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw;
						}
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Thanks, pardner! Have 1 `2Growtoken!", 0, 0);
					}
				}
				else VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wCrazy Jim's Daily Quest``|left|3902|\nadd_textbox|You've already completed my Daily Quest for today! Call me back after midnight to hear about my next cravings.|left|\nadd_button|12345|Back|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
			}
			else if (btn == "chc2_4") {
				int c_ = 0;
				Inventory::Modify(peer, 8470, c_);
				VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wInfinity Gem Lock``|left|13200|\nadd_textbox|Excellent! I'm happy to sell you a 100 " + Environment()->server_name + " Gem Lock in exchange for 1 Infinity Gem Lock..|left|\nadd_smalltext|`6You have " + to_string(c_) + " " + Environment()->server_name + " Gem Lock.``|left|" + (c_ >= 100 ? "\nadd_button|chc2_3_4|Thank you!|noflags|0|0|" : "") + "\nadd_button|11111|Back|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
			}
			else if (btn == "chc2_3_4") {
				int igl = Inventory::Contains(peer, 13200), mgl = Inventory::Contains(peer, 8470), additem = 0;
				if (mgl < 100) return;
				if (igl >= 200) {
					VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 0);
					fail = true;
					return;
				}
				if (mgl >= 100) {
					if (Inventory::Get_Slots(pInfo(peer)) >= 2) {
						int cz_ = 1;
						if (Inventory::Modify(peer, 8470, additem = -100) == 0) {
							if (Inventory::Modify(peer, 13200, additem = 1) == 0) {
								{
									PlayerMoving data_{}; PlayerMoving data{};
									data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = 13200, data_.punchY = pInfo(peer)->netID;
									int32_t to_netid = pInfo(peer)->netID;
									BYTE* raw = packPlayerMoving(&data_);
									raw[3] = 5;
									Memory_Copy(raw + 8, &to_netid, 4);
									data.packetType = 19, data.netID = -1, data.plantingTree = 0;
									data.x = pInfo(peer)->lastwrenchx * 32 + 16, data.y = pInfo(peer)->lastwrenchy * 32 + 16;
									data.XSpeed = pInfo(peer)->x + 16, data.YSpeed = pInfo(peer)->y + 16;
									data.punchX = 8470;
									BYTE* raw_ = packPlayerMoving(&data);
									raw_[3] = 6;
									for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; cp_++) {
										if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL) break;
										if (pInfo(peer)->world == pInfo(cp_)->world) {
											send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											send_raw(cp_, 4, raw_, 56, ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[] raw, raw_;
									VarList::OnConsoleMessage(peer, "[`6You spent 100 " + Environment()->server_name + " Gem Lock to get 1 Infinity Gem Lock``]");
								}
							}
							else {
								fail = true;
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 0);
								return;
							}
						}
						else {
							fail = true;
							VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 0);
							return;
						}
						int c_ = 0;
						Inventory::Modify(peer, 8470, c_);
						VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wInfinity Gem Lock``|left|13200|\nadd_textbox|Excellent! I'm happy to sell you a 100 " + Environment()->server_name + " Gem Lock in exchange for 1 Infinity Gem Lock..|left|\nadd_smalltext|`6You have " + to_string(c_) + " " + Environment()->server_name + " Gem Lock.``|left|" + (c_ >= 100 ? "\nadd_button|chc2_3_4|Thank you!|noflags|0|0|" : "") + "\nadd_button|11111|Back|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
					}
					else {
						fail = true;
						VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 0);
						return;
					}
				}
				else {
					VarList::OnConsoleMessage(peer, "You don't have enough inventory space!");
					fail = true;
				}
			}
			else if (btn == "chc2_5") {
				int c_ = 0;
				Inventory::Modify(peer, 13200, c_);
				VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wInfinity Gem Lock``|left|13200|\nadd_textbox|Excellent! I'm happy to sell you a 1 Infinity Gem Lock in exchange for 100 " + Environment()->server_name + " Gem Lock..|left|\nadd_smalltext|`6You have " + to_string(c_) + " Infinity Gem Lock.``|left|" + (c_ >= 1 ? "\nadd_button|chc2_3_5|Thank you!|noflags|0|0|" : "") + "\nadd_button|11111|Back|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
			}
			else if (btn == "chc2_3_5") {
				int igl = Inventory::Contains(peer, 13200), mgl = Inventory::Contains(peer, 8470), additem = 0;
				if (igl < 1) return;
				if (mgl >= 200) {
					VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 0);
					fail = true;
					return;
				}
				if (igl >= 1) {
					if (Inventory::Get_Slots(pInfo(peer)) >= 2) {
						int cz_ = 1;
						if (Inventory::Modify(peer, 13200, additem = -1) == 0) {
							if (Inventory::Modify(peer, 8470, additem = 100) == 0) {
								{
									PlayerMoving data_{}; PlayerMoving data{};
									data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = 8470, data_.punchY = pInfo(peer)->netID;
									int32_t to_netid = pInfo(peer)->netID;
									BYTE* raw = packPlayerMoving(&data_);
									raw[3] = 5;
									Memory_Copy(raw + 8, &to_netid, 4);
									data.packetType = 19, data.netID = -1, data.plantingTree = 0;
									data.x = pInfo(peer)->lastwrenchx * 32 + 16, data.y = pInfo(peer)->lastwrenchy * 32 + 16;
									data.XSpeed = pInfo(peer)->x + 16, data.YSpeed = pInfo(peer)->y + 16;
									data.punchX = 13200;
									BYTE* raw_ = packPlayerMoving(&data);
									raw_[3] = 6;
									for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; cp_++) {
										if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL) break;
										if (pInfo(peer)->world == pInfo(cp_)->world) {
											send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											send_raw(cp_, 4, raw_, 56, ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[] raw, raw_;
									VarList::OnConsoleMessage(peer, "[`6You spent 1 Infinity Gem Lock to get 100 " + Environment()->server_name + " Gem Lock``]");
								}
							}
							else {
								fail = true;
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 0);
								return;
							}
						}
						else {
							fail = true;
							VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 0);
							return;
						}
						int c_ = 0;
						Inventory::Modify(peer, 13200, c_);
						VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wInfinity Gem Lock``|left|13200|\nadd_textbox|Excellent! I'm happy to sell you a 1 Infinity Gem Lock in exchange for 100 " + Environment()->server_name + " Gem Lock..|left|\nadd_smalltext|`6You have " + to_string(c_) + " Infinity Gem Lock.``|left|" + (c_ >= 1 ? "\nadd_button|chc2_3_5|Thank you!|noflags|0|0|" : "") + "\nadd_button|11111|Back|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
					}
					else {
						fail = true;
						VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 0);
						return;
					}
				}
				else {
					VarList::OnConsoleMessage(peer, "You don't have enough inventory space!");
					fail = true;
				}
			}
			else if (btn == "chc2_3") {
				int c_ = 0;
				Inventory::Modify(peer, 8470, c_);
				VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + Environment()->server_name + " Gem Lock``|left|8470|\nadd_textbox|Excellent! I'm happy to sell you a 100 Platinum Gem Lock in exchange for 1 " + Environment()->server_name + " Gem Lock..|left|\nadd_smalltext|`6You have " + to_string(c_) + " " + Environment()->server_name + " Gem Lock.``|left|" + (c_ >= 1 ? "\nadd_button|chc2_3_3|Thank you!|noflags|0|0|" : "") + "\nadd_button|11111|Back|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
			}
			else if (btn == "chc2_3_3") {
				int platinum = Inventory::Contains(peer, 7188), ruth = Inventory::Contains(peer, 8470), additem = 0;
				if (ruth < 1) return;
				if (platinum >= 200) {
					VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 0);
					fail = true;
					return;
				}
				if (ruth >= 1) {
					if (Inventory::Get_Slots(pInfo(peer)) >= 2) {
						int cz_ = 1;
						if (Inventory::Modify(peer, 8470, additem = -1) == 0) {
							if (Inventory::Modify(peer, 7188, additem = 100) == 0) {
								{
									PlayerMoving data_{}; PlayerMoving data{};
									data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = 7188, data_.punchY = pInfo(peer)->netID;
									int32_t to_netid = pInfo(peer)->netID;
									BYTE* raw = packPlayerMoving(&data_);
									raw[3] = 5;
									Memory_Copy(raw + 8, &to_netid, 4);
									data.packetType = 19, data.netID = -1, data.plantingTree = 0;
									data.x = pInfo(peer)->lastwrenchx * 32 + 16, data.y = pInfo(peer)->lastwrenchy * 32 + 16;
									data.XSpeed = pInfo(peer)->x + 16, data.YSpeed = pInfo(peer)->y + 16;
									data.punchX = 8470;
									BYTE* raw_ = packPlayerMoving(&data);
									raw_[3] = 6;
									for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; cp_++) {
										if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL) break;
										if (pInfo(peer)->world == pInfo(cp_)->world) {
											send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											send_raw(cp_, 4, raw_, 56, ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[] raw, raw_;
									VarList::OnConsoleMessage(peer, "[`6You spent 1 " + Environment()->server_name + " Gem Lock to get 100 Platinum Gem Lock``]");
								}
							}
							else {
								fail = true;
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 0);
								return;
							}
						}
						else {
							fail = true;
							VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 0);
							return;
						}
						int c_ = 0;
						Inventory::Modify(peer, 8470, c_);
						VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + Environment()->server_name + " Gem Lock``|left|8470|\nadd_textbox|Excellent! I'm happy to sell you a 100 Platinum Gem Lock in exchange for 1 " + Environment()->server_name + " Gem Lock..|left|\nadd_smalltext|`6You have " + to_string(c_) + " " + Environment()->server_name + " Gem Lock.``|left|" + (c_ >= 1 ? "\nadd_button|chc2_3_3|Thank you!|noflags|0|0|" : "") + "\nadd_button|11111|Back|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
					}
					else {
						fail = true;
						VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 0);
						return;
					}
				}
				else {
					VarList::OnConsoleMessage(peer, "You don't have enough inventory space!");
					fail = true;
				}
			}
			else if (btn == "chc2_2") {
				int c_ = 0;
				Inventory::Modify(peer, 7188, c_);
				VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + Environment()->server_name + " Gem Lock``|left|8470|\nadd_textbox|Excellent! I'm happy to sell you a " + Environment()->server_name + " Gem Lock in exchange for 100 Platinum Gem Lock..|left|\nadd_smalltext|`6You have " + to_string(c_) + " Platinum Gem Lock.``|left|" + (c_ >= 100 ? "\nadd_button|chc2_2_2|Thank you!|noflags|0|0|" : "") + "\nadd_button|11111|Back|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
			}
			else if (btn == "chc2_2_2") {
				int platinum = Inventory::Contains(peer, 7188), ruth = Inventory::Contains(peer, 8470), additem = 0;
				if (platinum < 100) return;
				if (ruth >= 200) {
					VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 0);
					fail = true;
					return;
				}
				if (platinum >= 100) {
					if (Inventory::Get_Slots(pInfo(peer)) >= 2) {
						int cz_ = 1;
						if (Inventory::Modify(peer, 7188, additem = -100) == 0) {
							if (Inventory::Modify(peer, 8470, additem = 1) == 0) {
								{
									PlayerMoving data_{}; PlayerMoving data{};
									data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = 8470, data_.punchY = pInfo(peer)->netID;
									int32_t to_netid = pInfo(peer)->netID;
									BYTE* raw = packPlayerMoving(&data_);
									raw[3] = 5;
									Memory_Copy(raw + 8, &to_netid, 4);
									data.packetType = 19, data.netID = -1, data.plantingTree = 0;
									data.x = pInfo(peer)->lastwrenchx * 32 + 16, data.y = pInfo(peer)->lastwrenchy * 32 + 16;
									data.XSpeed = pInfo(peer)->x + 16, data.YSpeed = pInfo(peer)->y + 16;
									data.punchX = 7188;
									BYTE* raw_ = packPlayerMoving(&data);
									raw_[3] = 6;
									for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; cp_++) {
										if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL) break;
										if (pInfo(peer)->world == pInfo(cp_)->world) {
											send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											send_raw(cp_, 4, raw_, 56, ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[] raw, raw_;
									VarList::OnConsoleMessage(peer, "[`6You spent 100 Platinum Gem Lock to get 1 " + Environment()->server_name + " Gem Lock``]");
								}
							}
							else {
								fail = true;
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 0);
								return;
							}
						}
						else {
							fail = true;
							VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 0);
							return;
						}
						int c_ = 0;
						Inventory::Modify(peer, 7188, c_);
						VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + Environment()->server_name + " Gem Lock``|left|8470|\nadd_textbox|Excellent! I'm happy to sell you a " + Environment()->server_name + " Gem Lock in exchange for 100 Platinum Gem Lock..|left|\nadd_smalltext|`6You have " + to_string(c_) + " Platinum Gem Lock.``|left|" + (c_ >= 100 ? "\nadd_button|chc2_2_2|Thank you!|noflags|0|0|" : "") + "\nadd_button|11111|Back|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
					}
					else {
						fail = true;
						VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 0);
						return;
					}
				}
				else {
					VarList::OnConsoleMessage(peer, "You don't have enough inventory space!");
					fail = true;
				}
			}
			else if (btn == "chc2_1") {
				int c_ = 0;
				Inventory::Modify(peer, 1796, c_);
				VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wPlatinum Gem Lock``|left|7188|\nadd_textbox|Excellent! I'm happy to sell you a Platinum Gem Lock in exchange for 100 Diamond Lock..|left|\nadd_smalltext|`6You have " + to_string(c_) + " Diamond Lock.``|left|" + (c_ >= 100 ? "\nadd_button|chc2_2_1|Thank you!|noflags|0|0|" : "") + "\nadd_button|11111|Back|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
			}
			else if (btn == "chc2_2_1") {
				int c7188 = 0, c1796 = 0, additem = 0;
				Inventory::Modify(peer, 1796, c1796);
				if (c1796 < 100) return;
				Inventory::Modify(peer, 7188, c7188);
				if (c7188 >= 200) {
					VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 0);
					fail = true;
					return;
				}
				if (c1796 >= 100) {
					if (Inventory::Get_Slots(pInfo(peer)) >= 2) {
						int cz_ = 1;
						if (Inventory::Modify(peer, 1796, additem = -100) == 0) {
							Inventory::Modify(peer, 7188, additem = 1);
							{
								PlayerMoving data_{}; PlayerMoving data{};
								data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = 7188, data_.punchY = pInfo(peer)->netID;
								int32_t to_netid = pInfo(peer)->netID;
								BYTE* raw = packPlayerMoving(&data_);
								raw[3] = 5;
								Memory_Copy(raw + 8, &to_netid, 4);
								data.packetType = 19, data.netID = -1, data.plantingTree = 0;
								data.x = pInfo(peer)->lastwrenchx * 32 + 16, data.y = pInfo(peer)->lastwrenchy * 32 + 16;
								data.XSpeed = pInfo(peer)->x + 16, data.YSpeed = pInfo(peer)->y + 16;
								data.punchX = 1796;
								BYTE* raw_ = packPlayerMoving(&data);
								raw_[3] = 6;
								for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; cp_++) {
									if (cp_->state != ENET_PEER_STATE_CONNECTED || cp_->data == NULL) break;
									if (pInfo(peer)->world == pInfo(cp_)->world) {
										send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										send_raw(cp_, 4, raw_, 56, ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[] raw, raw_;
								VarList::OnConsoleMessage(peer, "[`6You spent 100 Diamond Lock to get 1 Platinum Gem Lock``]");
							}
						}
						else {
							fail = true;
							VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 0);
							return;
						}
						int c_ = 0;
						Inventory::Modify(peer, 1796, c_);
						VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wPlatinum Gem Lock``|left|7188|\nadd_textbox|Excellent! I'm happy to sell you a Platinum Gem Lock in exchange for 100 Diamond Lock..|left|\nadd_smalltext|`6You have " + to_string(c_) + " Diamond Lock.``|left|" + (c_ >= 100 ? "\nadd_button|chc2_2_1|Thank you!|noflags|0|0|" : "") + "\nadd_button|11111|Back|noflags|0|0|\nend_dialog|3898|Hang Up||\n");
					}
					else {
						fail = true;
						VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 0);
						return;
					}
				}
				else {
					VarList::OnConsoleMessage(peer, "You don't have enough inventory space!");
					fail = true;
				}
			}
			else if (btn == "chc3_1") {
				int zombie_brain = 0, pile = 0, total = 0;
				Inventory::Modify(peer, 4450, zombie_brain);
				Inventory::Modify(peer, 4452, pile);
				total += zombie_brain + (pile * 100);
				VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSales-Man: Zombie Defense``|left|4358|\nadd_textbox|Excellent! I'm happy to sell you Zombie Defense supplies in exchange for Zombie Brains.|left|\nadd_smalltext|You currently have " + Set_Count(total) + " Zombie Brains.|left|\nadd_spacer|small|\ntext_scaling_string|5,000ZB|\n" + Environment()->zombie_list + "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|53785|Back|noflags|0|0|\nend_dialog|zombie_back|Hang Up||\n");
			}
			else if (btn == "chc4_1") {
				int zombie_brain = 0, pile = 0, total = 0;
				Inventory::Modify(peer, 4298, zombie_brain);
				Inventory::Modify(peer, 4300, pile);
				total += zombie_brain + (pile * 100);
				VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSales-Man: Surgery``|left|4358|\nadd_textbox|Excellent! I'm happy to sell you rare and precious Surgery prizes in exchange for Caduceus medals.|left|\nadd_smalltext|You currently have " + Set_Count(total) + " Caducei.|left|\nadd_spacer|small|\ntext_scaling_string|50,000ZB|\n" + Environment()->surgery_list + "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|53785|Back|noflags|0|0|\nend_dialog|zurgery_back|Hang Up||\n");
			}
			else if (btn == "chc5_1") {
				int zombie_brain = 0, pile = 0, total = 0;
				Inventory::Modify(peer, 4354, zombie_brain);
				Inventory::Modify(peer, 4356, pile);
				total += zombie_brain + (pile * 100);
				VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSales-Man: Wolfworld``|left|4358|\nadd_textbox|Excellent! I'm happy to sell you rare and precious Woflworld prizes in exchange for Wolf Tickets.|left|\nadd_smalltext|You currently have " + Set_Count(total) + " Wolf Tickets.|left|\nadd_spacer|small|\ntext_scaling_string|50,000WT|\n" + Environment()->wolf_list + "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|53785|Back|noflags|0|0|\nend_dialog|wolf_back|Hang Up||\n");
			}
			else VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wDisconnected``|left|774|\nadd_textbox|The number you have tried to reach is disconnected. Please check yourself before you wreck yourself.|left|\nend_dialog|3898|Hang Up||\n");
		}
	}
	static void Daily_Quest_Info(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "View_Masterless_Starglitter") {
				DialogHandle::MStarglitter_Quest(peer);
			}
			if (button == "View_Role") {
				Role_Quest::Dialog(peer);
			}
			if (button == "backtow_dialog") {
				send_wrench_self(peer);
			}
		}
	}
	static void EarnFreeGems(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "back") {
				shop_tab(peer, "tab1_earn_free_gems");
			}
			if (button == "claim1") {
				if (pInfo(peer)->EarnFreeGems.Quest_1 >= 6 and not Has_Claimed::EFG(peer, 1)) {
					pInfo(peer)->EarnFreeGems.Claim.push_back(1);
					VarList::OnBuxGems(peer, 50000);
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`2Claimed 50,000 ė.");
					CAction::Log(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
					PlayerMoving data_{};
					data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
					BYTE* raw = packPlayerMoving(&data_);
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (pInfo(peer)->world != pInfo(cp_)->world) continue;
						send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw;
				}
			}
			if (button == "claim2") {
				if (pInfo(peer)->EarnFreeGems.Quest_2 >= 60 and not Has_Claimed::EFG(peer, 2)) {
					pInfo(peer)->EarnFreeGems.Claim.push_back(2);
					VarList::OnBuxGems(peer, 25000);
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`2Claimed 25,000 ė.");
					CAction::Log(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
					PlayerMoving data_{};
					data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
					BYTE* raw = packPlayerMoving(&data_);
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (pInfo(peer)->world != pInfo(cp_)->world) continue;
						send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw;
				}
			}
			if (button == "claim3") {
				if (pInfo(peer)->EarnFreeGems.Quest_3 >= 10 and not Has_Claimed::EFG(peer, 3)) {
					pInfo(peer)->EarnFreeGems.Claim.push_back(3);
					VarList::OnBuxGems(peer, 25000);
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`2Claimed 25,000 ė.");
					CAction::Log(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
					PlayerMoving data_{};
					data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
					BYTE* raw = packPlayerMoving(&data_);
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (pInfo(peer)->world != pInfo(cp_)->world) continue;
						send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw;
				}
			}
		}
	}
	static void EditStore_Stock(ENetPeer* peer, std::string cch) {
		if (not Role::Clist(pInfo(peer)->tankIDName)) return;
		TextScanner parser(cch);
		std::string item1 = parser.get("item1", 1), item2 = parser.get("item2", 1), item3 = parser.get("item3", 1), amount = parser.get("Amount", 1);
		if (not is_number(amount) or item1 == "0" and item2 == "0" and item3 == "0") {
			VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid Type/Input!");
			return;
		}
		if (item1 == "1" and std::atoi(amount.c_str()) != 0) Environment()->Stock_Mag += std::atoi(amount.c_str());
		if (item2 == "1" and std::atoi(amount.c_str()) != 0) Environment()->Stock_GRay += std::atoi(amount.c_str());
		if (item3 == "1" and std::atoi(amount.c_str()) != 0) Environment()->Stock_ERay += std::atoi(amount.c_str());
		EventPool::Save::Config();
		VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`2Successfully Updated Stock.");
	}
	static void EditItem_Apply(ENetPeer* peer, std::string cch) {
		if (not Role::Clist(pInfo(peer)->tankIDName)) return;
		TextScanner parser(cch);
		std::string button = "";
		int itemid = 0, id = std::atoi(get_embed(cch, "itemID").c_str());
		if (parser.try_get("itemid", itemid)) {
			if (itemid < 0 or itemid > items.size() || items[itemid].blockType == SEED || items[itemid].name.find("Wrench") != string::npos or items[itemid].name.find("Data Bedrock") != string::npos || items[itemid].name.find("null_item") != string::npos || items[itemid].name.find("null") != string::npos || items[itemid].name.find("Guild Entrance") != string::npos || items[itemid].name.find("Guild Key") != string::npos || items[itemid].name.find("World Key") != string::npos || itemid == 5640 || itemid == 9158 || itemid == 5814 || itemid == 5816) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "These items cannot be added to Extra Drop!");
				return;
			}
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`wSet Extra Drops: " + items[id].name + "|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`$Items:|left|\nembed_data|id|" + to_string(id) + "\nembed_data|item_id|" + to_string(itemid) + "\nadd_label_with_icon|small|`2" + items[itemid].name + "|left|" + to_string(itemid) + "|\nadd_spacer|small|\nadd_textbox|`$Count:|left|\nadd_text_input|count_items|||4|\nadd_spacer|small|\nadd_custom_button|back|textLabel:`wBack;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|Confirm_Add_Items|textLabel:`wConfirm!;anchor:_button_back;left:1;margin:60,0;|\nend_dialog|EditItem_Apply|||");
		}
		else if (parser.try_get("buttonClicked", button)) {
			if (button == "back") {
				int item_id = std::atoi(get_embed(cch, "item_id").c_str()), id_ = std::atoi(get_embed(cch, "id").c_str());
				DialogHandle::EditItemPro(peer, id_);
			}
			if (button == "Confirm_Add_Items") {
				int item_id = std::atoi(get_embed(cch, "item_id").c_str()), id_ = std::atoi(get_embed(cch, "id").c_str());
				std::string count = parser.get("count_items", 1);
				if (item_id < 0 or item_id > items.size() || items[item_id].blockType == SEED || items[item_id].name.find("Wrench") != string::npos or items[item_id].name.find("Data Bedrock") != string::npos || items[item_id].name.find("null_item") != string::npos || items[item_id].name.find("null") != string::npos || items[item_id].name.find("Guild Entrance") != string::npos || items[item_id].name.find("Guild Key") != string::npos || items[item_id].name.find("World Key") != string::npos || item_id == 5640 || item_id == 9158 || item_id == 5814 || item_id == 5816) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "These items cannot be added to Extra Drop!");
					return;
				}
				if (not is_number(count) or count.size() < 0 or std::atoi(count.c_str()) > 200) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid Input in Items Count");
					return;
				}
				auto it = find_if(EditItem.begin(), EditItem.end(), [id_](const Edit_ItemV2& my_item) {
					return my_item.ID == id_;
					});
				if (it == EditItem.end()) {
					Edit_ItemV2 rev;
					rev.ID = id_;
					rev.Name = items[id_].name;
					rev.Desc = items[id_].description;
					rev.rarity = items[id_].rarity;
					rev.Punch_Id = 0;
					rev.Far_Punch = 0;
					rev.Punch_Hit = 0;
					rev.Punch_Place = 0;
					rev.Gems = 0;
					rev.Xp = 0;
					rev.Bonus = 0;
					rev.Item_Price = 0;
					rev.property_untradeable = false;
					rev.property_blacklist = false;
					rev.property_gacha = false;
					rev.property_unobtainable = false;
					rev.property_blocked = false;
					rev.property_farmable = false;
					rev.Extra_Drops.push_back({ item_id, std::atoi(count.c_str()) });
					EditItem.push_back(rev);
				}
				else {
					for (int i = 0; i < EditItem.size(); i++) {
						if (EditItem[i].ID == id_) {
							EditItem[i].Extra_Drops.push_back({ item_id, std::atoi(count.c_str()) });
						}
					}
				}
				std::ofstream over_write("database/json/edit_itemv2.json");
				json j;
				json rev_ = json::array();
				for (int i_2 = 0; i_2 < EditItem.size(); i_2++) {
					json it_;
					it_["ID"] = EditItem[i_2].ID;
					it_["Name"] = EditItem[i_2].Name;
					it_["Desc"] = EditItem[i_2].Desc;
					it_["rarity"] = EditItem[i_2].rarity;
					it_["Change_Drop_Seeds"] = EditItem[i_2].Change_Drop_Seeds;
					it_["Punch_Id"] = EditItem[i_2].Punch_Id;
					it_["Far_Punch"] = EditItem[i_2].Far_Punch;
					it_["Punch_Hit"] = EditItem[i_2].Punch_Hit;
					it_["Punch_Place"] = EditItem[i_2].Punch_Place;
					it_["Gems"] = EditItem[i_2].Gems;
					it_["Xp"] = EditItem[i_2].Xp;
					it_["Bonus"] = EditItem[i_2].Bonus;
					it_["Item_Price"] = EditItem[i_2].Item_Price;
					it_["Extra_Drops"] = EditItem[i_2].Extra_Drops;
					it_["property_untradeable"] = EditItem[i_2].property_untradeable;
					it_["property_blacklist"] = EditItem[i_2].property_blacklist;
					it_["property_gacha"] = EditItem[i_2].property_gacha;
					it_["property_unobtainable"] = EditItem[i_2].property_unobtainable;
					it_["property_blocked"] = EditItem[i_2].property_blocked;
					it_["property_farmable"] = EditItem[i_2].property_farmable;
					rev_.push_back(it_);
				}
				j["items"] = rev_;
				over_write << j.dump(4) << endl;
				over_write.close();
				VarList::OnTextOverlay(peer, "`2Success added items");
				DialogHandle::EditItemPro(peer, id_);
			}
			if (button.substr(0, 7) == "remove_") {
				int id_s = std::atoi(button.substr(7).c_str());
				for (int i = 0; i < EditItem.size(); i++) {
					if (EditItem[i].ID == id) {
						if (!EditItem[i].Extra_Drops.empty()) {
							EditItem[i].Extra_Drops.erase(std::remove_if(EditItem[i].Extra_Drops.begin(), EditItem[i].Extra_Drops.end(),
								[id_s](const std::pair<int, int>& p) {
									return p.first == id_s;
								}), EditItem[i].Extra_Drops.end());
						}
					}
				}
				VarList::OnTextOverlay(peer, "`2Success remove items from Extra Drops");
				DialogHandle::EditItemPro(peer, id);
			}
		}
		else {
			if (id == 0 or id < 2 or id > items.size() or items[id].blockType == BlockTypes::CONSUMABLE or items[id].blockType == BlockTypes::LOCK || items[id].blockType == SEED || items[id].name.find("Blank") != string::npos || items[id].name.find("Phoenix") != string::npos || items[id].name.find("Wrench") != string::npos or items[id].name.find("Data Bedrock") != string::npos || items[id].name.find("null_item") != string::npos || items[id].name.find("null") != string::npos || items[id].name.find("Guild Entrance") != string::npos || items[id].name.find("Guild Banner") != string::npos || items[id].name.find("Guild Flag") != string::npos || items[id].name.find("Guild Key") != string::npos || items[id].name.find("World Key") != string::npos || id == 5640 || id == 9158 || id == 5814 || id == 5816 || items[id].actionType == 127 || items[id].actionType == 126 || items[id].actionType == 118 || items[id].actionType == 117 || items[id].actionType == 116 || items[id].actionType == 115 || items[id].actionType == 113 || items[id].actionType == 109 || items[id].actionType == 106 || items[id].actionType == 105 || items[id].actionType == 104 || items[id].actionType == 102 || items[id].actionType == 99 || items[id].actionType == 96 || items[id].actionType == 86 || items[id].actionType == 79 || items[id].actionType == 75 || items[id].actionType == 72 || items[id].actionType == 71 || items[id].actionType == 68 || items[id].actionType == 66 || items[id].actionType == 65 || items[id].actionType == 53 || items[id].actionType == 52 || items[id].actionType == 50 || items[id].actionType == 43 || items[id].actionType == 91 || items[id].id == 5818 || items[id].id == 5820) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "These items cannot be edited!");
				return;
			}
			std::string cdrop_seeds = "", property_blocked = "", property_farmable = "", p_hit = "", p_place = "", item_effect = "", p_far_range = "", item_name = parser.get("item_name", 1), item_desc = parser.get("item_desc", 1), item_rarity = parser.get("item_rarity", 1), extra_gems = "", extra_xp = "", change_bonus = "", item_price = parser.get("item_price", 1), property_untradeable = parser.get("property_untradeable", 1), property_blacklist = parser.get("property_blacklist", 1), property_unobtainable = parser.get("property_unobtainable", 1), property_gacha = "";
			if (!isValidCheckboxInput(property_untradeable) or !isValidCheckboxInput(property_blacklist) or !isValidCheckboxInput(property_unobtainable)) return;
			if (items.at(id).blockType == BlockTypes::CLOTHING or items[id].rarity > 0 and items[id].rarity < 999) {
				extra_gems = parser.get("extra_gems", 1), extra_xp = parser.get("extra_xp", 1);
				if (not is_number(extra_gems) or extra_gems.size() < 0 or extra_gems.size() > 3) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid Input in Extra Gems");
					return;
				}
				if (not is_number(extra_xp) or extra_xp.size() < 0 or extra_xp.size() > 3) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid Input in Extra Xp");
					return;
				}
			}
			if (items.at(id).blockType != BlockTypes::CLOTHING) {
				if (items[id].rarity > 0 and items[id].rarity < 999) {
					property_farmable = parser.get("property_farmable", 1);
					if (!isValidCheckboxInput(property_farmable)) return;
				}
				if (items.at(id).randomitem.size() == 0 or id == 9460 and Environment()->dstone.size() == 0) {
					property_gacha = parser.get("property_gacha", 1);
					if (!isValidCheckboxInput(property_gacha)) return;
				}
				property_blocked = parser.get("property_blocked", 1);
				if (!isValidCheckboxInput(property_blocked)) return;
			}
			if (items.at(id).blockType == BlockTypes::CLOTHING) {
				p_hit = parser.get("p_hit", 1), p_place = parser.get("p_place", 1), item_effect = parser.get("item_effect", 1), p_far_range = parser.get("p_far_range", 1);
				if (not is_number(item_effect) or item_effect.size() < 0 or item_effect.size() > 3) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid Input in Punch ID");
					return;
				}
				if (not is_number(p_far_range) or p_far_range.size() < 0 or p_far_range.size() > 2) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid Input in Punch Far");
					return;
				}
				if (not is_number(p_hit) or p_hit.size() < 0 or p_hit.size() > 2) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid Input in Punch Hits");
					return;
				}
				if (not is_number(p_place) or p_place.size() < 0 or p_place.size() > 2) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid Input in Punch Place");
					return;
				}
			}
			if (items[id].rarity > 0 and items[id].rarity < 999) {
				cdrop_seeds = parser.get("cdrop_seeds", 1);
				if (not is_number(cdrop_seeds) or cdrop_seeds.size() < 1 or cdrop_seeds.size() > 3 or atoi(cdrop_seeds.c_str()) > 100) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid Input in Change Drop Seeds!");
					return;
				}
			}
			if (item_name.size() < 3) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "To shorts Name items");
				return;
			}
			if (item_desc.size() < 10) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "To shorts Description Items");
				return;
			}
			if (not is_number(item_rarity) or item_rarity.size() < 1 or item_rarity.size() > 3) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid Input in Item Rarity");
				return;
			}
			if (items.at(id).randomitem.size() == 0 or id == 9460 and Environment()->dstone.size() == 0) {
				change_bonus = parser.get("change_bonus", 1);
				if (not is_number(change_bonus) or change_bonus.size() < 0 or change_bonus.size() > 3) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid Input in Change Bonus");
					return;
				}
			}
			if (not is_number(item_price) or item_price.size() < 0 or item_price.size() > 10) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Invalid Input in Item Price");
				return;
			}
			auto it = find_if(EditItem.begin(), EditItem.end(), [id](const Edit_ItemV2& my_item) {
				return my_item.ID == id;
				});
			if (it == EditItem.end()) {
				Edit_ItemV2 rev;
				rev.ID = id;
				if (item_name != "") rev.Name = item_name;
				if (item_desc != "") rev.Desc = item_desc;
				if (item_rarity != "") rev.rarity = std::atoi(item_rarity.c_str());
				if (cdrop_seeds != "") rev.Change_Drop_Seeds = std::atoi(cdrop_seeds.c_str());
				if (item_effect != "") rev.Punch_Id = std::atoi(item_effect.c_str());
				if (p_far_range != "") rev.Far_Punch = std::atoi(p_far_range.c_str());
				if (p_hit != "") rev.Punch_Hit = std::atoi(p_hit.c_str());
				if (p_place != "") rev.Punch_Place = std::atoi(p_place.c_str());
				if (extra_gems != "") rev.Gems = std::atoi(extra_gems.c_str());
				if (extra_xp != "") rev.Xp = std::atoi(extra_xp.c_str());
				if (change_bonus != "") rev.Bonus = std::atoi(change_bonus.c_str());
				if (item_price != "") rev.Item_Price = std::atoi(item_price.c_str());
				if (property_untradeable != "") rev.property_untradeable = (property_untradeable == "1" ? true : false);
				if (property_blacklist != "") rev.property_blacklist = (property_blacklist == "1" ? true : false);
				if (property_gacha != "") rev.property_gacha = (property_gacha == "1" ? true : false);
				if (property_unobtainable != "") rev.property_unobtainable = (property_unobtainable == "1" ? true : false);
				if (property_blocked != "") rev.property_blocked = (property_blocked == "1" ? true : false);
				if (property_farmable != "") rev.property_farmable = (property_farmable == "1" ? true : false);
				EditItem.push_back(rev);
			}
			else {
				for (int i = 0; i < EditItem.size(); i++) {
					if (EditItem[i].ID == id) {
						if (item_name != "") EditItem[i].Name = item_name;
						if (item_desc != "") EditItem[i].Desc = item_desc;
						if (item_rarity != "") EditItem[i].rarity = std::atoi(item_rarity.c_str());
						if (cdrop_seeds != "") EditItem[i].Change_Drop_Seeds = std::atoi(cdrop_seeds.c_str());
						if (item_effect != "") EditItem[i].Punch_Id = std::atoi(item_effect.c_str());
						if (p_far_range != "") EditItem[i].Far_Punch = std::atoi(p_far_range.c_str());
						if (p_hit != "") EditItem[i].Punch_Hit = std::atoi(p_hit.c_str());
						if (p_place != "") EditItem[i].Punch_Place = std::atoi(p_place.c_str());
						if (extra_gems != "") EditItem[i].Gems = std::atoi(extra_gems.c_str());
						if (extra_xp != "") EditItem[i].Xp = std::atoi(extra_xp.c_str());
						if (change_bonus != "") EditItem[i].Bonus = std::atoi(change_bonus.c_str());
						if (item_price != "") EditItem[i].Item_Price = std::atoi(item_price.c_str());
						if (property_untradeable != "") EditItem[i].property_untradeable = (property_untradeable == "1" ? true : false);
						if (property_blacklist != "") EditItem[i].property_blacklist = (property_blacklist == "1" ? true : false);
						if (property_gacha != "") EditItem[i].property_gacha = (property_gacha == "1" ? true : false);
						if (property_unobtainable != "") EditItem[i].property_unobtainable = (property_unobtainable == "1" ? true : false);
						if (property_blocked != "") EditItem[i].property_blocked = (property_blocked == "1" ? true : false);
						if (property_farmable != "") EditItem[i].property_farmable = (property_farmable == "1" ? true : false);
					}
				}
			}
			std::ofstream over_write("database/json/edit_itemv2.json");
			json j;
			json rev_ = json::array();
			for (int i_2 = 0; i_2 < EditItem.size(); i_2++) {
				json it_;
				it_["ID"] = EditItem[i_2].ID;
				it_["Name"] = EditItem[i_2].Name;
				it_["Desc"] = EditItem[i_2].Desc;
				it_["rarity"] = EditItem[i_2].rarity;
				it_["Change_Drop_Seeds"] = EditItem[i_2].Change_Drop_Seeds;
				it_["Punch_Id"] = EditItem[i_2].Punch_Id;
				it_["Far_Punch"] = EditItem[i_2].Far_Punch;
				it_["Punch_Place"] = EditItem[i_2].Punch_Place;
				it_["Punch_Hit"] = EditItem[i_2].Punch_Hit;
				it_["Gems"] = EditItem[i_2].Gems;
				it_["Xp"] = EditItem[i_2].Xp;
				it_["Bonus"] = EditItem[i_2].Bonus;
				it_["Item_Price"] = EditItem[i_2].Item_Price;
				it_["Extra_Drops"] = EditItem[i_2].Extra_Drops;
				it_["property_untradeable"] = EditItem[i_2].property_untradeable;
				it_["property_blacklist"] = EditItem[i_2].property_blacklist;
				it_["property_gacha"] = EditItem[i_2].property_gacha;
				it_["property_unobtainable"] = EditItem[i_2].property_unobtainable;
				it_["property_blocked"] = EditItem[i_2].property_blocked;
				it_["property_farmable"] = EditItem[i_2].property_farmable;
				rev_.push_back(it_);
			}
			j["items"] = rev_;
			over_write << j.dump(4) << endl;
			over_write.close();
			for (int i_ = 0; i_ < items.size(); i_++) {
				int item_id = items[i_].id;
				for (int i = 0; i < EditItem.size(); i++) {
					if (EditItem[i].ID == item_id) {
						items[EditItem[i].ID].name = EditItem[i].Name;
						items[EditItem[i].ID].ori_name = EditItem[i].Name;
						items[EditItem[i].ID].description = EditItem[i].Desc;
						items[EditItem[i].ID].rarity = EditItem[i].rarity;
						items[EditItem[i].ID].newdropchance = EditItem[i].Change_Drop_Seeds;
						items[EditItem[i].ID].max_gems = EditItem[i].Gems;
						items[EditItem[i].ID].untradeable = (EditItem[i].property_untradeable ? 1 : 0);
						items[EditItem[i].ID].unobtainable = (EditItem[i].property_unobtainable ? 1 : 0);
						items[EditItem[i].ID].blocked_place = (EditItem[i].property_blocked ? 1 : 0);
						items[EditItem[i].ID].farmable = (EditItem[i].property_farmable ? true : false);
						if (EditItem[i].property_blacklist) {
							if (not Gtps_Shop::Disable_Items(EditItem[i].ID)) Disable_Item.id.push_back(EditItem[i].ID);
						}
						else {
							if (Gtps_Shop::Disable_Items(EditItem[i].ID)) Disable_Item.id.erase(std::remove(Disable_Item.id.begin(), Disable_Item.id.end(), EditItem[i].ID), Disable_Item.id.end());
						}
						if (Gtps_Shop::Get_Price(EditItem[i].ID) == 0) Environment()->buy_item_list.push_back(std::make_pair(EditItem[i].ID, EditItem[i].ID));
						Environment()->shop_data[EditItem[i].ID] = EditItem[i].Item_Price;
					}
				}
			}
			for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
				if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
				Clothing_V2::Update_Value(cp_);
				Clothing_V2::Update(cp_, true);
				VarList::OnConsoleMessage(cp_, "`2[`o" + Environment()->server_name + " Information`2]");
				VarList::OnConsoleMessage(cp_, "`2>> `oNew update for item `2" + items[id].name + " `2[`o" + to_string(id) + "`2]");
				CAction::Log(cp_, "action|play_sfx\nfile|audio/sungate.wav\ndelayMS|0\n");
			}
			VarList::OnTextOverlay(peer, "`2Success added effect items");
		}
	}
	static void bingo_ui(ENetPeer* peer, std::string cch) {
		if (not WinterFest.Active or pInfo(peer)->Has_WinBingo == false) return;
		TextScanner parser(cch);
		std::string button = "";
		int my_wls = get_wls(peer, true);
		if (parser.try_get("buttonClicked", button)) {
			if (button == "BackTo_Bingo") DialogHandle::Winter_Bingo(peer);
			if (button.substr(0, 10) == "bingoItem_") {
				int id = std::atoi(button.substr(10).c_str());
				std::vector<int> list_{ 10458, 3204, 5348, 8278, 8280, 12942, 10488, 5350, 10508, 5444, 11192, 10478, 10476, 2564, 10444, 8722, 10480, 11538, 12934, 10464, 5354, 5446, 5382, 5476, 8948, 12944, 10466, 10468, 13014, 5398, 5362, 5386, 5400, 5478, 14134, 11530, 10472, 7436, 5396, 7448, 10474, 10484, 7396, 11526, 5394, 12950, 5358, 5360, 12954, 11528, 5352, 12948, 5474, 11522, 10470, 10460 };
				if (find(list_.begin(), list_.end(), id) == list_.end()) return;
				string text = "";
				/*Diamond Builder Bonanze*/
				if (id == 10458 or id == 12942 or id == 10466 or id == 10468 or id == 10470 or id == 11526 or id == 10480 or id == 10464 or id == 12944 or id == 14134 or id == 11530 or id == 10472 or id == 10474 or id == 10484 or id == 12950 or id == 12954 or id == 11528 or id == 10478 or id == 10476 or id == 11522 or id == 12948 or id == 10460) {
					text = "\nadd_label_with_icon|small|Diamond Builders Bonanza|left|10450|\nadd_spacer|small|\nadd_textbox|- Buy a `2Diamond Builders Bonanza`` from the store on Saturdays.|left|\nadd_textbox|- Build the `2Diamond Builders Bonanza`` in your world.|left|\nadd_textbox|- Punch the `2Diamond Builders Bonanza`` to retrieve your prize.|left|\nadd_spacer|small|\n";
				}
				/*Winterfest Calendar 2024*/
				if (id == 8278 or id == 8280 or id == 10488 or id == 2564 or id == 10444 or id == 5446 or id == 5382 or id == 11192 or id == 8722 or id == 8948) {
					text = "\nadd_label_with_icon|small|Winterfest Calendar - 2024|left|15010|\nadd_spacer|small|\nadd_textbox|- Buy a `2Winterfest Calendar - 2024`` from the store.|left|\nadd_textbox|- Build the `2Winterfest Calendar - 2024`` in your world.|left|\nadd_textbox|- Punch the `2Winterfest Calendar - 2024`` to retrieve your prize.|left|\nadd_spacer|small|\n";
				}
				/*Winter Wish*/
				if (id == 11538 or id == 12934) {
					text = "\nadd_label_with_icon|small|Winter Wish|left|10538|\nadd_spacer|small|\nadd_textbox|- Earn a `2Winter Wish`` from the Winter Wish List.|left|\nadd_textbox|- Consume the `2Winter Wish`` to get your prize.|left|\nadd_spacer|small|\n";
				}
				/*Special Winter Wish*/
				if (id == 13014) {
					text = "\nadd_label_with_icon|small|Special Winter Wish|left|10536|\nadd_spacer|small|\nadd_textbox|- Earn a `2Special Winter Wish`` from the Winter Wish List.|left|\nadd_textbox|- Consume the `2Special Winter Wish`` to get your prize.|left|\nadd_spacer|small|\n";
				}
				/*Winterfest Cracker*/
				if (id == 3204 or id == 5348 or id == 5350 or id == 5352 or id == 5354 or id == 5474 or id == 5394 or id == 5476 or id == 5386 or id == 5358 or id == 5360 or id == 5362 or id == 5400 or id == 5478 or id == 7436 or id == 5396 or id == 7448) {
					text = "\nadd_label_with_icon|small|Winterfest Cracker|left|5402|\nadd_spacer|small|\nadd_textbox|- Buy a `2Winterfest Cracker`` from the store.|left|\nadd_textbox|- Find a friend.|left|\nadd_textbox|- Consume the `2Winterfest Cracker`` with your friend to get your prize.|left|\nadd_spacer|small|\n";
				}
				/*Deluxe Winterfest Cracker*/
				if (id == 5398 or id == 10508 or id == 5444 or id == 7396) {
					text = "\nadd_label_with_icon|small|Deluxe Winterfest Cracker|left|5404|\nadd_spacer|small|\nadd_textbox|- Buy a `2Deluxe Winterfest Cracker`` from the store.|left|\nadd_textbox|- Find a friend.|left|\nadd_textbox|- Consume the `2Deluxe Winterfest Cracker`` with your friend to get your prize.|left|\nadd_spacer|small|\n";
				}
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`w" + items[id].name + "``|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|This item can be obtained as a prize from:|left|\nadd_spacer|small|" + text + "\nadd_spacer|small|\nadd_button|BackTo_Bingo|`wThanks for the info|0|0|\nend_dialog|bingo_ui|||\nadd_quick_exit|\n");
			}
			if (button == "resetcard") VarList::OnDialogRequest(peer, SetColor(peer) + "\nadd_label_with_icon|big|`wRe-roll Card?``|left|1360|\nadd_spacer|small|\nadd_textbox|You will lose all progress you have on the current card and replace all the prizes with new prizes.|left|\nadd_spacer|small|\nadd_button|reset_card_confirm|Pay 5 World Lock|" + (my_wls >= 5 ? "" : "off") + "|0|0|\nadd_spacer|small|\nadd_textbox|You currently have " + (my_wls >= 5 ? "`2" : "`4") + "" + Set_Count(my_wls) + "`` World Lock|left|\nadd_spacer|small|\nend_dialog|bingo_ui|Close||\nadd_quick_exit|");
			if (button == "reset_card_confirm") {
				if (my_wls >= 5) {
					get_wls(peer, true, true, 5);
					pInfo(peer)->Has_BingoPrize.clear(), pInfo(peer)->Has_BingoTask.clear(), pInfo(peer)->Has_ClaimBingo.clear();
					int num_prizes_to_take = 10, num_ids_to_take = 25;
					if (WinterFest.Bingo_Prize.size() < num_prizes_to_take) num_prizes_to_take = WinterFest.Bingo_Prize.size();
					if (WinterFest.Bingo_Id_Task.size() < num_ids_to_take) num_ids_to_take = WinterFest.Bingo_Id_Task.size();
					std::random_device rd;
					std::mt19937 g(rd());
					std::shuffle(WinterFest.Bingo_Prize.begin(), WinterFest.Bingo_Prize.end(), g);
					std::shuffle(WinterFest.Bingo_Id_Task.begin(), WinterFest.Bingo_Id_Task.end(), g);
					for (int i = 0; i < num_ids_to_take; ++i) {
						pInfo(peer)->WinterBingo_Task[std::to_string(i)] = WinterFest.Bingo_Id_Task[i];
					}
					for (int i = 0; i < num_prizes_to_take; ++i) {
						std::string key = (i < 5) ? "r" + std::to_string(i) : "c" + std::to_string(i - 5);
						pInfo(peer)->WinterBingo_Prize[key] = WinterFest.Bingo_Prize[i];
					}
					DialogHandle::Winter_Bingo(peer);
				}
			}
			if (button == "Claim_All_Prize") {
				if (pInfo(peer)->Has_BingoPrize.size() < 0) return;
				bool Reward_r0 = (Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["0"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["1"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["2"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["3"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["4"])), Reward_r1 = (Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["5"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["6"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["7"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["9"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["9"])), Reward_r2 = (Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["10"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["11"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["12"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["13"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["14"])), Reward_r3 = (Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["15"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["16"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["17"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["18"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["19"])), Reward_r4 = (Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["20"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["21"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["22"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["23"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["24"])), Reward_c0 = (Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["0"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["5"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["10"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["15"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["20"])), Reward_c1 = (Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["1"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["6"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["11"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["16"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["21"])), Reward_c2 = (Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["2"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["7"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["12"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["17"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["22"])), Reward_c3 = (Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["3"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["8"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["13"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["18"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["23"])), Reward_c4 = (Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["4"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["9"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["14"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["19"]) and Has_Claimed::Bingo(peer, pInfo(peer)->WinterBingo_Task["24"]));
				if (Reward_r0 and not Has_Claimed::BingoPr2(peer, "r0")
					or Reward_r1 and not Has_Claimed::BingoPr2(peer, "r1")
					or Reward_r2 and not Has_Claimed::BingoPr2(peer, "r2")
					or Reward_r3 and not Has_Claimed::BingoPr2(peer, "r3")
					or Reward_r4 and not Has_Claimed::BingoPr2(peer, "r4")
					or Reward_c0 and not Has_Claimed::BingoPr2(peer, "c0")
					or Reward_c1 and not Has_Claimed::BingoPr2(peer, "c1")
					or Reward_c2 and not Has_Claimed::BingoPr2(peer, "c2")
					or Reward_c3 and not Has_Claimed::BingoPr2(peer, "c3")
					or Reward_c4 and not Has_Claimed::BingoPr2(peer, "c4")) {
					int add = 0;
					for (auto it = pInfo(peer)->Has_BingoPrize.begin(); it != pInfo(peer)->Has_BingoPrize.end(); ) {
						std::string id = std::get<0>(*it);
						int itemid = std::get<1>(*it), count = std::get<2>(*it);
						if (Inventory::Modify(peer, itemid, count) == 0) {

						}
						else {
							WorldDrop drop_block_{};
							drop_block_.id = itemid, drop_block_.count = count, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
							std::string name_ = pInfo(peer)->world;
							std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								world_->fresh_world = true;
								VisualHandle::Drop(world_, drop_block_);
							}
						}
						it = pInfo(peer)->Has_BingoPrize.erase(it);
						pInfo(peer)->Has_ClaimBingo.push_back(id);
					}
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou claimed prizes from the Bingo card!", 0, 1);
				}
			}
		}
	}
	static void Piggy_Bank(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "Buy_Piggy") DialogHandle::Shop_Assets(peer);
			if (button == "Claim_Piggy_Bank") {
				if (pInfo(peer)->Banked_Piggy >= 350000) {
					pInfo(peer)->Banked_Piggy = 0;
					VarList::OnBuxGems(peer, 350000);
					VarList::OnEventButtonDataSet(peer, "PiggyBankButton", 1, "{\"active\":true,\"buttonAction\":\"openPiggyBank\",\"buttonState\":" + a + (pInfo(peer)->Banked_Piggy >= 350000 ? "2" : "0") + ",\"buttonTemplate\":\"BaseEventButton\",\"counter\":0,\"counterMax\":0,\"itemIdIcon\":0,\"name\":\"PiggyBankButton\",\"notification\":0,\"order\":2,\"rcssClass\":\"piggybank\",\"text\":\"" + (pInfo(peer)->Banked_Piggy >= 350000 ? "350K" : ConvertToK(pInfo(peer)->Banked_Piggy) + "/350K") + "\"}");
				}
			}
		}
	}
	static void MarketPlace_Gtps(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = ""; int id = 0;
		if (parser.try_get("add_item_to_market", id)) {
			if (id < 1 or id > items.size()) return;
			if (id == 242 || id == 1796 || id == 7188 || id == 9160 || id == 18 || id == 32 || id == 6336 || id == 9384 || id == 1424 || items[id].blockType == BlockTypes::FISH || not Role::Developer(peer) and items[id].properties & Property_Untradable || id == 8552 || id == 9472 || id == 9482 || id == 9356 || id == 9492 || id == 9498 || id == 8774 || id == 1790 || id == 2592 || id == 1784 || id == 1792 || id == 1794 || id == 7734 || id == 8306 || id == 9458 || items[id].blockType == BlockTypes::SEED) {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`$" + items[id].name + "|left|" + to_string(id) + "|\nadd_textbox|`$You can't place " + items[id].name + " on sale.|left|\nadd_button|enter_my_market|`$Back|noflags|0|0|\n");
			}
			else {
				auto mtitems = 0;
				for (auto i = 0; i < pInfo(peer)->inv.size(); i++) {
					if (pInfo(peer)->inv[i].first == id) {
						mtitems = pInfo(peer)->inv[i].second;
						break;
					}
				}
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`$" + items[id].name + "|left|" + to_string(id) + "|\nembed_data|itemid|" + to_string(id) + "\nadd_spacer|small|\nadd_smalltext|`$How many of " + items[id].name + " you want to put on sale?|left|\nadd_smalltext|`$You have " + to_string(mtitems) + " in your inventory.|left|\nadd_text_input|marketitempickercount|`$How many you want to put?|" + to_string(mtitems) + "|3|\nadd_spacer|small|\nadd_spacer|small|\nadd_smalltext|`$Choose the one that will be used as the price for your selling item.|left|\nmax_checks|1|\ntext_scaling_string|ckc|\nadd_checkicon|WorldLock|||242||0|\ntext_scaling_string|ckc|\nadd_checkicon|DiamondLock|||1796||0|\ntext_scaling_string|ckc|\nadd_checkicon|BGLock|||7188||0|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_smalltext|`$(Example : `2" + items[id].name + " `55 World Locks each.`$)|left|\nadd_smalltext|`$How many of these items that you wrote above need to buy your selling item?|left|\nadd_text_input|market_item_price|`$Price:||3|\nadd_spacer|small|\nadd_quick_exit|\nadd_button|backtomarketdialog|`oBack|noflags|0|0|\nadd_custom_button|confirm_add_item|textLabel:`2Add Items on Sale;anchor:_button_backtomarketdialog;left:1;margin:40,0;middle_colour:41421298;border_colour:41421298;|\nend_dialog|MarketPlace_Gtps|||\n");
			}
			return;
		}
		else if (parser.try_get("buttonClicked", button)) {
			if (button == "backtomarketdialog") DialogHandle::MarketPlace(peer);
			if (button == "backsocialportal") DialogHandle::Social_Portal(peer);
			if (button == "enter_my_market") market::dialog::enter_my_market(peer);
			if (button == "market_scan") DialogHandle::Trade_Scan(peer);
			if (button == "createmarket_info") {
				bool existx = filesystem::exists("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
				if (existx) return;
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`2Create Marketplace|left|13812|\nadd_smalltext|`oWelcome to Grow Market where you can create a MarketPlace! With a Market you can selling items you want in Marketplace.|left|\nadd_smalltext|`oTo create a Market you must have a `250 Diamond Locks``.|left|\nadd_spacer|small|\nadd_dual_layer_icon_label|small|`oMascot Preview (Example Id '7188') :|left|7188||1.0|1|\nadd_text_input|market_mascot|`oMascot Id||4|\nadd_text_input|market_name|`oMarket Name||20|\nadd_quick_exit|\nadd_spacer|small|\nadd_button|backtomarketdialog|`oBack|noflags|0|0|\nadd_custom_button|create_market|textLabel:`2Create Marketplace;anchor:_button_backtomarketdialog;left:1;margin:40,0;middle_colour:41421298;border_colour:41421298;|\nend_dialog|MarketPlace_Gtps|||\n");
			}
			if (button == "create_market") {
				bool existx = filesystem::exists("database/players/market/" + pInfo(peer)->tankIDName + "_.json"); int price = 5000;
				if (existx) return;
				std::string market_fg = parser.get("market_mascot", 1), market_nm = parser.get("market_name", 1);
				if (market_fg.find_first_not_of("1234567890") != std::string::npos) {
					VarList::OnDialogRequest(peer, market::rtrn::create("`oYou may only use numbers in Mascot id.", market_fg, market_nm));
					return;
				}
				if (market_fg == "") {
					VarList::OnDialogRequest(peer, market::rtrn::create("`oMascot id cannot be empty and cannot be less than 3 numbers.", market_fg, market_nm));
					return;
				}
				if (market_fg.size() < 3) {
					VarList::OnDialogRequest(peer, market::rtrn::create("`oMascot id cannot be less than 3 numbers.", market_fg, market_nm));
					return;
				}
				if (items[std::atoi(market_fg.c_str())].blockType == BlockTypes::SEED) {
					VarList::OnDialogRequest(peer, market::rtrn::create("`oSeed id is not allowed", market_fg, market_nm));
					return;
				}
				if (market_nm.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ") != std::string::npos) {
					VarList::OnDialogRequest(peer, market::rtrn::create("`oYou may only use letters in your market name.", market_fg, market_nm));
					return;
				}
				if (market_nm.size() < 4) {
					VarList::OnDialogRequest(peer, market::rtrn::create("`omarket name is too short!", market_fg, market_nm));
					return;
				}
				if (market_nm == "") {
					VarList::OnDialogRequest(peer, market::rtrn::create("`oYour market name cannot be empty!", market_fg, market_nm));
					return;
				}
				std::vector<std::string> allStores;
				std::ifstream iffff("database/players/market/marketinfo/stores.json");
				json j2;
				iffff >> j2;
				iffff.close();
				bool arYraToksId = false;
				for (int i = 0; i < j2["owners"].size(); i++) {
					allStores.push_back(j2["owners"][i]);
					ifstream iifff("database/players/market/" + allStores[i] + "_.json");
					json jh;
					iifff >> jh;
					iifff.close();
					if (jh["name"].get<string>() == market_nm) {
						arYraToksId = true;
					}
				}
				if (arYraToksId) {
					VarList::OnDialogRequest(peer, market::rtrn::create("`oThis name is already taken by another seller! Use another.", market_fg, market_nm));
					return;
				}
				time_t currentTime; struct tm* localTime; char buffer[80];
				time(&currentTime); localTime = localtime(&currentTime);
				int Mon = localTime->tm_mon + 1; int Day = localTime->tm_mday; int Hour = localTime->tm_hour; int Min = localTime->tm_min; int Sec = localTime->tm_sec;
				std::string tolog = " You have successfully created your own Marketplace `wat " + to_string(Hour) + ":" + to_string(Min) + " on " + to_string(Mon) + "/" + to_string(Day);
				std::vector<std::string> logs = { tolog };
				json j;
				j["fg"] = market_fg;
				j["name"] = market_nm;
				j["currentSpaceInStore"] = 5;
				j["logs"] = logs;
				j["newLogs"] = 1;
				json storeReviewall = json::array();
				json storeReview;
				for (int i = 1; i <= 50; i++) {
					storeReview["aposition"] = i;
					storeReview["sentBy"] = "";
					storeReview["review"] = "";
					storeReview["stars"] = 0;
					storeReviewall.push_back(storeReview);
				}
				j["storeReview"] = storeReviewall;
				json jjall = json::array();
				json jj;
				for (int i = 1; i <= 100; i++) {
					jj["aposition"] = i;
					jj["itemid"] = 0;
					jj["quantityOfItems"] = 0;/*count item*/
					jj["sellPer"] = 0;/*price*/
					jj["sellForItem"] = 0;/*payments*/
					jj["boughtItems"] = 0;/*withdraw*/
					jjall.push_back(jj);
				}
				j["itemsInStore"] = jjall;
				allStores.push_back(pInfo(peer)->tankIDName);
				j2["owners"] = allStores;
				std::ofstream oo("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
				if (!oo.is_open()) return;
				oo << j << std::endl;
				std::ofstream oo2("database/players/market/marketinfo/stores.json");
				if (!oo2.is_open()) return;
				oo2 << j2 << std::endl;
				VarList::OnTextOverlay(peer, "`2Successfully created marketplace!");
				market::dialog::enter_my_market(peer);
				return;
			}
			if (button.substr(0, 16) == "enterplayeritem_") {
				std::string whoseStore = button.substr(button.find("_") + 1);
				bool existx = filesystem::exists("database/players/market/" + whoseStore + "_.json");
				if (!existx) return;
				try {
					std::ifstream ifff("database/players/market/" + whoseStore + "_.json");
					json j;
					ifff >> j;
					ifff.close();
					string item_list = "";
					string str_dial = "set_default_color|";
					str_dial += "\nadd_label_with_icon|big|" + whoseStore + "'s Marketplace.|left|" + j["fg"].get<string>() + "|\nadd_smalltext|`$Welcome to the bustling Growtopia Marketplace, your one-stop destination for trading treasures! Here, adventurers like you gather to buy and trade a myriad of items.|left|\nadd_spacer|small|\nadd_small_font_button|marketreview_" + whoseStore + "|`$Wanna write a review about this marketplace?|noflags|0|0|\nadd_small_font_button|marketreviewcheck_" + whoseStore + "|`$Wanna check this marketplace reviews?|noflags|0|0|\nadd_spacer|small|\nadd_textbox|`$" + whoseStore + "'s selling items:|left|\n";
					int kiekItemuBus = 0;
					int id; int kiekis; int aPosition;
					int currentSpaceInStore = j["currentSpaceInStore"];
					for (int i = 0; i < j["itemsInStore"].size(); i++) {
						if (j["itemsInStore"][i]["itemid"] != 0) {
							kiekItemuBus++;
							aPosition = j["itemsInStore"][i]["aposition"];
							id = j["itemsInStore"][i]["itemid"];
							kiekis = j["itemsInStore"][i]["quantityOfItems"];
							item_list += "\nadd_button_with_icon|" + (kiekis == 0 ? "" : "playermarketitementer_" + to_string(aPosition) + "_" + whoseStore + "") + "|`o" + items[id].name + (kiekis == 0 ? " (SOLD)" : "") + "|" + (kiekis == 0 ? "staticGreyFrame,disabled" : "staticYellowFrame") + "|" + to_string(id) + "|" + to_string(kiekis) + "|\n";
						}
					}
					str_dial += "" + (kiekItemuBus >= 1 ? "\nadd_smalltext|`$Total Placed Items (" + to_string(kiekItemuBus) + "/" + to_string(currentSpaceInStore) + ")|left|" + item_list + "\nadd_button_with_icon||END_LIST|noflags|0||\n" : "\nadd_smalltext|`$There are no items placed in this Marketplace!|left|") + "|\nadd_spacer|small|\nadd_quicl_exit|\nadd_button|backtomarketdialog|`$Close " + whoseStore + "'s Market.|0|0|\nend_dialog|MarketPlace_Gtps|||\n";
					VarList::OnDialogRequest(peer, SetColor(peer) + str_dial);
				}
				catch (exception&) {
					return;
				}
			}
			if (button == "abandon_my_market") {
				std::string str_dial = "set_default_color|";
				str_dial += "\nadd_label_with_icon|big|`wAbandon Your Marketplace|left|1432|\nadd_smalltext|`oAre you sure that you want to abandon from your Marketplace?|left|\nadd_smalltext|`4NOTE: `omake sure that you have withdrawn all earnings and removed all items from your store, otherwise, they will be removed.|left|\nadd_spacer|small|\nadd_custom_button|enter_my_market|textLabel:`wNo, Back to Market;middle_colour:2415764;border_colour:2415764;|\nadd_custom_button|confirm_abandon_my_market|textLabel:`wYes, Abandon;anchor:_button_enter_my_market;left:1;margin:60,0;middle_colour:434431310;border_colour:434438350;|\nend_dialog|MarketPlace_Gtps|||\nadd_quick_exit|\n";
				VarList::OnDialogRequest(peer, SetColor(peer) + str_dial);
			}
			if (button == "confirm_abandon_my_market") {
				bool existx = filesystem::exists("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
				if (!existx) return;
				remove(("database/players/market/" + pInfo(peer)->tankIDName + "_.json").c_str());
				try {
					std::ifstream iffff("database/players/market/marketinfo/stores.json");
					json j2;
					iffff >> j2;
					iffff.close();
					std::vector<std::string> allStores;
					for (int i = 0; i < j2["owners"].size(); i++) {
						allStores.push_back(j2["owners"][i]);
					}
					for (int i = 0; i < allStores.size(); i++) {
						if (allStores[i] == pInfo(peer)->tankIDName) {
							allStores.erase(std::remove(allStores.begin(), allStores.end(), pInfo(peer)->tankIDName), allStores.end());
						}
					}
					j2["owners"] = allStores;
					std::ofstream oo2("database/players/market/marketinfo/stores.json");
					if (!oo2.is_open()) return;
					oo2 << j2 << std::endl;
					j2.clear();
					DialogHandle::MarketPlace(peer);
					VarList::OnTextOverlay(peer, "`wSuccessfully abandoned from the store!");
				}
				catch (exception&) {
					return;
				}
			}
			if (button == "upgradeCurrentSpace") {
				bool existx = filesystem::exists("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
				if (!existx) return;
				try {
					std::ifstream ifff("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
					json j;
					ifff >> j;
					ifff.close();
					int currentSpaceInStore = j["currentSpaceInStore"];
					int upgradeFor = 0;
					j.clear();
					if (currentSpaceInStore < 50) {
						if (currentSpaceInStore == 5) upgradeFor = 150000 * 2;
						else if (currentSpaceInStore == 10) upgradeFor = (150000 * 2) * 2;
						else if (currentSpaceInStore == 15) upgradeFor = ((150000 * 2) * 2) * 2;
						else if (currentSpaceInStore == 20) upgradeFor = ((200000 * 2) * 2) * 2;
						else if (currentSpaceInStore == 25) upgradeFor = ((300000 * 2) * 3) * 2;
						else if (currentSpaceInStore == 30) upgradeFor = ((400000 * 2) * 4) * 2;
						else if (currentSpaceInStore == 35) upgradeFor = ((500000 * 2) * 5) * 2;
						else if (currentSpaceInStore == 40) upgradeFor = ((600000 * 2) * 6) * 2;
						else if (currentSpaceInStore == 45) upgradeFor = ((700000 * 2) * 7) * 2;
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Upgrade Space Market|left|9412|\nadd_spacer|small|\nadd_textbox|`oYou can upgrade your current space from " + to_string(currentSpaceInStore) + " to " + to_string(currentSpaceInStore + 5) + " in your marketplace to place more items for " + Set_Count(upgradeFor) + "|left|\nadd_spacer|small|\nadd_button|confirm_upgrade_space|`2Upgrade|0|0|\nadd_button|enter_my_market|`wBack|0|0|\nend_dialog|MarketPlace_Gtps|||");
					}
					else {
						market::dialog::enter_my_market(peer);
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wCurrent Space in market is already full!", 0, 1);
					}
				}
				catch (exception&) {
					return;
				}
			}
			if (button == "confirm_upgrade_space") {
				bool existx = filesystem::exists("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
				if (!existx) return;
				try {
					std::ifstream ifff("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
					json j;
					ifff >> j;
					ifff.close();
					int currentSpaceInStore = j["currentSpaceInStore"];
					int upgradeFor = 0;
					if (currentSpaceInStore < 50) {
						if (currentSpaceInStore == 5) upgradeFor = 150000 * 2;
						else if (currentSpaceInStore == 10) upgradeFor = (150000 * 2) * 2;
						else if (currentSpaceInStore == 15) upgradeFor = ((150000 * 2) * 2) * 2;
						else if (currentSpaceInStore == 20) upgradeFor = ((200000 * 2) * 2) * 2;
						else if (currentSpaceInStore == 25) upgradeFor = ((300000 * 2) * 3) * 2;
						else if (currentSpaceInStore == 30) upgradeFor = ((400000 * 2) * 4) * 2;
						else if (currentSpaceInStore == 35) upgradeFor = ((500000 * 2) * 5) * 2;
						else if (currentSpaceInStore == 40) upgradeFor = ((600000 * 2) * 6) * 2;
						else if (currentSpaceInStore == 45) upgradeFor = ((700000 * 2) * 7) * 2;
						if (pInfo(peer)->gems >= upgradeFor) {
							VarList::OnMinGems(peer, upgradeFor);
							j["currentSpaceInStore"] = currentSpaceInStore + 5;
							std::vector<std::string> currentLogs;
							for (int i = 0; i < j["logs"].size(); i++) {
								currentLogs.push_back(j["logs"][i]);
							}
							time_t currentTime; struct tm* localTime; char buffer[80];
							time(&currentTime); localTime = localtime(&currentTime);
							int Mon = localTime->tm_mon + 1; int Day = localTime->tm_mday; int Hour = localTime->tm_hour; int Min = localTime->tm_min; int Sec = localTime->tm_sec;
							std::string tolog = " You upgrade space " + to_string(currentSpaceInStore + 5) + " for " + Set_Count(upgradeFor) + " Gems `wat " + to_string(Hour) + ":" + to_string(Min) + " on " + to_string(Mon) + "/" + to_string(Day);
							currentLogs.push_back(tolog);
							j["logs"] = currentLogs;
							j["newLogs"] = j["newLogs"].get<double>() + 1;
							std::ofstream oo("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
							if (!oo.is_open()) return;
							oo << j << std::endl;
							j.clear();
							market::dialog::enter_my_market(peer);
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You have succeessfully increased your market items space to " + to_string(currentSpaceInStore + 5) + " for " + Set_Count(upgradeFor), 0, 1);
						}
						else {
							market::dialog::enter_my_market(peer);
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou don't have enough gems.", 0, 1);
							return;
						}
					}
					else {
						market::dialog::enter_my_market(peer);
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wCurrent Space in market is already full!", 0, 1);
					}
				}
				catch (exception&) {
					return;
				}
			}
			if (button == "my_market_review_check") {
				bool existx = filesystem::exists("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
				if (!existx) return;
				try {
					std::ifstream ifff("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
					json j;
					ifff >> j;
					ifff.close();
					std::string str_dial = "set_default_color|";
					str_dial += "\nadd_label_with_icon|big|`wAll your Reviews:|left|660|\nadd_spacer|small|\n";
					bool noReviews = true;
					for (int i = 0; i < 50; i++) {
						if (j["storeReview"][i]["sentBy"].get<std::string>() != "") {
							noReviews = false;
							std::string review = j["storeReview"][i]["review"].get<std::string>();
							std::string sendBy = j["storeReview"][i]["sentBy"].get<std::string>();
							int stars = j["storeReview"][i]["stars"];
							str_dial += "\nadd_label_with_icon|small|`2" + sendBy + " (" + to_string(stars) + "/5) : " + review + "|left|660|\n";
						}
					}
					j.clear();
					if (noReviews == true) str_dial += "\nadd_textbox|`$There is no any reviews in your Marketplace.|left|\n";
					str_dial += "\nadd_spacer|small|\nadd_button|enter_my_market|Back|\nend_dialog|MarketPlace_Gtps|||\nadd_quick_exit|\n";
					VarList::OnDialogRequest(peer, SetColor(peer) + str_dial);
				}
				catch (exception&) {
					return;
				}
			}
			if (button == "read_market_notif") {
				bool existx = filesystem::exists("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
				if (!existx) return;
				try {
					std::ifstream ifff("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
					json j;
					ifff >> j;
					ifff.close();
					std::string str_logs = "", clear_logs = "", log;
					int id = 0;
					for (int i = 0; i < j["logs"].size(); i++) {
						log = j["logs"][i].get<string>();
						log.erase(std::remove(log.begin(), log.end(), '\n'), log.end());
						str_logs += "\nadd_textbox|`9" + log + "|left|\n";
					}
					if (log == "") {
						str_logs += "\nadd_textbox|`9The Market History is empty.|left|\n";
						clear_logs += "\nadd_button|clear_market_history|`4Clear History|off|0|0|\n";
					}
					else clear_logs += "\nadd_button|clear_market_history|`4Clear History|0|0|\n";
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`wMarketplace History|left|13802|\nadd_textbox|`$Here, you can trace the evolution of trades, track price fluctuations, and reminisce about the deals that shaped your Growtopian journey.|left|\nadd_spacer|small|" + clear_logs + "\nadd_spacer|small|" + str_logs + "|\nadd_spacer|small|\nadd_button|enter_my_market|`$Back|noflags|0|0|\nend_dialog|MarketPlace_Gtps|||\nadd_quick_exit\n");
					std::ofstream oo("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
					if (!oo.is_open()) return;
					oo << j << std::endl;
					j.clear();
				}
				catch (exception&) {
					return;
				}
			}
			if (button == "clear_market_history") {
				bool existx = filesystem::exists("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
				if (!existx) return;
				try {
					std::ifstream ifff("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
					json j;
					ifff >> j;
					ifff.close();
					std::vector<std::string> logs;
					j["logs"] = logs;
					std::ofstream oo("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
					if (!oo.is_open()) return;
					oo << j << std::endl;
					j.clear();
					market::dialog::enter_my_market(peer);
					VarList::OnTextOverlay(peer, "`2Market History cleared.");
					CAction::Positioned(peer, pInfo(peer)->netID, "audio/page_turn.wav", 0);
				}
				catch (exception&) {
					return;
				}
			}
			if (button.substr(0, 12) == "changeprice_") {
				std::string aposition = button.substr(button.find("_") + 1);
				if (aposition.size() > 9) return;
				int ap = std::atoi(aposition.c_str());
				bool existx = filesystem::exists("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
				if (!existx) return;
				try {
					std::ifstream ifff("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
					json j;
					ifff >> j;
					ifff.close();
					bool found = false;
					for (int i = 0; i < j["itemsInStore"].size(); i++) {
						if (j["itemsInStore"][i]["aposition"] == ap) {
							int pay = j["itemsInStore"][i]["sellForItem"], id = j["itemsInStore"][i]["itemid"], cnt = j["itemsInStore"][i]["quantityOfItems"];
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`$" + items[id].name + "|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_smalltext|`$You can change Payments, Price of the items.|left|\nadd_spacer|small|\nadd_smalltext|`$Choose the one that will be used as the price for your selling item.|left|\nmax_checks|1|\ntext_scaling_string|ckc|\nadd_checkicon|WorldLock|||242||0|\ntext_scaling_string|ckc|\nadd_checkicon|DiamondLock|||1796||0|\ntext_scaling_string|ckc|\nadd_checkicon|BGLock|||7188||0|\ntext_scaling_string|ckc|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_smalltext|`$The current price of this item : " + to_string(j["itemsInStore"][i]["sellPer"]) + " " + items[j["itemsInStore"][i]["sellForItem"]].name + " per Items|left|\nadd_text_input|NewPriceItems|`$Price of item:|" + to_string(j["itemsInStore"][i]["sellPer"]) + "|3|\nadd_quick_exit|\nadd_button|entermyitem_" + aposition + "|`$Back|\nadd_button|change_price_items|`$Change!|\nend_dialog|MarketPlace_Gtps|||\n");
							pInfo(peer)->store_pos = aposition; pInfo(peer)->store_price = pay; pInfo(peer)->store_id = id;
						}
					}
				}
				catch (exception&) {
					return;
				}
				return;
			}
			if (button == "change_price_items") {
				int idd = 0;
				std::string Wlock = parser.get("WorldLock", 1), Dlock = parser.get("DiamondLock", 1), BGlock = parser.get("BGLock", 1), new_price = parser.get("NewPriceItems", 1);
				if (!isValidCheckboxInput(Wlock) or !isValidCheckboxInput(Dlock) or !isValidCheckboxInput(BGlock)) return;
				if (Wlock == "0" && Dlock == "0" && BGlock == "0" or !isValidCheckboxInput(Wlock) or !isValidCheckboxInput(Dlock) or !isValidCheckboxInput(BGlock)) {
					VarList::OnDialogRequest(peer, market::rtrn::change("you at least choose one of the means of payment", to_string(pInfo(peer)->store_id), to_string(pInfo(peer)->store_price)/*pay*/, new_price, pInfo(peer)->store_pos));
					return;
				}
				if (Wlock == "1") idd = 242;
				if (Dlock == "1") idd = 1796;
				if (BGlock == "1") idd = 7188;
				if (new_price.find_first_not_of("1234567890") != std::string::npos) {
					VarList::OnDialogRequest(peer, market::rtrn::change("`wQuantity of How Many Per only use numbers", to_string(pInfo(peer)->store_id), to_string(pInfo(peer)->store_price)/*pay*/, new_price, pInfo(peer)->store_pos));
					return;
				}
				if (new_price == "") {
					VarList::OnDialogRequest(peer, market::rtrn::change("`wQuantity of How Many Per cannot be empty.", to_string(pInfo(peer)->store_id), to_string(pInfo(peer)->store_price)/*pay*/, new_price, pInfo(peer)->store_pos));
					return;
				}
				if (new_price.size() > 5 || new_price.size() <= 0) return;
				int sellPer = std::atoi(new_price.c_str());
				if (sellPer < 1 || sellPer > 200) {
					VarList::OnDialogRequest(peer, market::rtrn::change("`wQuantity of How Many Per should be more than 0 and lower than 200.", to_string(pInfo(peer)->store_id), to_string(pInfo(peer)->store_price)/*pay*/, new_price, pInfo(peer)->store_pos));
					return;
				}
				int payment_id = idd;
				std::string aposition = pInfo(peer)->store_pos;
				if (aposition.size() > 9) return;
				int ap = std::atoi(aposition.c_str()), new_price_ = std::atoi(new_price.c_str());
				try {
					std::ifstream ifff("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
					json j;
					ifff >> j;
					ifff.close();
					for (int i = 0; i < j["itemsInStore"].size(); i++) {
						if (j["itemsInStore"][i]["aposition"] == ap) {
							j["itemsInStore"][i]["sellForItem"] = payment_id;/*payments*/
							j["itemsInStore"][i]["sellPer"] = new_price_;/*price items*/
							std::ofstream oo("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
							if (!oo.is_open()) return;
							oo << j << std::endl;
							VarList::OnTextOverlay(peer, "`2Successfully changed!");
							market::dialog::enter_mymarket_item(peer, aposition, ap);
							break;
						}
					}
				}
				catch (exception&) {
					return;
				}
			}
			if (button.substr(0, 13) == "marketreview_") {
				std::string whoseStore = button.substr(button.find("_") + 1);
				bool existx = filesystem::exists("database/players/market/" + whoseStore + "_.json");
				if (!existx) return;
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Review Market of " + whoseStore + "|left|13812|\nadd_smalltext|`oWrite a review:|left|\nadd_text_box_input|market_review_text|||500|2|\nadd_smalltext|`oRate store 0-5:|left|\nadd_text_input|market_review_star|||2|\nadd_spacer|small|\nadd_button|enterplayeritem_" + whoseStore + "|`wBack|\nadd_custom_button|send_market_review|textLabel:`wApply a review;anchor:_button_enterplayeritem_" + whoseStore + ";left:1;margin:40,0;|\nend_dialog|MarketPlace_Gtps|||\n");
				pInfo(peer)->last_name = whoseStore;
			}
			if (button == "send_market_review") {
				std::string market_review_text = parser.get("market_review_text", 1), market_review_star = parser.get("market_review_star", 1), market_name_review = pInfo(peer)->last_name;
				if (market_review_text.size() < 5 || market_review_text == "") {
					VarList::OnDialogRequest(peer, market::rtrn::review("`oToo short review.", market_name_review, market_review_text, market_review_star));
					return;
				}
				if (market_review_star.size() < 1 || market_review_star.size() > 1 || market_review_star.find_first_not_of("012345") != std::string::npos) {
					VarList::OnDialogRequest(peer, market::rtrn::review("`oStars should be 0-5", market_name_review, market_review_text, market_review_star));
					return;
				}
				try {
					std::ifstream ifff("database/players/market/" + market_name_review + "_.json");
					json j;
					ifff >> j;
					ifff.close();
					bool arRase = false;
					bool arRado = false;
					for (int i = 0; i < 50; i++) {
						if (j["storeReview"][i]["sentBy"].get<string>() == pInfo(peer)->tankIDName) {
							arRase = true;
							VarList::OnDialogRequest(peer, market::rtrn::review("`oUnfortunately, but you have already sent the review in this Marketplace.", market_name_review, market_review_text, market_review_star));
							break;
						}
					}
					if (arRase == true) return;
					for (int i = 0; i < 50; i++) {
						if (j["storeReview"][i]["sentBy"].get<string>() == "") {
							j["storeReview"][i]["review"] = market_review_text;
							j["storeReview"][i]["sentBy"] = pInfo(peer)->tankIDName;
							j["storeReview"][i]["stars"] = std::atoi(market_review_star.c_str());
							j["newLogs"] = j["newLogs"].get<double>() + 1;
							std::ofstream oo("database/players/market/" + market_name_review + "_.json");
							if (!oo.is_open()) return;
							oo << j << std::endl;
							market::dialog::enter_player_market(peer, market_name_review);
							VarList::OnTextOverlay(peer, "`2Successfully sent.");
							arRado = true;
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED) break;
								if (market_name_review == pInfo(peer)->tankIDName) {
									VarList::OnConsoleMessage(cp_, "`2You have received a new notification in your Marketplace! Check it out.");
									CAction::Log(cp_, "action|play_sfx\nfile|audio/pay_time.wav\ndelayMS|0");
									break;
								}
							}
							break;
						}
					}
					if (arRado == false) {
						VarList::OnDialogRequest(peer, market::rtrn::review("`oUnfortunately, but the reviews in this Marketplace are overflowing.", market_name_review, market_review_text, market_review_star));
						return;
					}
				}
				catch (exception&) {
					return;
				}
			}
			if (button.substr(0, 18) == "marketreviewcheck_") {
				std::string whoseStore = button.substr(button.find("_") + 1);
				bool existx = filesystem::exists("database/players/market/" + whoseStore + "_.json");
				if (!existx) return;
				try {
					std::ifstream ifff("database/players/market/" + whoseStore + "_.json");
					json j;
					ifff >> j;
					ifff.close();
					std::string str_dial = "set_default_color|";
					str_dial += "\nadd_label_with_icon|big|`wAll " + whoseStore + "'s Marketplace Reviews:|left|660|\nadd_spacer|small|\n";
					bool noReviews = true;
					for (int i = 0; i < 50; i++) {
						if (j["storeReview"][i]["sentBy"].get<string>() != "") {
							noReviews = false;
							std::string review = j["storeReview"][i]["review"].get<string>();
							std::string sendBy = j["storeReview"][i]["sentBy"].get<string>();
							int stars = j["storeReview"][i]["stars"];
							str_dial += "\nadd_label_with_icon|small|`2" + sendBy + " (" + to_string(stars) + "/5) : " + review + "|left|660|\n";
						}
					}
					if (noReviews == true) str_dial += "\nadd_textbox|`$There is no any reviews in this Marketplace.|left|\n";
					str_dial += "\nadd_button|enterplayeritem_" + whoseStore + "|Back|\nadd_quick_exit|\nend_dialog|MarketPlace_Gtps|||\n";
					VarList::OnDialogRequest(peer, SetColor(peer) + str_dial);
				}
				catch (exception&) {
					return;
				}
				return;
			}
			if (button.substr(0, 11) == "addallitem_") {
				std::string aposition = button.substr(button.find("_") + 1);
				if (aposition.size() > 9) return;
				int ap = std::atoi(aposition.c_str());
				bool existx = filesystem::exists("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
				if (!existx) {
					VarList::OnTextOverlay(peer, "`4Store does not exist");
					return;
				}
				try {
					std::ifstream ifff("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
					json j;
					ifff >> j;
					ifff.close();
					bool found = false, doesHave = false;
					int howManyHave = 0, additem = 0;
					for (int i = 0; i < j["itemsInStore"].size(); i++) {
						if (j["itemsInStore"][i]["aposition"] == ap) {
							market::check::items_in_inv(peer, j["itemsInStore"][i]["itemid"], 1, doesHave);
							if (doesHave == false) {
								break;
							}
							howManyHave = market::check::count_items(peer, j["itemsInStore"][i]["itemid"]);
							j["itemsInStore"][i]["quantityOfItems"] = j["itemsInStore"][i]["quantityOfItems"].get<double>() + howManyHave;
							if (Inventory::Modify(peer, j["itemsInStore"][i]["itemid"], additem = -howManyHave) == 0) {
								std::vector<std::string> currentLogs;
								for (int i = 0; i < j["logs"].size(); i++) {
									currentLogs.push_back(j["logs"][i]);
								}
								time_t currentTime; struct tm* localTime; char buffer[80];
								time(&currentTime); localTime = localtime(&currentTime);
								int Mon = localTime->tm_mon + 1; int Day = localTime->tm_mday; int Hour = localTime->tm_hour; int Min = localTime->tm_min; int Sec = localTime->tm_sec;
								std::string tolog = " You added " + to_string(howManyHave) + " stock " + items[j["itemsInStore"][i]["itemid"]].name + " to your Marketplace `wat " + to_string(Hour) + ":" + to_string(Min) + " on " + to_string(Mon) + "/" + to_string(Day);
								currentLogs.push_back(tolog);
								j["logs"] = currentLogs;
								j["newLogs"] = j["newLogs"].get<double>() + 1;
								std::ofstream oo("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
								if (!oo.is_open()) break;
								oo << j << std::endl;
								market::dialog::enter_mymarket_item(peer, aposition, ap);
								VarList::OnConsoleMessage(peer, "Successfully added " + to_string(howManyHave) + " " + items[j["itemsInStore"][i]["itemid"]].name + " to your Marketplace.");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Successfully added " + to_string(howManyHave) + " " + items[j["itemsInStore"][i]["itemid"]].name + " to your Marketplace.", 0, 1);
								doesHave = true;
								found = true;
								break;
							}
						}
					}
					if (!doesHave) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou don't have that item in your inventory.");
						market::dialog::enter_mymarket_item(peer, aposition, ap);
						return;
					}
					if (!found) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wItem does not exist in your store");
						market::dialog::enter_mymarket_item(peer, aposition, ap);
						return;
					}
				}
				catch (exception&) {
					return;
				}
				return;
			}
			if (button.substr(0, 20) == "removeitemsfromsell_") {
				std::string aposition = button.substr(button.find("_") + 1);
				if (aposition.size() > 9) return;
				int ap = std::atoi(aposition.c_str());
				bool existx = filesystem::exists("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
				if (!existx) {
					VarList::OnTextOverlay(peer, "`wStore does not exist");
					return;
				}
				try {
					std::ifstream ifff("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
					json j;
					ifff >> j;
					ifff.close();
					bool found = false, earned = false, quantityOfItems = false;
					int quantityOfItemsHowMany = 0;
					for (int i = 0; i < j["itemsInStore"].size(); i++) {
						if (j["itemsInStore"][i]["aposition"] == ap) {
							found = true;
							if (j["itemsInStore"][i]["boughtItems"] > 0) {
								earned = true;
								break;
							}
							if (j["itemsInStore"][i]["quantityOfItems"] > 0) {
								quantityOfItems = true;
								quantityOfItemsHowMany = j["itemsInStore"][i]["quantityOfItems"];
								break;
							}
							VarList::OnConsoleMessage(peer, "You removed " + items[j["itemsInStore"][i]["itemid"]].name + " from selling in your Marketplace.");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You removed " + items[j["itemsInStore"][i]["itemid"]].name + " from selling in your Marketplace.", 0, 1);
							std::vector<std::string> currentLogs;
							for (int i = 0; i < j["logs"].size(); i++) {
								currentLogs.push_back(j["logs"][i]);
							}
							time_t currentTime; struct tm* localTime; char buffer[80];
							time(&currentTime); localTime = localtime(&currentTime);
							int Mon = localTime->tm_mon + 1; int Day = localTime->tm_mday; int Hour = localTime->tm_hour; int Min = localTime->tm_min; int Sec = localTime->tm_sec;
							std::string tolog = " You removed " + items[j["itemsInStore"][i]["itemid"]].name + " from selling in your Marketplace `wat " + to_string(Hour) + ":" + to_string(Min) + " on " + to_string(Mon) + "/" + to_string(Day);
							currentLogs.push_back(tolog);
							j["logs"] = currentLogs;
							j["newLogs"] = j["newLogs"].get<double>() + 1;
							j["itemsInStore"][i]["itemid"] = 0;
							j["itemsInStore"][i]["sellForItem"] = 0;
							j["itemsInStore"][i]["sellPer"] = 0;
							std::ofstream oo("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
							if (!oo.is_open()) break;
							oo << j << std::endl;
							market::dialog::enter_my_market(peer);
							break;
						}
					}
					if (earned) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou have earned items here. Withdraw them first.");
						market::dialog::enter_mymarket_item(peer, aposition, ap);
						return;
					}
					if (quantityOfItems) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wThere are " + to_string(quantityOfItemsHowMany) + " items placed on your store. Take them back to your inventory.");
						market::dialog::enter_mymarket_item(peer, aposition, ap);
						return;
					}
					if (!found) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`4Item does not exist in your marketplace");
						market::dialog::enter_mymarket_item(peer, aposition, ap);
						return;
					}
				}
				catch (exception&) {
					return;
				}
				return;
			}
			if (button.substr(0, 12) == "pickupitems_") {
				std::string aposition = button.substr(button.find("_") + 1);
				if (aposition.size() > 9) return;
				int ap = std::atoi(aposition.c_str());
				bool existx = filesystem::exists("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
				if (!existx) {
					VarList::OnTextOverlay(peer, "`wStore does not exist");
					return;
				}
				try {
					std::ifstream ifff("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
					json j;
					ifff >> j;
					ifff.close();
					int additem = 0;
					bool found = false, noHas = false;
					for (int i = 0; i < j["itemsInStore"].size(); i++) {
						if (j["itemsInStore"][i]["aposition"] == ap) {
							bool success = false;
							found = true;
							if (j["itemsInStore"][i]["quantityOfItems"] < 1) {
								noHas = true;
								break;
							}
							int howManyHas = j["itemsInStore"][i]["quantityOfItems"];
							if (market::check::items_exists(peer, j["itemsInStore"][i]["itemid"])) {
								int currentlyHave = market::check::count_items(peer, j["itemsInStore"][i]["itemid"]);
								if (j["itemsInStore"][i]["quantityOfItems"].get<double>() + currentlyHave < 201) {
									Inventory::Modify(peer, j["itemsInStore"][i]["itemid"], additem = j["itemsInStore"][i]["quantityOfItems"]);
									j["itemsInStore"][i]["quantityOfItems"] = 0;
									VarList::OnConsoleMessage(peer, "You picked up " + to_string(howManyHas) + " " + items[j["itemsInStore"][i]["itemid"]].name + "");
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You picked up " + to_string(howManyHas) + " " + items[j["itemsInStore"][i]["itemid"]].name + "", 0, 1);
								}
								else {
									int kiekTrukstaIki200 = 200 - currentlyHave;
									Inventory::Modify(peer, j["itemsInStore"][i]["itemid"], additem = kiekTrukstaIki200);
									j["itemsInStore"][i]["quantityOfItems"] = j["itemsInStore"][i]["quantityOfItems"].get<double>() - kiekTrukstaIki200;
									howManyHas -= kiekTrukstaIki200;
									VarList::OnConsoleMessage(peer, "You picked up " + to_string(kiekTrukstaIki200) + " " + items[j["itemsInStore"][i]["itemid"]].name + ", leaving " + to_string(howManyHas) + " in the marketplace.");
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You picked up " + to_string(kiekTrukstaIki200) + " " + items[j["itemsInStore"][i]["itemid"]].name + ", leaving " + to_string(howManyHas) + " in the marketplace.", 0, 1);
								}
							}
							else {
								if (j["itemsInStore"][i]["quantityOfItems"] > 200) {
									Inventory::Modify(peer, j["itemsInStore"][i]["itemid"], additem = 200);
									j["itemsInStore"][i]["quantityOfItems"] = j["itemsInStore"][i]["quantityOfItems"].get<double>() - 200;
									howManyHas -= 200;
									VarList::OnConsoleMessage(peer, "You picked up 200 " + items[j["itemsInStore"][i]["itemid"]].name + ", leaving " + to_string(howManyHas) + " in the marketplace.");
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You picked up 200 " + items[j["itemsInStore"][i]["itemid"]].name + ", leaving " + to_string(howManyHas) + " in the marketplace.", 0, 1);
								}
								else {
									Inventory::Modify(peer, j["itemsInStore"][i]["itemid"], additem = j["itemsInStore"][i]["quantityOfItems"]);
									j["itemsInStore"][i]["quantityOfItems"] = 0;
									VarList::OnConsoleMessage(peer, "You picked up " + to_string(howManyHas) + " " + items[j["itemsInStore"][i]["itemid"]].name + "");
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You picked up " + to_string(howManyHas) + " " + items[j["itemsInStore"][i]["itemid"]].name + "", 0, 1);
								}
							}
							std::vector<std::string> currentLogs;
							for (int i = 0; i < j["logs"].size(); i++) {
								currentLogs.push_back(j["logs"][i]);
							}
							time_t currentTime; struct tm* localTime; char buffer[80];
							time(&currentTime); localTime = localtime(&currentTime);
							int Mon = localTime->tm_mon + 1; int Day = localTime->tm_mday; int Hour = localTime->tm_hour; int Min = localTime->tm_min; int Sec = localTime->tm_sec;
							std::string tolog = " You returned " + to_string(howManyHas) + " " + items[j["itemsInStore"][i]["itemid"]].name + " from your Marketplace `wat " + to_string(Hour) + ":" + to_string(Min) + " on " + to_string(Mon) + "/" + to_string(Day);
							currentLogs.push_back(tolog);
							j["logs"] = currentLogs;
							j["newLogs"] = j["newLogs"].get<double>() + 1;
							std::ofstream oo("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
							if (!oo.is_open()) break;
							oo << j << std::endl;
							market::dialog::enter_mymarket_item(peer, aposition, ap);
							break;
						}
					}
					if (noHas) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou don't have more than 0 placed items.");
						market::dialog::enter_mymarket_item(peer, aposition, ap);
						return;
					}
					if (!found) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wItem does not exist in your store");
						market::dialog::enter_mymarket_item(peer, aposition, ap);
						return;
					}
				}
				catch (exception&) {
					return;
				}
				return;
			}
			if (button.substr(0, 20) == "withdrawallearnings_") {
				std::string aposition = button.substr(button.find("_") + 1);
				if (aposition.size() > 9) return;
				int ap = std::atoi(aposition.c_str());
				bool existx = filesystem::exists("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
				if (!existx) {
					VarList::OnTextOverlay(peer, "`wStore does not exist");
					return;
				}
				try {
					std::ifstream ifff("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
					json j;
					ifff >> j;
					ifff.close();
					int additem = 0;
					bool found = false, noearned = false;
					for (int i = 0; i < j["itemsInStore"].size(); i++) {
						if (j["itemsInStore"][i]["aposition"] == ap) {
							bool success = false;
							found = true;
							if (j["itemsInStore"][i]["boughtItems"] < 1) {
								noearned = true;
								break;
							}
							int howManyEarnings = j["itemsInStore"][i]["boughtItems"];
							if (market::check::items_exists(peer, j["itemsInStore"][i]["sellForItem"])) {
								int currentlyHave = market::check::count_items(peer, j["itemsInStore"][i]["sellForItem"]);
								if (j["itemsInStore"][i]["boughtItems"].get<double>() + currentlyHave < 201) {
									Inventory::Modify(peer, j["itemsInStore"][i]["sellForItem"], additem = j["itemsInStore"][i]["boughtItems"]);
									j["itemsInStore"][i]["boughtItems"] = 0;
									VarList::OnConsoleMessage(peer, "You collected " + to_string(howManyEarnings) + " " + items[j["itemsInStore"][i]["sellForItem"]].name + "");
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You collected " + to_string(howManyEarnings) + " " + items[j["itemsInStore"][i]["sellForItem"]].name + "", 0, 1);
								}
								else {
									int kiekTrukstaIki200 = 200 - currentlyHave;
									Inventory::Modify(peer, j["itemsInStore"][i]["sellForItem"], additem = kiekTrukstaIki200);
									j["itemsInStore"][i]["boughtItems"] = j["itemsInStore"][i]["boughtItems"].get<double>() - kiekTrukstaIki200;
									howManyEarnings -= kiekTrukstaIki200;
									VarList::OnConsoleMessage(peer, "You collected " + to_string(kiekTrukstaIki200) + " " + items[j["itemsInStore"][i]["sellForItem"]].name + ", and leaving " + to_string(howManyEarnings) + " " + items[j["itemsInStore"][i]["sellForItem"]].name + " in marketplace.");
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You collected " + to_string(kiekTrukstaIki200) + " " + items[j["itemsInStore"][i]["sellForItem"]].name + ", and leaving " + to_string(howManyEarnings) + " " + items[j["itemsInStore"][i]["sellForItem"]].name + " in marketplace.", 0, 1);
								}
							}
							else {
								if (j["itemsInStore"][i]["boughtItems"] > 200) {
									Inventory::Modify(peer, j["itemsInStore"][i]["sellForItem"], additem = 200);
									j["itemsInStore"][i]["boughtItems"] = j["itemsInStore"][i]["boughtItems"].get<double>() - 200;
									howManyEarnings -= 200;
									VarList::OnConsoleMessage(peer, "You collected 200 " + items[j["itemsInStore"][i]["sellForItem"]].name + ", and leaving " + to_string(howManyEarnings) + " " + items[j["itemsInStore"][i]["sellForItem"]].name + " in marketplace.");
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You collected 200 " + items[j["itemsInStore"][i]["sellForItem"]].name + ", and leaving " + to_string(howManyEarnings) + " " + items[j["itemsInStore"][i]["sellForItem"]].name + " in marketplace.", 0, 1);
								}
								else {
									Inventory::Modify(peer, j["itemsInStore"][i]["sellForItem"], additem = j["itemsInStore"][i]["boughtItems"]);
									j["itemsInStore"][i]["boughtItems"] = 0;
									VarList::OnConsoleMessage(peer, "You collected " + to_string(howManyEarnings) + " " + items[j["itemsInStore"][i]["sellForItem"]].name + "");
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You collected " + to_string(howManyEarnings) + " " + items[j["itemsInStore"][i]["sellForItem"]].name + "", 0, 1);
								}
							}
							std::ofstream oo("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
							if (!oo.is_open()) break;
							oo << j << std::endl;
							market::dialog::enter_mymarket_item(peer, aposition, ap);
							break;
						}
					}
					if (noearned) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wYou don't have earned items.");
						market::dialog::enter_mymarket_item(peer, aposition, ap);
						return;
					}
					if (!found) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`wItem does not exist in your store");
						market::dialog::enter_mymarket_item(peer, aposition, ap);
						return;
					}
				}
				catch (exception&) {
					return;
				}
				return;
			}
			if (button.substr(0, 22) == "playermarketitementer_") {
				std::string pos_and_whoseStore = button.erase(0, 22);
				std::string::size_type pos = pos_and_whoseStore.find('_');
				std::string apos = "", whoseStore = "";
				if (pos != std::string::npos) {
					apos = pos_and_whoseStore.substr(0, pos);
					pos_and_whoseStore.erase(0, pos + 1);
					whoseStore = pos_and_whoseStore;
				}
				else {
					return;
				}
				bool existx = filesystem::exists("database/players/market/" + whoseStore + "_.json");
				if (!existx) return;
				if (apos.size() > 9) return;
				int a_pos = std::atoi(apos.c_str());
				try {
					std::ifstream ifff("database/players/market/" + whoseStore + "_.json");
					json j;
					ifff >> j;
					ifff.close();
					std::string str_dial = "set_default_color|";
					bool found = false, error = false, error2 = false;
					for (int i = 0; i < j["itemsInStore"].size(); i++) {
						if (j["itemsInStore"][i]["aposition"] == a_pos) {
							found = true;
							if (j["itemsInStore"][i]["itemid"] == 0) {
								error = true;
								break;
							}
							if (j["itemsInStore"][i]["quantityOfItems"] == 0) {
								error2 = true;
								break;
							}
							int itemprice = j["itemsInStore"][i]["sellForItem"];
							int itempricePer = j["itemsInStore"][i]["sellPer"];
							int itemId = j["itemsInStore"][i]["itemid"];
							int quantity = j["itemsInStore"][i]["quantityOfItems"];
							short int currentItemCount = Inventory::Contains(peer, itemprice);
							str_dial += "\nadd_label_with_icon|big|`o" + items[j["itemsInStore"][i]["itemid"]].name + "|left|" + to_string(j["itemsInStore"][i]["itemid"]) + "|\nadd_spacer|small|\nadd_label_with_icon|sml|`oThe store contains a total of " + to_string(quantity) + " `2" + items[j["itemsInStore"][i]["itemid"]].name + "|left|" + to_string(j["itemsInStore"][i]["itemid"]) + "|\nadd_textbox|`oFor a cost of:|left|\nadd_label_with_icon|small|`o" + to_string(itempricePer) + " x `8" + items[itemprice].name + "|left|" + to_string(itemprice) + "|\nadd_spacer|small|\nadd_textbox|`oYou will get:|left|\nadd_label_with_icon|small|`o1 x `2" + items[itemId].name + "|left|" + to_string(itemId) + "|\nadd_spacer|small|\nadd_textbox|`oYou have " + to_string(currentItemCount) + " " + items[itemprice].name + ".|left|\nadd_text_input|quantity_buy_item_player|`oHow many would you like to buy||3|\n";
							break;
						}
					}
					if (error) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`oItem does not exist in this Marketplace.");
						market::dialog::enter_player_market(peer, whoseStore);
						return;
					}
					if (error2) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`oItem sold out.");
						market::dialog::enter_player_market(peer, whoseStore);
						return;
					}
					if (!found) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`oItem does not exist in this Marketplace.");
						market::dialog::enter_player_market(peer, whoseStore);
						return;
					}
					str_dial += "\nadd_spacer|small|\nadd_quick_exit|\nadd_button|enterplayeritem_" + whoseStore + "|`wBack|\nadd_custom_button|Buy_Player_Items|textLabel:`wBuy Items;anchor:_button_enterplayeritem_" + whoseStore + ";left:1;margin:40,0;|\nend_dialog|MarketPlace_Gtps|||\n";
					pInfo(peer)->last_name = whoseStore; pInfo(peer)->last_pos = apos;
					VarList::OnDialogRequest(peer, SetColor(peer) + str_dial);
				}
				catch (exception&) {
					return;
				}
				return;
			}
			if (button == "Buy_Player_Items") {
				std::string quantity_buy_item_player = parser.get("quantity_buy_item_player", 1), player_market_name_buy = pInfo(peer)->last_name;
				if (quantity_buy_item_player.find_first_not_of("1234567890") != std::string::npos) {
					VarList::OnDialogRequest(peer, market::rtrn::buy("`oQuantity should be only numbers.", player_market_name_buy));
					return;
				}
				if (quantity_buy_item_player.size() < 1) {
					VarList::OnDialogRequest(peer, market::rtrn::buy("`oQuantity cannot be empty..", player_market_name_buy));
					return;
				}
				std::string player_market_pos = pInfo(peer)->last_pos;
				int a_pos = std::atoi(player_market_pos.c_str()), quantityBuy = std::atoi(quantity_buy_item_player.c_str());
				if (std::atoi(quantity_buy_item_player.c_str()) < 1 || std::atoi(quantity_buy_item_player.c_str()) > 200) {
					VarList::OnDialogRequest(peer, market::rtrn::buy("`oQuantity should be 1-200.", player_market_name_buy));
					return;
				}
				try {
					std::ifstream ifff("database/players/market/" + player_market_name_buy + "_.json");
					json j;
					ifff >> j;
					ifff.close();
					bool found = false, error = false, error2 = false;
					for (int i = 0; i < j["itemsInStore"].size(); i++) {
						if (j["itemsInStore"][i]["aposition"] == a_pos) {
							found = true;
							if (j["itemsInStore"][i]["itemid"] == 0) {
								error = true;
								break;
							}
							if (j["itemsInStore"][i]["quantityOfItems"] == 0) {
								error2 = true;
								break;
							}
							int itemprice = j["itemsInStore"][i]["sellForItem"], additem = 0, itempricePer = j["itemsInStore"][i]["sellPer"], itemId = j["itemsInStore"][i]["itemid"], quantity = j["itemsInStore"][i]["quantityOfItems"];
							if (quantityBuy > quantity) {
								VarList::OnDialogRequest(peer, market::rtrn::buy2(peer, "`oThe number of items you want is insufficient, stock items left (" + to_string(quantity) + ").", player_market_name_buy, to_string(itemId), to_string(itemprice), to_string(itempricePer), to_string(quantity)));
								break;
							}
							if (market::check::items_exists(peer, j["itemsInStore"][i]["sellForItem"]) == false) {
								VarList::OnDialogRequest(peer, market::rtrn::buy2(peer, "`oYou don't have " + items[j["itemsInStore"][i]["sellForItem"]].name + ".", player_market_name_buy, to_string(itemId), to_string(itemprice), to_string(itempricePer), to_string(quantity)));
								break;
							}
							bool iscontains = false;
							market::check::items_in_inv(peer, j["itemsInStore"][i]["sellForItem"], quantityBuy * itempricePer, iscontains);
							if (iscontains == false) {
								VarList::OnDialogRequest(peer, market::rtrn::buy2(peer, "`oYou don't have enough (" + to_string(quantityBuy * itempricePer) + ") " + items[j["itemsInStore"][i]["sellForItem"]].name + ".", player_market_name_buy, to_string(itemId), to_string(itemprice), to_string(itempricePer), to_string(quantity)));
								break;
							}
							bool success = false;
							if (market::check::items_exists(peer, j["itemsInStore"][i]["itemid"])) {
								int currentlyHave = market::check::count_items(peer, j["itemsInStore"][i]["itemid"]);
								if (quantityBuy + currentlyHave < 201) {
									Inventory::Modify(peer, j["itemsInStore"][i]["itemid"], additem = quantityBuy);
									j["itemsInStore"][i]["quantityOfItems"] = j["itemsInStore"][i]["quantityOfItems"].get<double>() - quantityBuy;
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You bought " + to_string(quantityBuy) + " " + items[j["itemsInStore"][i]["itemid"]].name + "  for " + to_string(quantityBuy * itempricePer) + " " + items[j["itemsInStore"][i]["sellForItem"]].name + "", 0, 1);
									VarList::OnConsoleMessage(peer, "`7[```9You bought " + to_string(quantityBuy) + " " + items[j["itemsInStore"][i]["itemid"]].name + "  for " + to_string(quantityBuy * itempricePer) + " " + items[j["itemsInStore"][i]["sellForItem"]].name + "```7]``");

								}
								else {
									VarList::OnDialogRequest(peer, market::rtrn::buy2(peer, "`oYou don't have enought space in your inventory to buy " + to_string(quantityBuy) + " " + items[j["itemsInStore"][i]["itemid"]].name + ".", player_market_name_buy, to_string(itemId), to_string(itemprice), to_string(itempricePer), to_string(quantity)));
									break;
								}
							}
							else {
								Inventory::Modify(peer, j["itemsInStore"][i]["itemid"], additem = quantityBuy);
								j["itemsInStore"][i]["quantityOfItems"] = j["itemsInStore"][i]["quantityOfItems"].get<double>() - quantityBuy;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You bought " + to_string(quantityBuy) + " " + items[j["itemsInStore"][i]["itemid"]].name + "  for " + to_string(quantityBuy * itempricePer) + " " + items[j["itemsInStore"][i]["sellForItem"]].name + "", 0, 1);
								VarList::OnConsoleMessage(peer, "`7[```9You bought " + to_string(quantityBuy) + " " + items[j["itemsInStore"][i]["itemid"]].name + "  for " + to_string(quantityBuy * itempricePer) + " " + items[j["itemsInStore"][i]["sellForItem"]].name + "```7]``");
							}
							if (Inventory::Modify(peer, j["itemsInStore"][i]["sellForItem"], additem = -quantityBuy * itempricePer) == 0) {
								j["itemsInStore"][i]["boughtItems"] = j["itemsInStore"][i]["boughtItems"].get<double>() + (quantityBuy * itempricePer);
								std::vector<std::string> currentLogs;
								for (int i = 0; i < j["logs"].size(); i++) {
									currentLogs.push_back(j["logs"][i]);
								}
								time_t currentTime; struct tm* localTime; char buffer[80];
								time(&currentTime); localTime = localtime(&currentTime);
								int Mon = localTime->tm_mon + 1; int Day = localTime->tm_mday; int Hour = localTime->tm_hour; int Min = localTime->tm_min; int Sec = localTime->tm_sec;
								std::string tolog = " " + pInfo(peer)->tankIDName + " Purchase " + to_string(quantityBuy) + " " + items[j["itemsInStore"][i]["itemid"]].name + " `wat " + to_string(Hour) + ":" + to_string(Min) + " on " + to_string(Mon) + "/" + to_string(Day);
								currentLogs.push_back(tolog);
								j["logs"] = currentLogs;
								j["newLogs"] = j["newLogs"].get<double>() + 1;
								std::ofstream oo("database/players/market/" + player_market_name_buy + "_.json");
								if (!oo.is_open()) break;
								oo << j << std::endl;
								market::dialog::enter_player_market(peer, player_market_name_buy);
								for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
									if (cp_->state != ENET_PEER_STATE_CONNECTED) break;
									if (player_market_name_buy == pInfo(cp_)->tankIDName) {
										VarList::OnConsoleMessage(cp_, "`2You have received a new notification in your marketplace! Check it out.");
										CAction::Log(cp_, "action|play_sfx\nfile|audio/pay_time.wav\ndelayMS|0");
										break;
									}
								}
								break;
							}
						}
					}
					if (error) {
						VarList::OnTextOverlay(peer, "`wItem does not exist in this Marketplace.");
						market::dialog::enter_player_market(peer, player_market_name_buy);
						return;
					}
					if (error2) {
						VarList::OnTextOverlay(peer, "`wItem sold out.");
						market::dialog::enter_player_market(peer, player_market_name_buy);
						return;
					}
					if (!found) {
						VarList::OnTextOverlay(peer, "`wItem does not exist in this Marketplace.");
						market::dialog::enter_player_market(peer, player_market_name_buy);
						return;
					}
				}
				catch (exception&) {
					return;
				}
			}
			if (button.substr(0, 12) == "entermyitem_") {
				std::string aposition = button.substr(button.find("_") + 1);
				if (aposition.size() > 9) return;
				int ap = std::atoi(aposition.c_str());
				bool existx = filesystem::exists("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
				if (!existx) return;
				try {
					std::ifstream ifff("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
					json j;
					ifff >> j;
					ifff.close();
					bool found = false;
					for (int i = 0; i < j["itemsInStore"].size(); i++) {
						if (j["itemsInStore"][i]["aposition"] == ap) {
							auto mtitems = 0, mtitem = 0;
							int earned = j["itemsInStore"][i]["boughtItems"], itempricePer = j["itemsInStore"][i]["sellPer"], id = j["itemsInStore"][i]["sellForItem"], ids = j["itemsInStore"][i]["itemid"], cnt = j["itemsInStore"][i]["quantityOfItems"];
							std::string str_dial = "set_default_color|";
							str_dial += "\nadd_label_with_icon|big|`o" + items[j["itemsInStore"][i]["itemid"]].name + "|left|" + to_string(j["itemsInStore"][i]["itemid"]) + "|\nadd_spacer|small|\nadd_label_with_icon|sml|`oThe store contains a total of " + to_string(cnt) + " `2" + items[j["itemsInStore"][i]["itemid"]].name + "|left|" + to_string(j["itemsInStore"][i]["itemid"]) + "|\n";
							for (auto i = 0; i < pInfo(peer)->inv.size(); i++) {
								if (pInfo(peer)->inv[i].first == ids) {
									mtitems = pInfo(peer)->inv[i].second;
									break;
								}
							}
							for (auto i = 0; i < pInfo(peer)->inv.size(); i++) {
								if (pInfo(peer)->inv[i].first == id) {
									mtitem = pInfo(peer)->inv[i].second;
									break;
								}
							}
							if (mtitems > 0) str_dial += "\nadd_smalltext|`oYou have " + to_string(mtitems) + " " + items[ids].name + " in your backpack.|left|\nadd_button|addallitem_" + aposition + "|`oAdd them to the Store|noflags|0|0|\n";
							str_dial += "\nadd_spacer|small|\nadd_textbox|`oFor a cost of:|left|\nadd_label_with_icon|small|`o" + to_string(itempricePer) + " x `8" + items[j["itemsInStore"][i]["sellForItem"]].name + "|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`oYou will get:|left|\nadd_label_with_icon|small|`o1 x `2" + items[j["itemsInStore"][i]["itemid"]].name + "|left|" + to_string(j["itemsInStore"][i]["itemid"]) + "|\n";
							if (cnt == 0) str_dial += "\nadd_button|removeitemsfromsell_" + aposition + "|`oRemove that item from selling|noflags|0|0|\n";
							else str_dial += "\nadd_spacer|small|\nadd_button|changeprice_" + aposition + "|`oChange Price|noflags|0|0|" + (mtitems == 200 ? "\nadd_smalltext|`oYou are already carrying 200 " + items[ids].name + "!|left|\nadd_button||`oEmpty the stock|off|0|0|\n" : "\nadd_button|pickupitems_" + aposition + "|`oEmpty the stock|noflags|0|0|\n");
							if (earned > 0) str_dial += "" + (mtitem == 200 ? "\nadd_smalltext|`oYou are already carrying 200 " + items[id].name + "!|left|\nadd_button||`oWithdraw " + items[id].name + ".|off|0|0|\n" : "\nadd_smalltext|`oYou have earned " + to_string(earned) + " " + items[id].name + ".|left|\nadd_button|withdrawallearnings_" + aposition + "|`oWithdraw " + items[id].name + ".|noflags|0|0|\n");
							str_dial += "\nadd_quick_exit|\nadd_button|enter_my_market|`oBack To Market|0|0|\nend_dialog|MarketPlace_Gtps|||\n";
							VarList::OnDialogRequest(peer, SetColor(peer) + str_dial);
							found = true;
							break;
						}
					}
					if (!found) {
						VarList::OnTextOverlay(peer, "`4Item does not exist in your store");
						market::dialog::enter_my_market(peer);
						return;
					}
				}
				catch (exception&) {
					return;
				}
				return;
			}
			if (button == "confirm_add_item") {
				std::string Wlock = parser.get("WorldLock", 1), Dlock = parser.get("DiamondLock", 1), BGlock = parser.get("BGLock", 1), market_item_price = parser.get("market_item_price", 1), market_item_count = parser.get("marketitempickercount", 1);
				if (!isValidCheckboxInput(Wlock) or !isValidCheckboxInput(Dlock) or !isValidCheckboxInput(BGlock)) return;
				int id = std::atoi(get_embed(cch, "itemid").c_str()), idd = 0;
				if (Wlock == "0" && Dlock == "0" && BGlock == "0") {
					VarList::OnDialogRequest(peer, market::rtrn::add("you at least choose one of the means of payment", to_string(id), market_item_count, market_item_price));
					return;
				}
				if (Wlock == "1") idd = 242;
				if (Dlock == "1") idd = 1796;
				if (BGlock == "1") idd = 7188;
				if (market_item_count == "") {
					VarList::OnDialogRequest(peer, market::rtrn::add("`wQuantity of the items cannot be empty.", to_string(id), market_item_count, market_item_price));
					return;
				}
				if (market_item_count.find_first_not_of("1234567890") != std::string::npos) {
					VarList::OnDialogRequest(peer, market::rtrn::add("`wQuantity of the items only use numbers", to_string(id), market_item_count, market_item_price));
					return;
				}
				if (market_item_count.size() > 3 || market_item_count.size() <= 0) return;
				int count = std::atoi(market_item_count.c_str());
				if (count < 1 || count > 200) {
					VarList::OnDialogRequest(peer, market::rtrn::add("`wQuantity should be more than 0 and lower than 200.", to_string(id), market_item_count, market_item_price));
					return;
				}
				if (id <= 0 || id > items.size()) return;
				bool isContains = false;
				market::check::items_in_inv(peer, id, count, isContains);
				if (isContains == false) return;
				bool existx = filesystem::exists("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
				if (!existx) return;
				if (market_item_count.size() > 3 || market_item_count.size() <= 0) return;
				if (market_item_price.find_first_not_of("1234567890") != std::string::npos) {
					VarList::OnDialogRequest(peer, market::rtrn::add("`wQuantity of How Many Per only use numbers", to_string(id), market_item_count, market_item_price));
					return;
				}
				if (market_item_price == "") {
					VarList::OnDialogRequest(peer, market::rtrn::add("`wQuantity of How Many Per cannot be empty.", to_string(id), market_item_count, market_item_price));
					return;
				}
				if (market_item_price.size() > 5 || market_item_price.size() <= 0) return;
				int price = std::atoi(market_item_price.c_str());
				if (price < 1 || price > 200) {
					VarList::OnDialogRequest(peer, market::rtrn::add("`wQuantity of How Many Per should be more than 0 and lower than 200.", to_string(id), market_item_count, market_item_price));
					return;
				}
				int payment_id = idd;
				try {
					std::ifstream ifff("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
					json j;
					ifff >> j;
					ifff.close();
					int currentSpaceInStore = j["currentSpaceInStore"], additem = 0;
					bool arYraLaisvu = false;
					for (int i = 0; i < currentSpaceInStore; i++) {
						if (j["itemsInStore"][i]["itemid"] == id) {
							gamepacket_t p;
							VarList::OnTextOverlay(peer, "Sorry that item is already placed in your marketplace.");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Sorry that item is already placed in your marketplace.", 0, 1);
							break;
						}
						else if (j["itemsInStore"][i]["itemid"] == 0) {
							j["itemsInStore"][i]["itemid"] = id;/*item id*/
							j["itemsInStore"][i]["quantityOfItems"] = count;/*item count*/
							j["itemsInStore"][i]["sellForItem"] = payment_id;/*payments*/
							j["itemsInStore"][i]["sellPer"] = price;/*price*/
							std::vector<std::string> currentLogs;
							for (int i = 0; i < j["logs"].size(); i++) {
								currentLogs.push_back(j["logs"][i]);
							}
							time_t currentTime; struct tm* localTime; char buffer[80];
							time(&currentTime); localTime = localtime(&currentTime);
							int Mon = localTime->tm_mon + 1; int Day = localTime->tm_mday; int Hour = localTime->tm_hour; int Min = localTime->tm_min; int Sec = localTime->tm_sec;
							std::string tolog = " You added " + items[id].name + " to your Marketplace for " + to_string(price) + " " + items[payment_id].name + " `wat " + to_string(Hour) + ":" + to_string(Min) + " on " + to_string(Mon) + "/" + to_string(Day);
							currentLogs.push_back(tolog);
							j["logs"] = currentLogs;
							j["newLogs"] = j["newLogs"].get<double>() + 1;
							std::ofstream oo("database/players/market/" + pInfo(peer)->tankIDName + "_.json");
							if (!oo.is_open()) break;
							oo << j << std::endl;
							if (Inventory::Modify(peer, id, additem = -count) == 0) {
								VarList::OnTextOverlay(peer, "`2Successfully placed on sale!");
								market::dialog::enter_my_market(peer);
								arYraLaisvu = true;
								break;
							}
						}
					}
					if (arYraLaisvu == false) {
						VarList::OnDialogRequest(peer, market::rtrn::add("`wYou don't have enough space in your market to put this item! Please buy an upgrade.", to_string(id), market_item_count, market_item_price));
						return;
					}
				}
				catch (exception&) {
					return;
				}
			}
		}
	}
	static void Account_Security(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "my_account" or button == "Nevermind") DialogHandle::Acc_Security(peer, "my_account");
			if (button == "my_password") DialogHandle::Acc_Security(peer, "my_password");
			if (button == "my_email") DialogHandle::Acc_Security(peer, "my_email");
			if (button == "Security_Acc") {
				if (not pInfo(peer)->AccountSecured) {
					VarList::OnDialogRequest(peer, "set_default_color|\nadd_label|big|`wAdvanced Account Protection|left|\nadd_smalltext|`oYou are about to enable the Advanced Account Protection. After that, System AAP will ask your pin when login in new device, your pin can be a only Numbers, This will significantly increase your account Security.|left|\nadd_text_input|verificationcode|`5Enter New Pin:``||4|\nadd_button|my_account|`wBack|0|0|\nadd_custom_button|Submit_Fa2|textLabel:`wSubmit;anchor:_button_my_account;left:1;margin:40,0;|\nend_dialog|Account_Security|||");
				}
				else {
					pInfo(peer)->fa2 = 0;
					pInfo(peer)->AccountSecured = false;
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Security Account has `4DISABLED");
				}
			}
			if (button == "Submit_Fa2") {
				std::string code = parser.get("verificationcode", 1);
				if (code.size() >= 4 and is_number(code)) {
					if (not pInfo(peer)->AccountSecured) {
						pInfo(peer)->fa2 = atoi(code.c_str());
						pInfo(peer)->AccountSecured = true;
						pInfo(peer)->fa_ip = pInfo(peer)->ip;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Security Account has `2ENABLED");
					}
				}
				else {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "There was an error in your 2FA Code.");
				}
			}
			if (button == "Change_Email") {
				std::string change = parser.get("change", 1);
				if (change.empty()) VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`0Account Security``|left|1424|\nadd_spacer|small|\nadd_textbox|`6Information``|left|\nadd_smalltext|Having an up-to-date email address attached to your account is a great step toward improved account security.|left|\nadd_smalltext|Email: `5" + pInfo(peer)->email + "``|left|\nadd_spacer|small|\nadd_smalltext|Type your new `5email address``|left|\nadd_text_input|change|||50|\nadd_spacer|small|\nadd_custom_button|Nevermind|textLabel:`wNevermind;middle_colour:2415764;border_colour:2415764;|\nadd_custom_button|Change_Email|textLabel:`wApply Changes;anchor:_button_Nevermind;left:1;margin:60,0;middle_colour:434431310;border_colour:434438350;|\nend_dialog|Account_Security|||\n");
				else {
					pInfo(peer)->email = change;
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`0Account Security``|left|1424|\nadd_spacer|small|\nadd_textbox|`6Information``|left|\nadd_smalltext|Having an up-to-date email address attached to your account is a great step toward improved account security.|left|\nadd_smalltext|Your new Email: `5" + pInfo(peer)->email + "``|left|\nadd_spacer|small|\nend_dialog||OK||\n");
				}
				if (pInfo(peer)->starglitter_email == 0) DailyEvent_Task::MStarglitter(peer, "email", 1);
			}
			if (button == "Change_Password") {
				std::string change = parser.get("change", 1);
				if (change.empty()) VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`0Account Security``|left|1424|\nadd_spacer|small|\nadd_textbox|`6Information``|left|\nadd_smalltext|A hacker may attempt to access your account more than once over a period of time.|left|\nadd_smalltext|Changing your password `2often reduces the risk that they will have frequent access``.|left|\nadd_spacer|small|\nadd_smalltext|Type your new `5password``|left|\nadd_text_input|change|||18|\nadd_spacer|small|\nadd_custom_button|Nevermind|textLabel:`wNevermind;middle_colour:2415764;border_colour:2415764;|\nadd_custom_button|Change_Password|textLabel:`wApply Changes;anchor:_button_Nevermind;left:1;margin:60,0;middle_colour:434431310;border_colour:434438350;|\nend_dialog|Account_Security|||\n");
				else {
					VarList::SetHasGrowID(peer, 1, pInfo(peer)->tankIDName, pInfo(peer)->tankIDPass = change);
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`0Account Security``|left|1424|\nadd_spacer|small|\nadd_textbox|`6Information``|left|\nadd_smalltext|A hacker may attempt to access your account more than once over a period of time.|left|\nadd_smalltext|Changing your password `2often reduces the risk that they will have frequent access``.|left|\nadd_smalltext|Your new password: `5" + pInfo(peer)->tankIDPass + "``|left|\nadd_spacer|small|\nend_dialog||OK||\n");
				}
			}
		}
	}
	static void Server_Info(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "backto_info") DialogHandle::Server_Info(peer);
			if (button == "privacy_policy") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label|big|`wPrivacy Policy|left|\nadd_spacer|small|\nadd_textbox|`o" + Environment()->server_name + " Assets Purchase - No Refund Policy|left|\nadd_spacer|small|\nadd_smalltext|`o1. All Transactions Final:|left|\nadd_smalltext|`oIn-Game and real-life currency purchases are non-refundable and irreversible.|left|\nadd_spacer|small|\nadd_smalltext|`o2. No Exceptions:|left|\nadd_smalltext|`oStrict policy applies to accidental purchases or changes of mind.|left|\nadd_spacer|small|\nadd_smalltext|`o3. Account Security:|left|\nadd_smalltext|`oPlayers are responsible for securing their accounts and any consequences resulting from unauthorized access.|left|\nadd_spacer|smal|\nadd_smalltext|`o4. Terms of service:|left|\nadd_smalltext|`oAdherence to the game's Terms of Service is mandatory; violations may lead to penalties.|left|\nadd_spacer|small|\nadd_smalltext|`o5. Limited Liability:|left|\nadd_smalltext|`o" + Environment()->server_name + " administration holds no responsibility for the loss of in-game assets due to player actions or external factors.|left|\nadd_spacer|small|\nadd_smalltext|`o- " + Environment()->server_name + " Administration Team|left|\nadd_spacer|small|\nadd_button|backto_info|`wBack|0|0|\nend_dialog|Server_Info|||\nadd_quick_exit|");
			if (button == "cc_program") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_image_button||interface/large/gui_social_banner1.rttex|bannerlayout|||\nadd_spacer|small|\nadd_smalltext|`$We are looking streamer to stream " + Environment()->server_name + ", if you asking what's the benefits for streaming " + Environment()->server_name + ", this list is the benefits:|left|\nadd_smalltext|`7   - Role `#@Moderator`` (PERMANENT)|left|\nadd_smalltext|`7   - Tiktok Badge (for Tiktok Creator) / Verifed Badge (for Youtuber Creator)|left|\nadd_smalltext|`7   - Your videos about this server and your TikTok account or YouTube channel will be displayed on the Community Hub board and also on our official website|left|\nadd_smalltext|`7   - You will get items needed for live needs from the Owner such as Custom Items and other rare items.|left|\nadd_smalltext|`7   - Custom Block & Awesome Item-O-Matic|left|\nadd_button_with_icon|||noflags,no_padding_x,|8148||\nadd_button_with_icon|||noflags,no_padding_x,|8150||\nadd_button_with_icon|||noflags,no_padding_x,|8152||\nadd_button_with_icon|||noflags,no_padding_x,|8154||\nadd_button_with_icon|||noflags,no_padding_x,|8156||\nadd_button_with_icon|||noflags,no_padding_x,|8158||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|\nadd_smalltext|`$The benefits will increase along with your performance|left|\nadd_smalltext|`5Requierements:|left|\nadd_smalltext|`7   - Your followers / Subscriber must up to 250 (Real Followers / Subscriber)|left|\nadd_smalltext|`7   - Your view must up to 100+ (Real View)|left|\nadd_smalltext|`7   - Daily stream for once every 1 day|left|\nadd_smalltext|`7   - The content is about " + Environment()->server_name + "|left|\nadd_spacer|small|\nadd_smalltext|`$Contact Helper or Owner to send your live stats and profile.|left|\nadd_spacer|small|\nadd_button|backto_info|`wBack|\nend_dialog|Server_Info|||\nadd_quick_exit|");
			if (button == "cmd_check") {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Commands|left|1366|\nadd_spacer|small|"
					"\nadd_textbox|`oVIP Commands:|left|"
					"\nadd_smalltext|`$/surgerystats /vhelp /v <chat> /rainbow /valentine /searchuser <name> /info <name> (shows inventory) /hidestatus (big name) /warp <world> /warpto <player name> /vsb <text>|left|"
					"\nadd_spacer|small|"
					"\nadd_textbox|`oMODERATOR Commands:|left|"
					"\nadd_smalltext|`$/warpto <name> /destructo /noclip /fixworld /searchuser <name> /summon <name> /freeze <name> /info <name> /p <id> /warp <name> /banworld /nuke <time> <reason> /mute <name> <time> <reason> /curse <name> <time> <reason> /unmute <name> /uncurse <name> /hide /radio2 /togglemods /skin /invis /copyset <name> /msb <text> /m <text> /magic /nohands /nobody /unequip /warn <name> <text> /toldt <DROP TRASH DIALOG> /eff <id> /pban <name>|left|"
					"\nadd_spacer|small|"
					"\nadd_textbox|`oADMINISTRATOR Commands:|left|"
					"\nadd_smalltext|`$/color <skin> /checkid <item> /find /nick <nick> /freezeall /ghost /fakeban <name> /fakewarn <name> /fl <country> /banall /1hit /pullall /dsummon /logs /setmag <count> /setmagseed <count> /scan <world/player> <item id>|left|"
					"\nadd_spacer|small|"
					"\nadd_textbox|`oDEVELOPER Commands:|left|"
					"\nadd_smalltext|`$/setvend <count> /clearvend /clearmag /clearmagseed /blacklist <name> /ggems <count> /glevel <count> /online /saveworld /spk <name> <text> /asb <text> /removedrop /spl (spawn public lava) /rpl (remove public lava) /growall /infoex <name> /banrid <name> /banip <name>|left|"
					"\nadd_spacer|small|"
					"\nadd_textbox|`oOWNER Commands:|left|"
					"\nadd_smalltext|`$/reset <name> /takeworld /osb <text> /unsafeedit <action> <radius> <item_id> /drop <id> <count> /weather <id> /clearworld /spawnevent /ggxp <count> /gtoken <count> /gseal <count> /reset_rolequest /verifycsn /removereqcsn /ipcheck <name>|left|"
					"\nadd_spacer|small|"
					"\nadd_button|backto_info|`wBack|\nend_dialog|Server_Info|||\nadd_quick_exit|");
			}
			if (button == "featured_server") {
				std::ifstream txt("database/text/featured.txt");
				std::stringstream buffer;
				buffer << txt.rdbuf();
				std::string dialog(buffer.str());
				VarList::OnDialogRequest(peer, SetColor(peer) + dialog);
			}
		}
	}
	static void VipDailyRewards(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = ""; bool has_ = false; int add = 0;
		if (parser.try_get("buttonClicked", button)) {
			if (pInfo(peer)->vip_claimed_daily) return;
			std::string name_ = pInfo(peer)->world;
			std::vector<World>::iterator pd = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (pd != worlds.end()) {
				World* world_ = &worlds[pd - worlds.begin()];
				world_->fresh_world = true;
				if (button == "claim_1") {
					if (not Has_Claimed::Vip_Daily(peer, 1) and pInfo(peer)->vip_day >= 1) {
						has_ = true;
						if (Inventory::Modify(peer, 6856, add = 1) != 0) {
							WorldDrop drop_block_{};
							drop_block_.id = 6856, drop_block_.count = 1, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
							VisualHandle::Drop(world_, drop_block_);
						}
					}
				}
				if (button == "claim_2") {
					if (not Has_Claimed::Vip_Daily(peer, 2) and pInfo(peer)->vip_day >= 2) {
						has_ = true;
						if (Inventory::Modify(peer, 10944, add = 1) != 0) {
							WorldDrop drop_block_{};
							drop_block_.id = 10944, drop_block_.count = 1, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
							VisualHandle::Drop(world_, drop_block_);
						}
					}
				}
				if (button == "claim_3") {
					if (not Has_Claimed::Vip_Daily(peer, 3) and pInfo(peer)->vip_day >= 3) {
						has_ = true;
						if (Inventory::Modify(peer, 14534, add = 100) != 0) {
							WorldDrop drop_block_{};
							drop_block_.id = 14534, drop_block_.count = 100, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
							VisualHandle::Drop(world_, drop_block_);
						}
					}
				}
				if (button == "claim_4") {
					if (not Has_Claimed::Vip_Daily(peer, 4) and pInfo(peer)->vip_day >= 4) {
						has_ = true;
						if (Inventory::Modify(peer, 5136, add = 5) != 0) {
							WorldDrop drop_block_{};
							drop_block_.id = 5136, drop_block_.count = 5, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
							VisualHandle::Drop(world_, drop_block_);
						}
					}
				}
				if (button == "claim_5") {
					if (not Has_Claimed::Vip_Daily(peer, 5) and pInfo(peer)->vip_day >= 5) {
						has_ = true;
						if (Inventory::Modify(peer, 1796, add = 1) != 0) {
							WorldDrop drop_block_{};
							drop_block_.id = 1796, drop_block_.count = 1, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
							VisualHandle::Drop(world_, drop_block_);
						}
					}
				}
				if (button == "claim_6") {
					if (not Has_Claimed::Vip_Daily(peer, 6) and pInfo(peer)->vip_day >= 6) {
						has_ = true;
						if (Inventory::Modify(peer, 14220, add = 1) != 0) {
							WorldDrop drop_block_{};
							drop_block_.id = 14220, drop_block_.count = 1, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
							VisualHandle::Drop(world_, drop_block_);
						}
					}
				}
				if (button == "claim_7") {
					if (not Has_Claimed::Vip_Daily(peer, 7) and pInfo(peer)->vip_day >= 7) {
						has_ = true;
						if (Inventory::Modify(peer, 10400, add = 1) != 0) {
							WorldDrop drop_block_{};
							drop_block_.id = 10400, drop_block_.count = 1, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
							VisualHandle::Drop(world_, drop_block_);
						}
					}
				}
			}
			if (has_) {
				pInfo(peer)->vip_daily.push_back(pInfo(peer)->vip_day);
				pInfo(peer)->vip_claimed_daily = true;
				VarList::OnAddNotification(peer, "You claimed your VIp Daily Rewards : DAY " + to_string(pInfo(peer)->vip_day) + "!", "interface/guide_arrow.rttex", "audio/piano_nice.wav.wav");
				PlayerMoving data_{};
				data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
				BYTE* raw = packPlayerMoving(&data_);
				send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				delete[] raw;
			}
		}
	}
	static void WinterFest_Calendar2022(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "goto_maindialog") {
				std::string rewards = "", name_ = pInfo(peer)->world;
				std::vector<World>::iterator pd = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (pd != worlds.end()) {
					World* world_ = &worlds[pd - worlds.begin()];
					world_->fresh_world = true;
					WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
					for (int i = 1; i < 26; i++) rewards += "\nadd_button_with_icon|calendarSystem_" + to_string(i) + "|`$Day " + to_string(i) + "``|" + (block_->shelf_1 >= i ? "noflags|6292" : "frame|" + a + (i == 15 || i == 25 ? "9202" : "10486")) + "||";
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`w" + items[pInfo(peer)->lastwrenchb].name + "``|left|" + to_string(pInfo(peer)->lastwrenchb) + "|\nadd_textbox|Tap on a button below to view the `2rewards`` available on that day.|left|\nadd_spacer|small|\ntext_scaling_string|Defibrillators|" + rewards + "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|\nadd_button|cancel|Close|noflags|0|0|\nend_dialog|wfcalendar_dailyrewards|||\nadd_quick_exit|");
				}
			}
			if (button.substr(0, 15) == "calendarSystem_") {
				int id = std::atoi(button.substr(15).c_str());
				std::string dialog = "", epic = "", rare = "", uncommon = "", common = "";
				std::vector<double> ids = Winter_Fest::Calendar_2022(id);
				std::vector<int> added_prizes;
				for (int i = 0; i < ids.size(); i++) {
					double rand_item = ids[i];
					int rarity_ = 0, count_ = 1, rand_item2 = (int)rand_item;
					for (int i_ = 0; i_ < ids.size(); i_++) if (rand_item == ids[i_]) rarity_++;
					if (to_string(rand_item).find(".") != std::string::npos) {
						std::string asd_ = explode(".", to_string(rand_item))[1];
						std::string s(1, asd_[0]);
						int c_ = std::atoi(s.c_str());
						if (c_ != 0) {
							if (asd_.size() == 2) {
								c_ /= 10;
							}
							count_ = c_;
						}
					}
					if (find(added_prizes.begin(), added_prizes.end(), rand_item2) == added_prizes.end()) {
						added_prizes.push_back(rand_item2);
						if (rarity_ == 1) epic += "\nadd_label_with_icon|small|`w" + items[rand_item2].ori_name + "" + (count_ > 1 ? " (x" + to_string(count_) + ")" : "") + "``|left|" + to_string(rand_item2) + "|";
						else if (rarity_ == 2) rare += "\nadd_label_with_icon|small|`w" + items[rand_item2].ori_name + "" + (count_ > 1 ? " (x" + to_string(count_) + ")" : "") + "``|left|" + to_string(rand_item2) + "|";
						else if (rarity_ == 3) uncommon += "\nadd_label_with_icon|small|`w" + items[rand_item2].ori_name + "" + (count_ > 1 ? " (x" + to_string(count_) + ")" : "") + "``|left|" + to_string(rand_item2) + "|";
						else if (rarity_ == 4) common += "\nadd_label_with_icon|small|`w" + items[rand_item2].ori_name + "" + (count_ > 1 ? " (x" + to_string(count_) + ")" : "") + "``|left|" + to_string(rand_item2) + "|";
					}
				}
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wDay " + to_string(id) + " Rewards``|left|12986|\nadd_spacer|small|\nadd_textbox|You have a chance of obtaining the following items:|left|\nadd_spacer|small|\nadd_textbox|`5Epic``|left|\n" + epic + "\nadd_spacer|small|\nadd_textbox|`1Rare``|left|\n" + rare + "\nadd_spacer|small|\nadd_textbox|`6Uncommon``|left|\n" + uncommon + "\nadd_spacer|small|\nadd_textbox|Common|left|\n" + common + "\nadd_spacer|small|\nadd_button|goto_maindialog|Thanks for the info!|0|0|\nend_dialog|WinterFest_Calendar2022|||\nadd_quick_exit|");
				return;
			}
		}
	}
	static void WinterFest_Calendar2023(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "goto_maindialog") {
				std::string rewards = "", name_ = pInfo(peer)->world;
				std::vector<World>::iterator pd = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (pd != worlds.end()) {
					World* world_ = &worlds[pd - worlds.begin()];
					world_->fresh_world = true;
					WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
					for (int i = 1; i < 26; i++) rewards += "\nadd_button_with_icon|calendarSystem_" + to_string(i) + "|`$Day " + to_string(i) + "``|" + (block_->shelf_1 >= i ? "noflags|6292" : "frame|" + a + (i == 15 || i == 25 ? "9202" : "10486")) + "||";
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`w" + items[pInfo(peer)->lastwrenchb].name + "``|left|" + to_string(pInfo(peer)->lastwrenchb) + "|\nadd_textbox|Tap on a button below to view the `2rewards`` available on that day.|left|\nadd_spacer|small|\ntext_scaling_string|Defibrillators|" + rewards + "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|\nadd_button|cancel|Close|noflags|0|0|\nend_dialog|WinterFest_Calendar2023|||\nadd_quick_exit|");
				}
			}
			if (button.substr(0, 15) == "calendarSystem_") {
				int id = std::atoi(button.substr(15).c_str());
				std::string dialog = "", epic = "", rare = "", uncommon = "", common = "";
				std::vector<double> ids = Winter_Fest::Calendar_2023(id);
				std::vector<int> added_prizes;
				for (int i = 0; i < ids.size(); i++) {
					double rand_item = ids[i];
					int rarity_ = 0, count_ = 1, rand_item2 = (int)rand_item;
					for (int i_ = 0; i_ < ids.size(); i_++) if (rand_item == ids[i_]) rarity_++;
					if (to_string(rand_item).find(".") != std::string::npos) {
						std::string asd_ = explode(".", to_string(rand_item))[1];
						std::string s(1, asd_[0]);
						int c_ = std::atoi(s.c_str());
						if (c_ != 0) {
							if (asd_.size() == 2) {
								c_ /= 10;
							}
							count_ = c_;
						}
					}
					if (find(added_prizes.begin(), added_prizes.end(), rand_item2) == added_prizes.end()) {
						added_prizes.push_back(rand_item2);
						if (rarity_ == 1) epic += "\nadd_label_with_icon|small|`w" + items[rand_item2].ori_name + "" + (count_ > 1 ? " (x" + to_string(count_) + ")" : "") + "``|left|" + to_string(rand_item2) + "|";
						else if (rarity_ == 2) rare += "\nadd_label_with_icon|small|`w" + items[rand_item2].ori_name + "" + (count_ > 1 ? " (x" + to_string(count_) + ")" : "") + "``|left|" + to_string(rand_item2) + "|";
						else if (rarity_ == 3) uncommon += "\nadd_label_with_icon|small|`w" + items[rand_item2].ori_name + "" + (count_ > 1 ? " (x" + to_string(count_) + ")" : "") + "``|left|" + to_string(rand_item2) + "|";
						else if (rarity_ == 4) common += "\nadd_label_with_icon|small|`w" + items[rand_item2].ori_name + "" + (count_ > 1 ? " (x" + to_string(count_) + ")" : "") + "``|left|" + to_string(rand_item2) + "|";
					}
				}
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wDay " + to_string(id) + " Rewards``|left|14138|\nadd_spacer|small|\nadd_textbox|You have a chance of obtaining the following items:|left|\nadd_spacer|small|\nadd_textbox|`5Epic``|left|\n" + epic + "\nadd_spacer|small|\nadd_textbox|`1Rare``|left|\n" + rare + "\nadd_spacer|small|\nadd_textbox|`6Uncommon``|left|\n" + uncommon + "\nadd_spacer|small|\nadd_textbox|Common|left|\n" + common + "\nadd_spacer|small|\nadd_button|goto_maindialog|Thanks for the info!|0|0|\nend_dialog|WinterFest_Calendar2023|||\nadd_quick_exit|");
				return;
			}
		}
	}
	static void WinterFest_Calendar2024(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "goto_maindialog") {
				std::string rewards = "", name_ = pInfo(peer)->world;
				std::vector<World>::iterator pd = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (pd != worlds.end()) {
					World* world_ = &worlds[pd - worlds.begin()];
					world_->fresh_world = true;
					WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
					for (int i = 1; i < 26; i++) rewards += "\nadd_button_with_icon|calendarSystem_" + to_string(i) + "|`$Day " + to_string(i) + "``|" + (block_->shelf_1 >= i ? "noflags|6292" : "frame|" + a + (i == 15 || i == 25 ? "9202" : "10486")) + "||";
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`w" + items[pInfo(peer)->lastwrenchb].name + "``|left|" + to_string(pInfo(peer)->lastwrenchb) + "|\nadd_textbox|Tap on a button below to view the `2rewards`` available on that day.|left|\nadd_spacer|small|\ntext_scaling_string|Defibrillators|" + rewards + "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|\nadd_button|cancel|Close|noflags|0|0|\nend_dialog|WinterFest_Calendar2024|||\nadd_quick_exit|");
				}
			}
			if (button.substr(0, 15) == "calendarSystem_") {
				int id = std::atoi(button.substr(15).c_str());
				std::string dialog = "", epic = "", rare = "", uncommon = "", common = "";
				std::vector<double> ids = Winter_Fest::Calendar_2024(id);
				std::vector<int> added_prizes;
				for (int i = 0; i < ids.size(); i++) {
					double rand_item = ids[i];
					int rarity_ = 0, count_ = 1, rand_item2 = (int)rand_item;
					for (int i_ = 0; i_ < ids.size(); i_++) if (rand_item == ids[i_]) rarity_++;
					if (to_string(rand_item).find(".") != std::string::npos) {
						std::string asd_ = explode(".", to_string(rand_item))[1];
						std::string s(1, asd_[0]);
						int c_ = std::atoi(s.c_str());
						if (c_ != 0) {
							if (asd_.size() == 2) {
								c_ /= 10;
							}
							count_ = c_;
						}
					}
					if (find(added_prizes.begin(), added_prizes.end(), rand_item2) == added_prizes.end()) {
						added_prizes.push_back(rand_item2);
						if (rarity_ == 1) epic += "\nadd_label_with_icon|small|`w" + items[rand_item2].ori_name + "" + (count_ > 1 ? " (x" + to_string(count_) + ")" : "") + "``|left|" + to_string(rand_item2) + "|";
						else if (rarity_ == 2) rare += "\nadd_label_with_icon|small|`w" + items[rand_item2].ori_name + "" + (count_ > 1 ? " (x" + to_string(count_) + ")" : "") + "``|left|" + to_string(rand_item2) + "|";
						else if (rarity_ == 3) uncommon += "\nadd_label_with_icon|small|`w" + items[rand_item2].ori_name + "" + (count_ > 1 ? " (x" + to_string(count_) + ")" : "") + "``|left|" + to_string(rand_item2) + "|";
						else if (rarity_ == 4) common += "\nadd_label_with_icon|small|`w" + items[rand_item2].ori_name + "" + (count_ > 1 ? " (x" + to_string(count_) + ")" : "") + "``|left|" + to_string(rand_item2) + "|";
					}
				}
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wDay " + to_string(id) + " Rewards``|left|14138|\nadd_spacer|small|\nadd_textbox|You have a chance of obtaining the following items:|left|\nadd_spacer|small|\nadd_textbox|`5Epic``|left|\n" + epic + "\nadd_spacer|small|\nadd_textbox|`1Rare``|left|\n" + rare + "\nadd_spacer|small|\nadd_textbox|`6Uncommon``|left|\n" + uncommon + "\nadd_spacer|small|\nadd_textbox|Common|left|\n" + common + "\nadd_spacer|small|\nadd_button|goto_maindialog|Thanks for the info!|0|0|\nend_dialog|WinterFest_Calendar2024|||\nadd_quick_exit|");
				return;
			}
		}
	}
	static void zz(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "Seasonal_Clash") DialogHandle::Event_Leaderboard(peer, "Seasonal_Clash", 500);
			if (button == "Recycle_Lock") DialogHandle::Event_Leaderboard(peer, "Recycle_Lock", 500);
			if (button == "Punched") DialogHandle::Event_Leaderboard(peer, "Punched", 500);
			if (button == "Richest") DialogHandle::Event_Leaderboard(peer, "Richest", 500);
			if (button.substr(0, 8) == "warp_to_") {
				if (Playmods::HasById(pInfo(peer), 139)) {
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Hmm, you can't do that while cursed.", 0, 0);
					return;
				}
				std::string world_name = cch.substr(58, cch.length() - 60);
				Enter_World(peer, world_name);
			}
			if (button == "claim_event_guild") {
				if (pInfo(peer)->participated == event_item && pInfo(peer)->guild_id != 0) {
					auto it = std::find_if(top_guild_winners.begin(), top_guild_winners.end(), [&](const std::pair<int, std::string>& element) {
						return element.second == std::to_string(pInfo(peer)->guild_id); });
					if (it != top_guild_winners.end()) {
						uint32_t guild_id = pInfo(peer)->guild_id;
						std::string name = ""; int give_weather = 0, weat_id = 6280, tokens = 0, give_potion = 0, give_count = 1, give_medal = 0, place = it->first;
						if (place == 0) return;
						std::vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
						if (p != guilds.end()) {
							Guild* guild_information = &guilds[p - guilds.begin()];
							uint32_t my_rank = 0;
							for (GuildMember member_search : guild_information->guild_members) {
								if (member_search.member_name == pInfo(peer)->tankIDName) {
									my_rank = member_search.role_id;
								}
							}
							pInfo(peer)->participated = 0;
							vector<int> guild_potion{ 5942, 5940, 5938, 5936, 5934 };
							int random_potion = guild_potion[rand() % guild_potion.size()];
							int id_1 = 0, id_2 = 0, id_3 = 0;
							if (guild_event_type == "Spring Clash") {
								id_1 = 7974, id_2 = 7972, id_3 = 7970;
							}
							if (guild_event_type == "Summer Clash") {
								id_1 = 6138, id_2 = 6136, id_3 = 6134;
							}
							if (guild_event_type == "Winter Clash") {
								id_1 = 7340, id_2 = 7338, id_3 = 7336;
							}
							give_medal = (place == 1 ? id_1 : (place == 2 ? id_2 : (place == 3 ? id_3 : 0)));
							if (place == 1) {
								if (my_rank == 3) give_weather = 1, give_potion = 5, give_potion = 5;
								tokens = 800;
							}
							if (place == 2) {
								if (my_rank == 3) give_potion = 5;
								tokens = 640;
							}
							if (place == 3) {
								if (my_rank == 3) give_potion = 4;
								tokens = 560;
							}
							if (place == 4) {
								if (my_rank == 3) give_potion = 4;
								tokens = 480;
							}
							if (place == 5) {
								if (my_rank == 3) give_potion = 4;
								tokens = 400;
							}
							if (place > 5 and place <= 10) {
								if (my_rank == 3) give_potion = 3;
								tokens = 320;
							}
							if (place > 10 and place <= 20) {
								if (my_rank == 3) give_potion = 2;
								tokens = 290;
							}
							if (place > 20 and place <= 30) {
								if (my_rank == 3) give_potion = 2;
								tokens = 260;
							}
							if (place > 30 and place <= 40) {
								if (my_rank == 3) give_potion = 2;
								tokens = 240;
							}
							if (place > 40 and place <= 50) {
								if (my_rank == 3) give_potion = 2;
								tokens = 230;
							}
							if (place > 50 and place <= 75) {
								if (my_rank == 3) give_potion = 2;
								tokens = 210;
							}
							if (place > 75 and place <= 100) {
								if (my_rank == 3) give_potion = 1;
								tokens = 200;
							}
							if (place > 100 and place <= 200) tokens = 160;
							if (place > 200 and place <= 300) tokens = 100;
							if (place > 300 and place <= 400) tokens = 70;
							if (place > 400 and place <= 500) tokens = 40;
							if (give_weather != 0 and my_rank == 3) Inventory::Modify(peer, weat_id, give_weather);
							if (give_potion != 0 and my_rank == 3) Inventory::Modify(peer, random_potion, give_potion);
							if (give_medal != 0 and my_rank == 3) Inventory::Modify(peer, give_medal, give_count);
							if (guild_event_type == "Spring Clash") {
								name = "Spring Tokens";
								pInfo(peer)->spring_token += tokens;
							}
							if (guild_event_type == "Summer Clash") {
								name = "Summer Tokens";
								pInfo(peer)->summer_token += tokens;
							}
							if (guild_event_type == "Winter Clash") {
								name = "Winter Tokens";
								pInfo(peer)->winter_token += tokens;
							}
							VarList::OnConsoleMessage(peer, "`oYou received a " + a + (give_weather != 0 ? "Weather Machine - Guild, " : "") + (place == 1 or place == 2 or place == 3 ? items[give_medal].name + ", " : "") + (give_potion != 0 ? "a " + to_string(give_potion) + " " + items[random_potion].name + ", " : "") + "" + Set_Count(tokens) + " " + name + " as a reward for being Rank " + to_string(place) + " in the Guild Leaderboard!");
							VarList::OnAddNotification(peer, "You claimed your Guild Event reward!", "interface/guide_arrow.rttex", "audio/piano_nice.wav.wav");
							PlayerMoving data_{};
							data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
							BYTE* raw = packPlayerMoving(&data_);
							send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							delete[] raw;
						}
					}
				}
			}
			if (button == "claim_event_personal") {
				std::string find = pInfo(peer)->tankIDName;
				auto it = std::find_if(top_basher_winners.begin(), top_basher_winners.end(),
					[find](const std::pair<int, std::string>& element) { return element.second == find; });
				if (it != top_basher_winners.end()) {
					std::string name = it->second;
					int place = it->first, give_token = 0, give_medal = 0, give_count = 1, tokens = 0;
					if (place == 0) return;
					int id_1 = 0, id_2 = 0, id_3 = 0;
					if (guild_event_type == "Spring Clash") {
						id_1 = 7968, id_2 = 7966, id_3 = 7964;
					}
					if (guild_event_type == "Summer Clash") {
						id_1 = 6094, id_2 = 6132, id_3 = 6130;
					}
					if (guild_event_type == "Winter Clash") {
						id_1 = 7334, id_2 = 7332, id_3 = 7330;
					}
					if (place <= 100) give_token = 1;
					give_medal = (place == 1 ? id_1 : (place == 2 ? id_2 : (place == 3 ? id_3 : 0)));
					if (place == 1) tokens = 900;
					if (place == 2) tokens = 720;
					if (place == 3) tokens = 630;
					if (place == 4) tokens = 540;
					if (place == 5) tokens = 450;
					if (place > 5 and place <= 10) tokens = 360;
					if (place > 10 and place <= 20) tokens = 330;
					if (place > 20 and place <= 30) tokens = 300;
					if (place > 30 and place <= 40) tokens = 270;
					if (place > 40 and place <= 50) tokens = 260;
					if (place > 50 and place <= 75) tokens = 240;
					if (place > 75 and place <= 100) tokens = 230;
					if (place > 100 and place <= 200) tokens = 180;
					if (place > 200 and place <= 300) tokens = 120;
					if (place > 300 and place <= 400) tokens = 80;
					if (place > 400 and place <= 500) tokens = 50;
					add_peer_xp(peer, 1000);
					if (guild_event_type == "Spring Clash") {
						name = "Spring Tokens";
						pInfo(peer)->spring_token += tokens;
					}
					if (guild_event_type == "Summer Clash") {
						name = "Summer Tokens";
						pInfo(peer)->summer_token += tokens;
					}
					if (guild_event_type == "Winter Clash") {
						name = "Winter Tokens";
						pInfo(peer)->winter_token += tokens;
					}
					VarList::OnConsoleMessage(peer, "`6Daily Token Bonus Complete!\n`6Bonus: `o1,000 XP!");
					VarList::OnConsoleMessage(peer, "`oYou received a " + (place == 1 or place == 2 or place == 3 ? items[give_medal].name + ", " : "") + (place <= 100 ? "a Growtoken, " : "") + "" + Set_Count(tokens) + " " + name + " as a reward for being Rank " + to_string(place) + " in the Player Leaderboard!");
					VarList::OnAddNotification(peer, "You claimed your Personal Event reward!", "interface/guide_arrow.rttex", "audio/piano_nice.wav.wav");
					if (give_token != 0) {
						if (pInfo(peer)->lwiz_step == 6) add_lwiz_points(peer, give_token);
						Inventory::Modify(peer, 1486, give_token);
					}
					if (give_medal != 0) Inventory::Modify(peer, give_medal, give_count);
					PlayerMoving data_{};
					data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
					BYTE* raw = packPlayerMoving(&data_);
					send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					delete[] raw;
					top_basher_winners.erase(it);
					pInfo(peer)->participated_personal = true;
				}
			}
			if (button == "guild_event_rewards") {
				if (pInfo(peer)->guild_id == 0) {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Guild Event Rewards|left|6012|\nadd_textbox|`$Join a guild to access even more events prizes, work together with your friends to achieve awesome rewads!|left|\nend_dialog|backtoleader|Close|Back|\nadd_quick_exit|");
				}
				else {
					DialogHandle::Guild_Event_Rewards(peer);
				}
			}
			if (button == "personal_event_rewards") {
				DialogHandle::Personal_Event_Rewards(peer);
			}
			if (button == "limited_rewards") {
				DialogHandle::Limited_Clash(peer);
			}
			if (button == "event_clash_rewards") {
				if (guild_event_type == "Spring Clash") DialogHandle::Spring_Clash(peer);
				if (guild_event_type == "Summer Clash") DialogHandle::Summer_Clash(peer);
				if (guild_event_type == "Winter Clash") DialogHandle::Winter_Clash(peer);
			}
			if (button == "event_leaderboard") {
				bool has_ = false;
				if (top_basher.empty() && Event()->Can_Event) {
					auto it = std::find_if(last_guild_last.begin(), last_guild_last.end(), [&](const std::pair<long long int, std::string>& element) {
						return element.second == std::to_string(pInfo(peer)->guild_id); });
					if (it != last_guild_last.end() && it->first > 0) {
						has_ = true;
					}
				}
				else {
					auto it = std::find_if(top_guild.begin(), top_guild.end(), [&](const std::pair<long long int, std::string>& element) {
						return element.second == std::to_string(pInfo(peer)->guild_id); });
					if (it != top_guild.end() && it->first > 0) {
						has_ = true;
					}
				}
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Grow Event Leaderboards|left|6012|\nadd_button|personaleventleaderboard|`0Personal Event Leaderboard``|noflags|0|0|\nadd_button|personalleaderboardrewards|`0Personal Event Leaderboard Rewards|noflags|0|0|\nadd_button|guildeventleaderboard|`0Guild Event Leaderboard``|noflags|0|0|\nadd_button|guildleaderboardrewards|`0Guild Event Leaderboard Rewards``|noflags|0|0|" + (has_ ? "\nadd_button|guildmembercontribution|`0Guild Member Contribution``|noflags|0|0|" : "") + "\nend_dialog|backto_leaderboard|Close|Back|\nadd_quick_exit|");
			}
		}
	}
	static void backto_personalreward(ENetPeer* peer, std::string cch) {
		DialogHandle::Personal_Event_Rewards(peer);
	}
	static void backto_guildreward(ENetPeer* peer, std::string cch) {
		if (pInfo(peer)->guild_id == 0) {
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Guild Event Rewards|left|6012|\nadd_textbox|`$Join a guild to access even more events prizes, work together with your friends to achieve awesome rewads!|left|\nend_dialog|backtoleader|Close|Back|\nadd_quick_exit|");
		}
		else {
			DialogHandle::Guild_Event_Rewards(peer);
		}
	}
	static void backto_limitclashrewards(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button.substr(0, 9) == "buyitems_") {
				std::string type = button.substr(9);
				if (type == "1") {
					if (pInfo(peer)->Legendary_Keys >= 15 and not pInfo(peer)->claim_limited_clash) {
						int itemid = 14586, got = 1;
						int free_slots = Inventory::Get_Slots(pInfo(peer));
						if (free_slots == 0) {
							VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
							return;
						}
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->Legendary_Keys -= 15;
							pInfo(peer)->claim_limited_clash = true;
							DialogHandle::Limited_Clash(peer);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Legendary Key", 0, 0);
				}
			}
		}
		else {
			DialogHandle::Limited_Clash(peer);
		}
	}
	static void backto_clashrewards(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button.substr(0, 9) == "buyitems_") {
				std::string type = button.substr(9);
				if (guild_event_type == "Spring Clash") {
					if (type == "1") {
						if (not pInfo(peer)->row1_items1_claim and pInfo(peer)->spring_token >= 200) {
							int itemid = 7934, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->spring_token -= 200;
								pInfo(peer)->row1_items1_claim = true;
								DialogHandle::Spring_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "2") {
						if (not pInfo(peer)->row1_items2_claim and pInfo(peer)->row1_items1_claim and pInfo(peer)->spring_token >= 400) {
							int itemid = 5202, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->spring_token -= 400;
								pInfo(peer)->row1_items2_claim = true;
								DialogHandle::Spring_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "3") {
						if (not pInfo(peer)->row1_items3_claim and pInfo(peer)->row1_items2_claim and pInfo(peer)->spring_token >= 600) {
							int itemid = 6286, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->spring_token -= 600;
								pInfo(peer)->row1_items3_claim = true;
								DialogHandle::Spring_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "4") {
						if (not pInfo(peer)->row1_items4_claim and pInfo(peer)->row1_items3_claim and pInfo(peer)->spring_token >= 800) {
							int itemid = 7942, got = 10;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->spring_token -= 800;
								pInfo(peer)->row1_items4_claim = true;
								DialogHandle::Spring_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "5") {
						if (not pInfo(peer)->row1_items5_claim and pInfo(peer)->row1_items4_claim and pInfo(peer)->spring_token >= 1000) {
							int itemid = 7936, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->spring_token -= 1000;
								pInfo(peer)->row1_items5_claim = true;
								DialogHandle::Spring_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "6") {
						if (not pInfo(peer)->row1_items6_claim and pInfo(peer)->row1_items1_claim and pInfo(peer)->row1_items2_claim and pInfo(peer)->row1_items3_claim and pInfo(peer)->row1_items4_claim and pInfo(peer)->row1_items5_claim) {
							int itemid = 9220, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->Legendary_Keys += 1;
								pInfo(peer)->row1_items6_claim = true;
								DialogHandle::Spring_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
					}
					if (type == "7") {
						if (not pInfo(peer)->raw5_legendary_claim and pInfo(peer)->Legendary_Keys >= 10) {
							int itemid = 14414, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->Legendary_Keys -= 10;
								pInfo(peer)->raw5_legendary_claim = true;
								DialogHandle::Spring_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Keys", 0, 0);
					}
				}
				if (guild_event_type == "Summer Clash") {
					if (type == "1") {
						if (not pInfo(peer)->row1_items1_claim and pInfo(peer)->summer_token >= 200) {
							int itemid = 6264, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->summer_token -= 200;
								pInfo(peer)->row1_items1_claim = true;
								DialogHandle::Summer_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "2") {
						if (not pInfo(peer)->row1_items2_claim and pInfo(peer)->row1_items1_claim and pInfo(peer)->summer_token >= 400) {
							int itemid = 5202, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->summer_token -= 400;
								pInfo(peer)->row1_items2_claim = true;
								DialogHandle::Summer_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "3") {
						if (not pInfo(peer)->row1_items3_claim and pInfo(peer)->row1_items2_claim and pInfo(peer)->summer_token >= 600) {
							int itemid = 6286, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->summer_token -= 600;
								pInfo(peer)->row1_items3_claim = true;
								DialogHandle::Summer_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "4") {
						if (not pInfo(peer)->row1_items4_claim and pInfo(peer)->row1_items3_claim and pInfo(peer)->summer_token >= 800) {
							int itemid = 6154, got = 10;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->summer_token -= 800;
								pInfo(peer)->row1_items4_claim = true;
								DialogHandle::Summer_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "5") {
						if (not pInfo(peer)->row1_items5_claim and pInfo(peer)->row1_items4_claim and pInfo(peer)->summer_token >= 1000) {
							int itemid = 6266, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->summer_token -= 1000;
								pInfo(peer)->row1_items5_claim = true;
								DialogHandle::Summer_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "6") {
						if (not pInfo(peer)->row1_items6_claim and pInfo(peer)->row1_items1_claim and pInfo(peer)->row1_items2_claim and pInfo(peer)->row1_items3_claim and pInfo(peer)->row1_items4_claim and pInfo(peer)->row1_items5_claim) {
							int itemid = 8774, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->Legendary_Keys += 1;
								pInfo(peer)->row1_items6_claim = true;
								DialogHandle::Summer_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
					}
					if (type == "7") {
						if (not pInfo(peer)->raw5_legendary_claim and pInfo(peer)->Legendary_Keys >= 10) {
							int itemid = 14414, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->Legendary_Keys -= 10;
								pInfo(peer)->raw5_legendary_claim = true;
								DialogHandle::Summer_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Keys", 0, 0);
					}
				}
				if (guild_event_type == "Winter Clash") {
					if (type == "1") {
						if (not pInfo(peer)->row1_items1_claim and pInfo(peer)->winter_token >= 200) {
							int itemid = 7198, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->winter_token -= 200;
								pInfo(peer)->row1_items1_claim = true;
								DialogHandle::Winter_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "2") {
						if (not pInfo(peer)->row1_items2_claim and pInfo(peer)->row1_items1_claim and pInfo(peer)->winter_token >= 400) {
							int itemid = 5202, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->winter_token -= 400;
								pInfo(peer)->row1_items2_claim = true;
								DialogHandle::Winter_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "3") {
						if (not pInfo(peer)->row1_items3_claim and pInfo(peer)->row1_items2_claim and pInfo(peer)->winter_token >= 600) {
							int itemid = 6286, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->winter_token -= 600;
								pInfo(peer)->row1_items3_claim = true;
								DialogHandle::Winter_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "4") {
						if (not pInfo(peer)->row1_items4_claim and pInfo(peer)->row1_items3_claim and pInfo(peer)->winter_token >= 800) {
							int itemid = 7202, got = 10;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->winter_token -= 800;
								pInfo(peer)->row1_items4_claim = true;
								DialogHandle::Winter_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "5") {
						if (not pInfo(peer)->row1_items5_claim and pInfo(peer)->row1_items4_claim and pInfo(peer)->winter_token >= 1000) {
							int itemid = 7200, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->winter_token -= 1000;
								pInfo(peer)->row1_items5_claim = true;
								DialogHandle::Winter_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "6") {
						if (not pInfo(peer)->row1_items6_claim and pInfo(peer)->row1_items1_claim and pInfo(peer)->row1_items2_claim and pInfo(peer)->row1_items3_claim and pInfo(peer)->row1_items4_claim and pInfo(peer)->row1_items5_claim) {
							int itemid = 9216, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->Legendary_Keys += 1;
								pInfo(peer)->row1_items6_claim = true;
								DialogHandle::Winter_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
					}
					if (type == "7") {
						if (not pInfo(peer)->raw5_legendary_claim and pInfo(peer)->Legendary_Keys >= 10) {
							int itemid = 14414, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->Legendary_Keys -= 10;
								pInfo(peer)->raw5_legendary_claim = true;
								DialogHandle::Winter_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Keys", 0, 0);
					}
				}
			}
			if (button.substr(0, 10) == "buy2items_") {
				std::string type = button.substr(10);
				if (guild_event_type == "Spring Clash") {
					if (type == "1") {
						if (not pInfo(peer)->row2_items1_claim and pInfo(peer)->spring_token >= 200) {
							int itemid = 7944, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->spring_token -= 200;
								pInfo(peer)->row2_items1_claim = true;
								DialogHandle::Spring_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "2") {
						if (not pInfo(peer)->row2_items2_claim and pInfo(peer)->row2_items1_claim and pInfo(peer)->spring_token >= 400) {
							int itemid = 5202, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->spring_token -= 400;
								pInfo(peer)->row2_items2_claim = true;
								DialogHandle::Spring_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "3") {
						if (not pInfo(peer)->row2_items3_claim and pInfo(peer)->row2_items2_claim and pInfo(peer)->spring_token >= 600) {
							int itemid = 6286, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->spring_token -= 600;
								pInfo(peer)->row2_items3_claim = true;
								DialogHandle::Spring_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "4") {
						if (not pInfo(peer)->row2_items4_claim and pInfo(peer)->row2_items3_claim and pInfo(peer)->spring_token >= 800) {
							int itemid = 7952, got = 10;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->spring_token -= 800;
								pInfo(peer)->row2_items4_claim = true;
								DialogHandle::Spring_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "5") {
						if (not pInfo(peer)->row2_items5_claim and pInfo(peer)->row2_items4_claim and pInfo(peer)->spring_token >= 1000) {
							int itemid = 7946, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->spring_token -= 1000;
								pInfo(peer)->row2_items5_claim = true;
								DialogHandle::Spring_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "6") {
						if (not pInfo(peer)->row2_items6_claim and pInfo(peer)->row2_items1_claim and pInfo(peer)->row2_items2_claim and pInfo(peer)->row2_items3_claim and pInfo(peer)->row2_items4_claim and pInfo(peer)->row2_items5_claim) {
							int itemid = 9220, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->Legendary_Keys += 1;
								pInfo(peer)->row2_items6_claim = true;
								DialogHandle::Spring_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
					}
				}
				if (guild_event_type == "Summer Clash") {
					if (type == "1") {
						if (not pInfo(peer)->row2_items1_claim and pInfo(peer)->summer_token >= 200) {
							int itemid = 6268, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->summer_token -= 200;
								pInfo(peer)->row2_items1_claim = true;
								DialogHandle::Summer_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "2") {
						if (not pInfo(peer)->row2_items2_claim and pInfo(peer)->row2_items1_claim and pInfo(peer)->summer_token >= 400) {
							int itemid = 5202, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->summer_token -= 400;
								pInfo(peer)->row2_items2_claim = true;
								DialogHandle::Summer_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "3") {
						if (not pInfo(peer)->row2_items3_claim and pInfo(peer)->row2_items2_claim and pInfo(peer)->summer_token >= 600) {
							int itemid = 6286, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->summer_token -= 600;
								pInfo(peer)->row2_items3_claim = true;
								DialogHandle::Summer_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "4") {
						if (not pInfo(peer)->row2_items4_claim and pInfo(peer)->row2_items3_claim and pInfo(peer)->summer_token >= 800) {
							int itemid = 6156, got = 10;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->summer_token -= 800;
								pInfo(peer)->row2_items4_claim = true;
								DialogHandle::Summer_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "5") {
						if (not pInfo(peer)->row2_items5_claim and pInfo(peer)->row2_items4_claim and pInfo(peer)->summer_token >= 1000) {
							int itemid = 6270, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->summer_token -= 1000;
								pInfo(peer)->row2_items5_claim = true;
								DialogHandle::Summer_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "6") {
						if (not pInfo(peer)->row2_items6_claim and pInfo(peer)->row2_items1_claim and pInfo(peer)->row2_items2_claim and pInfo(peer)->row2_items3_claim and pInfo(peer)->row2_items4_claim and pInfo(peer)->row2_items5_claim) {
							int itemid = 8774, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->Legendary_Keys += 1;
								pInfo(peer)->row2_items6_claim = true;
								DialogHandle::Summer_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
					}
				}
				if (guild_event_type == "Winter Clash") {
					if (type == "1") {
						if (not pInfo(peer)->row2_items1_claim and pInfo(peer)->winter_token >= 200) {
							int itemid = 7208, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->winter_token -= 200;
								pInfo(peer)->row2_items1_claim = true;
								DialogHandle::Winter_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "2") {
						if (not pInfo(peer)->row2_items2_claim and pInfo(peer)->row2_items1_claim and pInfo(peer)->winter_token >= 400) {
							int itemid = 5202, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->winter_token -= 400;
								pInfo(peer)->row2_items2_claim = true;
								DialogHandle::Winter_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "3") {
						if (not pInfo(peer)->row2_items3_claim and pInfo(peer)->row2_items2_claim and pInfo(peer)->winter_token >= 600) {
							int itemid = 6286, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->winter_token -= 600;
								pInfo(peer)->row2_items3_claim = true;
								DialogHandle::Winter_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "4") {
						if (not pInfo(peer)->row2_items4_claim and pInfo(peer)->row2_items3_claim and pInfo(peer)->winter_token >= 800) {
							int itemid = 7212, got = 10;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->winter_token -= 800;
								pInfo(peer)->row2_items4_claim = true;
								DialogHandle::Winter_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "5") {
						if (not pInfo(peer)->row2_items5_claim and pInfo(peer)->row2_items4_claim and pInfo(peer)->winter_token >= 1000) {
							int itemid = 7210, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->winter_token -= 1000;
								pInfo(peer)->row2_items5_claim = true;
								DialogHandle::Winter_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "6") {
						if (not pInfo(peer)->row2_items6_claim and pInfo(peer)->row2_items1_claim and pInfo(peer)->row2_items2_claim and pInfo(peer)->row2_items3_claim and pInfo(peer)->row2_items4_claim and pInfo(peer)->row2_items5_claim) {
							int itemid = 9216, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->Legendary_Keys += 1;
								pInfo(peer)->row2_items6_claim = true;
								DialogHandle::Winter_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
					}
				}
			}
			if (button.substr(0, 10) == "buy3items_") {
				std::string type = button.substr(10);
				if (guild_event_type == "Spring Clash") {
					if (type == "1") {
						if (not pInfo(peer)->row3_items1_claim and pInfo(peer)->spring_token >= 200) {
							int itemid = 8014, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->spring_token -= 200;
								pInfo(peer)->row3_items1_claim = true;
								DialogHandle::Spring_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "2") {
						if (not pInfo(peer)->row3_items2_claim and pInfo(peer)->row3_items1_claim and pInfo(peer)->spring_token >= 400) {
							int itemid = 5202, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->spring_token -= 400;
								pInfo(peer)->row3_items2_claim = true;
								DialogHandle::Spring_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "3") {
						if (not pInfo(peer)->row3_items3_claim and pInfo(peer)->row3_items2_claim and pInfo(peer)->spring_token >= 600) {
							int itemid = 6286, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->spring_token -= 600;
								pInfo(peer)->row3_items3_claim = true;
								DialogHandle::Spring_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "4") {
						if (not pInfo(peer)->row3_items4_claim and pInfo(peer)->row3_items3_claim and pInfo(peer)->spring_token >= 800) {
							int itemid = 8020, got = 10;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->spring_token -= 800;
								pInfo(peer)->row3_items4_claim = true;
								DialogHandle::Spring_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "5") {
						if (not pInfo(peer)->row3_items5_claim and pInfo(peer)->row3_items4_claim and pInfo(peer)->spring_token >= 1000) {
							int itemid = 8016, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->spring_token -= 1000;
								pInfo(peer)->row3_items5_claim = true;
								DialogHandle::Spring_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "6") {
						if (not pInfo(peer)->row3_items6_claim and pInfo(peer)->row3_items1_claim and pInfo(peer)->row3_items2_claim and pInfo(peer)->row3_items3_claim and pInfo(peer)->row3_items4_claim and pInfo(peer)->row3_items5_claim) {
							int itemid = 9220, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->Legendary_Keys += 1;
								pInfo(peer)->row3_items6_claim = true;
								DialogHandle::Spring_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
					}
				}
				if (guild_event_type == "Summer Clash") {
					if (type == "1") {
						if (not pInfo(peer)->row3_items1_claim and pInfo(peer)->summer_token >= 200) {
							int itemid = 6302, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->summer_token -= 200;
								pInfo(peer)->row3_items1_claim = true;
								DialogHandle::Summer_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "2") {
						if (not pInfo(peer)->row3_items2_claim and pInfo(peer)->row3_items1_claim and pInfo(peer)->summer_token >= 400) {
							int itemid = 5202, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->summer_token -= 400;
								pInfo(peer)->row3_items2_claim = true;
								DialogHandle::Summer_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "3") {
						if (not pInfo(peer)->row3_items3_claim and pInfo(peer)->row3_items2_claim and pInfo(peer)->summer_token >= 600) {
							int itemid = 6286, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->summer_token -= 600;
								pInfo(peer)->row3_items3_claim = true;
								DialogHandle::Summer_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "4") {
						if (not pInfo(peer)->row3_items4_claim and pInfo(peer)->row3_items3_claim and pInfo(peer)->summer_token >= 800) {
							int itemid = 6296, got = 10;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->summer_token -= 800;
								pInfo(peer)->row3_items4_claim = true;
								DialogHandle::Summer_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "5") {
						if (not pInfo(peer)->row3_items5_claim and pInfo(peer)->row3_items4_claim and pInfo(peer)->summer_token >= 1000) {
							int itemid = 6304, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->summer_token -= 1000;
								pInfo(peer)->row3_items5_claim = true;
								DialogHandle::Summer_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "6") {
						if (not pInfo(peer)->row3_items6_claim and pInfo(peer)->row3_items1_claim and pInfo(peer)->row3_items2_claim and pInfo(peer)->row3_items3_claim and pInfo(peer)->row3_items4_claim and pInfo(peer)->row3_items5_claim) {
							int itemid = 8774, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->Legendary_Keys += 1;
								pInfo(peer)->row3_items6_claim = true;
								DialogHandle::Summer_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
					}
				}
				if (guild_event_type == "Winter Clash") {
					if (type == "1") {
						if (not pInfo(peer)->row3_items1_claim and pInfo(peer)->winter_token >= 200) {
							int itemid = 7388, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->winter_token -= 200;
								pInfo(peer)->row3_items1_claim = true;
								DialogHandle::Winter_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "2") {
						if (not pInfo(peer)->row3_items2_claim and pInfo(peer)->row3_items1_claim and pInfo(peer)->winter_token >= 400) {
							int itemid = 5202, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->winter_token -= 400;
								pInfo(peer)->row3_items2_claim = true;
								DialogHandle::Winter_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "3") {
						if (not pInfo(peer)->row3_items3_claim and pInfo(peer)->row3_items2_claim and pInfo(peer)->winter_token >= 600) {
							int itemid = 6286, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->winter_token -= 600;
								pInfo(peer)->row3_items3_claim = true;
								DialogHandle::Winter_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "4") {
						if (not pInfo(peer)->row3_items4_claim and pInfo(peer)->row3_items3_claim and pInfo(peer)->winter_token >= 800) {
							int itemid = 7394, got = 10;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->winter_token -= 800;
								pInfo(peer)->row3_items4_claim = true;
								DialogHandle::Winter_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "5") {
						if (not pInfo(peer)->row3_items5_claim and pInfo(peer)->row3_items4_claim and pInfo(peer)->winter_token >= 1000) {
							int itemid = 7386, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->winter_token -= 1000;
								pInfo(peer)->row3_items5_claim = true;
								DialogHandle::Winter_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "6") {
						if (not pInfo(peer)->row3_items6_claim and pInfo(peer)->row3_items1_claim and pInfo(peer)->row3_items2_claim and pInfo(peer)->row3_items3_claim and pInfo(peer)->row3_items4_claim and pInfo(peer)->row3_items5_claim) {
							int itemid = 9216, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->Legendary_Keys += 1;
								pInfo(peer)->row3_items6_claim = true;
								DialogHandle::Winter_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
					}
				}
			}
			if (button.substr(0, 10) == "buy4items_") {
				std::string type = button.substr(10);
				if (guild_event_type == "Spring Clash") {
					if (type == "1") {
						if (not pInfo(peer)->row4_items1_claim and pInfo(peer)->spring_token >= 200) {
							int itemid = 8296, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->spring_token -= 200;
								pInfo(peer)->row4_items1_claim = true;
								DialogHandle::Spring_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "2") {
						if (not pInfo(peer)->row4_items2_claim and pInfo(peer)->row4_items1_claim and pInfo(peer)->spring_token >= 400) {
							int itemid = 5202, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->spring_token -= 400;
								pInfo(peer)->row4_items2_claim = true;
								DialogHandle::Spring_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "3") {
						if (not pInfo(peer)->row4_items3_claim and pInfo(peer)->row4_items2_claim and pInfo(peer)->spring_token >= 600) {
							int itemid = 6286, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->spring_token -= 600;
								pInfo(peer)->row4_items3_claim = true;
								DialogHandle::Spring_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "4") {
						if (not pInfo(peer)->row4_items4_claim and pInfo(peer)->row4_items3_claim and pInfo(peer)->spring_token >= 800) {
							int itemid = 8300, got = 10;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->spring_token -= 800;
								pInfo(peer)->row4_items4_claim = true;
								DialogHandle::Spring_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "5") {
						if (not pInfo(peer)->row4_items5_claim and pInfo(peer)->row4_items4_claim and pInfo(peer)->spring_token >= 1000) {
							int itemid = 8298, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->spring_token -= 1000;
								pInfo(peer)->row4_items5_claim = true;
								DialogHandle::Spring_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "6") {
						if (not pInfo(peer)->row4_items6_claim and pInfo(peer)->row4_items1_claim and pInfo(peer)->row4_items2_claim and pInfo(peer)->row4_items3_claim and pInfo(peer)->row4_items4_claim and pInfo(peer)->row4_items5_claim) {
							int itemid = 9220, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->Legendary_Keys += 1;
								pInfo(peer)->row4_items6_claim = true;
								DialogHandle::Spring_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
					}
				}
				if (guild_event_type == "Summer Clash") {
					if (type == "1") {
						if (not pInfo(peer)->row4_items1_claim and pInfo(peer)->summer_token >= 200) {
							int itemid = 6750, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->summer_token -= 200;
								pInfo(peer)->row4_items1_claim = true;
								DialogHandle::Summer_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "2") {
						if (not pInfo(peer)->row4_items2_claim and pInfo(peer)->row4_items1_claim and pInfo(peer)->summer_token >= 400) {
							int itemid = 5202, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->summer_token -= 400;
								pInfo(peer)->row4_items2_claim = true;
								DialogHandle::Summer_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "3") {
						if (not pInfo(peer)->row4_items3_claim and pInfo(peer)->row4_items2_claim and pInfo(peer)->summer_token >= 600) {
							int itemid = 6286, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->summer_token -= 600;
								pInfo(peer)->row4_items3_claim = true;
								DialogHandle::Summer_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "4") {
						if (not pInfo(peer)->row4_items4_claim and pInfo(peer)->row4_items3_claim and pInfo(peer)->summer_token >= 800) {
							int itemid = 6772, got = 10;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->summer_token -= 800;
								pInfo(peer)->row4_items4_claim = true;
								DialogHandle::Summer_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "5") {
						if (not pInfo(peer)->row4_items5_claim and pInfo(peer)->row4_items4_claim and pInfo(peer)->summer_token >= 1000) {
							int itemid = 6752, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->summer_token -= 1000;
								pInfo(peer)->row4_items5_claim = true;
								DialogHandle::Summer_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "6") {
						if (not pInfo(peer)->row4_items6_claim and pInfo(peer)->row4_items1_claim and pInfo(peer)->row4_items2_claim and pInfo(peer)->row4_items3_claim and pInfo(peer)->row4_items4_claim and pInfo(peer)->row4_items5_claim) {
							int itemid = 8774, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->Legendary_Keys += 1;
								pInfo(peer)->row4_items6_claim = true;
								DialogHandle::Summer_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
					}
				}
				if (guild_event_type == "Winter Clash") {
					if (type == "1") {
						if (not pInfo(peer)->row4_items1_claim and pInfo(peer)->winter_token >= 200) {
							int itemid = 7576, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->winter_token -= 200;
								pInfo(peer)->row4_items1_claim = true;
								DialogHandle::Winter_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "2") {
						if (not pInfo(peer)->row4_items2_claim and pInfo(peer)->row4_items1_claim and pInfo(peer)->winter_token >= 400) {
							int itemid = 5202, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->winter_token -= 400;
								pInfo(peer)->row4_items2_claim = true;
								DialogHandle::Winter_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "3") {
						if (not pInfo(peer)->row4_items3_claim and pInfo(peer)->row4_items2_claim and pInfo(peer)->winter_token >= 600) {
							int itemid = 6286, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->winter_token -= 600;
								pInfo(peer)->row4_items3_claim = true;
								DialogHandle::Winter_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "4") {
						if (not pInfo(peer)->row4_items4_claim and pInfo(peer)->row4_items3_claim and pInfo(peer)->winter_token >= 800) {
							int itemid = 7580, got = 10;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->winter_token -= 800;
								pInfo(peer)->row4_items4_claim = true;
								DialogHandle::Winter_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "5") {
						if (not pInfo(peer)->row4_items5_claim and pInfo(peer)->row4_items4_claim and pInfo(peer)->winter_token >= 1000) {
							int itemid = 7578, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->winter_token -= 1000;
								pInfo(peer)->row4_items5_claim = true;
								DialogHandle::Winter_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough Tokens", 0, 0);
					}
					if (type == "6") {
						if (not pInfo(peer)->row4_items6_claim and pInfo(peer)->row4_items1_claim and pInfo(peer)->row4_items2_claim and pInfo(peer)->row4_items3_claim and pInfo(peer)->row4_items4_claim and pInfo(peer)->row4_items5_claim) {
							int itemid = 9216, got = 1;
							int free_slots = Inventory::Get_Slots(pInfo(peer));
							if (free_slots == 0) {
								VarList::OnConsoleMessage(peer, "You don't have room in your backpack!");
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have room in your backpack!", 0, 1);
								return;
							}
							if (Inventory::Modify(peer, itemid, got) == 0) {
								pInfo(peer)->Legendary_Keys += 1;
								pInfo(peer)->row4_items6_claim = true;
								DialogHandle::Winter_Clash(peer);
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your inventory", 0, 0);
						}
					}
				}
			}
		}
		else {
			if (guild_event_type == "Spring Clash") DialogHandle::Spring_Clash(peer);
			if (guild_event_type == "Summer Clash") DialogHandle::Summer_Clash(peer);
			if (guild_event_type == "Winter Clash") DialogHandle::Winter_Clash(peer);
		}
	}
	static void backtoleader(ENetPeer* peer, std::string cch) {
		VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Sorry, you need to be a member of a guild to access these rewards!``", 0, 1);
		DialogHandle::Event_Leaderboard(peer, "Seasonal_Clash", 500);
	}
	static void backto_leaderboard(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "back") DialogHandle::Event_Leaderboard(peer, "Seasonal_Clash", 500);
			if (button.substr(0, 14) == "claimperevent_") {
				std::string type = button.substr(14);
				int my_point = 0;
				if (Event()->Can_Event) {
					std::vector<std::pair<long long int, std::string>>::iterator pa = find_if(last_basher_list.begin(), last_basher_list.end(), [&](const pair < long long int, string>& element) { return element.second == pInfo(peer)->tankIDName; });
					if (pa != last_basher_list.end()) {
						my_point = last_basher_list[pa - last_basher_list.begin()].first;
					}
				}
				else {
					std::vector<std::pair<long long int, std::string>>::iterator p = find_if(top_basher.begin(), top_basher.end(), [&](const pair < long long int, string>& element) { return element.second == pInfo(peer)->tankIDName; });
					if (p != top_basher.end()) {
						my_point = top_basher[p - top_basher.begin()].first;
					}
				}
				if (guild_event_type == "Spring Clash") {
					if (type == "1") {
						if (my_point >= personal_t1 and not pInfo(peer)->claim_top1) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 5;
							pInfo(peer)->claim_top1 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t1) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$5 Spring Tokens|left|7844|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "2") {
						if (my_point >= personal_t2 and not pInfo(peer)->claim_top2) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 10;
							pInfo(peer)->claim_top2 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t2) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$10 Spring Tokens|left|7844|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "3") {
						if (my_point >= personal_t3 and not pInfo(peer)->claim_top3) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 15;
							pInfo(peer)->claim_top3 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t3) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$15 Spring Tokens|left|7844|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "4") {
						if (my_point >= personal_t4 and not pInfo(peer)->claim_top4) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 20;
							pInfo(peer)->claim_top4 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t4) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$20 Spring Tokens|left|7844|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "5") {
						if (my_point >= personal_t5 and not pInfo(peer)->claim_top5) {
							int random = rand() % items[7954].noob_item.size(), itemid = items[7954].noob_item[random].first, got = items[7954].noob_item[random].second;
							if (Inventory::Modify(peer, itemid, got) == 0) {
								VisualHandle::Trade(peer, 7844, 500);
								pInfo(peer)->spring_token += 25;
								pInfo(peer)->claim_top5 = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t5) + " Points!", 0, 1);
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$25 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$" + to_string(got) + " " + items[itemid].name + "|left|" + to_string(itemid) + "|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 1);
						}
					}
					if (type == "6") {
						if (my_point >= personal_t6 and not pInfo(peer)->claim_top6) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 25;
							pInfo(peer)->claim_top6 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t6) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$25 Spring Tokens|left|7844|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "7") {
						if (my_point >= personal_t7 and not pInfo(peer)->claim_top7) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 30;
							pInfo(peer)->claim_top7 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t7) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$30 Spring Tokens|left|7844|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "8") {
						if (my_point >= personal_t8 and not pInfo(peer)->claim_top8) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 35;
							pInfo(peer)->claim_top8 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t8) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$35 Spring Tokens|left|7844|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "9") {
						if (my_point >= personal_t9 and not pInfo(peer)->claim_top9) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 40;
							pInfo(peer)->claim_top9 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t9) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$40 Spring Tokens|left|7844|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "10") {
						if (my_point >= personal_t10 and not pInfo(peer)->claim_top10) {
							int random = rand() % items[7954].noob_item.size(), itemid = items[7954].noob_item[random].first, got = items[7954].noob_item[random].second;
							if (Inventory::Modify(peer, itemid, got) == 0) {
								VisualHandle::Trade(peer, 7844, 500);
								pInfo(peer)->spring_token += 50;
								pInfo(peer)->claim_top10 = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t10) + " Points!", 0, 1);
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$50 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$" + to_string(got) + " " + items[itemid].name + "|left|" + to_string(itemid) + "|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 1);
						}
					}
					if (type == "11") {
						if (my_point >= personal_t11 and not pInfo(peer)->claim_top11) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 60;
							pInfo(peer)->claim_top11 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t11) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$60 Spring Tokens|left|7844|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "12") {
						if (my_point >= personal_t12 and not pInfo(peer)->claim_top12) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 80;
							pInfo(peer)->claim_top12 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t12) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$80 Spring Tokens|left|7844|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "13") {
						if (my_point >= personal_t13 and not pInfo(peer)->claim_top13) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 100;
							pInfo(peer)->claim_top13 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t13) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$100 Spring Tokens|left|7844|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "14") {
						if (my_point >= personal_t14 and not pInfo(peer)->claim_top14) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 120;
							pInfo(peer)->claim_top14 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t14) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$120 Spring Tokens|left|7844|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "15") {
						if (my_point >= personal_t15 and not pInfo(peer)->claim_top15) {
							int random = rand() % items[7954].noob_item.size(), itemid = items[7954].noob_item[random].first, got = items[7954].noob_item[random].second;
							if (Inventory::Modify(peer, itemid, got) == 0) {
								VisualHandle::Trade(peer, 7844, 500);
								pInfo(peer)->spring_token += 150;
								pInfo(peer)->claim_top15 = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t15) + " Points!", 0, 1);
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$150 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$" + to_string(got) + " " + items[itemid].name + "|left|" + to_string(itemid) + "|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 1);
						}
					}
					if (type == "16") {
						if (my_point >= personal_t16 and not pInfo(peer)->claim_top16) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 180;
							pInfo(peer)->claim_top16 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t16) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$180 Spring Tokens|left|7844|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "17") {
						if (my_point >= personal_t17 and not pInfo(peer)->claim_top17) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 220;
							pInfo(peer)->claim_top17 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t17) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$220 Spring Tokens|left|7844|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "18") {
						if (my_point >= personal_t18 and not pInfo(peer)->claim_top18) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 250;
							pInfo(peer)->claim_top18 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t18) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$250 Spring Tokens|left|7844|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "19") {
						if (my_point >= personal_t19 and not pInfo(peer)->claim_top19) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 300;
							pInfo(peer)->claim_top19 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t19) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$300 Spring Tokens|left|7844|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "20") {
						if (my_point >= personal_t20 and not pInfo(peer)->claim_top20) {
							int random = rand() % items[7954].noob_item.size(), itemid = items[7954].noob_item[random].first, got = items[7954].noob_item[random].second;
							if (Inventory::Modify(peer, itemid, got) == 0) {
								VisualHandle::Trade(peer, 7844, 500);
								pInfo(peer)->spring_token += 400;
								pInfo(peer)->claim_top20 = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t20) + " Points!", 0, 1);
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$400 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$" + to_string(got) + " " + items[itemid].name + "|left|" + to_string(itemid) + "|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 1);
						}
					}
				}
				if (guild_event_type == "Summer Clash") {
					if (type == "1") {
						if (my_point >= personal_t1 and not pInfo(peer)->claim_top1) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 5;
							pInfo(peer)->claim_top1 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t1) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$5 Summer Tokens|left|6198|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "2") {
						if (my_point >= personal_t2 and not pInfo(peer)->claim_top2) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 10;
							pInfo(peer)->claim_top2 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t2) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$10 Summer Tokens|left|6198|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "3") {
						if (my_point >= personal_t3 and not pInfo(peer)->claim_top3) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 15;
							pInfo(peer)->claim_top3 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t3) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$15 Summer Tokens|left|6198|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "4") {
						if (my_point >= personal_t4 and not pInfo(peer)->claim_top4) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 20;
							pInfo(peer)->claim_top4 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t4) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$20 Summer Tokens|left|6198|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "5") {
						if (my_point >= personal_t5 and not pInfo(peer)->claim_top5) {
							int random = rand() % items[5948].noob_item.size(), itemid = items[5948].noob_item[random].first, got = items[5948].noob_item[random].second;
							if (Inventory::Modify(peer, itemid, got) == 0) {
								VisualHandle::Trade(peer, 6198, 500);
								pInfo(peer)->summer_token += 25;
								pInfo(peer)->claim_top5 = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t5) + " Points!", 0, 1);
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$25 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$" + to_string(got) + " " + items[itemid].name + "|left|" + to_string(itemid) + "|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 1);
						}
					}
					if (type == "6") {
						if (my_point >= personal_t6 and not pInfo(peer)->claim_top6) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 25;
							pInfo(peer)->claim_top6 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t6) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$25 Summer Tokens|left|6198|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "7") {
						if (my_point >= personal_t7 and not pInfo(peer)->claim_top7) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 30;
							pInfo(peer)->claim_top7 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t7) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$30 Summer Tokens|left|6198|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "8") {
						if (my_point >= personal_t8 and not pInfo(peer)->claim_top8) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 35;
							pInfo(peer)->claim_top8 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t8) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$35 Summer Tokens|left|6198|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "9") {
						if (my_point >= personal_t9 and not pInfo(peer)->claim_top9) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 40;
							pInfo(peer)->claim_top9 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t9) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$40 Summer Tokens|left|6198|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "10") {
						if (my_point >= personal_t10 and not pInfo(peer)->claim_top10) {
							int random = rand() % items[5948].noob_item.size(), itemid = items[5948].noob_item[random].first, got = items[5948].noob_item[random].second;
							if (Inventory::Modify(peer, itemid, got) == 0) {
								VisualHandle::Trade(peer, 6198, 500);
								pInfo(peer)->summer_token += 50;
								pInfo(peer)->claim_top10 = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t10) + " Points!", 0, 1);
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$50 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$" + to_string(got) + " " + items[itemid].name + "|left|" + to_string(itemid) + "|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 1);
						}
					}
					if (type == "11") {
						if (my_point >= personal_t11 and not pInfo(peer)->claim_top11) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 60;
							pInfo(peer)->claim_top11 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t11) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$60 Summer Tokens|left|6198|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "12") {
						if (my_point >= personal_t12 and not pInfo(peer)->claim_top12) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 80;
							pInfo(peer)->claim_top12 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t12) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$80 Summer Tokens|left|6198|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "13") {
						if (my_point >= personal_t13 and not pInfo(peer)->claim_top13) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 100;
							pInfo(peer)->claim_top13 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t13) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$100 Summer Tokens|left|6198|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "14") {
						if (my_point >= personal_t14 and not pInfo(peer)->claim_top14) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 120;
							pInfo(peer)->claim_top14 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t14) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$120 Summer Tokens|left|6198|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "15") {
						if (my_point >= personal_t15 and not pInfo(peer)->claim_top15) {
							int random = rand() % items[5948].noob_item.size(), itemid = items[5948].noob_item[random].first, got = items[5948].noob_item[random].second;
							if (Inventory::Modify(peer, itemid, got) == 0) {
								VisualHandle::Trade(peer, 6198, 500);
								pInfo(peer)->summer_token += 150;
								pInfo(peer)->claim_top15 = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t15) + " Points!", 0, 1);
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$150 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$" + to_string(got) + " " + items[itemid].name + "|left|" + to_string(itemid) + "|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 1);
						}
					}
					if (type == "16") {
						if (my_point >= personal_t16 and not pInfo(peer)->claim_top16) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 180;
							pInfo(peer)->claim_top16 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t16) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$180 Summer Tokens|left|6198|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "17") {
						if (my_point >= personal_t17 and not pInfo(peer)->claim_top17) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 220;
							pInfo(peer)->claim_top17 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t17) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$220 Summer Tokens|left|6198|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "18") {
						if (my_point >= personal_t18 and not pInfo(peer)->claim_top18) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 250;
							pInfo(peer)->claim_top18 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t18) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$250 Summer Tokens|left|6198|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "19") {
						if (my_point >= personal_t19 and not pInfo(peer)->claim_top19) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 300;
							pInfo(peer)->claim_top19 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t19) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$300 Summer Tokens|left|6198|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "20") {
						if (my_point >= personal_t20 and not pInfo(peer)->claim_top20) {
							int random = rand() % items[5948].noob_item.size(), itemid = items[5948].noob_item[random].first, got = items[5948].noob_item[random].second;
							if (Inventory::Modify(peer, itemid, got) == 0) {
								VisualHandle::Trade(peer, 6198, 500);
								pInfo(peer)->summer_token += 400;
								pInfo(peer)->claim_top20 = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t20) + " Points!", 0, 1);
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$400 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$" + to_string(got) + " " + items[itemid].name + "|left|" + to_string(itemid) + "|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 1);
						}
					}
				}
				if (guild_event_type == "Winter Clash") {
					if (type == "1") {
						if (my_point >= personal_t1 and not pInfo(peer)->claim_top1) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 5;
							pInfo(peer)->claim_top1 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t1) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$5 Winter Tokens|left|7328|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "2") {
						if (my_point >= personal_t2 and not pInfo(peer)->claim_top2) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 10;
							pInfo(peer)->claim_top2 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t2) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$10 Winter Tokens|left|7328|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "3") {
						if (my_point >= personal_t3 and not pInfo(peer)->claim_top3) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 15;
							pInfo(peer)->claim_top3 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t3) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$15 Winter Tokens|left|7328|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "4") {
						if (my_point >= personal_t4 and not pInfo(peer)->claim_top4) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 20;
							pInfo(peer)->claim_top4 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t4) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$20 Winter Tokens|left|7328|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "5") {
						if (my_point >= personal_t5 and not pInfo(peer)->claim_top5) {
							int random = rand() % items[7484].noob_item.size(), itemid = items[7484].noob_item[random].first, got = items[7484].noob_item[random].second;
							if (Inventory::Modify(peer, itemid, got) == 0) {
								VisualHandle::Trade(peer, 7328, 500);
								pInfo(peer)->winter_token += 25;
								pInfo(peer)->claim_top5 = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t5) + " Points!", 0, 1);
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$25 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$" + to_string(got) + " " + items[itemid].name + "|left|" + to_string(itemid) + "|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 1);
						}
					}
					if (type == "6") {
						if (my_point >= personal_t6 and not pInfo(peer)->claim_top6) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 25;
							pInfo(peer)->claim_top6 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t6) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$25 Winter Tokens|left|7328|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "7") {
						if (my_point >= personal_t7 and not pInfo(peer)->claim_top7) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 30;
							pInfo(peer)->claim_top7 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t7) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$30 Winter Tokens|left|7328|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "8") {
						if (my_point >= personal_t8 and not pInfo(peer)->claim_top8) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 35;
							pInfo(peer)->claim_top8 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t8) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$35 Winter Tokens|left|7328|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "9") {
						if (my_point >= personal_t9 and not pInfo(peer)->claim_top9) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 40;
							pInfo(peer)->claim_top9 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t9) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$40 Winter Tokens|left|7328|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "10") {
						if (my_point >= personal_t10 and not pInfo(peer)->claim_top10) {
							int random = rand() % items[7484].noob_item.size(), itemid = items[7484].noob_item[random].first, got = items[7484].noob_item[random].second;
							if (Inventory::Modify(peer, itemid, got) == 0) {
								VisualHandle::Trade(peer, 7328, 500);
								pInfo(peer)->winter_token += 50;
								pInfo(peer)->claim_top10 = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t10) + " Points!", 0, 1);
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$50 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$" + to_string(got) + " " + items[itemid].name + "|left|" + to_string(itemid) + "|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 1);
						}
					}
					if (type == "11") {
						if (my_point >= personal_t11 and not pInfo(peer)->claim_top11) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 60;
							pInfo(peer)->claim_top11 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t11) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$60 Winter Tokens|left|7328|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "12") {
						if (my_point >= personal_t12 and not pInfo(peer)->claim_top12) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 80;
							pInfo(peer)->claim_top12 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t12) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$80 Winter Tokens|left|7328|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "13") {
						if (my_point >= personal_t13 and not pInfo(peer)->claim_top13) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 100;
							pInfo(peer)->claim_top13 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t13) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$100 Winter Tokens|left|7328|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "14") {
						if (my_point >= personal_t14 and not pInfo(peer)->claim_top14) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 120;
							pInfo(peer)->claim_top14 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t14) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$120 Winter Tokens|left|7328|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "15") {
						if (my_point >= personal_t15 and not pInfo(peer)->claim_top15) {
							int random = rand() % items[7484].noob_item.size(), itemid = items[7484].noob_item[random].first, got = items[7484].noob_item[random].second;
							if (Inventory::Modify(peer, itemid, got) == 0) {
								VisualHandle::Trade(peer, 7328, 500);
								pInfo(peer)->winter_token += 150;
								pInfo(peer)->claim_top15 = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t15) + " Points!", 0, 1);
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$150 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$" + to_string(got) + " " + items[itemid].name + "|left|" + to_string(itemid) + "|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 1);
						}
					}
					if (type == "16") {
						if (my_point >= personal_t16 and not pInfo(peer)->claim_top16) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 180;
							pInfo(peer)->claim_top16 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t16) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$180 Winter Tokens|left|7328|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "17") {
						if (my_point >= personal_t17 and not pInfo(peer)->claim_top17) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 220;
							pInfo(peer)->claim_top17 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t17) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$220 Winter Tokens|left|7328|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "18") {
						if (my_point >= personal_t18 and not pInfo(peer)->claim_top18) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 250;
							pInfo(peer)->claim_top18 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t18) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$250 Winter Tokens|left|7328|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "19") {
						if (my_point >= personal_t19 and not pInfo(peer)->claim_top19) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 300;
							pInfo(peer)->claim_top19 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t19) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$300 Winter Tokens|left|7328|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "20") {
						if (my_point >= personal_t20 and not pInfo(peer)->claim_top20) {
							int random = rand() % items[7484].noob_item.size(), itemid = items[7484].noob_item[random].first, got = items[7484].noob_item[random].second;
							if (Inventory::Modify(peer, itemid, got) == 0) {
								VisualHandle::Trade(peer, 7328, 500);
								pInfo(peer)->winter_token += 400;
								pInfo(peer)->claim_top20 = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t20) + " Points!", 0, 1);
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$400 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$" + to_string(got) + " " + items[itemid].name + "|left|" + to_string(itemid) + "|\nend_dialog|backto_personalreward|Close|Ok|\nadd_quick_exit|");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 1);
						}
					}
				}
			}
			if (button == "claim_all_perevent") {
				int my_point = 0;
				if (Event()->Can_Event) {
					std::vector<std::pair<long long int, std::string>>::iterator pa = find_if(last_basher_list.begin(), last_basher_list.end(), [&](const pair < long long int, string>& element) { return element.second == pInfo(peer)->tankIDName; });
					if (pa != last_basher_list.end()) my_point = last_basher_list[pa - last_basher_list.begin()].first;
				}
				else {
					std::vector<std::pair<long long int, std::string>>::iterator p = find_if(top_basher.begin(), top_basher.end(), [&](const pair < long long int, string>& element) { return element.second == pInfo(peer)->tankIDName; });
					if (p != top_basher.end()) my_point = top_basher[p - top_basher.begin()].first;
				}
				if (guild_event_type == "Spring Clash") {
					if (my_point >= personal_t1 and not pInfo(peer)->claim_top1) {
						pInfo(peer)->spring_token += 5;
						pInfo(peer)->claim_top1 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t1) + " Points!", 0, 0);
					}
					if (my_point >= personal_t2 and not pInfo(peer)->claim_top2) {
						pInfo(peer)->spring_token += 10;
						pInfo(peer)->claim_top2 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t2) + " Points!", 0, 0);
					}
					if (my_point >= personal_t3 and not pInfo(peer)->claim_top3) {
						pInfo(peer)->spring_token += 15;
						pInfo(peer)->claim_top3 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t3) + " Points!", 0, 0);
					}
					if (my_point >= personal_t4 and not pInfo(peer)->claim_top4) {
						pInfo(peer)->spring_token += 20;
						pInfo(peer)->claim_top4 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t4) + " Points!", 0, 0);
					}
					if (my_point >= personal_t5 and not pInfo(peer)->claim_top5) {
						int random = rand() % items[7954].noob_item.size(), itemid = items[7954].noob_item[random].first, got = items[7954].noob_item[random].second;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->spring_token += 25;
							pInfo(peer)->claim_top5 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t5) + " Points!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 0);
					}
					if (my_point >= personal_t6 and not pInfo(peer)->claim_top6) {
						pInfo(peer)->spring_token += 25;
						pInfo(peer)->claim_top6 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t6) + " Points!", 0, 0);
					}
					if (my_point >= personal_t7 and not pInfo(peer)->claim_top7) {
						pInfo(peer)->spring_token += 30;
						pInfo(peer)->claim_top7 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t7) + " Points!", 0, 0);
					}
					if (my_point >= personal_t8 and not pInfo(peer)->claim_top8) {
						pInfo(peer)->spring_token += 35;
						pInfo(peer)->claim_top8 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t8) + " Points!", 0, 0);
					}
					if (my_point >= personal_t9 and not pInfo(peer)->claim_top9) {
						pInfo(peer)->spring_token += 40;
						pInfo(peer)->claim_top9 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t9) + " Points!", 0, 0);
					}
					if (my_point >= personal_t10 and not pInfo(peer)->claim_top10) {
						int random = rand() % items[7954].noob_item.size(), itemid = items[7954].noob_item[random].first, got = items[7954].noob_item[random].second;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->spring_token += 50;
							pInfo(peer)->claim_top10 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t10) + " Points!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 0);
					}
					if (my_point >= personal_t11 and not pInfo(peer)->claim_top11) {
						pInfo(peer)->spring_token += 60;
						pInfo(peer)->claim_top11 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t11) + " Points!", 0, 0);
					}
					if (my_point >= personal_t12 and not pInfo(peer)->claim_top12) {
						pInfo(peer)->spring_token += 80;
						pInfo(peer)->claim_top12 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t12) + " Points!", 0, 0);
					}
					if (my_point >= personal_t13 and not pInfo(peer)->claim_top13) {
						pInfo(peer)->spring_token += 100;
						pInfo(peer)->claim_top13 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t13) + " Points!", 0, 0);
					}
					if (my_point >= personal_t14 and not pInfo(peer)->claim_top14) {
						pInfo(peer)->spring_token += 120;
						pInfo(peer)->claim_top14 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t14) + " Points!", 0, 0);
					}
					if (my_point >= personal_t15 and not pInfo(peer)->claim_top15) {
						int random = rand() % items[7954].noob_item.size(), itemid = items[7954].noob_item[random].first, got = items[7954].noob_item[random].second;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->spring_token += 150;
							pInfo(peer)->claim_top15 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t15) + " Points!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 0);
					}
					if (my_point >= personal_t16 and not pInfo(peer)->claim_top16) {
						pInfo(peer)->spring_token += 180;
						pInfo(peer)->claim_top16 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t16) + " Points!", 0, 0);
					}
					if (my_point >= personal_t17 and not pInfo(peer)->claim_top17) {
						pInfo(peer)->spring_token += 220;
						pInfo(peer)->claim_top17 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t17) + " Points!", 0, 0);
					}
					if (my_point >= personal_t18 and not pInfo(peer)->claim_top18) {
						pInfo(peer)->spring_token += 250;
						pInfo(peer)->claim_top18 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t18) + " Points!", 0, 0);
					}
					if (my_point >= personal_t19 and not pInfo(peer)->claim_top19) {
						pInfo(peer)->spring_token += 300;
						pInfo(peer)->claim_top19 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t19) + " Points!", 0, 0);
					}
					if (my_point >= personal_t20 and not pInfo(peer)->claim_top20) {
						int random = rand() % items[7954].noob_item.size(), itemid = items[7954].noob_item[random].first, got = items[7954].noob_item[random].second;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->spring_token += 400;
							pInfo(peer)->claim_top20 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t20) + " Points!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 0);
					}
				}
				if (guild_event_type == "Summer Clash") {
					if (my_point >= personal_t1 and not pInfo(peer)->claim_top1) {
						pInfo(peer)->summer_token += 5;
						pInfo(peer)->claim_top1 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t1) + " Points!", 0, 0);
					}
					if (my_point >= personal_t2 and not pInfo(peer)->claim_top2) {
						pInfo(peer)->summer_token += 10;
						pInfo(peer)->claim_top2 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t2) + " Points!", 0, 0);
					}
					if (my_point >= personal_t3 and not pInfo(peer)->claim_top3) {
						pInfo(peer)->summer_token += 15;
						pInfo(peer)->claim_top3 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t3) + " Points!", 0, 0);
					}
					if (my_point >= personal_t4 and not pInfo(peer)->claim_top4) {
						pInfo(peer)->summer_token += 20;
						pInfo(peer)->claim_top4 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t4) + " Points!", 0, 0);
					}
					if (my_point >= personal_t5 and not pInfo(peer)->claim_top5) {
						int random = rand() % items[5948].noob_item.size(), itemid = items[5948].noob_item[random].first, got = items[5948].noob_item[random].second;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->summer_token += 25;
							pInfo(peer)->claim_top5 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t5) + " Points!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 0);
					}
					if (my_point >= personal_t6 and not pInfo(peer)->claim_top6) {
						pInfo(peer)->summer_token += 25;
						pInfo(peer)->claim_top6 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t6) + " Points!", 0, 0);
					}
					if (my_point >= personal_t7 and not pInfo(peer)->claim_top7) {
						pInfo(peer)->summer_token += 30;
						pInfo(peer)->claim_top7 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t7) + " Points!", 0, 0);
					}
					if (my_point >= personal_t8 and not pInfo(peer)->claim_top8) {
						pInfo(peer)->summer_token += 35;
						pInfo(peer)->claim_top8 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t8) + " Points!", 0, 0);
					}
					if (my_point >= personal_t9 and not pInfo(peer)->claim_top9) {
						pInfo(peer)->summer_token += 40;
						pInfo(peer)->claim_top9 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t9) + " Points!", 0, 0);
					}
					if (my_point >= personal_t10 and not pInfo(peer)->claim_top10) {
						int random = rand() % items[5948].noob_item.size(), itemid = items[5948].noob_item[random].first, got = items[5948].noob_item[random].second;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->summer_token += 50;
							pInfo(peer)->claim_top10 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t10) + " Points!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 0);
					}
					if (my_point >= personal_t11 and not pInfo(peer)->claim_top11) {
						pInfo(peer)->summer_token += 60;
						pInfo(peer)->claim_top11 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t11) + " Points!", 0, 0);
					}
					if (my_point >= personal_t12 and not pInfo(peer)->claim_top12) {
						pInfo(peer)->summer_token += 80;
						pInfo(peer)->claim_top12 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t12) + " Points!", 0, 0);
					}
					if (my_point >= personal_t13 and not pInfo(peer)->claim_top13) {
						pInfo(peer)->summer_token += 100;
						pInfo(peer)->claim_top13 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t13) + " Points!", 0, 0);
					}
					if (my_point >= personal_t14 and not pInfo(peer)->claim_top14) {
						pInfo(peer)->summer_token += 120;
						pInfo(peer)->claim_top14 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t14) + " Points!", 0, 0);
					}
					if (my_point >= personal_t15 and not pInfo(peer)->claim_top15) {
						int random = rand() % items[5948].noob_item.size(), itemid = items[5948].noob_item[random].first, got = items[5948].noob_item[random].second;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->summer_token += 150;
							pInfo(peer)->claim_top15 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t15) + " Points!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 0);
					}
					if (my_point >= personal_t16 and not pInfo(peer)->claim_top16) {
						pInfo(peer)->summer_token += 180;
						pInfo(peer)->claim_top16 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t16) + " Points!", 0, 0);
					}
					if (my_point >= personal_t17 and not pInfo(peer)->claim_top17) {
						pInfo(peer)->summer_token += 220;
						pInfo(peer)->claim_top17 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t17) + " Points!", 0, 0);
					}
					if (my_point >= personal_t18 and not pInfo(peer)->claim_top18) {
						pInfo(peer)->summer_token += 250;
						pInfo(peer)->claim_top18 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t18) + " Points!", 0, 0);
					}
					if (my_point >= personal_t19 and not pInfo(peer)->claim_top19) {
						pInfo(peer)->summer_token += 300;
						pInfo(peer)->claim_top19 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t19) + " Points!", 0, 0);
					}
					if (my_point >= personal_t20 and not pInfo(peer)->claim_top20) {
						int random = rand() % items[5948].noob_item.size(), itemid = items[5948].noob_item[random].first, got = items[5948].noob_item[random].second;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->summer_token += 400;
							pInfo(peer)->claim_top20 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t20) + " Points!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 0);
					}
				}
				if (guild_event_type == "Winter Clash") {
					if (my_point >= personal_t1 and not pInfo(peer)->claim_top1) {
						pInfo(peer)->winter_token += 5;
						pInfo(peer)->claim_top1 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t1) + " Points!", 0, 0);
					}
					if (my_point >= personal_t2 and not pInfo(peer)->claim_top2) {
						pInfo(peer)->winter_token += 10;
						pInfo(peer)->claim_top2 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t2) + " Points!", 0, 0);
					}
					if (my_point >= personal_t3 and not pInfo(peer)->claim_top3) {
						pInfo(peer)->winter_token += 15;
						pInfo(peer)->claim_top3 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t3) + " Points!", 0, 0);
					}
					if (my_point >= personal_t4 and not pInfo(peer)->claim_top4) {
						pInfo(peer)->winter_token += 20;
						pInfo(peer)->claim_top4 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t4) + " Points!", 0, 0);
					}
					if (my_point >= personal_t5 and not pInfo(peer)->claim_top5) {
						int random = rand() % items[7484].noob_item.size(), itemid = items[7484].noob_item[random].first, got = items[7484].noob_item[random].second;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->winter_token += 25;
							pInfo(peer)->claim_top5 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t5) + " Points!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 0);
					}
					if (my_point >= personal_t6 and not pInfo(peer)->claim_top6) {
						pInfo(peer)->winter_token += 25;
						pInfo(peer)->claim_top6 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t6) + " Points!", 0, 0);
					}
					if (my_point >= personal_t7 and not pInfo(peer)->claim_top7) {
						pInfo(peer)->winter_token += 30;
						pInfo(peer)->claim_top7 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t7) + " Points!", 0, 0);
					}
					if (my_point >= personal_t8 and not pInfo(peer)->claim_top8) {
						pInfo(peer)->winter_token += 35;
						pInfo(peer)->claim_top8 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t8) + " Points!", 0, 0);
					}
					if (my_point >= personal_t9 and not pInfo(peer)->claim_top9) {
						pInfo(peer)->winter_token += 40;
						pInfo(peer)->claim_top9 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t9) + " Points!", 0, 0);
					}
					if (my_point >= personal_t10 and not pInfo(peer)->claim_top10) {
						int random = rand() % items[7484].noob_item.size(), itemid = items[7484].noob_item[random].first, got = items[7484].noob_item[random].second;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->winter_token += 50;
							pInfo(peer)->claim_top10 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t10) + " Points!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 0);
					}
					if (my_point >= personal_t11 and not pInfo(peer)->claim_top11) {
						pInfo(peer)->winter_token += 60;
						pInfo(peer)->claim_top11 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t11) + " Points!", 0, 0);
					}
					if (my_point >= personal_t12 and not pInfo(peer)->claim_top12) {
						VisualHandle::Trade(peer, 7328, 500);
						pInfo(peer)->winter_token += 80;
						pInfo(peer)->claim_top12 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t12) + " Points!", 0, 0);
					}
					if (my_point >= personal_t13 and not pInfo(peer)->claim_top13) {
						pInfo(peer)->winter_token += 100;
						pInfo(peer)->claim_top13 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t13) + " Points!", 0, 0);
					}
					if (my_point >= personal_t14 and not pInfo(peer)->claim_top14) {
						pInfo(peer)->winter_token += 120;
						pInfo(peer)->claim_top14 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t14) + " Points!", 0, 0);
					}
					if (my_point >= personal_t15 and not pInfo(peer)->claim_top15) {
						int random = rand() % items[7484].noob_item.size(), itemid = items[7484].noob_item[random].first, got = items[7484].noob_item[random].second;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->winter_token += 150;
							pInfo(peer)->claim_top15 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t15) + " Points!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 0);
					}
					if (my_point >= personal_t16 and not pInfo(peer)->claim_top16) {
						pInfo(peer)->winter_token += 180;
						pInfo(peer)->claim_top16 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t16) + " Points!", 0, 0);
					}
					if (my_point >= personal_t17 and not pInfo(peer)->claim_top17) {
						pInfo(peer)->winter_token += 220;
						pInfo(peer)->claim_top17 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t17) + " Points!", 0, 0);
					}
					if (my_point >= personal_t18 and not pInfo(peer)->claim_top18) {
						pInfo(peer)->winter_token += 250;
						pInfo(peer)->claim_top18 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t18) + " Points!", 0, 0);
					}
					if (my_point >= personal_t19 and not pInfo(peer)->claim_top19) {
						pInfo(peer)->winter_token += 300;
						pInfo(peer)->claim_top19 = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t19) + " Points!", 0, 0);
					}
					if (my_point >= personal_t20 and not pInfo(peer)->claim_top20) {
						int random = rand() % items[7484].noob_item.size(), itemid = items[7484].noob_item[random].first, got = items[7484].noob_item[random].second;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->winter_token += 400;
							pInfo(peer)->claim_top20 = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(personal_t20) + " Points!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 0);
					}
				}
				DialogHandle::Personal_Event_Rewards(peer);
			}
			if (button.substr(0, 13) == "claimguevent_") {
				std::string type = button.substr(13);
				if (pInfo(peer)->guild_id == 0) return;
				int guild_point = 0;
				if (Event()->Can_Event) {
					auto it = std::find_if(last_guild_last.begin(), last_guild_last.end(), [&](const std::pair<long long int, std::string>& element) {
						return element.second == std::to_string(pInfo(peer)->guild_id);
						});
					if (it != last_guild_last.end()) {
						guild_point = it->first;
					}
				}
				else {
					auto it = std::find_if(top_guild.begin(), top_guild.end(), [&](const std::pair<long long int, std::string>& element) {
						return element.second == std::to_string(pInfo(peer)->guild_id);
						});
					if (it != top_guild.end()) {
						guild_point = it->first;
					}
				}
				if (guild_event_type == "Spring Clash") {
					if (type == "1") {
						if (guild_point >= guild_t1 and not pInfo(peer)->claim_top1g) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 3;
							pInfo(peer)->claim_top1g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t1) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$3 Spring Tokens|left|7844|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "2") {
						if (guild_point >= guild_t2 and not pInfo(peer)->claim_top2g) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 8;
							pInfo(peer)->claim_top2g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t2) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$8 Spring Tokens|left|7844|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "3") {
						if (guild_point >= guild_t3 and not pInfo(peer)->claim_top3g) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 12;
							pInfo(peer)->claim_top3g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t3) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$12 Spring Tokens|left|7844|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "4") {
						if (guild_point >= guild_t4 and not pInfo(peer)->claim_top4g) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 18;
							pInfo(peer)->claim_top4g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t4) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$18 Spring Tokens|left|7844|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "5") {
						if (guild_point >= guild_t5 and not pInfo(peer)->claim_top5g) {
							int random = rand() % items[7954].noob_item.size(), itemid = items[7954].noob_item[random].first, got = items[7954].noob_item[random].second;
							if (Inventory::Modify(peer, itemid, got) == 0) {
								VisualHandle::Trade(peer, 7844, 500);
								pInfo(peer)->spring_token += 22;
								pInfo(peer)->claim_top5g = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t5) + " Points!", 0, 1);
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$22 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$" + to_string(got) + " " + items[itemid].name + "|left|" + to_string(itemid) + "|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 1);
						}
					}
					if (type == "6") {
						if (guild_point >= guild_t6 and not pInfo(peer)->claim_top6g) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 25;
							pInfo(peer)->claim_top6g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t6) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$25 Spring Tokens|left|7844|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "7") {
						if (guild_point >= guild_t7 and not pInfo(peer)->claim_top7g) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 28;
							pInfo(peer)->claim_top7g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t7) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$28 Spring Tokens|left|7844|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "8") {
						if (guild_point >= guild_t8 and not pInfo(peer)->claim_top8g) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 30;
							pInfo(peer)->claim_top8g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t8) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$30 Spring Tokens|left|7844|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "9") {
						if (guild_point >= guild_t9 and not pInfo(peer)->claim_top9g) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 35;
							pInfo(peer)->claim_top9g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t9) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$35 Spring Tokens|left|7844|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "10") {
						if (guild_point >= guild_t10 and not pInfo(peer)->claim_top10g) {
							int random = rand() % items[7954].noob_item.size(), itemid = items[7954].noob_item[random].first, got = items[7954].noob_item[random].second;
							if (Inventory::Modify(peer, itemid, got) == 0) {
								VisualHandle::Trade(peer, 7844, 500);
								pInfo(peer)->spring_token += 40;
								pInfo(peer)->claim_top10g = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t10) + " Points!", 0, 1);
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$40 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$" + to_string(got) + " " + items[itemid].name + "|left|" + to_string(itemid) + "|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 1);
						}
					}
					if (type == "11") {
						if (guild_point >= guild_t11 and not pInfo(peer)->claim_top11g) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 50;
							pInfo(peer)->claim_top11g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t11) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$50 Spring Tokens|left|7844|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "12") {
						if (guild_point >= guild_t12 and not pInfo(peer)->claim_top12g) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 60;
							pInfo(peer)->claim_top12g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t12) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$60 Spring Tokens|left|7844|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "13") {
						if (guild_point >= guild_t13 and not pInfo(peer)->claim_top13g) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 75;
							pInfo(peer)->claim_top13g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t13) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$75 Spring Tokens|left|7844|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "14") {
						if (guild_point >= guild_t14 and not pInfo(peer)->claim_top14g) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 100;
							pInfo(peer)->claim_top14g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t14) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$100 Spring Tokens|left|7844|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "15") {
						if (guild_point >= guild_t15 and not pInfo(peer)->claim_top15g) {
							int random = rand() % items[7954].noob_item.size(), itemid = items[7954].noob_item[random].first, got = items[7954].noob_item[random].second;
							if (Inventory::Modify(peer, itemid, got) == 0) {
								VisualHandle::Trade(peer, 7844, 500);
								pInfo(peer)->spring_token += 125;
								pInfo(peer)->claim_top15g = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t15) + " Points!", 0, 1);
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$125 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$" + to_string(got) + " " + items[itemid].name + "|left|" + to_string(itemid) + "|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 1);
						}
					}
					if (type == "16") {
						if (guild_point >= guild_t16 and not pInfo(peer)->claim_top16g) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 150;
							pInfo(peer)->claim_top16g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t16) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$150 Spring Tokens|left|7844|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "17") {
						if (guild_point >= guild_t17 and not pInfo(peer)->claim_top17g) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 175;
							pInfo(peer)->claim_top17g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t17) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$175 Spring Tokens|left|7844|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "18") {
						if (guild_point >= guild_t18 and not pInfo(peer)->claim_top18g) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 200;
							pInfo(peer)->claim_top18g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t18) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$200 Spring Tokens|left|7844|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "19") {
						if (guild_point >= guild_t19 and not pInfo(peer)->claim_top19g) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 225;
							pInfo(peer)->claim_top19g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t19) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$225 Spring Tokens|left|7844|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "20") {
						if (guild_point >= guild_t20 and not pInfo(peer)->claim_top20g) {
							int random = rand() % items[7954].noob_item.size(), itemid = items[7954].noob_item[random].first, got = items[7954].noob_item[random].second;
							if (Inventory::Modify(peer, itemid, got) == 0) {
								VisualHandle::Trade(peer, 7844, 500);
								pInfo(peer)->spring_token += 275;
								pInfo(peer)->claim_top20g = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t20) + " Points!", 0, 1);
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$275 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$" + to_string(got) + " " + items[itemid].name + "|left|" + to_string(itemid) + "|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 1);
						}
					}
					if (type == "21") {
						if (guild_point >= guild_t21 and not pInfo(peer)->claim_top21g) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 400;
							pInfo(peer)->claim_top21g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t21) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$400 Spring Tokens|left|7844|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "22") {
						if (guild_point >= guild_t22 and not pInfo(peer)->claim_top22g) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 500;
							pInfo(peer)->claim_top22g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t22) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$500 Spring Tokens|left|7844|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "23") {
						if (guild_point >= guild_t23 and not pInfo(peer)->claim_top23g) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 750;
							pInfo(peer)->claim_top23g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t23) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$750 Spring Tokens|left|7844|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "24") {
						if (guild_point >= guild_t24 and not pInfo(peer)->claim_top24g) {
							VisualHandle::Trade(peer, 7844, 500);
							pInfo(peer)->spring_token += 1250;
							pInfo(peer)->claim_top24g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t24) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$1,250 Spring Tokens|left|7844|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "25") {
						if (guild_point >= guild_t25 and not pInfo(peer)->claim_top25g) {
							int random = rand() % items[7954].noob_item.size(), itemid = items[7954].noob_item[random].first, got = items[7954].noob_item[random].second;
							if (Inventory::Modify(peer, itemid, got) == 0) {
								VisualHandle::Trade(peer, 7844, 500);
								pInfo(peer)->spring_token += 1500;
								pInfo(peer)->claim_top25g = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t25) + " Points!", 0, 1);
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$1,500 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$" + to_string(got) + " " + items[itemid].name + "|left|" + to_string(itemid) + "|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 1);
						}
					}
				}
				if (guild_event_type == "Summer Clash") {
					if (type == "1") {
						if (guild_point >= guild_t1 and not pInfo(peer)->claim_top1g) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 3;
							pInfo(peer)->claim_top1g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t1) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$3 Summer Tokens|left|6198|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "2") {
						if (guild_point >= guild_t2 and not pInfo(peer)->claim_top2g) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 8;
							pInfo(peer)->claim_top2g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t2) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$8 Summer Tokens|left|6198|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "3") {
						if (guild_point >= guild_t3 and not pInfo(peer)->claim_top3g) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 12;
							pInfo(peer)->claim_top3g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t3) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$12 Summer Tokens|left|6198|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "4") {
						if (guild_point >= guild_t4 and not pInfo(peer)->claim_top4g) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 18;
							pInfo(peer)->claim_top4g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t4) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$18 Summer Tokens|left|6198|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "5") {
						if (guild_point >= guild_t5 and not pInfo(peer)->claim_top5g) {
							int random = rand() % items[5948].noob_item.size(), itemid = items[5948].noob_item[random].first, got = items[5948].noob_item[random].second;
							if (Inventory::Modify(peer, itemid, got) == 0) {
								VisualHandle::Trade(peer, 6198, 500);
								pInfo(peer)->summer_token += 22;
								pInfo(peer)->claim_top5g = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t5) + " Points!", 0, 1);
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$22 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$" + to_string(got) + " " + items[itemid].name + "|left|" + to_string(itemid) + "|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 1);
						}
					}
					if (type == "6") {
						if (guild_point >= guild_t6 and not pInfo(peer)->claim_top6g) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 25;
							pInfo(peer)->claim_top6g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t6) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$25 Summer Tokens|left|6198|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "7") {
						if (guild_point >= guild_t7 and not pInfo(peer)->claim_top7g) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 28;
							pInfo(peer)->claim_top7g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t7) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$28 Summer Tokens|left|6198|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "8") {
						if (guild_point >= guild_t8 and not pInfo(peer)->claim_top8g) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 30;
							pInfo(peer)->claim_top8g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t8) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$30 Summer Tokens|left|6198|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "9") {
						if (guild_point >= guild_t9 and not pInfo(peer)->claim_top9g) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 35;
							pInfo(peer)->claim_top9g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t9) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$35 Summer Tokens|left|6198|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "10") {
						if (guild_point >= guild_t10 and not pInfo(peer)->claim_top10g) {
							int random = rand() % items[5948].noob_item.size(), itemid = items[5948].noob_item[random].first, got = items[5948].noob_item[random].second;
							if (Inventory::Modify(peer, itemid, got) == 0) {
								VisualHandle::Trade(peer, 6198, 500);
								pInfo(peer)->summer_token += 40;
								pInfo(peer)->claim_top10g = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t10) + " Points!", 0, 1);
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$40 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$" + to_string(got) + " " + items[itemid].name + "|left|" + to_string(itemid) + "|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 1);
						}
					}
					if (type == "11") {
						if (guild_point >= guild_t11 and not pInfo(peer)->claim_top11g) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 50;
							pInfo(peer)->claim_top11g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t11) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$50 Summer Tokens|left|6198|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "12") {
						if (guild_point >= guild_t12 and not pInfo(peer)->claim_top12g) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 60;
							pInfo(peer)->claim_top12g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t12) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$60 Summer Tokens|left|6198|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "13") {
						if (guild_point >= guild_t13 and not pInfo(peer)->claim_top13g) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 75;
							pInfo(peer)->claim_top13g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t13) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$75 Summer Tokens|left|6198|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "14") {
						if (guild_point >= guild_t14 and not pInfo(peer)->claim_top14g) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 100;
							pInfo(peer)->claim_top14g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t14) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$100 Summer Tokens|left|6198|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "15") {
						if (guild_point >= guild_t15 and not pInfo(peer)->claim_top15g) {
							int random = rand() % items[5948].noob_item.size(), itemid = items[5948].noob_item[random].first, got = items[5948].noob_item[random].second;
							if (Inventory::Modify(peer, itemid, got) == 0) {
								VisualHandle::Trade(peer, 6198, 500);
								pInfo(peer)->summer_token += 125;
								pInfo(peer)->claim_top15g = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t15) + " Points!", 0, 1);
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$125 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$" + to_string(got) + " " + items[itemid].name + "|left|" + to_string(itemid) + "|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 1);
						}
					}
					if (type == "16") {
						if (guild_point >= guild_t16 and not pInfo(peer)->claim_top16g) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 150;
							pInfo(peer)->claim_top16g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t16) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$150 Summer Tokens|left|6198|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "17") {
						if (guild_point >= guild_t17 and not pInfo(peer)->claim_top17g) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 175;
							pInfo(peer)->claim_top17g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t17) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$175 Summer Tokens|left|6198|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "18") {
						if (guild_point >= guild_t18 and not pInfo(peer)->claim_top18g) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 200;
							pInfo(peer)->claim_top18g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t18) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$200 Summer Tokens|left|6198|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "19") {
						if (guild_point >= guild_t19 and not pInfo(peer)->claim_top19g) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 225;
							pInfo(peer)->claim_top19g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t19) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$225 Summer Tokens|left|6198|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "20") {
						if (guild_point >= guild_t20 and not pInfo(peer)->claim_top20g) {
							int random = rand() % items[5948].noob_item.size(), itemid = items[5948].noob_item[random].first, got = items[5948].noob_item[random].second;
							if (Inventory::Modify(peer, itemid, got) == 0) {
								VisualHandle::Trade(peer, 6198, 500);
								pInfo(peer)->summer_token += 275;
								pInfo(peer)->claim_top20g = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t20) + " Points!", 0, 1);
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$275 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$" + to_string(got) + " " + items[itemid].name + "|left|" + to_string(itemid) + "|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 1);
						}
					}
					if (type == "21") {
						if (guild_point >= guild_t21 and not pInfo(peer)->claim_top21g) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 400;
							pInfo(peer)->claim_top21g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t21) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$400 Summer Tokens|left|6198|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "22") {
						if (guild_point >= guild_t22 and not pInfo(peer)->claim_top22g) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 500;
							pInfo(peer)->claim_top22g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t22) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$500 Summer Tokens|left|6198|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "23") {
						if (guild_point >= guild_t23 and not pInfo(peer)->claim_top23g) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 750;
							pInfo(peer)->claim_top23g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t23) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$750 Summer Tokens|left|6198|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "24") {
						if (guild_point >= guild_t24 and not pInfo(peer)->claim_top24g) {
							VisualHandle::Trade(peer, 6198, 500);
							pInfo(peer)->summer_token += 1250;
							pInfo(peer)->claim_top24g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t24) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$1,250 Summer Tokens|left|6198|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "25") {
						if (guild_point >= guild_t25 and not pInfo(peer)->claim_top25g) {
							int random = rand() % items[5948].noob_item.size(), itemid = items[5948].noob_item[random].first, got = items[5948].noob_item[random].second;
							if (Inventory::Modify(peer, itemid, got) == 0) {
								VisualHandle::Trade(peer, 6198, 500);
								pInfo(peer)->summer_token += 1500;
								pInfo(peer)->claim_top25g = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t25) + " Points!", 0, 1);
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$1,500 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$" + to_string(got) + " " + items[itemid].name + "|left|" + to_string(itemid) + "|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 1);
						}
					}
				}
				if (guild_event_type == "Winter Clash") {
					if (type == "1") {
						if (guild_point >= guild_t1 and not pInfo(peer)->claim_top1g) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 3;
							pInfo(peer)->claim_top1g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t1) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$3 Winter Tokens|left|7328|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "2") {
						if (guild_point >= guild_t2 and not pInfo(peer)->claim_top2g) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 8;
							pInfo(peer)->claim_top2g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t2) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$8 Winter Tokens|left|7328|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "3") {
						if (guild_point >= guild_t3 and not pInfo(peer)->claim_top3g) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 12;
							pInfo(peer)->claim_top3g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t3) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$12 Winter Tokens|left|7328|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "4") {
						if (guild_point >= guild_t4 and not pInfo(peer)->claim_top4g) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 18;
							pInfo(peer)->claim_top4g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t4) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$18 Winter Tokens|left|7328|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "5") {
						if (guild_point >= guild_t5 and not pInfo(peer)->claim_top5g) {
							int random = rand() % items[7484].noob_item.size(), itemid = items[7484].noob_item[random].first, got = items[7484].noob_item[random].second;
							if (Inventory::Modify(peer, itemid, got) == 0) {
								VisualHandle::Trade(peer, 7328, 500);
								pInfo(peer)->winter_token += 22;
								pInfo(peer)->claim_top5g = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t5) + " Points!", 0, 1);
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$22 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$" + to_string(got) + " " + items[itemid].name + "|left|" + to_string(itemid) + "|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 1);
						}
					}
					if (type == "6") {
						if (guild_point >= guild_t6 and not pInfo(peer)->claim_top6g) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 25;
							pInfo(peer)->claim_top6g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t6) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$25 Winter Tokens|left|7328|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "7") {
						if (guild_point >= guild_t7 and not pInfo(peer)->claim_top7g) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 28;
							pInfo(peer)->claim_top7g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t7) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$28 Winter Tokens|left|7328|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "8") {
						if (guild_point >= guild_t8 and not pInfo(peer)->claim_top8g) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 30;
							pInfo(peer)->claim_top8g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t8) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$30 Winter Tokens|left|7328|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "9") {
						if (guild_point >= guild_t9 and not pInfo(peer)->claim_top9g) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 35;
							pInfo(peer)->claim_top9g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t9) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$35 Winter Tokens|left|7328|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "10") {
						if (guild_point >= guild_t10 and not pInfo(peer)->claim_top10g) {
							int random = rand() % items[7484].noob_item.size(), itemid = items[7484].noob_item[random].first, got = items[7484].noob_item[random].second;
							if (Inventory::Modify(peer, itemid, got) == 0) {
								VisualHandle::Trade(peer, 7328, 500);
								pInfo(peer)->winter_token += 40;
								pInfo(peer)->claim_top10g = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t10) + " Points!", 0, 1);
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$40 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$" + to_string(got) + " " + items[itemid].name + "|left|" + to_string(itemid) + "|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 1);
						}
					}
					if (type == "11") {
						if (guild_point >= guild_t11 and not pInfo(peer)->claim_top11g) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 50;
							pInfo(peer)->claim_top11g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t11) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$50 Winter Tokens|left|7328|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "12") {
						if (guild_point >= guild_t12 and not pInfo(peer)->claim_top12g) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 60;
							pInfo(peer)->claim_top12g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t12) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$60 Winter Tokens|left|7328|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "13") {
						if (guild_point >= guild_t13 and not pInfo(peer)->claim_top13g) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 75;
							pInfo(peer)->claim_top13g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t13) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$75 Winter Tokens|left|7328|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "14") {
						if (guild_point >= guild_t14 and not pInfo(peer)->claim_top14g) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 100;
							pInfo(peer)->claim_top14g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t14) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$100 Winter Tokens|left|7328|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "15") {
						if (guild_point >= guild_t15 and not pInfo(peer)->claim_top15g) {
							int random = rand() % items[7484].noob_item.size(), itemid = items[7484].noob_item[random].first, got = items[7484].noob_item[random].second;
							if (Inventory::Modify(peer, itemid, got) == 0) {
								VisualHandle::Trade(peer, 7328, 500);
								pInfo(peer)->winter_token += 125;
								pInfo(peer)->claim_top15g = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t15) + " Points!", 0, 1);
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$125 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$" + to_string(got) + " " + items[itemid].name + "|left|" + to_string(itemid) + "|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 1);
						}
					}
					if (type == "16") {
						if (guild_point >= guild_t16 and not pInfo(peer)->claim_top16g) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 150;
							pInfo(peer)->claim_top16g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t16) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$150 Winter Tokens|left|7328|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "17") {
						if (guild_point >= guild_t17 and not pInfo(peer)->claim_top17g) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 175;
							pInfo(peer)->claim_top17g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t17) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$175 Winter Tokens|left|7328|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "18") {
						if (guild_point >= guild_t18 and not pInfo(peer)->claim_top18g) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 200;
							pInfo(peer)->claim_top18g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t18) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$200 Winter Tokens|left|7328|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "19") {
						if (guild_point >= guild_t19 and not pInfo(peer)->claim_top19g) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 225;
							pInfo(peer)->claim_top19g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t19) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$225 Winter Tokens|left|7328|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "20") {
						if (guild_point >= guild_t20 and not pInfo(peer)->claim_top20g) {
							int random = rand() % items[7484].noob_item.size(), itemid = items[7484].noob_item[random].first, got = items[7484].noob_item[random].second;
							if (Inventory::Modify(peer, itemid, got) == 0) {
								VisualHandle::Trade(peer, 7328, 500);
								pInfo(peer)->winter_token += 275;
								pInfo(peer)->claim_top20g = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t20) + " Points!", 0, 1);
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$275 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$" + to_string(got) + " " + items[itemid].name + "|left|" + to_string(itemid) + "|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 1);
						}
					}
					if (type == "21") {
						if (guild_point >= guild_t21 and not pInfo(peer)->claim_top21g) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 400;
							pInfo(peer)->claim_top21g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t21) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$400 Winter Tokens|left|7328|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "22") {
						if (guild_point >= guild_t22 and not pInfo(peer)->claim_top22g) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 500;
							pInfo(peer)->claim_top22g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t22) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$500 Winter Tokens|left|7328|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "23") {
						if (guild_point >= guild_t23 and not pInfo(peer)->claim_top23g) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 750;
							pInfo(peer)->claim_top23g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t23) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$750 Winter Tokens|left|7328|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "24") {
						if (guild_point >= guild_t24 and not pInfo(peer)->claim_top24g) {
							VisualHandle::Trade(peer, 7328, 500);
							pInfo(peer)->winter_token += 1250;
							pInfo(peer)->claim_top24g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t24) + " Points!", 0, 1);
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$1,250 Winter Tokens|left|7328|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
						}
					}
					if (type == "25") {
						if (guild_point >= guild_t25 and not pInfo(peer)->claim_top25g) {
							int random = rand() % items[7484].noob_item.size(), itemid = items[7484].noob_item[random].first, got = items[7484].noob_item[random].second;
							if (Inventory::Modify(peer, itemid, got) == 0) {
								VisualHandle::Trade(peer, 7328, 500);
								pInfo(peer)->winter_token += 1500;
								pInfo(peer)->claim_top25g = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t25) + " Points!", 0, 1);
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_textbox|`$Congratulations! You have won:|left|\nadd_label_with_icon|small|`$1,500 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$" + to_string(got) + " " + items[itemid].name + "|left|" + to_string(itemid) + "|\nend_dialog|backto_guildreward|Close|Ok|\nadd_quick_exit|");
							}
							else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 1);
						}
					}
				}
			}
			if (button == "claim_all_guevent") {
				if (pInfo(peer)->guild_id == 0) return;
				int guild_point = 0;
				if (Event()->Can_Event) {
					auto it = std::find_if(last_guild_last.begin(), last_guild_last.end(), [&](const std::pair<long long int, std::string>& element) {
						return element.second == std::to_string(pInfo(peer)->guild_id);
						});
					if (it != last_guild_last.end()) {
						guild_point = it->first;
					}
				}
				else {
					auto it = std::find_if(top_guild.begin(), top_guild.end(), [&](const std::pair<long long int, std::string>& element) {
						return element.second == std::to_string(pInfo(peer)->guild_id);
						});
					if (it != top_guild.end()) {
						guild_point = it->first;
					}
				}
				if (guild_event_type == "Spring Clash") {
					if (guild_point >= guild_t1 and not pInfo(peer)->claim_top1g) {
						pInfo(peer)->spring_token += 3;
						pInfo(peer)->claim_top1g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t1) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t2 and not pInfo(peer)->claim_top2g) {
						pInfo(peer)->spring_token += 8;
						pInfo(peer)->claim_top2g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t2) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t3 and not pInfo(peer)->claim_top3g) {
						pInfo(peer)->spring_token += 12;
						pInfo(peer)->claim_top3g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t3) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t4 and not pInfo(peer)->claim_top4g) {
						pInfo(peer)->spring_token += 18;
						pInfo(peer)->claim_top4g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t4) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t5 and not pInfo(peer)->claim_top5g) {
						int random = rand() % items[7954].noob_item.size(), itemid = items[7954].noob_item[random].first, got = items[7954].noob_item[random].second;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->spring_token += 22;
							pInfo(peer)->claim_top5g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t5) + " Points!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 0);
					}
					if (guild_point >= guild_t6 and not pInfo(peer)->claim_top6g) {
						pInfo(peer)->spring_token += 25;
						pInfo(peer)->claim_top6g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t6) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t7 and not pInfo(peer)->claim_top7g) {
						pInfo(peer)->spring_token += 28;
						pInfo(peer)->claim_top7g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t7) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t8 and not pInfo(peer)->claim_top8g) {
						pInfo(peer)->spring_token += 30;
						pInfo(peer)->claim_top8g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t8) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t9 and not pInfo(peer)->claim_top9g) {
						pInfo(peer)->spring_token += 35;
						pInfo(peer)->claim_top9g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t9) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t10 and not pInfo(peer)->claim_top10g) {
						int random = rand() % items[7954].noob_item.size(), itemid = items[7954].noob_item[random].first, got = items[7954].noob_item[random].second;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->spring_token += 40;
							pInfo(peer)->claim_top10g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t10) + " Points!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 0);
					}
					if (guild_point >= guild_t11 and not pInfo(peer)->claim_top11g) {
						pInfo(peer)->spring_token += 50;
						pInfo(peer)->claim_top11g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t11) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t12 and not pInfo(peer)->claim_top12g) {
						pInfo(peer)->spring_token += 60;
						pInfo(peer)->claim_top12g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t12) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t13 and not pInfo(peer)->claim_top13g) {
						pInfo(peer)->spring_token += 75;
						pInfo(peer)->claim_top13g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t13) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t14 and not pInfo(peer)->claim_top14g) {
						pInfo(peer)->spring_token += 100;
						pInfo(peer)->claim_top14g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t14) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t15 and not pInfo(peer)->claim_top15g) {
						int random = rand() % items[7954].noob_item.size(), itemid = items[7954].noob_item[random].first, got = items[7954].noob_item[random].second;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->spring_token += 125;
							pInfo(peer)->claim_top15g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t15) + " Points!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 0);
					}
					if (guild_point >= guild_t16 and not pInfo(peer)->claim_top16g) {
						pInfo(peer)->spring_token += 150;
						pInfo(peer)->claim_top16g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t16) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t17 and not pInfo(peer)->claim_top17g) {
						pInfo(peer)->spring_token += 175;
						pInfo(peer)->claim_top17g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t17) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t18 and not pInfo(peer)->claim_top18g) {
						pInfo(peer)->spring_token += 200;
						pInfo(peer)->claim_top18g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t18) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t19 and not pInfo(peer)->claim_top19g) {
						pInfo(peer)->spring_token += 225;
						pInfo(peer)->claim_top19g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t19) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t20 and not pInfo(peer)->claim_top20g) {
						int random = rand() % items[7954].noob_item.size(), itemid = items[7954].noob_item[random].first, got = items[7954].noob_item[random].second;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->spring_token += 275;
							pInfo(peer)->claim_top20g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t20) + " Points!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 0);
					}
					if (guild_point >= guild_t21 and not pInfo(peer)->claim_top21g) {
						pInfo(peer)->spring_token += 400;
						pInfo(peer)->claim_top21g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t21) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t22 and not pInfo(peer)->claim_top22g) {
						pInfo(peer)->spring_token += 500;
						pInfo(peer)->claim_top22g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t22) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t23 and not pInfo(peer)->claim_top23g) {
						pInfo(peer)->spring_token += 750;
						pInfo(peer)->claim_top23g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t23) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t24 and not pInfo(peer)->claim_top24g) {
						pInfo(peer)->spring_token += 1250;
						pInfo(peer)->claim_top24g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t24) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t25 and not pInfo(peer)->claim_top25g) {
						int random = rand() % items[7954].noob_item.size(), itemid = items[7954].noob_item[random].first, got = items[7954].noob_item[random].second;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->spring_token += 1500;
							pInfo(peer)->claim_top25g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t25) + " Points!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 0);
					}
				}
				if (guild_event_type == "Summer Clash") {
					if (guild_point >= guild_t1 and not pInfo(peer)->claim_top1g) {
						pInfo(peer)->summer_token += 3;
						pInfo(peer)->claim_top1g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t1) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t2 and not pInfo(peer)->claim_top2g) {
						VisualHandle::Trade(peer, 6198, 500);
						pInfo(peer)->summer_token += 8;
						pInfo(peer)->claim_top2g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t2) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t3 and not pInfo(peer)->claim_top3g) {
						pInfo(peer)->summer_token += 12;
						pInfo(peer)->claim_top3g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t3) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t4 and not pInfo(peer)->claim_top4g) {
						pInfo(peer)->summer_token += 18;
						pInfo(peer)->claim_top4g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t4) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t5 and not pInfo(peer)->claim_top5g) {
						int random = rand() % items[5948].noob_item.size(), itemid = items[5948].noob_item[random].first, got = items[5948].noob_item[random].second;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->summer_token += 22;
							pInfo(peer)->claim_top5g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t5) + " Points!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 0);
					}
					if (guild_point >= guild_t6 and not pInfo(peer)->claim_top6g) {
						pInfo(peer)->summer_token += 25;
						pInfo(peer)->claim_top6g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t6) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t7 and not pInfo(peer)->claim_top7g) {
						pInfo(peer)->summer_token += 28;
						pInfo(peer)->claim_top7g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t7) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t8 and not pInfo(peer)->claim_top8g) {
						pInfo(peer)->summer_token += 30;
						pInfo(peer)->claim_top8g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t8) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t9 and not pInfo(peer)->claim_top9g) {
						pInfo(peer)->summer_token += 35;
						pInfo(peer)->claim_top9g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t9) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t10 and not pInfo(peer)->claim_top10g) {
						int random = rand() % items[5948].noob_item.size(), itemid = items[5948].noob_item[random].first, got = items[5948].noob_item[random].second;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->summer_token += 40;
							pInfo(peer)->claim_top10g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t10) + " Points!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 0);
					}
					if (guild_point >= guild_t11 and not pInfo(peer)->claim_top11g) {
						pInfo(peer)->summer_token += 50;
						pInfo(peer)->claim_top11g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t11) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t12 and not pInfo(peer)->claim_top12g) {
						pInfo(peer)->summer_token += 60;
						pInfo(peer)->claim_top12g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t12) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t13 and not pInfo(peer)->claim_top13g) {
						pInfo(peer)->summer_token += 75;
						pInfo(peer)->claim_top13g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t13) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t14 and not pInfo(peer)->claim_top14g) {
						pInfo(peer)->summer_token += 100;
						pInfo(peer)->claim_top14g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t14) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t15 and not pInfo(peer)->claim_top15g) {
						int random = rand() % items[5948].noob_item.size(), itemid = items[5948].noob_item[random].first, got = items[5948].noob_item[random].second;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->summer_token += 125;
							pInfo(peer)->claim_top15g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t15) + " Points!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 0);
					}
					if (guild_point >= guild_t16 and not pInfo(peer)->claim_top16g) {
						pInfo(peer)->summer_token += 150;
						pInfo(peer)->claim_top16g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t16) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t17 and not pInfo(peer)->claim_top17g) {
						pInfo(peer)->summer_token += 175;
						pInfo(peer)->claim_top17g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t17) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t18 and not pInfo(peer)->claim_top18g) {
						pInfo(peer)->summer_token += 200;
						pInfo(peer)->claim_top18g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t18) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t19 and not pInfo(peer)->claim_top19g) {
						pInfo(peer)->summer_token += 225;
						pInfo(peer)->claim_top19g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t19) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t20 and not pInfo(peer)->claim_top20g) {
						int random = rand() % items[5948].noob_item.size(), itemid = items[5948].noob_item[random].first, got = items[5948].noob_item[random].second;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->summer_token += 275;
							pInfo(peer)->claim_top20g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t20) + " Points!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 0);
					}
					if (guild_point >= guild_t21 and not pInfo(peer)->claim_top21g) {
						pInfo(peer)->summer_token += 400;
						pInfo(peer)->claim_top21g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t21) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t22 and not pInfo(peer)->claim_top22g) {
						pInfo(peer)->summer_token += 500;
						pInfo(peer)->claim_top22g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t22) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t23 and not pInfo(peer)->claim_top23g) {
						pInfo(peer)->summer_token += 750;
						pInfo(peer)->claim_top23g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t23) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t24 and not pInfo(peer)->claim_top24g) {
						pInfo(peer)->summer_token += 1250;
						pInfo(peer)->claim_top24g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t24) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t25 and not pInfo(peer)->claim_top25g) {
						int random = rand() % items[5948].noob_item.size(), itemid = items[5948].noob_item[random].first, got = items[5948].noob_item[random].second;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->summer_token += 1500;
							pInfo(peer)->claim_top25g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t25) + " Points!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 0);
					}
				}
				if (guild_event_type == "Winter Clash") {
					if (guild_point >= guild_t1 and not pInfo(peer)->claim_top1g) {
						pInfo(peer)->winter_token += 3;
						pInfo(peer)->claim_top1g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t1) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t2 and not pInfo(peer)->claim_top2g) {
						pInfo(peer)->winter_token += 8;
						pInfo(peer)->claim_top2g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t2) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t3 and not pInfo(peer)->claim_top3g) {
						pInfo(peer)->winter_token += 12;
						pInfo(peer)->claim_top3g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t3) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t4 and not pInfo(peer)->claim_top4g) {
						pInfo(peer)->winter_token += 18;
						pInfo(peer)->claim_top4g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t4) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t5 and not pInfo(peer)->claim_top5g) {
						int random = rand() % items[7484].noob_item.size(), itemid = items[7484].noob_item[random].first, got = items[7484].noob_item[random].second;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->winter_token += 22;
							pInfo(peer)->claim_top5g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t5) + " Points!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 0);
					}
					if (guild_point >= guild_t6 and not pInfo(peer)->claim_top6g) {
						pInfo(peer)->winter_token += 25;
						pInfo(peer)->claim_top6g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t6) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t7 and not pInfo(peer)->claim_top7g) {
						pInfo(peer)->winter_token += 28;
						pInfo(peer)->claim_top7g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t7) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t8 and not pInfo(peer)->claim_top8g) {
						pInfo(peer)->winter_token += 30;
						pInfo(peer)->claim_top8g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t8) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t9 and not pInfo(peer)->claim_top9g) {
						pInfo(peer)->winter_token += 35;
						pInfo(peer)->claim_top9g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t9) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t10 and not pInfo(peer)->claim_top10g) {
						int random = rand() % items[7484].noob_item.size(), itemid = items[7484].noob_item[random].first, got = items[7484].noob_item[random].second;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->winter_token += 40;
							pInfo(peer)->claim_top10g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t10) + " Points!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 0);
					}
					if (guild_point >= guild_t11 and not pInfo(peer)->claim_top11g) {
						pInfo(peer)->winter_token += 50;
						pInfo(peer)->claim_top11g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t11) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t12 and not pInfo(peer)->claim_top12g) {
						pInfo(peer)->winter_token += 60;
						pInfo(peer)->claim_top12g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t12) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t13 and not pInfo(peer)->claim_top13g) {
						pInfo(peer)->winter_token += 75;
						pInfo(peer)->claim_top13g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t13) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t14 and not pInfo(peer)->claim_top14g) {
						pInfo(peer)->winter_token += 100;
						pInfo(peer)->claim_top14g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t14) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t15 and not pInfo(peer)->claim_top15g) {
						int random = rand() % items[7484].noob_item.size(), itemid = items[7484].noob_item[random].first, got = items[7484].noob_item[random].second;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->winter_token += 125;
							pInfo(peer)->claim_top15g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t15) + " Points!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 0);
					}
					if (guild_point >= guild_t16 and not pInfo(peer)->claim_top16g) {
						pInfo(peer)->winter_token += 150;
						pInfo(peer)->claim_top16g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t16) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t17 and not pInfo(peer)->claim_top17g) {
						pInfo(peer)->winter_token += 175;
						pInfo(peer)->claim_top17g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t17) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t18 and not pInfo(peer)->claim_top18g) {
						pInfo(peer)->winter_token += 200;
						pInfo(peer)->claim_top18g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t18) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t19 and not pInfo(peer)->claim_top19g) {
						pInfo(peer)->winter_token += 225;
						pInfo(peer)->claim_top19g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t19) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t20 and not pInfo(peer)->claim_top20g) {
						int random = rand() % items[7484].noob_item.size(), itemid = items[7484].noob_item[random].first, got = items[7484].noob_item[random].second;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->winter_token += 275;
							pInfo(peer)->claim_top20g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t20) + " Points!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 0);
					}
					if (guild_point >= guild_t21 and not pInfo(peer)->claim_top21g) {
						pInfo(peer)->winter_token += 400;
						pInfo(peer)->claim_top21g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t21) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t22 and not pInfo(peer)->claim_top22g) {
						pInfo(peer)->winter_token += 500;
						pInfo(peer)->claim_top22g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t22) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t23 and not pInfo(peer)->claim_top23g) {
						pInfo(peer)->winter_token += 750;
						pInfo(peer)->claim_top23g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t23) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t24 and not pInfo(peer)->claim_top24g) {
						pInfo(peer)->winter_token += 1250;
						pInfo(peer)->claim_top24g = true;
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t24) + " Points!", 0, 0);
					}
					if (guild_point >= guild_t25 and not pInfo(peer)->claim_top25g) {
						int random = rand() % items[7484].noob_item.size(), itemid = items[7484].noob_item[random].first, got = items[7484].noob_item[random].second;
						if (Inventory::Modify(peer, itemid, got) == 0) {
							pInfo(peer)->winter_token += 1500;
							pInfo(peer)->claim_top25g = true;
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a reward for earning: " + Set_Count(guild_t25) + " Points!", 0, 0);
						}
						else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough room in your backpack for that prize, free some up and try again later.", 0, 0);
					}
				}
				DialogHandle::Guild_Event_Rewards(peer);
			}
			if (button.substr(0, 10) == "limititem_") {
				std::string type = button.substr(10);
				if (type == "1") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[14586].name + "|left|14586|\nadd_spacer|small|\nadd_smalltext|`w" + items[14586].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Keys: `2" + Set_Count(pInfo(peer)->Legendary_Keys) + "|left|8504|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[14586].name + " for `215 ``Keys.|left|\nadd_spacer|small|" + (pInfo(peer)->Legendary_Keys < 15 ? "\nadd_textbox|`wYou don't have enough Keys.|left|\nadd_spacer|small|" : "\nadd_button|buyitems_1|`oBuy|0|0|") + "\nend_dialog|backto_limitclashrewards|Close|Back|");
			}
			if (button.substr(0, 10) == "row1enter_") {
				std::string type = button.substr(10);
				/*Legendary Branch*/if (type == "7") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[14414].name + "|left|14414|\nadd_spacer|small|\nadd_smalltext|`wBecome one with the stars with the Galaxy Skin!|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Keys: `2" + Set_Count(pInfo(peer)->Legendary_Keys) + "|left|8504|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[14414].name + " for `210 ``Keys.|left|\nadd_spacer|small|" + (pInfo(peer)->Legendary_Keys < 10 ? "\nadd_textbox|`wYou don't have enough Keys.|left|\nadd_spacer|small|" : "\nadd_button|buyitems_7|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
				if (guild_event_type == "Spring Clash") {
					if (type == "1") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[7934].name + "|left|7934|\nadd_spacer|small|\nadd_smalltext|`w" + items[7934].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Spring Tokens: `2" + Set_Count(pInfo(peer)->spring_token) + "|left|7844|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[7934].name + " for `2200 ``Spring Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->spring_token < 200 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buyitems_1|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "2") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[5202].name + "|left|5202|\nadd_spacer|small|\nadd_smalltext|`w" + items[5202].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Spring Tokens: `2" + Set_Count(pInfo(peer)->spring_token) + "|left|7844|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[5202].name + " for `2400 ``Spring Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->spring_token < 400 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buyitems_2|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "3") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[6286].name + "|left|6286|\nadd_spacer|small|\nadd_smalltext|`w" + items[6286].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Spring Tokens: `2" + Set_Count(pInfo(peer)->spring_token) + "|left|7844|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[6286].name + " for `2600 ``Spring Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->spring_token < 600 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buyitems_3|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "4") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[7942].name + "|left|7942|\nadd_spacer|small|\nadd_smalltext|`w" + items[7942].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Spring Tokens: `2" + Set_Count(pInfo(peer)->spring_token) + "|left|7844|\nadd_spacer|small|\nadd_textbox|`wGet `210 ``" + items[7942].name + " for `2800 ``Spring Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->spring_token < 800 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buyitems_4|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "5") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[7936].name + "|left|7936|\nadd_spacer|small|\nadd_smalltext|`w" + items[7936].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Spring Tokens: `2" + Set_Count(pInfo(peer)->spring_token) + "|left|7844|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[7936].name + " for `21,000 ``Spring Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->spring_token < 1000 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buyitems_5|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "6") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[9218].name + "|left|9218|\nadd_spacer|small|\nadd_smalltext|`w" + items[9218].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Spring Tokens: `2" + Set_Count(pInfo(peer)->spring_token) + "|left|7844|\nadd_spacer|small|\nadd_textbox|`wClaim your " + items[9218].name + ".|left|\nadd_spacer|small|\nadd_button|buyitems_6|`oBuy|0|0|\nend_dialog|backto_clashrewards|Close|Back|");
				}
				if (guild_event_type == "Summer Clash") {
					if (type == "1") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[6264].name + "|left|6264|\nadd_spacer|small|\nadd_smalltext|`w" + items[6264].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Summer Tokens: `2" + Set_Count(pInfo(peer)->summer_token) + "|left|6198|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[6264].name + " for `2200 ``Summer Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->summer_token < 200 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buyitems_1|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "2") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[5202].name + "|left|5202|\nadd_spacer|small|\nadd_smalltext|`w" + items[5202].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Summer Tokens: `2" + Set_Count(pInfo(peer)->summer_token) + "|left|6198|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[5202].name + " for `2400 ``Summer Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->summer_token < 400 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buyitems_2|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "3") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[6286].name + "|left|6286|\nadd_spacer|small|\nadd_smalltext|`w" + items[6286].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Summer Tokens: `2" + Set_Count(pInfo(peer)->summer_token) + "|left|6198|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[6286].name + " for `2600 ``Summer Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->summer_token < 600 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buyitems_3|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "4") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[6154].name + "|left|6154|\nadd_spacer|small|\nadd_smalltext|`w" + items[6154].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Summer Tokens: `2" + Set_Count(pInfo(peer)->summer_token) + "|left|6198|\nadd_spacer|small|\nadd_textbox|`wGet `210 ``" + items[6154].name + " for `2800 ``Summer Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->summer_token < 800 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buyitems_4|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "5") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[6266].name + "|left|6266|\nadd_spacer|small|\nadd_smalltext|`w" + items[6266].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Summer Tokens: `2" + Set_Count(pInfo(peer)->summer_token) + "|left|6198|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[6266].name + " for `21,000 ``Summer Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->summer_token < 1000 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buyitems_5|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "6") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[9218].name + "|left|9218|\nadd_spacer|small|\nadd_smalltext|`w" + items[9218].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Summer Tokens: `2" + Set_Count(pInfo(peer)->summer_token) + "|left|6198|\nadd_spacer|small|\nadd_textbox|`wClaim your " + items[9218].name + ".|left|\nadd_spacer|small|\nadd_button|buyitems_6|`oBuy|0|0|\nend_dialog|backto_clashrewards|Close|Back|");
				}
				if (guild_event_type == "Winter Clash") {
					if (type == "1") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[7198].name + "|left|7198|\nadd_spacer|small|\nadd_smalltext|`w" + items[7198].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Winter Tokens: `2" + Set_Count(pInfo(peer)->winter_token) + "|left|7328|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[7198].name + " for `2200 ``Winter Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->winter_token < 200 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buyitems_1|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "2") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[5202].name + "|left|5202|\nadd_spacer|small|\nadd_smalltext|`w" + items[5202].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Winter Tokens: `2" + Set_Count(pInfo(peer)->winter_token) + "|left|7328|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[5202].name + " for `2400 ``Winter Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->winter_token < 400 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buyitems_2|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "3") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[6286].name + "|left|6286|\nadd_spacer|small|\nadd_smalltext|`w" + items[6286].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Winter Tokens: `2" + Set_Count(pInfo(peer)->winter_token) + "|left|7328|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[6286].name + " for `2600 ``Winter Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->winter_token < 600 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buyitems_3|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "4") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[7202].name + "|left|7202|\nadd_spacer|small|\nadd_smalltext|`w" + items[7202].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Winter Tokens: `2" + Set_Count(pInfo(peer)->winter_token) + "|left|7328|\nadd_spacer|small|\nadd_textbox|`wGet `210 ``" + items[7202].name + " for `2800 ``Winter Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->winter_token < 800 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buyitems_4|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "5") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[7200].name + "|left|7200|\nadd_spacer|small|\nadd_smalltext|`w" + items[7200].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Winter Tokens: `2" + Set_Count(pInfo(peer)->winter_token) + "|left|7328|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[7200].name + " for `21,000 ``Winter Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->winter_token < 1000 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buyitems_5|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "6") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[9214].name + "|left|9214|\nadd_spacer|small|\nadd_smalltext|`w" + items[9214].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Winter Tokens: `2" + Set_Count(pInfo(peer)->winter_token) + "|left|7328|\nadd_spacer|small|\nadd_textbox|`wClaim your " + items[9214].name + ".|left|\nadd_spacer|small|\nadd_button|buyitems_6|`oBuy|0|0|\nend_dialog|backto_clashrewards|Close|Back|");
				}
			}
			if (button.substr(0, 10) == "row2enter_") {
				std::string type = button.substr(10);
				if (guild_event_type == "Spring Clash") {
					if (type == "1") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[7944].name + "|left|7944|\nadd_spacer|small|\nadd_smalltext|`w" + items[7944].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Spring Tokens: `2" + Set_Count(pInfo(peer)->spring_token) + "|left|7844|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[7944].name + " for `2200 ``Spring Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->spring_token < 200 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy2items_1|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "2") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[5202].name + "|left|5202|\nadd_spacer|small|\nadd_smalltext|`w" + items[5202].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Spring Tokens: `2" + Set_Count(pInfo(peer)->spring_token) + "|left|7844|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[5202].name + " for `2400 ``Spring Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->spring_token < 400 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy2items_2|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "3") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[6286].name + "|left|6286|\nadd_spacer|small|\nadd_smalltext|`w" + items[6286].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Spring Tokens: `2" + Set_Count(pInfo(peer)->spring_token) + "|left|7844|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[6286].name + " for `2600 ``Spring Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->spring_token < 600 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy2items_3|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "4") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[7952].name + "|left|7952|\nadd_spacer|small|\nadd_smalltext|`w" + items[7952].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Spring Tokens: `2" + Set_Count(pInfo(peer)->spring_token) + "|left|7844|\nadd_spacer|small|\nadd_textbox|`wGet `210 ``" + items[7952].name + " for `2800 ``Spring Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->spring_token < 800 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy2items_4|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "5") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[7946].name + "|left|7946|\nadd_spacer|small|\nadd_smalltext|`w" + items[7946].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Spring Tokens: `2" + Set_Count(pInfo(peer)->spring_token) + "|left|7844|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[7946].name + " for `21,000 ``Spring Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->spring_token < 1000 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy2items_5|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "6") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[9218].name + "|left|9218|\nadd_spacer|small|\nadd_smalltext|`w" + items[9218].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Spring Tokens: `2" + Set_Count(pInfo(peer)->spring_token) + "|left|7844|\nadd_spacer|small|\nadd_textbox|`wClaim your " + items[9218].name + ".|left|\nadd_spacer|small|\nadd_button|buy2items_6|`oBuy|0|0|\nend_dialog|backto_clashrewards|Close|Back|");
				}
				if (guild_event_type == "Summer Clash") {
					if (type == "1") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[6268].name + "|left|6268|\nadd_spacer|small|\nadd_smalltext|`w" + items[6268].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Summer Tokens: `2" + Set_Count(pInfo(peer)->summer_token) + "|left|6198|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[6268].name + " for `2200 ``Summer Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->summer_token < 200 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy2items_1|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "2") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[5202].name + "|left|5202|\nadd_spacer|small|\nadd_smalltext|`w" + items[5202].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Summer Tokens: `2" + Set_Count(pInfo(peer)->summer_token) + "|left|6198|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[5202].name + " for `2400 ``Summer Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->summer_token < 400 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy2items_2|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "3") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[6286].name + "|left|6286|\nadd_spacer|small|\nadd_smalltext|`w" + items[6286].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Summer Tokens: `2" + Set_Count(pInfo(peer)->summer_token) + "|left|6198|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[6286].name + " for `2600 ``Summer Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->summer_token < 600 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy2items_3|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "4") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[6156].name + "|left|6156|\nadd_spacer|small|\nadd_smalltext|`w" + items[6156].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Summer Tokens: `2" + Set_Count(pInfo(peer)->summer_token) + "|left|6198|\nadd_spacer|small|\nadd_textbox|`wGet `210 ``" + items[6156].name + " for `2800 ``Summer Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->summer_token < 800 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy2items_4|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "5") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[6270].name + "|left|6270|\nadd_spacer|small|\nadd_smalltext|`w" + items[6270].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Summer Tokens: `2" + Set_Count(pInfo(peer)->summer_token) + "|left|6198|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[6270].name + " for `21,000 ``Summer Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->summer_token < 1000 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy2items_5|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "6") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[9218].name + "|left|9218|\nadd_spacer|small|\nadd_smalltext|`w" + items[9218].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Summer Tokens: `2" + Set_Count(pInfo(peer)->summer_token) + "|left|6198|\nadd_spacer|small|\nadd_textbox|`wClaim your " + items[9218].name + ".|left|\nadd_spacer|small|\nadd_button|buy2items_6|`oBuy|0|0|\nend_dialog|backto_clashrewards|Close|Back|");
				}
				if (guild_event_type == "Winter Clash") {
					if (type == "1") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[7208].name + "|left|7208|\nadd_spacer|small|\nadd_smalltext|`w" + items[7208].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Winter Tokens: `2" + Set_Count(pInfo(peer)->winter_token) + "|left|7328|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[7208].name + " for `2200 ``Winter Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->winter_token < 200 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy2items_1|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "2") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[5202].name + "|left|5202|\nadd_spacer|small|\nadd_smalltext|`w" + items[5202].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Winter Tokens: `2" + Set_Count(pInfo(peer)->winter_token) + "|left|7328|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[5202].name + " for `2400 ``Winter Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->winter_token < 400 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy2items_2|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "3") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[6286].name + "|left|6286|\nadd_spacer|small|\nadd_smalltext|`w" + items[6286].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Winter Tokens: `2" + Set_Count(pInfo(peer)->winter_token) + "|left|7328|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[6286].name + " for `2600 ``Winter Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->winter_token < 600 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy2items_3|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "4") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[7212].name + "|left|7212|\nadd_spacer|small|\nadd_smalltext|`w" + items[7212].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Winter Tokens: `2" + Set_Count(pInfo(peer)->winter_token) + "|left|7328|\nadd_spacer|small|\nadd_textbox|`wGet `210 ``" + items[7212].name + " for `2800 ``Winter Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->winter_token < 800 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy2items_4|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "5") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[7210].name + "|left|7210|\nadd_spacer|small|\nadd_smalltext|`w" + items[7210].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Winter Tokens: `2" + Set_Count(pInfo(peer)->winter_token) + "|left|7328|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[7210].name + " for `21,000 ``Winter Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->winter_token < 1000 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy2items_5|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "6") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[9214].name + "|left|9214|\nadd_spacer|small|\nadd_smalltext|`w" + items[9214].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Winter Tokens: `2" + Set_Count(pInfo(peer)->winter_token) + "|left|7328|\nadd_spacer|small|\nadd_textbox|`wClaim your " + items[9214].name + ".|left|\nadd_spacer|small|\nadd_button|buy2items_6|`oBuy|0|0|\nend_dialog|backto_clashrewards|Close|Back|");
				}
			}
			if (button.substr(0, 10) == "row3enter_") {
				std::string type = button.substr(10);
				if (guild_event_type == "Spring Clash") {
					if (type == "1") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[8014].name + "|left|8014|\nadd_spacer|small|\nadd_smalltext|`w" + items[8014].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Spring Tokens: `2" + Set_Count(pInfo(peer)->spring_token) + "|left|7844|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[8014].name + " for `2200 ``Spring Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->spring_token < 200 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy3items_1|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "2") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[5202].name + "|left|5202|\nadd_spacer|small|\nadd_smalltext|`w" + items[5202].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Spring Tokens: `2" + Set_Count(pInfo(peer)->spring_token) + "|left|7844|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[5202].name + " for `2400 ``Spring Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->spring_token < 400 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy3items_2|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "3") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[6286].name + "|left|6286|\nadd_spacer|small|\nadd_smalltext|`w" + items[6286].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Spring Tokens: `2" + Set_Count(pInfo(peer)->spring_token) + "|left|7844|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[6286].name + " for `2600 ``Spring Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->spring_token < 600 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy3items_3|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "4") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[8020].name + "|left|8020|\nadd_spacer|small|\nadd_smalltext|`w" + items[8020].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Spring Tokens: `2" + Set_Count(pInfo(peer)->spring_token) + "|left|7844|\nadd_spacer|small|\nadd_textbox|`wGet `210 ``" + items[8020].name + " for `2800 ``Spring Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->spring_token < 800 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy3items_4|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "5") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[8016].name + "|left|8016|\nadd_spacer|small|\nadd_smalltext|`w" + items[8016].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Spring Tokens: `2" + Set_Count(pInfo(peer)->spring_token) + "|left|7844|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[8016].name + " for `21,000 ``Spring Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->spring_token < 1000 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy3items_5|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "6") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[9218].name + "|left|9218|\nadd_spacer|small|\nadd_smalltext|`w" + items[9218].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Spring Tokens: `2" + Set_Count(pInfo(peer)->spring_token) + "|left|7844|\nadd_spacer|small|\nadd_textbox|`wClaim your " + items[9218].name + ".|left|\nadd_spacer|small|\nadd_button|buy3items_6|`oBuy|0|0|\nend_dialog|backto_clashrewards|Close|Back|");
				}
				if (guild_event_type == "Summer Clash") {
					if (type == "1") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[6302].name + "|left|6302|\nadd_spacer|small|\nadd_smalltext|`w" + items[6302].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Summer Tokens: `2" + Set_Count(pInfo(peer)->summer_token) + "|left|6198|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[6302].name + " for `2200 ``Summer Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->summer_token < 200 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy3items_1|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "2") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[5202].name + "|left|5202|\nadd_spacer|small|\nadd_smalltext|`w" + items[5202].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Summer Tokens: `2" + Set_Count(pInfo(peer)->summer_token) + "|left|6198|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[5202].name + " for `2400 ``Summer Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->summer_token < 400 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy3items_2|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "3") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[6286].name + "|left|6286|\nadd_spacer|small|\nadd_smalltext|`w" + items[6286].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Summer Tokens: `2" + Set_Count(pInfo(peer)->summer_token) + "|left|6198|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[6286].name + " for `2600 ``Summer Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->summer_token < 600 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy3items_3|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "4") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[6296].name + "|left|6296|\nadd_spacer|small|\nadd_smalltext|`w" + items[6296].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Summer Tokens: `2" + Set_Count(pInfo(peer)->summer_token) + "|left|6198|\nadd_spacer|small|\nadd_textbox|`wGet `210 ``" + items[6296].name + " for `2800 ``Summer Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->summer_token < 800 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy3items_4|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "5") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[6304].name + "|left|6304|\nadd_spacer|small|\nadd_smalltext|`w" + items[6304].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Summer Tokens: `2" + Set_Count(pInfo(peer)->summer_token) + "|left|6198|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[6304].name + " for `21,000 ``Summer Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->summer_token < 1000 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy3items_5|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "6") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[9218].name + "|left|9218|\nadd_spacer|small|\nadd_smalltext|`w" + items[9218].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Summer Tokens: `2" + Set_Count(pInfo(peer)->summer_token) + "|left|6198|\nadd_spacer|small|\nadd_textbox|`wClaim your " + items[9218].name + ".|left|\nadd_spacer|small|\nadd_button|buy3items_6|`oBuy|0|0|\nend_dialog|backto_clashrewards|Close|Back|");
				}
				if (guild_event_type == "Winter Clash") {
					if (type == "1") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[7388].name + "|left|7388|\nadd_spacer|small|\nadd_smalltext|`w" + items[7388].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Winter Tokens: `2" + Set_Count(pInfo(peer)->winter_token) + "|left|7328|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[7388].name + " for `2200 ``Winter Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->winter_token < 200 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy3items_1|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "2") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[5202].name + "|left|5202|\nadd_spacer|small|\nadd_smalltext|`w" + items[5202].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Winter Tokens: `2" + Set_Count(pInfo(peer)->winter_token) + "|left|7328|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[5202].name + " for `2400 ``Winter Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->winter_token < 400 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy3items_2|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "3") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[6286].name + "|left|6286|\nadd_spacer|small|\nadd_smalltext|`w" + items[6286].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Winter Tokens: `2" + Set_Count(pInfo(peer)->winter_token) + "|left|7328|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[6286].name + " for `2600 ``Winter Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->winter_token < 600 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy3items_3|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "4") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[7394].name + "|left|7394|\nadd_spacer|small|\nadd_smalltext|`w" + items[7394].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Winter Tokens: `2" + Set_Count(pInfo(peer)->winter_token) + "|left|7328|\nadd_spacer|small|\nadd_textbox|`wGet `210 ``" + items[7394].name + " for `2800 ``Winter Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->winter_token < 800 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy3items_4|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "5") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[7386].name + "|left|7386|\nadd_spacer|small|\nadd_smalltext|`w" + items[7386].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Winter Tokens: `2" + Set_Count(pInfo(peer)->winter_token) + "|left|7328|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[7386].name + " for `21,000 ``Winter Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->winter_token < 1000 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy3items_5|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "6") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[9214].name + "|left|9214|\nadd_spacer|small|\nadd_smalltext|`w" + items[9214].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Winter Tokens: `2" + Set_Count(pInfo(peer)->winter_token) + "|left|7328|\nadd_spacer|small|\nadd_textbox|`wClaim your " + items[9214].name + ".|left|\nadd_spacer|small|\nadd_button|buy3items_6|`oBuy|0|0|\nend_dialog|backto_clashrewards|Close|Back|");
				}
			}
			if (button.substr(0, 10) == "row4enter_") {
				std::string type = button.substr(10);
				if (guild_event_type == "Spring Clash") {
					if (type == "1") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[8296].name + "|left|8296|\nadd_spacer|small|\nadd_smalltext|`w" + items[8296].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Spring Tokens: `2" + Set_Count(pInfo(peer)->spring_token) + "|left|7844|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[8296].name + " for `2200 ``Spring Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->spring_token < 200 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy4items_1|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "2") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[5202].name + "|left|5202|\nadd_spacer|small|\nadd_smalltext|`w" + items[5202].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Spring Tokens: `2" + Set_Count(pInfo(peer)->spring_token) + "|left|7844|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[5202].name + " for `2400 ``Spring Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->spring_token < 400 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy4items_2|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "3") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[6286].name + "|left|6286|\nadd_spacer|small|\nadd_smalltext|`w" + items[6286].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Spring Tokens: `2" + Set_Count(pInfo(peer)->spring_token) + "|left|7844|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[6286].name + " for `2600 ``Spring Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->spring_token < 600 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy4items_3|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "4") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[8300].name + "|left|8300|\nadd_spacer|small|\nadd_smalltext|`w" + items[8300].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Spring Tokens: `2" + Set_Count(pInfo(peer)->spring_token) + "|left|7844|\nadd_spacer|small|\nadd_textbox|`wGet `210 ``" + items[8300].name + " for `2800 ``Spring Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->spring_token < 800 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy4items_4|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "5") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[8298].name + "|left|8298|\nadd_spacer|small|\nadd_smalltext|`w" + items[8298].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Spring Tokens: `2" + Set_Count(pInfo(peer)->spring_token) + "|left|7844|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[8298].name + " for `21,000 ``Spring Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->spring_token < 1000 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy4items_5|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "6") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[9218].name + "|left|9218|\nadd_spacer|small|\nadd_smalltext|`w" + items[9218].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Spring Tokens: `2" + Set_Count(pInfo(peer)->spring_token) + "|left|7844|\nadd_spacer|small|\nadd_textbox|`wClaim your " + items[9218].name + ".|left|\nadd_spacer|small|\nadd_button|buy4items_6|`oBuy|0|0|\nend_dialog|backto_clashrewards|Close|Back|");
				}
				if (guild_event_type == "Summer Clash") {
					if (type == "1") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[6750].name + "|left|6750|\nadd_spacer|small|\nadd_smalltext|`w" + items[6750].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Summer Tokens: `2" + Set_Count(pInfo(peer)->summer_token) + "|left|6198|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[6750].name + " for `2200 ``Summer Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->summer_token < 200 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy4items_1|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "2") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[5202].name + "|left|5202|\nadd_spacer|small|\nadd_smalltext|`w" + items[5202].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Summer Tokens: `2" + Set_Count(pInfo(peer)->summer_token) + "|left|6198|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[5202].name + " for `2400 ``Summer Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->summer_token < 400 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy4items_2|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "3") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[6286].name + "|left|6286|\nadd_spacer|small|\nadd_smalltext|`w" + items[6286].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Summer Tokens: `2" + Set_Count(pInfo(peer)->summer_token) + "|left|6198|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[6286].name + " for `2600 ``Summer Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->summer_token < 600 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy4items_3|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "4") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[6772].name + "|left|6772|\nadd_spacer|small|\nadd_smalltext|`w" + items[6772].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Summer Tokens: `2" + Set_Count(pInfo(peer)->summer_token) + "|left|6198|\nadd_spacer|small|\nadd_textbox|`wGet `210 ``" + items[6772].name + " for `2800 ``Summer Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->summer_token < 800 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy4items_4|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "5") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[6752].name + "|left|6752|\nadd_spacer|small|\nadd_smalltext|`w" + items[6752].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Summer Tokens: `2" + Set_Count(pInfo(peer)->summer_token) + "|left|6198|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[6752].name + " for `21,000 ``Summer Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->summer_token < 1000 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy4items_5|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "6") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[9218].name + "|left|9218|\nadd_spacer|small|\nadd_smalltext|`w" + items[9218].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Summer Tokens: `2" + Set_Count(pInfo(peer)->summer_token) + "|left|6198|\nadd_spacer|small|\nadd_textbox|`wClaim your " + items[9218].name + ".|left|\nadd_spacer|small|\nadd_button|buy4items_6|`oBuy|0|0|\nend_dialog|backto_clashrewards|Close|Back|");
				}
				if (guild_event_type == "Winter Clash") {
					if (type == "1") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[7576].name + "|left|7576|\nadd_spacer|small|\nadd_smalltext|`w" + items[7576].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Winter Tokens: `2" + Set_Count(pInfo(peer)->winter_token) + "|left|7328|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[7576].name + " for `2200 ``Winter Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->winter_token < 200 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy4items_1|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "2") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[5202].name + "|left|5202|\nadd_spacer|small|\nadd_smalltext|`w" + items[5202].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Winter Tokens: `2" + Set_Count(pInfo(peer)->winter_token) + "|left|7328|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[5202].name + " for `2400 ``Winter Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->winter_token < 400 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy4items_2|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "3") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[6286].name + "|left|6286|\nadd_spacer|small|\nadd_smalltext|`w" + items[6286].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Winter Tokens: `2" + Set_Count(pInfo(peer)->winter_token) + "|left|7328|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[6286].name + " for `2600 ``Winter Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->winter_token < 600 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy4items_3|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "4") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[7580].name + "|left|7580|\nadd_spacer|small|\nadd_smalltext|`w" + items[7580].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Winter Tokens: `2" + Set_Count(pInfo(peer)->winter_token) + "|left|7328|\nadd_spacer|small|\nadd_textbox|`wGet `210 ``" + items[7580].name + " for `2800 ``Winter Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->winter_token < 800 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy4items_4|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "5") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[7578].name + "|left|7578|\nadd_spacer|small|\nadd_smalltext|`w" + items[7578].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Winter Tokens: `2" + Set_Count(pInfo(peer)->winter_token) + "|left|7328|\nadd_spacer|small|\nadd_textbox|`wGet `21 ``" + items[7578].name + " for `21,000 ``Winter Tokens.|left|\nadd_spacer|small|" + (pInfo(peer)->winter_token < 1000 ? "\nadd_textbox|`wYou don't have enough Tokens.|left|\nadd_spacer|small|" : "\nadd_button|buy4items_5|`oBuy|0|0|") + "\nend_dialog|backto_clashrewards|Close|Back|");
					if (type == "6") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|`w" + items[9214].name + "|left|9214|\nadd_spacer|small|\nadd_smalltext|`w" + items[9214].description + "|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wYour Winter Tokens: `2" + Set_Count(pInfo(peer)->winter_token) + "|left|7328|\nadd_spacer|small|\nadd_textbox|`wClaim your " + items[9214].name + ".|left|\nadd_spacer|small|\nadd_button|buy4items_6|`oBuy|0|0|\nend_dialog|backto_clashrewards|Close|Back|");
				}
			}
			if (button == "personaleventleaderboard") {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n\nadd_label_with_icon|big|`0Top Players|left|6012|\nadd_spacer|" + (Event()->Can_Event ? top_basher_last : top_basher_list) + "|\nadd_spacer|\nadd_button|event_leaderboard|`oBack``|noflags|0|0|\nend_dialog|zz|Close||\n");
			}
			if (button == "guildmembercontribution") {
				uint32_t guild_id = pInfo(peer)->guild_id;string list = "";
				std::vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					std::vector<std::pair<long long int, string>> top_tiers;
					if (Event()->Can_Event == false) top_tiers = top_basher;
					else top_tiers = last_basher_list;
					sort(top_tiers.begin(), top_tiers.end());
					reverse(top_tiers.begin(), top_tiers.end());
					for (uint8_t i = 0; i < top_tiers.size(); i++) {
						for (GuildMember member_search : guild_information->guild_members) {
							if (to_lower(member_search.member_name) == to_lower(top_tiers[i].second)) {
								list += "\nadd_smalltext|" + to_string(i + 1) + " : " + top_tiers[i].second + ", Score: " + Set_Count(top_tiers[i].first) + "|";
							}
						}
					}
					if (list.empty()) list = "\nadd_smalltext|The list should update in few minutes..|";
				}
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n\nadd_label_with_icon|big|`0Guild Members Contribution|left|6012|\nadd_spacer|" + list + "|\nadd_spacer|\nadd_button|event_leaderboard|`oBack``|noflags|0|0|\nend_dialog|zz|Close||\n");
			}
			if (button == "personalleaderboardrewards") {
				if (guild_event_type == "Spring Clash") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n\nadd_label_with_icon|big|`0Personal Leaderboard Rewards``|left|6012|\nadd_smalltext|`$Compete with your fellow Growtopians to earn extra `2Spring Tokens ``(and maybe a medal or two) by getting the most point in Growtech's monthly events! Here are the rewards for each rank! These rewards are given out at the end of every event:|left|\nadd_spacer|small|\nadd_button|event_leaderboard|`0Back|noflags|0|0|\nadd_spacer|small|\nadd_textbox|`$1st place:|left|\nadd_label_with_icon|small|`$900 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_label_with_icon|small|`$1 Spring Event Player Medal: Gold|left|7968|\nadd_spacer|small|\nadd_textbox|`$2nd place:|left|\nadd_label_with_icon|small|`$720 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_label_with_icon|small|`$1 Spring Event Player Medal: Silver|left|7966|\nadd_spacer|small|\nadd_textbox|`$3rd place:|left|\nadd_label_with_icon|small|`$630 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_label_with_icon|small|`$1 Spring Event Player Medal: Bronze|left|7964|\nadd_spacer|small|\nadd_textbox|`$4th place:|left|\nadd_label_with_icon|small|`$540 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_spacer|small|\nadd_textbox|`$5th place:|left|\nadd_label_with_icon|small|`$450 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_spacer|small|\nadd_textbox|`$6th - 10th place:|left|\nadd_label_with_icon|small|`$360 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_spacer|small|\nadd_textbox|`$11th - 20th place:|left|\nadd_label_with_icon|small|`$330 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_spacer|small|\nadd_textbox|`$21th - 30th place:|left|\nadd_label_with_icon|small|`$300 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_spacer|small|\nadd_textbox|`$31th - 40th place:|left|\nadd_label_with_icon|smal|`$270 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_spacer|small|\nadd_textbox|`$41th - 50th place:|left|\nadd_label_with_icon|small|`$260 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_spacer|small|\nadd_textbox|`$51th - 75th place:|left|\nadd_label_with_icon|small|`$240 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_spacer|small|\nadd_textbox|`$76th - 100th place:|left|\nadd_label_with_icon|small|`$230 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_spacer|small|\nadd_textbox|`$101th - 200th place:|left|\nadd_label_with_icon|small|`$180 Spring Tokens|left|7844|\nadd_spacer|small|\nadd_textbox|`$201th - 300th place:|left|\nadd_label_with_icon|small|`$120 Spring Tokens|left|7844|\nadd_spacer|small|\nadd_textbox|`$301th - 400th place:|left|\nadd_label_with_icon|small|`$80 Spring Tokens|left|7844|\nadd_spacer|small|\nadd_textbox|`$401th - 500th place:|left|\nadd_label_with_icon|small|`$50 Spring Tokens|left|7844|\nadd_spacer|small|\nend_dialog|grow_event|Close|Back|");
				if (guild_event_type == "Summer Clash") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n\nadd_label_with_icon|big|`0Personal Leaderboard Rewards``|left|6012|\nadd_smalltext|`$Compete with your fellow Growtopians to earn extra `2Summer Tokens ``(and maybe a medal or two) by getting the most point in Growtech's monthly events! Here are the rewards for each rank! These rewards are given out at the end of every event:|left|\nadd_spacer|small|\nadd_button|event_leaderboard|`0Back|noflags|0|0|\nadd_spacer|small|\nadd_textbox|`$1st place:|left|\nadd_label_with_icon|small|`$900 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_label_with_icon|small|`$1 Summer Event Player Medal: Gold|left|6094|\nadd_spacer|small|\nadd_textbox|`$2nd place:|left|\nadd_label_with_icon|small|`$720 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_label_with_icon|small|`$1 Summer Event Player Medal: Silver|left|6132|\nadd_spacer|small|\nadd_textbox|`$3rd place:|left|\nadd_label_with_icon|small|`$630 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_label_with_icon|small|`$1 Summer Event Player Medal: Bronze|left|6130|\nadd_spacer|small|\nadd_textbox|`$4th place:|left|\nadd_label_with_icon|small|`$540 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_spacer|small|\nadd_textbox|`$5th place:|left|\nadd_label_with_icon|small|`$450 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_spacer|small|\nadd_textbox|`$6th - 10th place:|left|\nadd_label_with_icon|small|`$360 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_spacer|small|\nadd_textbox|`$11th - 20th place:|left|\nadd_label_with_icon|small|`$330 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_spacer|small|\nadd_textbox|`$21th - 30th place:|left|\nadd_label_with_icon|small|`$300 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_spacer|small|\nadd_textbox|`$31th - 40th place:|left|\nadd_label_with_icon|smal|`$270 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_spacer|small|\nadd_textbox|`$41th - 50th place:|left|\nadd_label_with_icon|small|`$260 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_spacer|small|\nadd_textbox|`$51th - 75th place:|left|\nadd_label_with_icon|small|`$240 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_spacer|small|\nadd_textbox|`$76th - 100th place:|left|\nadd_label_with_icon|small|`$230 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_spacer|small|\nadd_textbox|`$101th - 200th place:|left|\nadd_label_with_icon|small|`$180 Summer Tokens|left|6198|\nadd_spacer|small|\nadd_textbox|`$201th - 300th place:|left|\nadd_label_with_icon|small|`$120 Summer Tokens|left|6198|\nadd_spacer|small|\nadd_textbox|`$301th - 400th place:|left|\nadd_label_with_icon|small|`$80 Summer Tokens|left|6198|\nadd_spacer|small|\nadd_textbox|`$401th - 500th place:|left|\nadd_label_with_icon|small|`$50 Summer Tokens|left|6198|\nadd_spacer|small|\nend_dialog|grow_event|Close|Back|");
				if (guild_event_type == "Winter Clash") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n\nadd_label_with_icon|big|`0Personal Leaderboard Rewards``|left|6012|\nadd_smalltext|`$Compete with your fellow Growtopians to earn extra `2Winter Tokens ``(and maybe a medal or two) by getting the most point in Growtech's monthly events! Here are the rewards for each rank! These rewards are given out at the end of every event:|left|\nadd_spacer|small|\nadd_button|event_leaderboard|`0Back|noflags|0|0|\nadd_spacer|small|\nadd_textbox|`$1st place:|left|\nadd_label_with_icon|small|`$900 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_label_with_icon|small|`$1 Winter Event Player Medal: Gold|left|7334|\nadd_spacer|small|\nadd_textbox|`$2nd place:|left|\nadd_label_with_icon|small|`$720 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_label_with_icon|small|`$1 Winter Event Player Medal: Silver|left|7332|\nadd_spacer|small|\nadd_textbox|`$3rd place:|left|\nadd_label_with_icon|small|`$630 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_label_with_icon|small|`$1 Winter Event Player Medal: Bronze|left|7330|\nadd_spacer|small|\nadd_textbox|`$4th place:|left|\nadd_label_with_icon|small|`$540 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_spacer|small|\nadd_textbox|`$5th place:|left|\nadd_label_with_icon|small|`$450 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_spacer|small|\nadd_textbox|`$6th - 10th place:|left|\nadd_label_with_icon|small|`$360 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_spacer|small|\nadd_textbox|`$11th - 20th place:|left|\nadd_label_with_icon|small|`$330 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_spacer|small|\nadd_textbox|`$21th - 30th place:|left|\nadd_label_with_icon|small|`$300 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_spacer|small|\nadd_textbox|`$31th - 40th place:|left|\nadd_label_with_icon|smal|`$270 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_spacer|small|\nadd_textbox|`$41th - 50th place:|left|\nadd_label_with_icon|small|`$260 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_spacer|small|\nadd_textbox|`$51th - 75th place:|left|\nadd_label_with_icon|small|`$240 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_spacer|small|\nadd_textbox|`$76th - 100th place:|left|\nadd_label_with_icon|small|`$230 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$1 Growtoken|left|1486|\nadd_spacer|small|\nadd_textbox|`$101th - 200th place:|left|\nadd_label_with_icon|small|`$180 Winter Tokens|left|7328|\nadd_spacer|small|\nadd_textbox|`$201th - 300th place:|left|\nadd_label_with_icon|small|`$120 Winter Tokens|left|7328|\nadd_spacer|small|\nadd_textbox|`$301th - 400th place:|left|\nadd_label_with_icon|small|`$80 Winter Tokens|left|7328|\nadd_spacer|small|\nadd_textbox|`$401th - 500th place:|left|\nadd_label_with_icon|small|`$50 Winter Tokens|left|7328|\nadd_spacer|small|\nend_dialog|grow_event|Close|Back|");
			}
			if (button == "guildeventleaderboard") {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n\nadd_label_with_icon|big|`0Top Guilds``|left|6012|\nadd_spacer|" + (Event()->Can_Event ? top_guild_last : top_guild_list) + "\nadd_spacer|\nadd_button|event_leaderboard|`oBack``|noflags|0|0|\nend_dialog|zz|Close||\nadd_quick_exit|");
			}
			if (button == "guildleaderboardrewards") {
				if (guild_event_type == "Spring Clash") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n\nadd_label_with_icon|big|`0Guild Leaderboard Rewards``|left|6012|\nadd_smalltext|`$Compete with other guilds to earn extra `2Spring Tokens ``(and bonus prizes for your Guild Leader!) by getting the most points in GrowTech's montly events. These rewards are given out at the end of every event!.|left|\nadd_smalltext|`6Note: `$All guild members receive `2Spring Tokens`$, but only Leaders get other prizes, too!|left|\nadd_spacer|small|\nadd_button|event_leaderboard|`0Back|noflags|0|0|\nadd_spacer|small|\nadd_textbox|`$1st place:|left|\nadd_label_with_icon|small|`2800 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$1 Spring Event Guild Medal: Gold|left|7974|\nadd_label_with_icon|small|`$5 Random Guild Potion|left|5934|\nadd_label_with_icon|small|`$1 Weather Machine - Guild|left|6280|\nadd_spacer|small|\nadd_textbox|`$2nd place:|left|\nadd_label_with_icon|small|`2640 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$1 Spring Event Guild Medal: Silver|left|7972|\nadd_label_with_icon|small|`$4 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$3rd place:|left|\nadd_label_with_icon|small|`2560 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$1 Spring Event Guild Medal: Bronze|left|7970|\nadd_label_with_icon|small|`$4 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$4th place:|left|\nadd_label_with_icon|small|`2480 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$4 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$5th place:|left|\nadd_label_with_icon|small|`2400 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$4 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$6th - 10th place:|left|\nadd_label_with_icon|small|`2320 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$3 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$11th - 20th place:|left|\nadd_label_with_icon|small|`2290 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$2 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$21th - 30th place:|left|\nadd_label_with_icon|small|`2260 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$2 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$31th - 40th place:|left|\nadd_label_with_icon|small|`2240 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$2 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$41th - 50th place:|left|\nadd_label_with_icon|small|`2230 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$2 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$51th - 75th place:|left|\nadd_label_with_icon|small|`2210 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$2 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$76th - 100th place:|left|\nadd_label_with_icon|small|`2200 Spring Tokens|left|7844|\nadd_label_with_icon|small|`$1 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$101th - 200th place:|left|\nadd_label_with_icon|small|`2160 Spring Tokens|left|7844|\nadd_spacer|small|\nadd_textbox|`$201th - 300th place:|left|\nadd_label_with_icon|small|`2100 Spring Tokens|left|7844|\nadd_spacer|small|\nadd_textbox|`$301th - 400th place:|left|\nadd_label_with_icon|small|`270 Spring Tokens|left|7844|\nadd_spacer|small|\nadd_textbox|`$401th - 500th place:|left|\nadd_label_with_icon|small|`240 Spring Tokens|left|7844|\nadd_spacer|small|\nend_dialog|grow_event|Close|Back|");
				if (guild_event_type == "Summer Clash") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n\nadd_label_with_icon|big|`0Guild Leaderboard Rewards``|left|6012|\nadd_smalltext|`$Compete with other guilds to earn extra `2Summer Tokens ``(and bonus prizes for your Guild Leader!) by getting the most points in GrowTech's montly events. These rewards are given out at the end of every event!.|left|\nadd_smalltext|`6Note: `$All guild members receive `2Summer Tokens`$, but only Leaders get other prizes, too!|left|\nadd_spacer|small|\nadd_button|event_leaderboard|`0Back|noflags|0|0|\nadd_spacer|small|\nadd_textbox|`$1st place:|left|\nadd_label_with_icon|small|`2800 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$1 Summer Event Guild Medal: Gold|left|6138|\nadd_label_with_icon|small|`$5 Random Guild Potion|left|5934|\nadd_label_with_icon|small|`$1 Weather Machine - Guild|left|6280|\nadd_spacer|small|\nadd_textbox|`$2nd place:|left|\nadd_label_with_icon|small|`2640 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$1 Summer Event Guild Medal: Silver|left|6136|\nadd_label_with_icon|small|`$4 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$3rd place:|left|\nadd_label_with_icon|small|`2560 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$1 Summer Event Guild Medal: Bronze|left|6134|\nadd_label_with_icon|small|`$4 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$4th place:|left|\nadd_label_with_icon|small|`2480 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$4 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$5th place:|left|\nadd_label_with_icon|small|`2400 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$4 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$6th - 10th place:|left|\nadd_label_with_icon|small|`2320 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$3 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$11th - 20th place:|left|\nadd_label_with_icon|small|`2290 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$2 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$21th - 30th place:|left|\nadd_label_with_icon|small|`2260 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$2 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$31th - 40th place:|left|\nadd_label_with_icon|small|`2240 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$2 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$41th - 50th place:|left|\nadd_label_with_icon|small|`2230 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$2 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$51th - 75th place:|left|\nadd_label_with_icon|small|`2210 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$2 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$76th - 100th place:|left|\nadd_label_with_icon|small|`2200 Summer Tokens|left|6198|\nadd_label_with_icon|small|`$1 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$101th - 200th place:|left|\nadd_label_with_icon|small|`2160 Summer Tokens|left|6198|\nadd_spacer|small|\nadd_textbox|`$201th - 300th place:|left|\nadd_label_with_icon|small|`2100 Summer Tokens|left|6198|\nadd_spacer|small|\nadd_textbox|`$301th - 400th place:|left|\nadd_label_with_icon|small|`270 Summer Tokens|left|6198|\nadd_spacer|small|\nadd_textbox|`$401th - 500th place:|left|\nadd_label_with_icon|small|`240 Summer Tokens|left|6198|\nadd_spacer|small|\nend_dialog|grow_event|Close|Back|");
				if (guild_event_type == "Winter Clash") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n\nadd_label_with_icon|big|`0Guild Leaderboard Rewards``|left|6012|\nadd_smalltext|`$Compete with other guilds to earn extra `2Winter Tokens ``(and bonus prizes for your Guild Leader!) by getting the most points in GrowTech's montly events. These rewards are given out at the end of every event!.|left|\nadd_smalltext|`6Note: `$All guild members receive `2Winter Tokens`$, but only Leaders get other prizes, too!|left|\nadd_spacer|small|\nadd_button|event_leaderboard|`0Back|noflags|0|0|\nadd_spacer|small|\nadd_textbox|`$1st place:|left|\nadd_label_with_icon|small|`2800 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$1 Winter Event Guild Medal: Gold|left|7340|\nadd_label_with_icon|small|`$5 Random Guild Potion|left|5934|\nadd_label_with_icon|small|`$1 Weather Machine - Guild|left|6280|\nadd_spacer|small|\nadd_textbox|`$2nd place:|left|\nadd_label_with_icon|small|`2640 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$1 Winter Event Guild Medal: Silver|left|7338|\nadd_label_with_icon|small|`$4 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$3rd place:|left|\nadd_label_with_icon|small|`2560 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$1 Winter Event Guild Medal: Bronze|left|7336|\nadd_label_with_icon|small|`$4 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$4th place:|left|\nadd_label_with_icon|small|`2480 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$4 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$5th place:|left|\nadd_label_with_icon|small|`2400 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$4 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$6th - 10th place:|left|\nadd_label_with_icon|small|`2320 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$3 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$11th - 20th place:|left|\nadd_label_with_icon|small|`2290 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$2 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$21th - 30th place:|left|\nadd_label_with_icon|small|`2260 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$2 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$31th - 40th place:|left|\nadd_label_with_icon|small|`2240 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$2 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$41th - 50th place:|left|\nadd_label_with_icon|small|`2230 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$2 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$51th - 75th place:|left|\nadd_label_with_icon|small|`2210 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$2 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$76th - 100th place:|left|\nadd_label_with_icon|small|`2200 Winter Tokens|left|7328|\nadd_label_with_icon|small|`$1 Random Guild Potion|left|5934|\nadd_spacer|small|\nadd_textbox|`$101th - 200th place:|left|\nadd_label_with_icon|small|`2160 Winter Tokens|left|7328|\nadd_spacer|small|\nadd_textbox|`$201th - 300th place:|left|\nadd_label_with_icon|small|`2100 Winter Tokens|left|7328|\nadd_spacer|small|\nadd_textbox|`$301th - 400th place:|left|\nadd_label_with_icon|small|`270 Winter Tokens|left|7328|\nadd_spacer|small|\nadd_textbox|`$401th - 500th place:|left|\nadd_label_with_icon|small|`240 Winter Tokens|left|7328|\nadd_spacer|small|\nend_dialog|grow_event|Close|Back|");
			}
		}
		else {
			DialogHandle::Event_Leaderboard(peer, "Seasonal_Clash", 500);
		}
	}
	static void grow_event(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "event_leaderboard") {
				bool has_ = false;
				if (top_basher.empty() && Event()->Can_Event) {
					auto it = std::find_if(last_guild_last.begin(), last_guild_last.end(), [&](const std::pair<long long int, std::string>& element) {
						return element.second == std::to_string(pInfo(peer)->guild_id); });
					if (it != last_guild_last.end() && it->first > 0) {
						has_ = true;
					}
				}
				else {
					auto it = std::find_if(top_guild.begin(), top_guild.end(), [&](const std::pair<long long int, std::string>& element) {
						return element.second == std::to_string(pInfo(peer)->guild_id); });
					if (it != top_guild.end() && it->first > 0) {
						has_ = true;
					}
				}
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Grow Event Leaderboards|left|6012|\nadd_button|personaleventleaderboard|`0Personal Event Leaderboard``|noflags|0|0|\nadd_button|personalleaderboardrewards|`0Personal Event Leaderboard Rewards|noflags|0|0|\nadd_button|guildeventleaderboard|`0Guild Event Leaderboard``|noflags|0|0|\nadd_button|guildleaderboardrewards|`0Guild Event Leaderboard Rewards``|noflags|0|0|" + (has_ ? "\nadd_button|guildmembercontribution|`0Guild Member Contribution``|noflags|0|0|" : "") + "\nend_dialog|backto_leaderboard|Close|Back|\nadd_quick_exit|");
			}
		}
		else {
			bool has_ = false;
			if (top_basher.empty() && Event()->Can_Event) {
				auto it = std::find_if(last_guild_last.begin(), last_guild_last.end(), [&](const std::pair<long long int, std::string>& element) {
					return element.second == std::to_string(pInfo(peer)->guild_id); });
				if (it != last_guild_last.end() && it->first > 0) {
					has_ = true;
				}
			}
			else {
				auto it = std::find_if(top_guild.begin(), top_guild.end(), [&](const std::pair<long long int, std::string>& element) {
					return element.second == std::to_string(pInfo(peer)->guild_id); });
				if (it != top_guild.end() && it->first > 0) {
					has_ = true;
				}
			}
			VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|\nadd_label_with_icon|big|Grow Event Leaderboards|left|6012|\nadd_button|personaleventleaderboard|`0Personal Event Leaderboard``|noflags|0|0|\nadd_button|personalleaderboardrewards|`0Personal Event Leaderboard Rewards|noflags|0|0|\nadd_button|guildeventleaderboard|`0Guild Event Leaderboard``|noflags|0|0|\nadd_button|guildleaderboardrewards|`0Guild Event Leaderboard Rewards``|noflags|0|0|" + (has_ ? "\nadd_button|guildmembercontribution|`0Guild Member Contribution``|noflags|0|0|" : "") + "\nend_dialog|backto_leaderboard|Close|Back|\nadd_quick_exit|");
		}
	}
	static void wls(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "Seasonal_Clash") DialogHandle::Event_Leaderboard(peer, "Seasonal_Clash", 500);
			if (button == "Recycle_Lock" or button == "BackTo_Leaderboard") DialogHandle::Event_Leaderboard(peer, "Recycle_Lock", 500);
			if (button == "Punched") DialogHandle::Event_Leaderboard(peer, "Punched", 500);
			if (button == "Richest") DialogHandle::Event_Leaderboard(peer, "Richest", 500);
			if (button == "event_recycle") {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n\nadd_label_with_icon|big|`0Recycle Locks``|left|8470|\nadd_smalltext|`4How many to recycle? (minimum 100)``|left|\nadd_textbox|You have " + Set_Count(get_wls(peer, true)) + " World Locks.|left|\nadd_text_input|howmuch|||7|\nadd_spacer|\nadd_button|recycle|`9Recycle``|noflags|0|0|\nadd_button|BackTo_Leaderboard|`wBack|\nend_dialog|wls|||\nadd_quick_exit|");
			}
			if (button == "showwlspersonalleaderboard") {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`0Top Recycle|left|8470|\nadd_spacer|" + top_wls_list + "|\nadd_spacer|small|\nend_quick_exit|\nadd_button|BackTo_Leaderboard|`wBack|\nend_dialog|wls|Close||\n", 500);
			}
			if (button == "event_rewards_topwls") {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`0Recycle Locks``|left|8470|\nadd_smalltext|`$Earn rewards by participating in Recycle events! The point you earn by Recycle Locks will unlock the milestone below. Here are the rewards for each rank! These rewards are given out at the end of every event:|left|\nadd_spacer|small|\nadd_textbox|`$1st place:|left|\nadd_label_with_icon|small|`$Permanent Vip Role|left|9882|\nadd_label_with_icon|small|`$5 " + Environment()->server_name + " Coin|left|244|\nadd_spacer|small|\nadd_textbox|`$2nd place:|left|\nadd_label_with_icon|small|`$Golden Legendary Wings|left|10684|\nadd_label_with_icon|small|`$5 " + Environment()->server_name + " Coin|left|244|\nadd_spacer|small|\nadd_textbox|3rd place:|left|\nadd_label_with_icon|small|`$Rosewater Dragonlance|left|10940|\nadd_label_with_icon|small|`$5 " + Environment()->server_name + " Coin|left|244|\nadd_spacer|small|\nadd_textbox|4th place:|left|\nadd_label_with_icon|small|`$Leonidas Scythe|left|9774|\nadd_label_with_icon|small|`$5 " + Environment()->server_name + " Coin|left|244|\nadd_spacer|small|\nadd_textbox|`$5th place:|left|\nadd_label_with_icon|small|`$5 " + Environment()->server_name + " Coin|left|244|\nadd_spacer|small|\nadd_textbox|`$6th - 10th place:|left|\nadd_label_with_icon|small|`$5 " + Environment()->server_name + " Coin|left|244|\nadd_spacer|small|\nadd_textbox|`$11th - 20th place:|left|\nadd_label_with_icon|small|`$5 " + Environment()->server_name + " Coin|left|244|\nadd_spacer|small|\nadd_quick_exit|\nadd_button|BackTo_Leaderboard|`wBack|\nend_dialog|wls|Close||\n", 500);
			}
			if (button == "claim_event_wls") {
				if (pInfo(peer)->has_claim_event_wls) return;
				int prize = 0, get_him = 1, prized = 0, get_wls = 5;
				std::string contribute = "", prize_ = "", prize_1 = "";
				for (uint16_t i = 0; i < top_wls.size(); i++) {
					if (to_lower(top_wls[i].second) == to_lower(pInfo(peer)->tankIDName)) {
						prize = i + 1;
					}
				}
				if (prize == 1) {
					prize_ += "Vip Role ";
					pInfo(peer)->Role.Vip = true;
				}
				if (prize == 2) prized = 10684;
				if (prize == 3) prized = 10940;
				if (prize == 4) prized = 9774;
				if (prize == 5) prized = 9906;
				if (prize > 5 && prize <= 11);
				if (prize > 10 && prize <= 20);
				if (prized != 0) {
					if (Inventory::Modify(peer, prized, get_him) == 0) {
						prize_1 += (prize_.empty() ? "" : prize_ + "and ") + items[prized].ori_name + " ";
					}
				}
				pInfo(peer)->gtwl += get_wls;
				contribute += (prize_.empty() and prize_1.empty() ? "" : prize_ + prize_1 + "and ") + Set_Count(get_wls) + " " + Environment()->server_name + " Coin";
				VarList::OnConsoleMessage(peer, "Thanks for participating in our event, you ended up being #" + to_string(prize) + " (Your prize: `5" + contribute + "``).");
				VarList::OnAddNotification(peer, "You claimed your Recycle Event reward!", "interface/guide_arrow.rttex", "audio/piano_nice.wav.wav");
				pInfo(peer)->has_claim_event_wls = true;
				pInfo(peer)->wls_participated = false;
				PlayerMoving data_{};
				data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
				BYTE* raw = packPlayerMoving(&data_);
				send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				delete[] raw;
			}
			if (button == "recycle") {
				if (wls_event_time - time(nullptr) <= 0) return;
				if (pInfo(peer)->world.empty()) return;
				std::vector<std::string> t_ = explode("|", cch);
				if (t_.size() < 4) return;
				int wls = std::atoi(explode("\n", t_[4])[0].c_str());
				if (get_wls(peer, true) >= wls && wls >= 100) {
					get_wls(peer, true, true, wls);
					VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Thank you for your generosity!", 0, 1);
					EventPool::Recycle::Point::Add(peer, wls);
				}
				else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough world locks or the minimum deposit didn't reach 100!", 0, 1);
			}
		}
	}
	static void consum_gems(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string count = parser.get("count", 1);
		int c_ = std::atoi(count.c_str()), got = 0;
		int count_ = Inventory::Contains(peer, 4490);
		if (count.size() > 3 || c_ > 200 || c_ < 0 || c_ > count_) return;
		PlayerMoving data2_{};
		data2_.x = pInfo(peer)->x + 16, data2_.y = pInfo(peer)->y + 16, data2_.packetType = 19, data2_.punchX = 9438, data2_.punchY = pInfo(peer)->netID;
		int32_t to_netid = pInfo(peer)->netID;
		BYTE* raw2 = packPlayerMoving(&data2_);
		raw2[3] = 5;
		memcpy(raw2 + 8, &to_netid, 4);
		send_raw(peer, 4, raw2, 56, ENET_PACKET_FLAG_RELIABLE);
		delete[] raw2;
		VarList::OnBuxGems(peer, c_ * items[4490].max_gems3);
		Inventory::Modify(peer, 4490, got = -c_);
		VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`6[``You received " + Set_Count(c_ * items[4490].max_gems3) + " Gems```6]``", 0, 0);
	}
	static void requestcreateguildpage(ENetPeer* peer, std::string cch) {
		if (pInfo(peer)->guild_id != 0) return;
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "back") {
				DialogHandle::Social_Portal(peer);
			}
			if (button == "showcreateguild") {
				VarList::OnDialogRequest(peer, get_guild_create(peer));
			}
		}
	}
	static void unaccess(ENetPeer* peer, std::string cch) {
		std::string name_ = pInfo(peer)->world;
		std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
			bool upd_ = false;
			for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
				if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
					WorldBlock* block_ = &world_->blocks[i_];
					if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) {
						if (find(block_->admins.begin(), block_->admins.end(), to_lower(pInfo(peer)->tankIDName)) != block_->admins.end()) {
							block_->admins.erase(remove(block_->admins.begin(), block_->admins.end(), to_lower(pInfo(peer)->tankIDName)), block_->admins.end());
							tile_update(peer, world_, block_, i_ % xSize, i_ / xSize);
							upd_ = true;
						}
					}
					else {
						if (find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(peer)->tankIDName)) != world_->admins.end()) {
							world_->admins.erase(remove(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(peer)->tankIDName)), world_->admins.end());
							tile_update(peer, world_, block_, i_ % xSize, i_ / xSize);
							upd_ = true;
							VisualHandle::Nick(peer, NULL);
						}
					}
				}
			}
			if (upd_) {
				CAction::Log(peer, "action|play_sfx\nfile|audio/dialog_cancel.wav\ndelayMS|0");
				VarList::OnConsoleMessage(peer, "Removed your access from all locks.");
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Removed your access from all locks.", 0, 0);
				pInfo(peer)->name_color = (Role::Developer(peer) ? "`6@" : Role::Administrator(peer) ? "`e@" : Role::Moderator(peer) ? "`#@" : Role::Vip(peer) ? "`w[`1VIP`w] " : (to_lower(pInfo(peer)->tankIDName) == to_lower(world_->owner_name)) ? "`2" : "`0");
				VisualHandle::Nick(peer, NULL);
			}
			else {
				VarList::OnConsoleMessage(peer, "You didn't have access on any locks!");
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You didn't have access on any locks!", 0, 0);
			}
		}
	}
	static void show_guild_logs(ENetPeer* peer, std::string cch) {
		if (pInfo(peer)->guild_id == 0) return;
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "back") {
				std::string guild_info = get_guild_info(peer);
				if (guild_info == "set_default_color|`o\nadd_label_with_icon|big|`wGrow Guild ``|left|5814|\nadd_textbox|Something went wrong!|left|\nend_dialog|guildalreadyjoined|Close||") set_Guilds(peer);
				VarList::OnDialogRequest(peer, guild_info);
			}
		}
	}
	static void acceptaccess(ENetPeer* peer, std::string cch) {
		if (pInfo(peer)->access_offers.size() == 0) return;
		for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
			if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
			if (pInfo(cp_)->world == pInfo(peer)->world) {
				if (pInfo(peer)->access_offers.find(pInfo(cp_)->netID) != pInfo(peer)->access_offers.end()) {
					std::string name_ = pInfo(peer)->world;
					std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
					if (p != worlds.end()) {
						World* world_ = &worlds[p - worlds.begin()];
						if (world_->admins.size() >= 26) {
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "World has reached access limit!", 0, 0);
							return;
						}
						std::string peer_name = to_lower(pInfo(peer)->tankIDName), owner_name = to_lower(world_->owner_name), user_name = to_lower(pInfo(cp_)->tankIDName);
						int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
						int x_ = (pInfo(peer)->access_offers[pInfo(cp_)->netID]) % xSize, y_ = (pInfo(peer)->access_offers[pInfo(cp_)->netID]) / xSize;
						if (x_ < 0 or y_ < 0) return;
						if (y_ >= world_->max_y || x_ >= world_->max_x) return;
						WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
						if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) {
							if (to_lower(block_->owner_name) != user_name) return;
							if (block_->admins.size() >= 26) {
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Lock has reached access limit!", 0, 0);
								return;
							}
							block_->admins.push_back(to_lower(peer_name));
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED || pInfo(peer)->world != pInfo(cp_)->world) continue;
								VarList::OnConsoleMessage(cp_, get_player_nick(peer) + " was given access to a " + items[block_->fg].name + ".");
							}
							tile_update(peer, world_, block_, x_, y_);
						}
						else {
							if (owner_name != user_name) return;
							if (world_->admins.size() >= 26) {
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "World has reached access limit!", 0, 0);
								return;
							}
							world_->admins.push_back(to_lower(peer_name));
							if (pInfo(peer)->name_color == "`0") pInfo(peer)->name_color = "`^";
							VisualHandle::Nick(peer, NULL);
							for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
								if (cp_->state != ENET_PEER_STATE_CONNECTED || pInfo(peer)->world != pInfo(cp_)->world) continue;
								VarList::OnConsoleMessage(cp_, get_player_nick(peer) + " was given access to a " + items[block_->fg].name + ".");
							}
							tile_update(peer, world_, block_, x_, y_);
						}
						CAction::Log(peer, "action|play_sfx\nfile|audio/secret.wav\ndelayMS|0");
					}
					pInfo(peer)->access_offers.clear();
					return;
				}
			}
		}
		VarList::OnTalkBubble(peer, pInfo(peer)->netID, "The lock owner has left!", 0, 0);
		pInfo(peer)->access_offers.clear();
		return;
	}
	static void Guild_Notebook(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "save_notebook") {
				std::string new_stat = parser.get("guildnote", 1);
				uint32_t guild_id = pInfo(peer)->guild_id;
				std::vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					guild_information->guild_notebook = new_stat;
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
						if (pInfo(peer)->guild_id != 0) {
							if (pInfo(peer)->guild_id == pInfo(cp_)->guild_id) VarList::OnConsoleMessage(cp_, "`5[Guild-Note] `o " + new_stat + "");
						}
					}
					send_wrench_self(peer);
				}
			}
			else if (button == "cancel_notebook") {
				send_wrench_self(peer);
			}
			else if (button == "clear_notebook") {
				uint32_t guild_id = pInfo(peer)->guild_id;
				std::vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					guild_information->guild_notebook = "";
					send_wrench_self(peer);
				}
			}
		}
	}
	static void upgrading_guild(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "back") {
				std::string name_ = pInfo(peer)->world;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					int x_ = 0, y_ = 0;
					int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
					{
						std::vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return a.fg == 5814; });
						if (p != world_->blocks.end()) {
							int i_ = p - world_->blocks.begin();
							x_ = i_ % xSize;
							y_ = i_ / xSize;
						}
					}
					WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
					DialogHandle::Lock(peer, world_, block_->fg, x_, y_);
				}
			}
			else if (button == "upgrade_guild") {
				uint32_t guild_id = pInfo(peer)->guild_id;
				if (guild_id == 0) return;
				std::vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					guild_information->guild_settings &= ~SETTINGS::SETTINGS_0;
					guild_information->guild_settings |= SETTINGS::SETTINGS_0;
					if (guild_information->guild_level > guild_lvl.size()) {
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`0Your guild is already max level!", 0, 0);
					}
					else {
						if (guild_information->guild_xp >= guild_lvl[guild_information->guild_level - 1][0]) {
							if (pInfo(peer)->gems < guild_lvl[guild_information->guild_level - 1][1]) {
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`0You don't have enough gems!``", 0, 0);
							}
							else {
								for (GuildMember member_search : guild_information->guild_members) {
									if (to_lower(member_search.member_name) == to_lower(pInfo(peer)->tankIDName)) {
										if (member_search.role_id == 3) {
											string name_ = pInfo(peer)->world;
											std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
											if (p != worlds.end()) {
												World* world_ = &worlds[p - worlds.begin()];
												WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
												if (block_->fg != 5814) return;
												VarList::OnBuxGems(peer, guild_lvl[guild_information->guild_level - 1][1] * -1);
												guild_information->guild_level++;
												guild_information->guild_xp = 0;
												PlayerMoving data_{};
												data_.packetType = 5, data_.punchX = pInfo(peer)->lastwrenchx, data_.punchY = pInfo(peer)->lastwrenchy, data_.characterState = 0x8;
												BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
												BYTE* blc = raw + 56;
												form_visual(blc, *block_, *world_, peer, false);
												for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
													if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
													if (pInfo(cp_)->world == pInfo(peer)->world) {
														send_raw(cp_, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
													}
													if (pInfo(cp_)->guild_id == guild_id) {
														VarList::OnConsoleMessage(cp_, "`5[GUILD ALERT]`` " + pInfo(peer)->tankIDName + " Upgraded Guild to Level " + to_string(guild_information->guild_level) + "!");
													}
												}
												VarList::OnAddNotification(peer, "`wAwesome! You reached Guild Level " + to_string(guild_information->guild_level) + "``", "interface/large/guild_levelup.rttex", "audio/hub_open.wav");
											}
										}
									}
								}
							}
						}
					}
				}
				return;
			}
		}
	}
	static void sdbrespond(ENetPeer* peer, std::string cch) {
		Enter_World(peer, Environment()->Sdb_World);
	}
	static void sdbsend(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string line_1 = parser.get("sdb_1", 1), line_2 = parser.get("sdb_2", 1), line_3 = parser.get("sdb_3", 1);
		if (line_1.empty() and line_2.empty() and line_3.empty()) {
			gamepacket_t p;
			p.Insert("OnTalkBubble");
			p.Insert(pInfo(peer)->netID);
			p.Insert("`5[`2I'm not wasting Growtokens on an empty broadcast!``]``");
			p.Insert(0), p.Insert(0);
			p.CreatePacket(peer);
			return;
		}
		if (Playmods::HasById(pInfo(peer), 3)) {
			int time_ = 0;
			for (PlayMods peer_playmod : pInfo(peer)->playmods) {
				if (peer_playmod.id == 13) {
					time_ = peer_playmod.time - time(nullptr);
				}
			}
			CAction::Log(peer, "action|log\nmsg|>> (" + Time::Playmod(time_) + " before you can broadcast again)", "");
			return;
		}
		std::string name_ = pInfo(peer)->world;
		std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			bool jammed = find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) != world_->active_jammers.end() ? true : false;
			if (pInfo(peer)->m_h == 1) jammed = true;
			int b = -200;
			int totaltoken = 0, tokencount = 0, mega_token = 0, token = 200;
			Inventory::Modify(peer, 1486, tokencount);
			Inventory::Modify(peer, 6802, mega_token);
			totaltoken = tokencount + (mega_token * 100);
			if (totaltoken < token) {
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(peer)->netID);
				p.Insert("You need 200 Growtoken to do this!");
				p.Insert(0), p.Insert(1);
				p.CreatePacket(peer);
				{
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("You need 200 Growtoken to do this!");
					p.CreatePacket(peer);
				}
			}
			else {
				{
					Playmods::Add(peer, 13);
					CAction::Log(peer, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
				}
				gamepacket_t p;
				p.Insert("OnSDBroadcast");
				p.Insert((get_player_nick(peer) + "``") + "\n" + (jammed ? "`4JAMMED!``" : pInfo(peer)->world) + "\n" + line_1 + "\n" + line_2 + "\n" + line_3);
				p.Insert(jammed ? 0 : 1);
				if (not jammed) {
					Environment()->Sdb_World = pInfo(peer)->world;
					Environment()->Sb_World = pInfo(peer)->world;
				}
				for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
					if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(cp_)->radio or pInfo(cp_)->surgery_started or pInfo(cp_)->world.empty()) continue;
					p.CreatePacket(cp_);
				}
				if (tokencount >= token) Inventory::Modify(peer, 1486, token *= -1);
				else {
					Inventory::Modify(peer, 1486, tokencount *= -1);
					Inventory::Modify(peer, 6802, mega_token *= -1);
					int givemegatoken = (totaltoken - token) / 100;
					int givetoken = (totaltoken - token) - (givemegatoken * 100);
					Inventory::Modify(peer, 1486, givetoken);
					Inventory::Modify(peer, 6802, givemegatoken);
				}
			}
		}
	}
	static void sign_edit(ENetPeer* peer, std::string cch) {
		if (not is_number(std::string(get_embed(cch, "tilex"))) or not is_number(std::string(get_embed(cch, "tiley")))) return;
		int x_ = std::atoi(get_embed(cch, "tilex").c_str()), y_ = std::atoi(get_embed(cch, "tiley").c_str());
		TextScanner parser(cch);
		std::string tekstas = parser.get("sign_text", 1);
		if (x_ < 0 or y_ < 0 or tekstas.size() > 128) return;
		if (abs(pInfo(peer)->x / 32 - x_) > 5 || abs(pInfo(peer)->y / 32 - y_) > 5) return;
		std::string name_ = pInfo(peer)->world;
		std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			if (x_ >= world_->max_x || y_ >= world_->max_y) return;
			WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
			if (block_->txt == tekstas or block_->fg == 0 or items[block_->fg].blockType != BlockTypes::SIGN) return;
			if (Only_Access(peer, world_, block_)) {
				if (items[block_->fg].path_marker) {
					transform(tekstas.begin(), tekstas.end(), tekstas.begin(), ::toupper);
					block_->door_id = tekstas;
				}
				else {
					block_->txt = tekstas;
					tile_update(peer, world_, block_, x_, y_);
				}
			}
		}
	}
	static void confirmguildlockkey(ENetPeer* peer, std::string cch) {
		std::string name_ = pInfo(peer)->world;
		std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			if (to_lower(world_->owner_name) != to_lower(pInfo(peer)->tankIDName)) return;
			int c_ = 0;
			Inventory::Modify(peer, 5816, c_);
			if (c_ != 0) return;
			std::vector<WorldBlock>::iterator pf = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return a.fg == 202 || a.fg == 204 || a.fg == 206 || a.fg == 4994 || a.fg == 10000; });
			if (pf != world_->blocks.end()) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "To trade a world, you can only have one lock on it, the `5World Lock``.  Remove the rest!", 0, 0);
				return;
			}
			std::vector<WorldBlock>::iterator pz = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return a.fg == 4516; });
			if (pz != world_->blocks.end()) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`4To trade a world, you will need to remove Untrade-a-Box!``", 0, 0);
				return;
			}
			if (world_->admins.size() != 0) {
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You'll first need to remove all players with access to your " + items[242].name + " to get a " + items[5816].name + ".", 0, 1);
				return;
			}
			c_ = 1;
			if (Inventory::Modify(peer, 5816, c_) == 0) {
				CAction::Log(peer, "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0");
				VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You got a `#" + items[5816].name + "``! You can now transfer leadership of the guild!", 0, 0);
			}
		}
	}
	static void worlds_list(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "My_World") {
				std::string worlds_owned_ = "";
				for (int w_ = 0; w_ < pInfo(peer)->worlds_owned.size(); w_++) worlds_owned_ += "\nadd_button|" + pInfo(peer)->worlds_owned[w_] + "|" + pInfo(peer)->worlds_owned[w_] + "|noflags|0|0|";
				if (worlds_owned_.empty()) worlds_owned_ = "\nadd_textbox|You do not have any World-Locked worlds.``|left|";
				std::string dialog = SetColor(peer) + "set_default_color|`o\nstart_custom_tabs|\nadd_custom_button|My_World|image:interface/large/btn_tabs2.rttex;image_size:228,92;frame:1,0;width:0.15;|\nadd_custom_button|Home_World|image:interface/large/btn_tabs2.rttex;image_size:228,92;frame:0,1;width:0.15;|\nadd_custom_button|Fav_World|image:interface/large/btn_tabs2.rttex;image_size:228,92;frame:0,2;width:0.15;|\nend_custom_tabs|";
				VarList::OnDialogRequest(peer, dialog + "\nadd_label|big|Locked Worlds|left|\nadd_spacer|small|\nadd_textbox|You must be a Supporter or Super Supporter to warp to these worlds.|left|\nadd_textbox|Place a World Lock in a World to lock. Break your World Lock to unlock a world.|\nadd_spacer|small|" + worlds_owned_ + "|\nadd_quick_exit|\nadd_spacer|small|\nend_dialog|worlds_list||Back|", 500);
			}
			if (button == "Home_World") {
				std::string home_worlds = "";
				if (not pInfo(peer)->home_world.empty()) home_worlds += "\nadd_textbox|Your home world|left|\nadd_button|" + pInfo(peer)->home_world + "|" + pInfo(peer)->home_world + "|noflags|0|0|\nadd_spacer|small|";
				std::string dialog = SetColor(peer) + "set_default_color|`o\nstart_custom_tabs|\nadd_custom_button|My_World|image:interface/large/btn_tabs2.rttex;image_size:228,92;frame:0,0;width:0.15;|\nadd_custom_button|Home_World|image:interface/large/btn_tabs2.rttex;image_size:228,92;frame:1,1;width:0.15;|\nadd_custom_button|Fav_World|image:interface/large/btn_tabs2.rttex;image_size:228,92;frame:0,2;width:0.15;|\nend_custom_tabs|";
				VarList::OnDialogRequest(peer, dialog + "\nadd_label|big|Home World|left|\nadd_spacer|small|\nadd_textbox|Use /sethome to assign a world as your home world.|left|\nadd_textbox|Use /home to warp directly to your home world.|left|\nadd_spacer|small|" + home_worlds + "|\nadd_quick_exit|\nadd_spacer|small|\nend_dialog|worlds_list||Back|", 500);
			}
			if (button == "Fav_World") {
				std::string worlds_fav_ = "";
				for (int w_ = 0; w_ < pInfo(peer)->worlds_favorite.size(); w_++) worlds_fav_ += "\nadd_button|" + pInfo(peer)->worlds_favorite[w_] + "|" + pInfo(peer)->worlds_favorite[w_] + "|noflags|0|0|";
				std::string dialog = SetColor(peer) + "set_default_color|`o\nstart_custom_tabs|\nadd_custom_button|My_World|image:interface/large/btn_tabs2.rttex;image_size:228,92;frame:0,0;width:0.15;|\nadd_custom_button|Home_World|image:interface/large/btn_tabs2.rttex;image_size:228,92;frame:0,1;width:0.15;|\nadd_custom_button|Fav_World|image:interface/large/btn_tabs2.rttex;image_size:228,92;frame:1,2;width:0.15;|\nend_custom_tabs|";
				VarList::OnDialogRequest(peer, dialog + "\nadd_label|big|Favorited Worls|left|\nadd_spacer|small|\nadd_textbox|You must be a Supporter or Super Supporter to Warp to these worlds.|left|\nadd_textbox|Use /fav in a world to add or remove a favorite world.|left|\nadd_spacer|small|\nadd_textbox|Favorite Worlds: " + to_string(pInfo(peer)->worlds_favorite.size()) + "/10|left|\nadd_spacer|small|" + worlds_fav_ + "|\nadd_quick_exit|\nadd_spacer|small|\nend_dialog|worlds_list||Back|", 500);
			}
			if (button.substr(0, 0) == "") {
				std::string world_ = button.substr(0);
				if (pInfo(peer)->home_world == world_) {
					bool a___ = false;
					for (std::pair<std::string, long long int> p : Environment()->Home_Timed) {
						if (p.first == pInfo(peer)->tankIDName) {
							if (p.second + HOME_TIME > (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
								a___ = true;
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`4Cooldown active`` - You can use `5home warp`` in `5" + to_string(((p.second + HOME_TIME - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) / 1000) - ((((p.second + HOME_TIME - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) / 1000) / 60) * 60)) + " ``seconds.", 0, 0);
								return;
							}
						}
					}
					if (a___) return;
					Environment()->Home_Timed.push_back(std::make_pair(pInfo(peer)->tankIDName, (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));
					Enter_World(peer, world_);
				}
				else {
					if (pInfo(peer)->supp == 1 or pInfo(peer)->supp == 2) {
						Enter_World(peer, world_);
					}
					else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You must be either a Supporter or Super Supporter to warp to a world.", 0, 0);
				}
			}
		}
		else {
			send_wrench_self(peer);
			return;
		}
	}
	static void confirmguild(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "Create_Guild") {
				int price = guild_create_gem_requirement;
				if (pInfo(peer)->supp > 1) price /= 2;
				if (pInfo(peer)->gems >= price) {
					if (pInfo(peer)->guild_id == 0) {
						std::string name_ = pInfo(peer)->world;
						std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
						if (p != worlds.end()) {
							World* world_ = &worlds[p - worlds.begin()];
							std::string guild_name = get_embed(cch, "guildname");
							std::string guild_description = get_embed(cch, "guilddesc");
							bool bad_name = false, already_taken = false;
							std::string check_name = to_lower(guild_name);
							for (int i = 0; i < Environment()->swear_words.size(); i++) {
								if (check_name.find(to_lower(Environment()->swear_words[i])) != string::npos) {
									bad_name = true;
								}
							}
							for (Guild check_guild_name : guilds) {
								if (to_lower(check_guild_name.guild_name) == check_name) {
									already_taken = true;
								}
							}
							if (already_taken or bad_name or guild_name.size() < 3 or guild_name.size() > 15 or guild_description.size() < 6 or guild_description.size() > 24 or special_char(guild_name) or world_->owner_name != pInfo(peer)->tankIDName) return;
							Guild new_guild{};
							new_guild.guild_id = guilds.size() + 1;
							new_guild.guild_name = guild_name;
							new_guild.guild_settings |= SETTINGS::SETTINGS_0;
							new_guild.guild_description = guild_description;
							new_guild.guild_world = pInfo(peer)->world;
							GuildMember new_member{};
							new_member.member_name = pInfo(peer)->tankIDName;
							new_member.role_id = 3;
							new_member.last_online = time(NULL);
							new_guild.guild_members.push_back(new_member);
							guilds.push_back(new_guild);
							save_guilds();
							pInfo(peer)->guild_id = new_guild.guild_id;
							{
								int x_ = 0, y_ = 0;
								int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
								{
									std::vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return items[a.fg].blockType == BlockTypes::LOCK && a.fg != 202 && a.fg != 204 && a.fg != 206 && a.fg != 4994 && a.fg != 10000; });
									if (p != world_->blocks.end()) {
										int i_ = p - world_->blocks.begin();
										x_ = i_ % xSize;
										y_ = i_ / xSize;
									}
								}
								WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
								world_->guild_id = new_guild.guild_id;
								world_->fresh_world = true;
								block_->fg = 5814;
								PlayerMoving data_{};
								data_.packetType = 15, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
								data_.netID = name_to_number(to_lower(pInfo(peer)->tankIDName));
								data_.plantingTree = block_->fg;
								BYTE* raw = packPlayerMoving(&data_, 56);
								PlayerMoving data_2{};
								data_2.packetType = 5, data_2.punchX = x_, data_2.punchY = y_, data_2.characterState = 0x8;
								BYTE* raw2 = packPlayerMoving(&data_2, 112 + (world_->admins.size() * 4));
								BYTE* blc = raw2 + 56;
								form_visual(blc, *block_, *world_, peer, false);
								Clothing_V2::Update_Value(peer, true);
								Clothing_V2::Update(peer);
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnGuildDataChanged"), p.Insert(50478), p.Insert(79289404), p.Insert(0), p.Insert(3);
								for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
									if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
									if (pInfo(cp_)->world == world_->name) {
										send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										send_raw(cp_, 4, raw2, 112 + (world_->admins.size() * 4), ENET_PACKET_FLAG_RELIABLE);
										p.CreatePacket(cp_);
									}
								}
								delete[] raw, raw2, blc;
								VarList::OnMinGems(peer, price);
								VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Guild created", 0, 0);
							}
						}
					}
				}
				else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough gems!", 0, 0);
			}
		}
	}
	static void createguild(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "Create_Guild") {
				int price = 5000;
				if (pInfo(peer)->supp > 1) price = 2500;
				if (pInfo(peer)->gems >= price) {
					std::string name_ = pInfo(peer)->world;
					std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
					if (p != worlds.end()) {
						World* world_ = &worlds[p - worlds.begin()];
						std::string guild_name = parser.get("guildname", 1);
						std::string guild_description = parser.get("guilddesc", 1);
						bool bad_name = false, already_taken = false;
						std::string check_name = to_lower(guild_name);
						for (int i = 0; i < Environment()->swear_words.size(); i++) {
							if (check_name.find(Environment()->swear_words[i]) != string::npos) {
								bad_name = true;
							}
						}
						for (Guild check_guild_name : guilds) {
							if (to_lower(check_guild_name.guild_name) == check_name) {
								already_taken = true;
							}
						}
						if (already_taken) VarList::OnDialogRequest(peer, get_guild_create(peer, "`4The guild name is not available!``", guild_name, guild_description));
						else if (bad_name) VarList::OnDialogRequest(peer, get_guild_create(peer, "`4Oops!`` Guild name cannot contain `$swear words``.", guild_name, guild_description));
						else if (guild_name.size() < 3 or guild_name.size() > 15) VarList::OnDialogRequest(peer, get_guild_create(peer, "You'll need a name `$3 characters`` or longer to create a Guild - select cancel and enter a longer name.", guild_name, guild_description));
						else if (guild_description.size() < 6 or guild_description.size() > 24) VarList::OnDialogRequest(peer, get_guild_create(peer, "You need to enter at least `$6 characters`` to add a guild statement!", guild_name, guild_description));
						else if (special_char(guild_name)) VarList::OnDialogRequest(peer, get_guild_create(peer, "`4Oops!`` You can only use letters and numbers in your `$Guild`` name.", guild_name, guild_description));
						else if (world_->owner_name != pInfo(peer)->tankIDName) VarList::OnDialogRequest(peer, get_guild_create(peer, "You can only create the guild inside a world which is owned by you!", guild_name, guild_description));
						else VarList::OnDialogRequest(peer, get_guild_create(peer, "", guild_name, guild_description, true));
					}
				}
			}
		}
	}
	static void guild_member_role_change_finish(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "back") {
				std::string guild_info = get_guild_info(peer);
				if (guild_info == "set_default_color|`o\nadd_label_with_icon|big|`wGrow Guild ``|left|5814|\nadd_textbox|Something went wrong!|left|\nend_dialog|guildalreadyjoined|Close||") set_Guilds(peer);
				VarList::OnDialogRequest(peer, guild_info);
			}
		}
	}
	static void guild_member_role_change(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "back") {
				std::string guild_member_name = get_embed(cch, "guildmembername");
				send_guild_member_info(peer, to_lower(guild_member_name));
			}
			if (button == "promote" or button == "demote") {
				uint32_t guild_id = pInfo(peer)->guild_id;
				std::vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					uint32_t my_rank = 0;
					for (GuildMember member_search : guild_information->guild_members) {
						if (to_lower(member_search.member_name) == to_lower(pInfo(peer)->tankIDName)) {
							my_rank = member_search.role_id;
						}
					}
					for (int i_ = 0; i_ < guild_information->guild_members.size(); i_++) {
						GuildMember* member_search = &guild_information->guild_members[i_];
						if (to_lower(member_search->member_name) == to_lower(get_embed(cch, "guildmembername"))) {
							bool can_promote = false;
							bool can_demote = false;
							if (member_search->role_id != 3) {
								if (member_search->role_id == 1 and my_rank == 3) {
									can_promote = true;
									can_demote = true;
								}
								else if (member_search->role_id == 2 and my_rank == 3) {
									can_promote = false;
									can_demote = true;
								}
								else if (member_search->role_id != 3 and my_rank >= 2 and member_search->role_id != 2) {
									can_promote = true;
								}
							}
							if (can_promote and button == "promote") {
								guild_information->guild_settings &= ~SETTINGS::SETTINGS_0;
								guild_information->guild_settings |= SETTINGS::SETTINGS_0;
								member_search->role_id++;
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wGuild Member Promoted``|left|1366|\nadd_spacer|small|\nadd_textbox|`o" + get_embed(cch, "guildmembername") + " is `2promoted`` to " + (member_search->role_id == 3 ? "Leader" : member_search->role_id == 2 ? "Co-Leader" : member_search->role_id == 1 ? "Elder" : "Member") + "!|left|\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog|guild_member_role_change_finish|||\nadd_quick_exit|");
								for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
									if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
									if (pInfo(cp_)->guild_id == guild_id) {
										VarList::OnConsoleMessage(cp_, "`5[GUILD ALERT]`` `2" + get_embed(cch, "guildmembername") + "`` has been `2promoted`` `oto " + (member_search->role_id == 3 ? "Leader" : member_search->role_id == 2 ? "Co-Leader" : member_search->role_id == 1 ? "Elder" : "Member") + "!");
									}
									if (to_lower(pInfo(cp_)->tankIDName) == to_lower(get_embed(cch, "guildmembername"))) {
										if (member_search->role_id == 3) VarList::OnAddNotification(cp_, "`wYou has been `2promote `wto Leader!", "interface/large/gd_prom.rttex", "audio/levelup2.wav");
										else if (member_search->role_id == 2) VarList::OnAddNotification(cp_, "`wYou has been `2promote `wto Co-Leader!", "interface/large/gd_prom.rttex", "audio/levelup2.wav");
										else if (member_search->role_id == 1) VarList::OnAddNotification(cp_, "`wYou has been `2promote `wto Elder!", "interface/large/gd_prom.rttex", "audio/levelup2.wav");
										else VarList::OnAddNotification(cp_, "`wYou has been `2promote `wto Member!", "interface/large/gd_prom.rttex", "audio/levelup2.wav");
										gamepacket_t p4(0, pInfo(cp_)->netID);
										p4.Insert("OnGuildDataChanged"), p4.Insert(50478), p4.Insert(79289404);
										if (pInfo(cp_)->guild_fg == 0 && pInfo(cp_)->guild_bg == 0) p4.Insert(0);
										else p4.Insert((65536 * pInfo(cp_)->guild_bg) + pInfo(cp_)->guild_fg);
										p4.Insert(member_search->role_id);
										for (ENetPeer* cp = server->peers; cp < &server->peers[server->peerCount]; ++cp) {
											if (cp->state != ENET_PEER_STATE_CONNECTED or cp->data == NULL) continue;
											if (pInfo(cp)->world == pInfo(peer)->world) p4.CreatePacket(cp);
										}
										std::string name_ = pInfo(cp_)->world;
										std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
										if (p != worlds.end()) {
											World* world_ = &worlds[p - worlds.begin()];
											update_guild_name(cp_, guild_information->guild_world, world_);
											if (pInfo(cp_)->world == guild_information->guild_world) {
												std::string name_ = pInfo(cp_)->world;
												std::vector<World>::iterator p_w = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
												if (p_w != worlds.end()) {
													World* world_ = &worlds[p_w - worlds.begin()];
													int x_ = 0, y_ = 0;
													int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
													{
														std::vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return a.fg == 5814; });
														if (p != world_->blocks.end()) {
															int i_ = p - world_->blocks.begin();
															x_ = i_ % xSize;
															y_ = i_ / xSize;
														}
													}
													WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
													tile_update(cp_, world_, block_, x_, y_);
												}
											}
										}
									}
								}
								create_guild_log(guild_information, "`$" + pInfo(peer)->tankIDName + "`` `2promoted `$" + get_embed(cch, "guildmembername") + "`` `oto " + (member_search->role_id == 3 ? "Leader" : member_search->role_id == 2 ? "Co-Leader" : member_search->role_id == 1 ? "Elder" : "Member"), 484);
							}
							else if (can_demote and button == "demote") {
								member_search->role_id--;
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wGuild Member Demoted``|left|1366|\nadd_spacer|small|\nadd_textbox|`o" + get_embed(cch, "guildmembername") + " is `4demoted`` to " + (member_search->role_id == 3 ? "Leader" : member_search->role_id == 2 ? "Co-Leader" : member_search->role_id == 1 ? "Elder" : "Member") + "!|left|\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog|guild_member_role_change_finish|||\nadd_quick_exit|");
								for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
									if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
									if (pInfo(cp_)->guild_id == guild_id) {
										VarList::OnConsoleMessage(cp_, "`5[GUILD ALERT]`` `2" + get_embed(cch, "guildmembername") + "`` has been `4demoted`` `oto " + (member_search->role_id == 3 ? "Leader" : member_search->role_id == 2 ? "Co-Leader" : member_search->role_id == 1 ? "Elder" : "Member") + "!");
									}
									if (to_lower(pInfo(cp_)->tankIDName) == to_lower(get_embed(cch, "guildmembername"))) {
										if (member_search->role_id == 2) VarList::OnAddNotification(cp_, "`wYou has been `4demoted `wto Co-Leader!", "interface/large/gd_prom.rttex", "audio/levelup2.wav");
										else if (member_search->role_id == 1) VarList::OnAddNotification(cp_, "`wYou has been `4demoted `wto Elder!", "interface/large/gd_prom.rttex", "audio/levelup2.wav");
										else VarList::OnAddNotification(cp_, "`wYou has been `4demoted `wto Member!", "interface/large/gd_prom.rttex", "audio/levelup2.wav");
										gamepacket_t p4(0, pInfo(cp_)->netID);
										p4.Insert("OnGuildDataChanged"), p4.Insert(50478), p4.Insert(79289404);
										if (pInfo(cp_)->guild_fg == 0 && pInfo(cp_)->guild_bg == 0) p4.Insert(0);
										else p4.Insert((65536 * pInfo(cp_)->guild_bg) + pInfo(cp_)->guild_fg);
										p4.Insert(member_search->role_id);
										for (ENetPeer* cp = server->peers; cp < &server->peers[server->peerCount]; ++cp) {
											if (cp->state != ENET_PEER_STATE_CONNECTED or cp->data == NULL) continue;
											if (pInfo(cp)->world == pInfo(peer)->world) p4.CreatePacket(cp);
										}
										std::string name_ = pInfo(cp_)->world;
										std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
										if (p != worlds.end()) {
											World* world_ = &worlds[p - worlds.begin()];
											update_guild_name(cp_, guild_information->guild_world, world_);
											if (pInfo(cp_)->world == guild_information->guild_world) {
												std::string name_ = pInfo(cp_)->world;
												std::vector<World>::iterator p_w = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
												if (p_w != worlds.end()) {
													World* world_ = &worlds[p_w - worlds.begin()];
													int x_ = 0, y_ = 0;
													int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
													{
														std::vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return a.fg == 5814; });
														if (p != world_->blocks.end()) {
															int i_ = p - world_->blocks.begin();
															x_ = i_ % xSize;
															y_ = i_ / xSize;
														}
													}
													WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
													tile_update(cp_, world_, block_, x_, y_);
												}
											}
										}
									}
								}
								create_guild_log(guild_information, "`$" + pInfo(peer)->tankIDName + "`` `4demoted `$" + get_embed(cch, "guildmembername") + "`` `oto " + (member_search->role_id == 3 ? "Leader" : member_search->role_id == 2 ? "Co-Leader" : member_search->role_id == 1 ? "Elder" : "Member"), 486);
							}
						}
					}
				}
			}
		}
	}
	static void guild_member_remove_finish(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "back") {
				std::string guild_info = get_guild_info(peer);
				if (guild_info == "set_default_color|`o\nadd_label_with_icon|big|`wGrow Guild ``|left|5814|\nadd_textbox|Something went wrong!|left|\nend_dialog|guildalreadyjoined|Close||") set_Guilds(peer);
				VarList::OnDialogRequest(peer, guild_info);
			}
		}
	}
	static void guild_member_remove(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "remove") {
				uint32_t guild_id = pInfo(peer)->guild_id;
				std::vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					uint32_t my_rank = 0;
					for (GuildMember member_search : guild_information->guild_members) {
						if (to_lower(member_search.member_name) == to_lower(pInfo(peer)->tankIDName)) {
							my_rank = member_search.role_id;
						}
					}
					for (int i_ = 0; i_ < guild_information->guild_members.size(); i_++) {
						GuildMember* member_search = &guild_information->guild_members[i_];
						if (to_lower(member_search->member_name) == to_lower(get_embed(cch, "guildmembername"))) {
							bool can_kick = my_rank >= 1 and member_search->role_id < my_rank;
							if (can_kick) {
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wGuild Member removed``|left|1366|\nadd_spacer|small|\nadd_textbox|`o" + get_embed(cch, "guildmembername") + " is no longer in the guild.|left|\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog|guild_member_remove_finish|||\nadd_quick_exit|");
								{
									bool on_ = false;
									for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
										if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
										if (pInfo(cp_)->guild_id == guild_id) VarList::OnConsoleMessage(cp_, "`5[GUILD ALERT]`` " + get_embed(cch, "guildmembername") + " kicked from the guild by " + pInfo(peer)->tankIDName);
										if (to_lower(pInfo(cp_)->tankIDName) == to_lower(get_embed(cch, "guildmembername"))) {
											on_ = true;
											pInfo(cp_)->guild_id = 0;
											Clothing_V2::Update_Value(cp_);
											Clothing_V2::Update(cp_);
											std::string name_ = pInfo(cp_)->world;
											std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
											if (p != worlds.end()) {
												World* world_ = &worlds[p - worlds.begin()];
												update_guild_name(cp_, guild_information->guild_world, world_);
												if (not guild_access(cp_, guild_id) and pInfo(cp_)->world == guild_information->guild_world) {
													std::string name_ = pInfo(cp_)->world;
													std::vector<World>::iterator p_w = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
													if (p_w != worlds.end()) {
														World* world_ = &worlds[p_w - worlds.begin()];
														int x_ = 0, y_ = 0;
														int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
														{
															std::vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return a.fg == 5814; });
															if (p != world_->blocks.end()) {
																int i_ = p - world_->blocks.begin();
																x_ = i_ % xSize;
																y_ = i_ / xSize;
															}
														}
														WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
														tile_update(cp_, world_, block_, x_, y_);
													}
												}
											}
										}
									}
									if (not on_) {
										std::string path_ = "database/players/" + get_embed(cch, "guildmembername") + "_.json";
										if (_access_s(path_.c_str(), 0) == 0) {
											json r_;
											std::ifstream f_(path_, ifstream::binary);
											f_ >> r_;
											f_.close();
											r_["guild_id"] = 0;
											{
												std::ofstream f_(path_, ifstream::binary);
												f_ << r_;
												f_.close();
											}
										}
									}
								}
								create_guild_log(guild_information, "`$" + pInfo(peer)->tankIDName + "`` `wkicked `$" + get_embed(cch, "guildmembername") + "`` from the guild", 6);
								guild_information->guild_members.erase(guild_information->guild_members.begin() + i_);
							}
							return;
						}
					}
				}
			}
			if (button == "back") {
				std::string guild_member_name = get_embed(cch, "guildmembername");
				send_guild_member_info(peer, to_lower(guild_member_name));
			}
		}
	}
	static void guild_member_edit(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "back") {
				std::string guild_info = get_guild_info(peer);
				if (guild_info == "set_default_color|`o\nadd_label_with_icon|big|`wGrow Guild ``|left|5814|\nadd_textbox|Something went wrong!|left|\nend_dialog|guildalreadyjoined|Close||") set_Guilds(peer);
				VarList::OnDialogRequest(peer, guild_info);
			}
			if (button == "promote" or button == "demote" or button == "goto" or button == "remove") {
				uint32_t guild_id = pInfo(peer)->guild_id;
				std::vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					for (int i_ = 0; i_ < guild_information->guild_members.size(); i_++) {
						GuildMember* member_search = &guild_information->guild_members[i_];
						if (to_lower(member_search->member_name) == to_lower(get_embed(cch, "guildmembername"))) {
							if (button == "remove") {
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wKick Guild Member``|left|1366|\nadd_spacer|small|\nadd_textbox|`oAre you sure you wish to `4kick`` " + get_embed(cch, "guildmembername") + " from the guild?|left|\nadd_spacer|small|\nadd_button|remove|`4Kick " + get_embed(cch, "guildmembername") + "``|noflags|0|0|\nembed_data|guildmembername|" + get_embed(cch, "guildmembername") + "\nadd_button|back|Back|noflags|0|0|\nend_dialog|guild_member_remove|||\nadd_quick_exit|");
							}
							if (button == "goto") {
								std::string world_name = "";
								for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
									if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
									if (to_lower(pInfo(cp_)->tankIDName) == to_lower(get_embed(cch, "guildmembername"))) {
										world_name = pInfo(cp_)->world;
									}
								}
								if (world_name.empty()) {
									VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Hmm, my friend isn't in a world right now.", 0, 0);
									return;
								}
								else {
									if (world_name == pInfo(peer)->world) {
										VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You want to warp to the same world you're in?  That's illogical, captain.", 0, 0);
										return;
									}
									else {
										VarList::OnTextOverlay(peer, "Moving to guild member location (`2" + world_name + "``) ...");
										Enter_World(peer, world_name);
									}
								}
							}
							if (button == "promote") {
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wPromote Guild Member``|left|1366|\nadd_spacer|small|\nadd_textbox|`oAre you sure you wish to `2promote`` " + get_embed(cch, "guildmembername") + " to " + (member_search->role_id == 3 ? "" : member_search->role_id == 2 ? "" : member_search->role_id == 1 ? "Co-Leader" : "Elder") + "?|left|\nadd_spacer|small|\nadd_button|promote|`wPromote " + get_embed(cch, "guildmembername") + "``|noflags|0|0|\nembed_data|guildmembername|" + get_embed(cch, "guildmembername") + "\nadd_button|back|Back|noflags|0|0|\nend_dialog|guild_member_role_change|||\nadd_quick_exit|");
							}
							if (button == "demote") {
								VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wDemote Guild Member``|left|1366|\nadd_spacer|small|\nadd_textbox|`oAre you sure you wish to `4demote`` " + get_embed(cch, "guildmembername") + " to " + (member_search->role_id == 3 ? "" : member_search->role_id == 2 ? "Elder" : member_search->role_id == 1 ? "Member" : "") + "?|left|\nadd_spacer|small|\nadd_button|demote|`wDemote " + get_embed(cch, "guildmembername") + "``|noflags|0|0|\nembed_data|guildmembername|" + get_embed(cch, "guildmembername") + "\nadd_button|back|Back|noflags|0|0|\nend_dialog|guild_member_role_change|||\nadd_quick_exit|");
							}
							return;
						}
					}
				}
			}
		}
	}
	static void guild_statement_edit(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "changestatementsubmit") {
				std::string new_stat = parser.get("guilddesc", 1);
				if (new_stat.size() < 6 or new_stat.size() > 24) {
					VarList::OnDialogRequest(peer, get_guild_statement_edit(peer, "`oYou need to enter at least `$6 characters`` to add a guild statement!``"));
					return;
				}
				uint32_t guild_id = pInfo(peer)->guild_id;
				std::vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					guild_information->guild_description = new_stat;
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					std::string guild_info = get_guild_info(peer);
					if (guild_info == "set_default_color|`o\nadd_label_with_icon|big|`wGrow Guild ``|left|5814|\nadd_textbox|Something went wrong!|left|\nend_dialog|guildalreadyjoined|Close||") set_Guilds(peer);
					VarList::OnDialogRequest(peer, guild_info);
					create_guild_log(guild_information, "`$" + pInfo(peer)->tankIDName + "`` `wchanged guild statement to `$" + new_stat + "``", 658);
				}
				return;
			}
		}
	}
	static void sellstuff(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button.substr(0, 5) == "sell_") {
				int itemID = std::atoi(button.substr(5).c_str()), amount = 0, adaBrp = 0;
				Inventory::Modify(peer, itemID, adaBrp);
				std::vector<std::pair<int, int>>::iterator pz = find_if(Environment()->janeway_item.begin(), Environment()->janeway_item.end(), [&](const pair < int, int>& element) { return element.first == itemID; });
				if (pz != Environment()->janeway_item.end()) {
					if (adaBrp == 200) {
						amount = 200;
						VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wTrade Confirmation``|left|242|\nembed_data|sellID|" + to_string(itemID) + "_" + to_string(amount) + "|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|" + to_string(amount) + " " + items[itemID].ori_name + "|left|" + to_string(itemID) + "|\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|" + to_string(Environment()->janeway_item[pz - Environment()->janeway_item.begin()].second) + " " + items[Environment()->janeway_payout].ori_name + "|left|" + to_string(Environment()->janeway_payout) + "|\nadd_spacer|small|\nadd_button|accept|Do The Trade!|noflags|0|0|\nadd_button|back|Cancel|noflags|0|0|\nend_dialog|sellstuffconfirm|||");
					}
					else {
						VarList::OnTextOverlay(peer, "Janeway only intrested in buying 200pcs of item at once");
					}
				}
			}
		}
	}
	static void sellstuffconfirm(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "back") {
				DialogHandle::Janeway(peer);
			}
			if (button == "back") {
				string checkItem = get_embed(cch, "sellID");
				std::vector<std::string> x = explode("_", checkItem);
				if (not isdigit(x[0][0]) and not isdigit(x[1][0])) return;
				int sellID = std::atoi(x[0].c_str()), sellAmount = std::atoi(x[1].c_str()), adaBrp = 0, removeItem = -sellAmount, itemPrice = 0;
				Inventory::Modify(peer, sellID, adaBrp);
				if (adaBrp != sellAmount) return;
				if (adaBrp == sellAmount) {
					std::vector<std::pair<int, int>>::iterator pz = find_if(Environment()->janeway_item.begin(), Environment()->janeway_item.end(), [&](const pair < int, int>& element) { return element.first == sellID; });
					if (pz != Environment()->janeway_item.end()) {
						itemPrice = Environment()->janeway_item[pz - Environment()->janeway_item.begin()].second;
						if (Inventory::Modify(peer, sellID, removeItem) == 0) {
							VarList::OnConsoleMessage(peer, "`1You`` traded " + to_string(sellAmount) + " " + items[sellID].ori_name + " to Environment()->``");
							VarList::OnConsoleMessage(peer, "`1Janeway`` traded " + to_string(itemPrice) + " " + items[Environment()->janeway_payout].ori_name + " to You.``");
							Inventory::Modify(peer, Environment()->janeway_payout, itemPrice);
							CAction::Positioned(peer, pInfo(peer)->netID, "audio/keypad_hit.wav", 1250);
						}
					}
				}
			}
		}
	}
	static void trade_item(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string count = parser.get("count", 1);
		if (not is_number(std::string(get_embed(cch, "itemID"))) or not is_number(count)) return;
		int item_id = std::atoi(get_embed(cch, "itemID").c_str()), item_count = std::atoi(count.c_str()), c_ = 0;
		Inventory::Modify(peer, item_id, c_);
		if (c_ < item_count or c_ == 0) return;
		mod_trade(peer, item_id, item_count);
	}
	static void trade_confirm(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "back") {
				cancel_trade(peer, true);
			}
			if (button == "accept") {
				for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
					if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
					if (pInfo(cp_)->world == pInfo(peer)->world) {
						if (pInfo(cp_)->netID == pInfo(peer)->trading_with and pInfo(peer)->netID == pInfo(cp_)->trading_with) {
							pInfo(peer)->accept_the_offer = true;
							if (pInfo(cp_)->accept_the_offer and pInfo(peer)->accept_the_offer) {
								std::string name_ = pInfo(peer)->world;
								std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p != worlds.end()) {
									World* world_ = &worlds[p - worlds.begin()];
									if (not trade_space_check(peer, cp_)) {
										cancel_trade(peer);
										return;
									}
									else if (not trade_space_check(cp_, peer)) {
										cancel_trade(peer);
										return;
									}
									bool c_ = false;
									for (int i_ = 0; i_ < pInfo(peer)->trade_items.size(); i_++) {
										if (c_) break;
										std::map<std::string, int>::iterator it;
										for (auto it = pInfo(peer)->trade_items[i_].begin(); it != pInfo(peer)->trade_items[i_].end(); it++) {
											if (it->first == 1424 or it->first == 5816) {
												{
													std::vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return items[a.fg].blockType == BlockTypes::LOCK && a.fg == 202 || a.fg == 204 || a.fg == 206 || a.fg == 4994 || a.fg == 10000; });
													if (p != world_->blocks.end()) {
														cancel_trade(peer);
														return;
													}
												}
												c_ = true;
												break;
											}
										}
									}
									c_ = false;
									for (int i_ = 0; i_ < pInfo(cp_)->trade_items.size(); i_++) {
										if (c_) break;
										std::map<std::string, int>::iterator it;
										for (auto it = pInfo(cp_)->trade_items[i_].begin(); it != pInfo(cp_)->trade_items[i_].end(); it++) {
											if (it->first == 1424 or it->first == 5816) {
												{
													std::vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return items[a.fg].blockType == BlockTypes::LOCK && a.fg == 202 || a.fg == 204 || a.fg == 206 || a.fg == 4994 || a.fg == 10000; });
													if (p != world_->blocks.end()) {
														cancel_trade(cp_);
														return;
													}
												}
												c_ = true;
												break;
											}
										}
									}
									std::vector<std::string> traded_p;
									int time_out = 0;
									for (int i_ = 0; i_ < pInfo(peer)->trade_items.size(); i_++) {
										std::map<std::string, int>::iterator it;
										for (auto it = pInfo(peer)->trade_items[i_].begin(); it != pInfo(peer)->trade_items[i_].end(); it++) {
											int c_ = it->second * -1;
											if (Inventory::Modify(peer, it->first, c_, true) == 0) {
												traded_p.push_back(to_string(it->second) + " " + items[it->first].name);
												if (it->first == 1424 or it->first == 5816) {
													transfer_world(world_, peer, cp_);
												}
												else {
													int c2_ = it->second;
													Inventory::Modify(cp_, it->first, c2_, true);
												}
												PlayerMoving data_{};
												time_out += 450;
												data_.packetType = 19, data_.plantingTree = (i_ + 1) * 450, data_.netID = pInfo(cp_)->netID;
												data_.punchX = it->first, data_.punchY = it->first;
												int32_t to_netid = pInfo(peer)->netID;
												BYTE* raw = packPlayerMoving(&data_);
												raw[3] = 3;
												Memory_Copy(raw + 8, &to_netid, 4);
												for (ENetPeer* cp_2 = server->peers; cp_2 < &server->peers[server->peerCount]; ++cp_2) {
													if (cp_2->state != ENET_PEER_STATE_CONNECTED or cp_2->data == NULL) continue;
													if (pInfo(cp_2)->world == world_->name) {
														send_raw(cp_2, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
													}
												}
												delete[]raw;
												CAction::Positioned(peer, pInfo(peer)->netID, "audio/change_clothes.wav", (i_ + 1) * 450);
												CAction::Positioned(cp_, pInfo(cp_)->netID, "audio/change_clothes.wav", (i_ + 1) * 450);
											}
										}
									}
									std::string traded_ = "";
									if (traded_p.size() != 0) {
										for (int i_ = 0; i_ < traded_p.size(); i_++) {
											if (traded_p.size() == i_ + 1) traded_ += traded_p[i_];
											else if (traded_p.size() - 2 == i_) traded_ += traded_p[i_] + " and ";
											else traded_ += traded_p[i_] + ", ";
										}
									}
									else {
										traded_ = "nothing";
									}
									traded_p.clear();
									for (int i_ = 0; i_ < pInfo(cp_)->trade_items.size(); i_++) {
										std::map<std::string, int>::iterator it;
										for (auto it = pInfo(cp_)->trade_items[i_].begin(); it != pInfo(cp_)->trade_items[i_].end(); it++) {
											int c_ = it->second * -1;
											if (Inventory::Modify(cp_, it->first, c_, true) == 0) {
												traded_p.push_back(to_string(it->second) + " " + items[it->first].name);
												if (it->first == 1424 or it->first == 5816) {
													transfer_world(world_, cp_, peer);
												}
												else {
													int c2_ = it->second;
													Inventory::Modify(peer, it->first, c2_, true);
												}
												PlayerMoving data_{};
												data_.packetType = 19, data_.plantingTree = (i_ + 1) * 450 + time_out, data_.netID = pInfo(peer)->netID;
												data_.punchX = it->first, data_.punchY = it->first;
												int32_t to_netid = pInfo(cp_)->netID;
												BYTE* raw = packPlayerMoving(&data_);
												raw[3] = 3;
												Memory_Copy(raw + 8, &to_netid, 4);
												for (ENetPeer* cp_2 = server->peers; cp_2 < &server->peers[server->peerCount]; ++cp_2) {
													if (cp_2->state != ENET_PEER_STATE_CONNECTED or cp_2->data == NULL) continue;
													if (pInfo(cp_2)->world == world_->name) {
														send_raw(cp_2, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
													}
												}
												delete[]raw;
												CAction::Positioned(peer, pInfo(peer)->netID, "audio/change_clothes.wav", (i_ + 1) * 450);
												CAction::Positioned(cp_, pInfo(cp_)->netID, "audio/change_clothes.wav", (i_ + 1) * 450);
											}
										}
									}
									std::string traded2_ = "";
									if (traded_p.size() != 0) {
										for (int i_ = 0; i_ < traded_p.size(); i_++) {
											if (traded_p.size() == i_ + 1) traded2_ += traded_p[i_];
											else if (traded_p.size() - 2 == i_) traded2_ += traded_p[i_] + " and ";
											else traded2_ += traded_p[i_] + ", ";
										}
									}
									else {
										traded2_ = "nothing";
									}
									{
										if (pInfo(peer)->starglitter_trade < 10) DailyEvent_Task::MStarglitter(peer, "trade", 1);
										if (pInfo(cp_)->starglitter_trade < 10) DailyEvent_Task::MStarglitter(cp_, "trade", 1);
										struct tm newtime;
										time_t now = time(0);
#ifdef _WIN32
										localtime_s(&newtime, &now);
#elif defined(__linux__)
										localtime_r(&now, &newtime);
#endif
										if (pInfo(peer)->trade_history.size() >= 10) pInfo(peer)->trade_history.erase(pInfo(peer)->trade_history.begin() + 0);
										if (pInfo(cp_)->trade_history.size() >= 10) pInfo(cp_)->trade_history.erase(pInfo(cp_)->trade_history.begin() + 0);
										pInfo(peer)->trade_history.push_back("`9You traded [" + traded_ + "] with `1" + get_player_nick(cp_) + "`` in `2" + pInfo(peer)->world + "`` " + (traded2_ == "nothing" ? "" : +"and received [" + traded2_ + "] ") + "`0at " + (newtime.tm_hour < 10 ? "0" + to_string(newtime.tm_hour) + "" : to_string(newtime.tm_hour)) + ":" + (newtime.tm_min < 10 ? "0" + to_string(newtime.tm_min) + "" : to_string(newtime.tm_min)) + " on " + to_string(newtime.tm_mon + 1) + "/" + to_string(newtime.tm_mday) + ".``");
										pInfo(cp_)->trade_history.push_back("`9You traded [" + traded2_ + "] with `1" + get_player_nick(peer) + "`` in `2" + pInfo(peer)->world + "`` " + (traded_ == "nothing" ? "" : +"and received [" + traded_ + "] ") + "`0at " + (newtime.tm_hour < 10 ? "0" + to_string(newtime.tm_hour) + "" : to_string(newtime.tm_hour)) + ":" + (newtime.tm_min < 10 ? "0" + to_string(newtime.tm_min) + "" : to_string(newtime.tm_min)) + " on " + to_string(newtime.tm_mon + 1) + "/" + to_string(newtime.tm_mday) + ".``");
										for (ENetPeer* cp_2 = server->peers; cp_2 < &server->peers[server->peerCount]; ++cp_2) {
											if (cp_2->state != ENET_PEER_STATE_CONNECTED or cp_2->data == NULL or pInfo(cp_2)->world != world_->name) continue;
											VarList::OnConsoleMessage(cp_2, "`1" + fixchar2(get_player_nick(cp_)) + " traded " + traded2_ + " to " + fixchar2(get_player_nick(peer)) + ".``");
											VarList::OnConsoleMessage(cp_2, "`1" + fixchar2(get_player_nick(peer)) + " traded " + traded_ + " to " + fixchar2(get_player_nick(cp_)) + ".``");
										}
									}
									CAction::Positioned(peer, pInfo(cp_)->netID, "audio/keypad_hit.wav", 1250);
									CAction::Positioned(cp_, pInfo(cp_)->netID, "audio/keypad_hit.wav", 1250);
									pInfo(cp_)->block_trade = false, pInfo(cp_)->accept_the_offer = false, pInfo(cp_)->trade_accept = false, pInfo(cp_)->trading_with = -1, pInfo(cp_)->trade_items.clear();
									pInfo(peer)->block_trade = false, pInfo(peer)->trading_with = -1, pInfo(peer)->trade_accept = false, pInfo(peer)->accept_the_offer = false, pInfo(peer)->trade_items.clear();
								}
								return;
							}
							for (int i_ = 0; i_ < pInfo(cp_)->trade_items.size(); i_++) {
								std::map<std::string, int>::iterator it;
								for (auto it = pInfo(cp_)->trade_items[i_].begin(); it != pInfo(cp_)->trade_items[i_].end(); it++) {
									if (it->first == 1424 or it->first == 5816) {
										pInfo(peer)->accept_the_offer = false;
										send_trade_confirm_dialog(peer, cp_, true);
										VarList::OnTextOverlay(peer, "`6[``you must wait for the other player to accept first`6]``");
										VarList::OnConsoleMessage(cp_, "`6[``You must accept first because you're selling a World Key`6]``");
										VarList::OnTalkBubble(cp_, pInfo(cp_)->netID, "`6[``You must accept first because you're selling a World Key`6]``", 0, 0);
										return;
									}
								}
							}
							VarList::OnConsoleMessage(peer, "`6[``Trade accepted, waiting for other player to accept`6]``");
							VarList::OnTalkBubble(peer, pInfo(peer)->netID, "`6[``Trade accepted, waiting for other player to accept`6]``", 0, 0);
							VarList::OnConsoleMessage(cp_, "`6[``Trade accepted by other player, waiting for you`6]``");
							VarList::OnTalkBubble(cp_, pInfo(cp_)->netID, "`6[``Trade accepted by other player, waiting for you`6]``", 0, 0);
							return;
						}
					}
				}
				VarList::OnTextOverlay(peer, "The other person left the trade!");
				pInfo(peer)->block_trade = false, pInfo(peer)->trading_with = -1, pInfo(peer)->trade_accept = false, pInfo(peer)->accept_the_offer = false, pInfo(peer)->trade_items.clear();
			}
		}
	}
	static void friends_remove_finish(ENetPeer* peer, std::string cch) {
		DialogHandle::Friends(peer);
	}
	static void friends_remove(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "", name = get_embed(cch, "friendID");
		if (parser.try_get("buttonClicked", button)) {
			if (button == "back") {
				DialogHandle::Info_Friend(peer, name);
			}
			if (button == "remove") {
				string name_ = pInfo(peer)->world;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					remove_friend(peer, world_, name);
				}
			}
		}
	}
	static void friends_ignore(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "", name_ = get_embed(cch, "friendID");
		if (parser.try_get("buttonClicked", button)) {
			if (button == "back") {
				DialogHandle::Friends(peer);
			}
			if (button == "remove") {
				if (find(pInfo(peer)->ignored.begin(), pInfo(peer)->ignored.end(), to_lower(name_)) != pInfo(peer)->ignored.end()) {
					std::string name = to_lower(name_);
					pInfo(peer)->ignored.erase(remove(pInfo(peer)->ignored.begin(), pInfo(peer)->ignored.end(), name), pInfo(peer)->ignored.end());
					VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`4Ignore removed``|left|1366|\nadd_spacer|small|\nadd_textbox|`oOk, you will now be able to see chat from " + name + ".|left|\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog|friends_remove_finish|||\nadd_quick_exit|");
				}
			}
		}
	}
	static void friends_message(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "", name_ = get_embed(cch, "friendID");
		if (parser.try_get("buttonClicked", button)) {
			if (button == "back") {
				DialogHandle::Info_Friend(peer, name_);
			}
			if (button == "send") {
				std::string message = parser.get("text", 1);
				SendMsg(peer, pInfo(peer)->last_msg_wrenched, message);
			}
		}
	}
	static void friends_edit(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "", name_ = get_embed(cch, "friendID");
		if (parser.try_get("buttonClicked", button)) {
			if (button == "back") {
				DialogHandle::Friends(peer);
			}
			if (button == "remove" or button == "back") {
				DialogHandle::Edit_Friend(peer, name_, (button == "back" ? true : false));
			}
			if (button == "goto") {
				if (Playmods::HasById(pInfo(peer), 139)) {
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Hmm, you can't do that while cursed."), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
					return;
				}
				for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
					if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
					if (to_lower(pInfo(cp_)->tankIDName) == to_lower(name_)) {
						for (int c_ = 0; c_ < pInfo(cp_)->friends.size(); c_++) {
							if (to_lower(pInfo(cp_)->friends[c_].name) == to_lower(pInfo(peer)->tankIDName)) {
								if (pInfo(cp_)->show_location_) {
									if (pInfo(cp_)->world.empty()) {
										VarList::OnTalkBubble(peer, pInfo(peer)->netID, "Hmm, my friend isn't in a world right now.", 0, 0);
										break;
									}
									else if (pInfo(cp_)->world == pInfo(peer)->world) {
										VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You want to warp to the same world you're in?  That's illogical, captain.", 0, 0);
										break;
									}
									Enter_World(peer, pInfo(cp_)->world);
								}
							}
						}
					}
				}
			}
			if (button == "msg") {
				pInfo(peer)->last_wrenched = name_;
				VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`5Message to ``" + name_ + "|left|660|\nadd_spacer|small|\nadd_text_input|text|||80|left|\nadd_spacer|small|\nembed_data|friendID|" + name_ + "\nadd_button|send|`5Send``|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|friends_message|||\nadd_quick_exit|");
			}
			if (button == "mute" or button == "trade_block") {
				for (int c_ = 0; c_ < pInfo(peer)->friends.size(); c_++) {
					if (to_lower(pInfo(peer)->friends[c_].name) == to_lower(name_)) {
						if (button == "mute") {
							if (not pInfo(peer)->friends[c_].mute) VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|Are you sure you want to `4Mute`` " + name_ + "? You will not receive any messages from this player until you unmute, consider this /ignore a friend|left|\nadd_button|ok|OK|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|mute_friend|||\nadd_quick_exit|");
							else VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|Are you sure you want to `4Un Mute`` " + name_ + "? You will receive any messages from this player until you mute.|left|\nadd_button|ok|OK|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|mute_friend|||\nadd_quick_exit|");
						}
						else {
							if (not pInfo(peer)->friends[c_].block_trade) VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|Are you sure you want to `4Disable Trade`` with " + name_ + "? You will not receive any trade request until you enable trading again.|left|\nadd_button|ok|OK|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|block_friend|||\nadd_quick_exit|");
							else VarList::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|Are you sure you want to `4Enable Trade`` with " + name_ + "? You will receive any trade request until you disable trading again.|left|\nadd_button|ok|OK|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|block_friend|||\nadd_quick_exit|");
						}
					}
				}
			}
		}
	}
	static void guildmembers(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (pInfo(peer)->guild_id == 0) return;
			if (button == "guild_members_all") {
				string guild_info = get_guild_info(peer, true);
				if (guild_info == "set_default_color|`o\nadd_label_with_icon|big|`wGrow Guild ``|left|5814|\nadd_textbox|Something went wrong!|left|\nend_dialog|guildalreadyjoined|Close||") set_Guilds(peer);
				VarList::OnDialogRequest(peer, guild_info);
			}
			if (button == "guild_members_options") {
				uint32_t guild_id = pInfo(peer)->guild_id;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					for (GuildMember member_search : guild_information->guild_members) {
						if (to_lower(member_search.member_name) == to_lower(pInfo(peer)->tankIDName)) {
							string notify_ = (member_search.show_notifications ? "1" : "0");
							string public_ = (member_search.public_location ? "1" : "0");
							string guild_foreground = (guild_information->guild_mascot[0] == 0 ? "5814" : to_string(guild_information->guild_mascot[0]));
							string guild_background = (guild_information->guild_mascot[1] == 0 ? "0" : to_string(guild_information->guild_mascot[1]));
							VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_dual_layer_icon_label|big|`wGuild Member Options``|left|" + guild_background + "|" + guild_foreground + "|1.0|0|\nadd_spacer|small|\nadd_checkbox|checkbox_public|Show location to guild members|" + public_ + "\nadd_checkbox|checkbox_notifications|Show guild member notifications|" + notify_ + "\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog|guild_members_options|||\nadd_quick_exit|");
							return;
						}
					}
				}
			}
			if (button == "changestatement") {
				VarList::OnDialogRequest(peer, get_guild_statement_edit(peer));
			}
			if (button == "changeguildnotebook") {
				VarList::OnDialogRequest(peer, get_guild_notebook_edit(peer));
			}
			if (button == "guild_logs") {
				uint32_t guild_id = pInfo(peer)->guild_id;
				std::vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					std::vector<std::string> logs{};
					std::vector<std::vector<std::string>> sort_by_time;
					for (GuildLog log_ : guild_information->guild_logs) {
						sort_by_time.push_back({ to_string(log_.date), log_.info, to_string(log_.display_id) });
					}
					sort(sort_by_time.begin(), sort_by_time.end(), [](const vector< string >& a, const vector< string >& b) {
						return atoi(a[1].c_str()) > atoi(b[1].c_str());
						});
					for (int i = sort_by_time.size() - 1; i >= 0; i--) {
						char* endptr = NULL;
#ifdef _WIN32
						long long laikas_ = strtoll(sort_by_time[i][0].c_str(), &endptr, 10);
						const time_t* temp = &laikas_;
#elif defined(__linux__)
						long long laikas_ = strtoll(sort_by_time[i][0].c_str(), &endptr, 10);
						const time_t* temp = reinterpret_cast<const time_t*>(&laikas_);
#endif
						std::string the_time = strtok(ctime(temp), "\n");
						logs.push_back("\nadd_label_with_icon|small|" + sort_by_time[i][1] + " `wat " + the_time + "|left|" + sort_by_time[i][2] + "|\nadd_spacer|small|");
					}
					if (logs.size() == 0) {
						logs.push_back("\nadd_label_with_icon|small|There are no logs at the moment!|left|8|\nadd_spacer|small|");
					}
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big| `w" + guild_information->guild_name + " Logs``|left|1436\nadd_spacer|small|" + join(logs, "") + "\nadd_button|back|`wBack``|noflags|0|0|\nend_dialog|show_guild_logs|||\nadd_quick_exit|");
				}
			}
			if (button == "warphome") {
				uint32_t guild_id = pInfo(peer)->guild_id;
				std::vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					if (pInfo(peer)->world == guild_information->guild_world) {
						VarList::OnConsoleMessage(peer, "You want to warp to the same world you're in?  That's illogical, captain.");
						VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You want to warp to the same world you're in?  That's illogical, captain.", 0, 0);
						return;
					}
					VarList::OnTextOverlay(peer, "Moving to guild home (`2" + guild_information->guild_world + "``) ...");
					Enter_World(peer, guild_information->guild_world);
				}
			}
			if (button == "back") DialogHandle::Social_Portal(peer);
			if (button == "leave_guild") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wLeave Guild``|left|1366|\nadd_spacer|small|\nadd_textbox|`oAre you sure you wish to `4leave`` the guild?|left|\nadd_spacer|small|\nadd_button|leave_guild_confirmed|`4Leave Guild``|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|leave_guild|||\nadd_quick_exit|");
			if (button.substr(0, 0) == "") {
				std::string guild_member_name = button.substr(0);
				send_guild_member_info(peer, to_lower(guild_member_name));
			}
		}
	}
	static void leaveguild(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "leave_guild_confirmed") {
				if (pInfo(peer)->guild_id == 0) return;
				uint32_t guild_id = pInfo(peer)->guild_id;
				std::vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					leave_guild(peer);
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`4Leave Guild``|left|1366|\nadd_spacer|small|\nadd_textbox|`o You are no longer in the guild.|left|\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog||||\nadd_quick_exit|");
					if (guild_information->guild_world == pInfo(peer)->world) {
						std::string name_ = pInfo(peer)->world;
						std::vector<World>::iterator p_w = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
						if (p_w != worlds.end()) {
							World* world_ = &worlds[p_w - worlds.begin()];
							int x_ = 0, y_ = 0;
							int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
							{
								std::vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return a.fg == 5814; });
								if (p != world_->blocks.end()) {
									int i_ = p - world_->blocks.begin();
									x_ = i_ % xSize;
									y_ = i_ / xSize;
								}
							}
							WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
							tile_update(peer, world_, block_, x_, y_);
						}
					}
				}
			}
			if (button == "back") {
				std::string guild_info = get_guild_info(peer);
				if (guild_info == "set_default_color|`o\nadd_label_with_icon|big|`wGrow Guild ``|left|5814|\nadd_textbox|Something went wrong!|left|\nend_dialog|guildalreadyjoined|Close||") set_Guilds(peer);
				VarList::OnDialogRequest(peer, SetColor(peer) + guild_info);
			}
		}
	}
	static void friends(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "back") DialogHandle::Social_Portal(peer);
			if (button == "all_friends") DialogHandle::Edit_All_Friends(peer);
			if (button == "friends_options") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wFriend Options``|left|1366|\nadd_spacer|small|\nadd_checkbox|checkbox_public|Show location to friends|" + to_string(pInfo(peer)->show_location_) + "\nadd_checkbox|checkbox_notifications|Show friend notifications|" + to_string(pInfo(peer)->show_friend_notifications_) + "\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog|friends_options|||\nadd_quick_exit|");
			if (button == "send_mailbox") VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`wSend mail``|left|1366|\nadd_spacer|small|\nadd_text_input|growid|GrowID:||18|\nadd_text_input|text|Message:||200|\nadd_spacer|small|\nadd_button|send_mailbox|Send mail|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nadd_button||Close|noflags|0|0|\nend_dialog|send_mailbox|||\nadd_quick_exit|");
			if (button == "friend_all") {
				DialogHandle::Friends(peer, true);
			}
			if (button.substr(0, 0) == "") {
				string name = button.substr(0);
				if (find(pInfo(peer)->ignored.begin(), pInfo(peer)->ignored.end(), to_lower(name)) != pInfo(peer)->ignored.end()) {
					VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|`4Remove ignore``|left|1366|\nadd_spacer|small|\nadd_textbox|`oAre you sure you wish to stop ignoring " + to_lower(name) + "?|left|\nadd_spacer|small|\nadd_button|remove|`4Remove ignore``|noflags|0|0|\nembed_data|friendID|" + to_lower(name) + "\nadd_button|back|Back|noflags|0|0|\nend_dialog|friends_ignore|||\nadd_quick_exit|");
				}
				else DialogHandle::Info_Friend(peer, name);
			}
		}
	}
	static void crystal_exchange(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button.substr(0, 0) == "") {
				if (not is_number(button.substr(0)) or not is_number(std::string(get_embed(cch, "tilex"))) or not is_number(std::string(get_embed(cch, "tiley")))) return;
				int x_ = std::atoi(get_embed(cch, "tilex").c_str()), y_ = std::atoi(get_embed(cch, "tiley").c_str());
				if (x_ < 0 or y_ < 0) return;
				int item_id = std::atoi(button.substr(0).c_str());
				if (item_id <= 0 || item_id >= items.size()) return;
				std::string name_ = pInfo(peer)->world;
				std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					if (y_ >= world_->max_y || x_ >= world_->max_x) return;
					WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
					uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
					if (items[t_].blockType != BlockTypes::CRYSTAL) return;
					if (Only_Access(peer, world_, block_) == false && !guild_access(peer, world_->guild_id)) return;
					std::vector<std::vector<int>> current_{ {2242, 0}, {2244, 0}, {2246, 0}, {2248, 0}, {2250, 0} };
					for (int i = 0; i < block_->crystals.size(); i++) {
						std::vector<int> c_ = block_->crystals[i];
						for (int a = 0; a < current_.size(); a++) {
							if (current_[a][0] == c_[0]) {
								current_[a][1] = block_->crystals[i][1];
								break;
							}
						}
					}
					for (std::vector<std::vector<int>> a_ : crystal_receptai) {
						if (a_[5][0] == item_id) {
							bool can_ = true;
							for (std::vector<int> b_ : a_) {
								for (int i = 0; i < current_.size(); i++) {
									if (current_[i][0] == b_[0] and current_[i][1] < b_[1]) {
										can_ = false;
										break;
									}
								}
								if (not can_) {
									return;
								}
							}
							if (can_) {
								if (pInfo(peer)->C_QuestActive && pInfo(peer)->C_QuestKind == 12 && pInfo(peer)->C_QuestProgress < pInfo(peer)->C_ProgressNeeded) {
									pInfo(peer)->C_QuestProgress++;
									if (pInfo(peer)->C_QuestProgress >= pInfo(peer)->C_ProgressNeeded) {
										pInfo(peer)->C_QuestProgress = pInfo(peer)->C_ProgressNeeded;
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(peer)->netID);
										p.Insert("`9Ring Quest task complete! Go tell the Ringmaster!");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(peer);
									}
								}
								PlayerMoving data_{};
								data_.packetType = 0x11, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16;
								data_.YSpeed = 97, data_.XSpeed = t_;
								BYTE* raw = packPlayerMoving(&data_);
								for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
									if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL) continue;
									if (pInfo(cp_)->world == world_->name) {
										send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[] raw;
								{
									if (pInfo(peer)->starglitter_crystal < 4) DailyEvent_Task::MStarglitter(peer, "crystal", 1);
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(peer)->netID);
									p.Insert("The crystal shatters and drops " + items[a_[5][0]].name + "!");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(peer);
									WorldDrop drop_block_{};
									drop_block_.id = a_[5][0], drop_block_.count = a_[5][1], drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
									VisualHandle::Drop(world_, drop_block_);
								}
								reset_(block_, x_, y_, world_);
								tile_update(peer, world_, block_, x_, y_);
							}
							else {
								break;
							}
						}
					}
				}
			}
		}
	}
	static void Login_Regis_Handle(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "Get_GrowID") {
				std::string user_ = parser.get("username", 1), pass_ = parser.get("password", 1), pass_verify_ = parser.get("password_verify", 1), email_ = parser.get("email", 1);
				try {
					if (not pInfo(peer)->tankIDName.empty() and not pInfo(peer)->tankIDPass.empty() or pInfo(peer)->bypass == false or not pInfo(peer)->world.empty()) return;
					std::string path_ = "database/players/" + user_ + "_.json";
					bool bad_name = false;
					std::string check_user = user_;
					transform(check_user.begin(), check_user.end(), check_user.begin(), ::toupper);
					for (int i = 0; i < Environment()->swear_words.size(); i++) {
						if (check_user.find(Environment()->swear_words[i]) != string::npos) {
							bad_name = true;
							return;
						}
					}
					bool exist = filesystem::exists("database/players/" + user_ + "_.json");
					if (exist) {
						VarList::OnDialogRequest(peer, SetColor(peer) + PlayerDB::Regis_Dialog("`4Oops!`` The name `w" + user_ + "`` is so cool someone else has already taken it.  Please choose a different name.", user_, pass_, pass_verify_, email_));
					}
					if (bad_name) VarList::OnDialogRequest(peer, SetColor(peer) + PlayerDB::Regis_Dialog("`4Oops!``  Your `wGrowID`` cannot contain `$swear words``.", user_, pass_, pass_verify_, email_));
					else if (not email(email_)) VarList::OnDialogRequest(peer, SetColor(peer) + PlayerDB::Regis_Dialog("`4Oops!``  Look, if you'd like to be able try retrieve your password if you lose it, you'd better enter a real email.  We promise to keep your data 100% private and never spam you.", user_, pass_, pass_verify_, email_));
					else if (user_.size() < 3 or user_.size() > 18) VarList::OnDialogRequest(peer, SetColor(peer) + PlayerDB::Regis_Dialog("`4Oops!``  Your `wGrowID`` must be between `$3`` and `$18`` characters long.", user_, pass_, pass_verify_, email_));
					else if (pass_.size() < 4 or pass_.size() > 18) VarList::OnDialogRequest(peer, SetColor(peer) + PlayerDB::Regis_Dialog("`4Oops!``  Your password must be between `$4`` and `$18`` characters long.", user_, pass_, pass_verify_, email_));
					else if (pass_ != pass_verify_) VarList::OnDialogRequest(peer, SetColor(peer) + PlayerDB::Regis_Dialog("`4Oops!``  Passwords don't match.  Try again.", user_, pass_, pass_verify_, email_));
					else if (special_char(user_)) VarList::OnDialogRequest(peer, SetColor(peer) + PlayerDB::Regis_Dialog("`4Oops!`` You can only use letters and numbers in your GrowID.", user_, pass_, pass_verify_, email_));
					else if (_access_s(path_.c_str(), 0) == 0) VarList::OnDialogRequest(peer, SetColor(peer) + PlayerDB::Regis_Dialog("`4Oops!`` The name `w" + user_ + "`` is so cool someone else has already taken it.  Please choose a different name.", user_, pass_, pass_verify_, email_));
					else {
						bool wlachi = filesystem::exists("database/players/PlayerCharIp/" + pInfo(peer)->ip + ".txt");
						if (wlachi == false) {
							int limit = 1;
							ofstream Dayz("database/players/PlayerCharIp/" + pInfo(peer)->ip + ".txt");
							Dayz << limit << endl;
							Dayz.close();
						}
						else {
							int limit = 0;
							ifstream fd("database/players/PlayerCharIp/" + pInfo(peer)->ip + ".txt");
							fd >> limit;
							fd.close();
							if (limit == 1) {
								int limit_2 = 2;
								ofstream Dayz("database/players/PlayerCharIp/" + pInfo(peer)->ip + ".txt");
								Dayz << limit_2 << endl;
								Dayz.close();
							}
							else if (limit == 2) {
								int limit_3 = 3;
								ofstream Dayz("database/players/PlayerCharIp/" + pInfo(peer)->ip + ".txt");
								Dayz << limit_3 << endl;
								Dayz.close();
							}
							else {
								Logger::Info("WARNING", "Player: " + user_ + " with IP Address [" + pInfo(peer)->ip + "] is trying to create another account but the IP is already maxed.");
								VarList::OnDialogRequest(peer, SetColor(peer) + PlayerDB::Regis_Dialog("`4Too many accounts created from this IP."));
								return;
							}
						}
						pInfo(peer)->auth_ = false;
						pInfo(peer)->growid = true;
						pInfo(peer)->new_player = true;
						pInfo(peer)->country = "id";
						pInfo(peer)->account_created = int(time(NULL)) / (60 * 60 * 24), pInfo(peer)->playtime = time(NULL);
						pInfo(peer)->inv.push_back({ 18, 1 }), pInfo(peer)->inv.push_back({ 32, 1 }), pInfo(peer)->inv.push_back({ 6336, 1 }), pInfo(peer)->inv.push_back({ 9640, 1 });
						for (int i_ = pInfo(peer)->inv.size(); i_ <= 26; i_++) pInfo(peer)->inv.push_back({ 0,0 });
						pInfo(peer)->tankIDName = user_, pInfo(peer)->tankIDPass = pass_, pInfo(peer)->email = email_;
						ServerPool::Logs::Add("GrowID: " + user_ + " created a new account" + " ip: " + pInfo(peer)->ip + " rid: " + pInfo(peer)->rid, "Register");
						//VarList::SetHasGrowID(peer, 1, user_, pass_);
						pInfo(peer)->n = 1; pInfo(peer)->cc = 1; pInfo(peer)->temp_radio = false;
						Inventory::Visuals(peer);
						VarList::OnBuxGems(peer);
						Clothing_V2::Update(peer);
						ServerPool::SaveDatabase::Players(pInfo(peer), false);
						Clothing_V2::Update_Value(peer);
						enet_peer_disconnect_later(peer, 0);
						string list = "";
						for (int c_ = 0; c_ < new_get.list.size(); c_++) {
							if (new_get.list[c_].Gemss != 0) {
								list += "\nadd_button_with_icon||`wGems|staticYellowFrame|14590|" + Set_Count(new_get.list[c_].Gemss) + "|\n";
								VarList::OnBuxGems(peer, new_get.list[c_].Gemss);
							}
							if (new_get.list[c_].Coin != 0) {
								list += "\nadd_button_with_icon||`w" + Environment()->server_name + " Coin|staticYellowFrame|244|" + Set_Count(new_get.list[c_].Coin) + "|\n";
								pInfo(peer)->gtwl += new_get.list[c_].Coin;
							}
							if (new_get.list[c_].Seasonals_Token != 0) {
								list += "\nadd_button_with_icon||`w" + guild_event_type + " Tokens|staticYellowFrame|" + to_string(guild_event_id) + "|" + Set_Count(new_get.list[c_].Seasonals_Token) + "|\n";
								if (guild_event_type == "Spring Clash") pInfo(peer)->spring_token += new_get.list[c_].Seasonals_Token;
								if (guild_event_type == "Summer Clash") pInfo(peer)->summer_token += new_get.list[c_].Seasonals_Token;
								if (guild_event_type == "Winter Clash") pInfo(peer)->winter_token += new_get.list[c_].Seasonals_Token;
							}
							for (const auto& items_ : new_get.list[c_].items) {
								int cc_ = items_.second, id_ = items_.first;
								if (Inventory::Modify(peer, id_, cc_) == 0) {
									for (int i_ = 0; i_ < new_get.list[c_].items.size(); i_++) {
										list += "\nadd_button_with_icon||`w" + items[new_get.list[c_].items[i_].first].name + "|staticYellowFrame|" + to_string(new_get.list[c_].items[i_].first) + "|" + to_string(new_get.list[c_].items[i_].second) + "|\n";
									}
									VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\n\nadd_image_button||interface/large/tianvan/welcome_banner.rttex||||\nadd_spacer|small|\nadd_label_with_icon|small|`wCongratulations " + pInfo(peer)->tankIDName + "Ĩ!!``|left|6336|\nadd_spacer|small|\nadd_textbox|You've got these supplies for beginners at " + Environment()->server_name + "!|left|\ntext_scaling_string|Subscribtions+++|" + list + "\nadd_button_with_icon||END_LIST|noflags|0||\ntext_scaling_string|AAAAAAAAAAAAA|\nadd_custom_margin|x:718;y:0|\nadd_custom_button||image:interface/large/tianvan/newsbtn.rttex;image_size:675,113;frame:0,2;width:0.20;min_width:60;margin:10,0;|\nadd_custom_margin|x:490;y:0|\nadd_custom_break|");
								}
							}
						}
					}
				}
				catch (exception) {
					Logger::Info("ERROR", "Something failed new growid");
				}
			}
			if (button == "verify_2fa") {
				std::string code = parser.get("verificationcode", 1);
				if (code.size() >= 4 and is_number(code)) {
					if (pInfo(peer)->fa2 == atoi(code.c_str())) {
						pInfo(peer)->fa_ip = pInfo(peer)->ip;
						DialogHandle::News(peer);
					}
					else {
						pInfo(peer)->fa2_entered++;
						PlayerDB::Aap_Page(peer, "You entered wrong 2FA Code.");
					}
				}
				else PlayerDB::Aap_Page(peer, "There was an error in your 2FA Code.");
				if (pInfo(peer)->fa2_entered >= 5) {
					pInfo(peer)->tankIDName = "", pInfo(peer)->tankIDPass = "";
					VarList::SetHasGrowID(peer, 1, "", "");
					VarList::OnConsoleMessage(peer, "`4Invalid Credential`o: Your Code 2fa is not correct. you session will be reset!");
					enet_peer_disconnect_later(peer, 0);
				}
			}
			if (button == "back") {
				PlayerDB::RegisAndLogin_Page(peer);
			}
			if (button == "RegisterPage") {
				VarList::OnDialogRequest(peer, SetColor(peer) + PlayerDB::Regis_Dialog(""), 250);
			}
		}
	}
	static void euphoriaEventUI(ENetPeer* peer, std::string cch) {
		if (not Event()->Anniversary) return;
		TextScanner parser(cch);
		std::string button = "";
		if (parser.try_get("buttonClicked", button)) {
			if (button == "euphoriaBtnClicked") {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_image_button|noclick|interface/large/anni_toparty.rttex|bannerlayout|||\nadd_spacer|small|\nadd_textbox|The current world is `10%`` of the way towards starting the party. To help the world reach 100% and start the party, let's get creative and use some fun party items!|left|\nadd_spacer|small|\nadd_textbox|Remember, the points you gain count towards your personal rank, so let's make this party as fun and memorable as possible!|left|\nadd_spacer|small|\nadd_button|info_btn|Information|no_flags|0|0|\nadd_spacer|small|\nend_dialog|euphoriaEventUI|Close||\nadd_quick_exit|\n", 500);
			}
			else if (button == "leaderboardBtnClicked") {
				EventPool::Load::Anniversary_Leaderboard();
				string contribute = "";
				std::vector<std::pair<long long int, std::string>>::iterator pa2 = find_if(Event()->top_anniversary.begin(), Event()->top_anniversary.end(), [&](const pair < long long int, string>& element) { return to_lower(element.second) == to_lower(pInfo(peer)->tankIDName); });
				if (pa2 != Event()->top_anniversary.end()) contribute = "\nadd_textbox|Your rank: `9" + to_string(distance(Event()->top_anniversary.begin(), pa2) + 1) + "``|left|\nadd_textbox|Your Points: `9" + Set_Count(Event()->top_anniversary[pa2 - Event()->top_anniversary.begin()].first) + "``|left|";
				else contribute = "\nadd_textbox|Your rank: `9---``|left|\nadd_textbox|Your Points: `90``|left|";
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`w\nadd_label|big|`8Anniversary Global Leaderboard``|left|\nadd_spacer|small|\nadd_textbox|Time Remaining: `2" + Time::Event(Event()->Anniversary_Time - time(nullptr)) + "``|left|\nadd_spacer|small|\nadd_textbox|The best party hosts will be awarded the title of `5PA```9RTY`` `eAN```5IM```9AL``!|left|\nadd_spacer|small|" + contribute + "\nadd_spacer|small|" + Event()->top_anniversary_list + "\nadd_spacer|small|\nadd_smalltext|`8NOTE: Scores are updated every 20 seconds.``|\nadd_spacer|small|\nadd_button|info_btn1|Information|no_flags|0|0|\nadd_spacer|small|\nadd_custom_button|rewards_info_btn|textLabel:Rewards;middle_colour:-2043447809;border_colour:-2043447809;|\nadd_custom_break|\nadd_spacer|small|\nend_dialog|euphoriaEventUI|Close||\nadd_quick_exit|\n", 500);
			}
			else if (button == "info_btn") {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_textbox|Items that give points:|left|\nadd_spacer|small|\nadd_label_with_icon|small|Party Screamer - 150|left|4366|\nadd_spacer|small|\nadd_label_with_icon|small|Party Popper - 8|left|4370|\nadd_spacer|small|\nadd_label_with_icon|small|Anniversary Skyrocket - 50|left|9264|\nadd_spacer|small|\nadd_label_with_icon|small|Party Cake - 8|left|4378|\nadd_spacer|small|\nadd_label_with_icon|small|Party-In-A-Box - 10|left|2306|\nadd_spacer|small|\nadd_label_with_icon|small|Party Confetti - 400|left|2288|\nadd_spacer|small|\nadd_custom_button|close|textLabel:`wClose;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|euphoriaBtnClicked|textLabel:`wBack;anchor:_button_close;left:1;margin:60,0;|\nend_dialog|euphoriaEventUI|||\nadd_quick_exit|");
			}
			else if (button == "info_btn1") {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_textbox|Items that give points:|left|\nadd_spacer|small|\nadd_label_with_icon|small|Party Screamer - 150|left|4366|\nadd_spacer|small|\nadd_label_with_icon|small|Party Popper - 8|left|4370|\nadd_spacer|small|\nadd_label_with_icon|small|Anniversary Skyrocket - 50|left|9264|\nadd_spacer|small|\nadd_label_with_icon|small|Party Cake - 8|left|4378|\nadd_spacer|small|\nadd_label_with_icon|small|Party-In-A-Box - 10|left|2306|\nadd_spacer|small|\nadd_label_with_icon|small|Party Confetti - 400|left|2288|\nadd_spacer|small|\nadd_custom_button|close|textLabel:`wClose;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|leaderboardBtnClicked|textLabel:`wBack;anchor:_button_close;left:1;margin:60,0;|\nend_dialog|euphoriaEventUI|||\nadd_quick_exit|");
			}
			else if (button == "rewards_info_btn") {
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`w\nadd_label|big|`8Anniversary Global Leaderboard Rewards``|left|\nadd_spacer|small|\nadd_textbox|Earn points by participating in the Euphoria event or by using items from the event!|left|\nadd_spacer|small|\nadd_textbox|Top 20 Rank:|left|\ntext_scaling_string|Defibrillators|\nadd_button_with_icon|eup_leader_reward_btn_14186||frame|14186|1|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon|eup_leader_reward_btn_10566||frame|10566|1|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|\nadd_textbox|Top 1% Rewards:|left|\ntext_scaling_string|Defibrillators|\nadd_button_with_icon|eup_leader_reward_btn_7672||frame|7672|5|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon|eup_leader_reward_btn_2306||frame|2306|10|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon|eup_leader_reward_btn_15126||frame|15126|10|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|\nadd_textbox|Top 5% Rewards:|left|\ntext_scaling_string|Defibrillators|\nadd_button_with_icon|eup_leader_reward_btn_7672||frame|7672|1|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon|eup_leader_reward_btn_2306||frame|2306|10|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon|eup_leader_reward_btn_15126||frame|15126|10|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|\nadd_textbox|Top 10% Rewards:|left|\ntext_scaling_string|Defibrillators|\nadd_button_with_icon|eup_leader_reward_btn_2306||frame|2306|10|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon|eup_leader_reward_btn_15126||frame|15126|10|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|\nadd_textbox|Top 25% Rewards:|left|\ntext_scaling_string|Defibrillators|\nadd_button_with_icon|eup_leader_reward_btn_2306||frame|2306|5|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon|eup_leader_reward_btn_15126||frame|15126|5|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|\nadd_textbox|Top 50% Rewards:|left|\ntext_scaling_string|Defibrillators|\nadd_button_with_icon|eup_leader_reward_btn_2306||frame|2306|2|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon|eup_leader_reward_btn_15126||frame|15126|5|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|\nadd_textbox|Top 100% Rewards:|left|\ntext_scaling_string|Defibrillators|\nadd_button_with_icon|eup_leader_reward_btn_15126||frame|15126|5|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|\nadd_custom_button|close|textLabel:`wClose;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|leaderboardBtnClicked|textLabel:`wBack;anchor:_button_close;left:1;margin:60,0;|\nend_dialog|euphoriaEventUI|||\nadd_quick_exit|");
			}
			else if (button.substr(0, 22) == "eup_leader_reward_btn_") {
				int id = std::atoi(button.substr(22).c_str());
				if (id < 0 or id > items.size()) return;
				vector<int> list_{ 14186,10566,7672,2306,15126 };
				if (find(list_.begin(), list_.end(), id) == list_.end()) return;
				VarList::OnDialogRequest(peer, SetColor(peer) + "set_default_color|`o\nadd_label_with_icon|big|" + items[id].name + "|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|" + items[id].description + "|left|\nadd_spacer|small|\nadd_custom_button|close|textLabel:`wClose;middle_colour:80543231;border_colour:80543231;|\nadd_custom_button|rewards_info_btn|textLabel:`wBack;anchor:_button_close;left:1;margin:60,0;|\nend_dialog|euphoriaEventUI|||\nadd_quick_exit|");
			}
		}
	}
	static void Upgrade_DigiVend(ENetPeer* peer, std::string cch) {
		TextScanner parser(cch);
		if (not is_number(std::string(get_embed(cch, "tilex"))) or not is_number(std::string(get_embed(cch, "tiley")))) return;
		int x = std::atoi(get_embed(cch, "tilex").c_str()), y = std::atoi(get_embed(cch, "tiley").c_str());
		string button = "", name_ = pInfo(peer)->world;
		std::vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			WorldBlock* block_ = &world_->blocks[x + (y * 100)];
			if (items[block_->fg].blockType != BlockTypes::VENDING) return;
			if (Only_Access(peer, world_, block_)) {
				if (pInfo(peer)->gems >= 4000) {
					VarList::OnMinGems(peer, 4000);
					block_->fg = 9268;
					PlayerMoving data_{};
					data_.packetType = 17, data_.netID = 44, data_.YSpeed = 44, data_.x = x * 32 + 16, data_.y = y * 32 + 16;
					BYTE* raw = packPlayerMoving(&data_);
					for (ENetPeer* cp_ = server->peers; cp_ < &server->peers[server->peerCount]; ++cp_) {
						if (cp_->state != ENET_PEER_STATE_CONNECTED or cp_->data == NULL or pInfo(cp_)->world != world_->name) continue;
						send_raw(cp_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw;
					tile_update(peer, world_, block_, x, y);
				}
				else VarList::OnTalkBubble(peer, pInfo(peer)->netID, "You don't have enough gems!.", 0, 1);
			}
		}
	}
};